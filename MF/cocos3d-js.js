System.register([], function(exports) {
    "use strict";
    return {
        execute: function() {
            function _typeof(obj) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                    return typeof obj;
                } : function(obj) {
                    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                })(obj);
            }
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            function _defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            function _createClass(Constructor, protoProps, staticProps) {
                return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
                Constructor;
            }
            function _defineProperty(obj, key, value) {
                return key in obj ? Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : obj[key] = value, obj;
            }
            function _inherits(subClass, superClass) {
                if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        writable: !0,
                        configurable: !0
                    }
                }), superClass && _setPrototypeOf(subClass, superClass);
            }
            function _getPrototypeOf(o) {
                return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                    return o.__proto__ || Object.getPrototypeOf(o);
                })(o);
            }
            function _setPrototypeOf(o, p) {
                return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                    return o.__proto__ = p, o;
                })(o, p);
            }
            function _assertThisInitialized(self) {
                if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return self;
            }
            function _possibleConstructorReturn(self, call) {
                return !call || "object" != typeof call && "function" != typeof call ? _assertThisInitialized(self) : call;
            }
            function _superPropBase(object, property) {
                for (;!Object.prototype.hasOwnProperty.call(object, property) && null !== (object = _getPrototypeOf(object)); ) ;
                return object;
            }
            function _get(target, property, receiver) {
                return (_get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function _get(target, property, receiver) {
                    var base = _superPropBase(target, property);
                    if (base) {
                        var desc = Object.getOwnPropertyDescriptor(base, property);
                        return desc.get ? desc.get.call(receiver) : desc.value;
                    }
                })(target, property, receiver || target);
            }
            function set(target, property, value, receiver) {
                return (set = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function set(target, property, value, receiver) {
                    var desc, base = _superPropBase(target, property);
                    if (base) {
                        if ((desc = Object.getOwnPropertyDescriptor(base, property)).set) return desc.set.call(receiver, value), 
                        !0;
                        if (!desc.writable) return !1;
                    }
                    if (desc = Object.getOwnPropertyDescriptor(receiver, property)) {
                        if (!desc.writable) return !1;
                        desc.value = value, Object.defineProperty(receiver, property, desc);
                    } else _defineProperty(receiver, property, value);
                    return !0;
                })(target, property, value, receiver);
            }
            function _set(target, property, value, receiver, isStrict) {
                if (!set(target, property, value, receiver || target) && isStrict) throw new Error("failed to set property");
                return value;
            }
            function _toConsumableArray(arr) {
                return function _arrayWithoutHoles(arr) {
                    if (Array.isArray(arr)) {
                        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                        return arr2;
                    }
                }(arr) || function _iterableToArray(iter) {
                    if (Symbol.iterator in Object(iter) || "[object Arguments]" === Object.prototype.toString.call(iter)) return Array.from(iter);
                }(arr) || function _nonIterableSpread() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance");
                }();
            }
            function _initializerDefineProperty(target, property, descriptor, context) {
                descriptor && Object.defineProperty(target, property, {
                    enumerable: descriptor.enumerable,
                    configurable: descriptor.configurable,
                    writable: descriptor.writable,
                    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
                });
            }
            function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
                var desc = {};
                return Object.keys(descriptor).forEach(function(key) {
                    desc[key] = descriptor[key];
                }), desc.enumerable = !!desc.enumerable, desc.configurable = !!desc.configurable, 
                ("value" in desc || desc.initializer) && (desc.writable = !0), desc = decorators.slice().reverse().reduce(function(desc, decorator) {
                    return decorator(target, property, desc) || desc;
                }, desc), context && void 0 !== desc.initializer && (desc.value = desc.initializer ? desc.initializer.call(context) : void 0, 
                desc.initializer = void 0), void 0 === desc.initializer && (Object.defineProperty(target, property, desc), 
                desc = null), desc;
            }
            exports({
                BitMask: BitMask,
                Enum: Enum,
                EventType: void 0,
                GFXAddress: void 0,
                GFXAttributeName: void 0,
                GFXBindingType: void 0,
                GFXBlendFactor: void 0,
                GFXBlendOp: void 0,
                GFXBufferAccessBit: void 0,
                GFXBufferFlagBit: void 0,
                GFXBufferUsageBit: void 0,
                GFXClearFlag: void 0,
                GFXColorMask: void 0,
                GFXCommandBufferType: void 0,
                GFXComparisonFunc: void 0,
                GFXCullMode: void 0,
                GFXDynamicState: void 0,
                GFXFilter: void 0,
                GFXFormat: void 0,
                GFXFormatSize: GFXFormatSize,
                GFXFormatSurfaceSize: GFXFormatSurfaceSize,
                GFXFormatType: void 0,
                GFXGetTypeSize: GFXGetTypeSize,
                GFXLoadOp: void 0,
                GFXMemoryUsageBit: void 0,
                GFXObjectType: void 0,
                GFXPipelineBindPoint: void 0,
                GFXPolygonMode: void 0,
                GFXPrimitiveMode: void 0,
                GFXQueueType: void 0,
                GFXSampleCount: void 0,
                GFXShadeModel: void 0,
                GFXShaderType: void 0,
                GFXStatus: void 0,
                GFXStencilFace: void 0,
                GFXStencilOp: void 0,
                GFXStoreOp: void 0,
                GFXTextureFlagBit: void 0,
                GFXTextureLayout: void 0,
                GFXTextureType: void 0,
                GFXTextureUsageBit: void 0,
                GFXTextureViewType: void 0,
                GFXType: void 0,
                HorizontalTextAlignment: void 0,
                InstanceMaterialType: void 0,
                Overflow: void 0,
                RenderPassStage: void 0,
                SystemEventType: void 0,
                VerticalTextAlignment: void 0,
                WorldNode3DToLocalNodeUI: WorldNode3DToLocalNodeUI,
                WorldNode3DToWorldNodeUI: WorldNode3DToWorldNodeUI,
                approx: approx,
                assert: assert,
                assertID: assertID,
                bezier: bezier,
                bezierByTime: bezierByTime,
                clamp: clamp,
                clamp01: clamp01,
                color: color,
                computeRatioByType: computeRatioByType,
                equals: equals,
                error: error,
                errorID: errorID,
                find: find,
                fragmentText: fragmentText,
                getPathFromRoot: getPathFromRoot,
                getWorldTransformUntilRoot: getWorldTransformUntilRoot,
                inverseLerp: inverseLerp,
                isCustomTargetModifier: isCustomTargetModifier,
                isDisplayStats: isDisplayStats,
                isElementModifier: isElementModifier,
                isPropertyModifier: isPropertyModifier,
                isUnicodeCJK: isUnicodeCJK,
                isUnicodeSpace: isUnicodeSpace,
                lerp: lerp,
                log: log,
                logID: logID,
                markAsWarning: void 0,
                mat4: mat4,
                nextPow2: nextPow2$1,
                pingPong: pingPong,
                pseudoRandom: pseudoRandom,
                pseudoRandomRange: pseudoRandomRange,
                pseudoRandomRangeInt: pseudoRandomRangeInt,
                quat: quat,
                randomRange: randomRange,
                randomRangeInt: randomRangeInt,
                rect: rect,
                removeProperty: void 0,
                repeat: repeat,
                replaceProperty: void 0,
                safeMeasureText: safeMeasureText,
                sampleAnimationCurve: sampleAnimationCurve,
                setDefaultLogTimes: function setDefaultLogTimes(times) {
                    0 < times && (defaultLogTimes = times);
                },
                setDisplayStats: setDisplayStats,
                size: size,
                toDegree: toDegree,
                toRadian: toRadian,
                tween: tween,
                tweenUtil: tweenUtil,
                v2: v2,
                v3: v3,
                v4: v4,
                warn: warn,
                warnID: warnID
            });
            var _global = "undefined" == typeof window ? global : window, cc$1 = _global.cc = _global.cc || {};
            function defineMacro(name, defaultValue) {
                void 0 === _global[name] && (_global[name] = defaultValue);
            }
            cc$1.internal = cc$1.internal || {}, cc$1._global = _global, defineMacro("CC_BUILD", !1), 
            _global.CC_BUILD = !0, _global.CC_TEST = !1, _global.CC_EDITOR = !1, _global.CC_PREVIEW = !1, 
            _global.CC_DEV = !1, _global.CC_DEBUG = !0, _global.CC_JSB = !1, _global.CC_WECHATGAME = !1, 
            _global.CC_QQPLAY = !1, _global.CC_RUNTIME = !1, _global.CC_SUPPORT_JIT = !0, _global.CC_PHYSICS_BUILTIN = !1, 
            _global.CC_PHYSICS_CANNON = !0, _global.CC_PHYSICS_AMMO = !1;
            _global.CocosEngine = cc$1.ENGINE_VERSION = "1.0.0", Object.defineProperty(_global, "CC_PHYSICS_BUILT_IN", {
                get: function get() {
                    return console.warn("CC_PHYSICS_BUILT_IN is deprecated, please using CC_PHYSICS_BUILTIN instead."), 
                    _global.CC_PHYSICS_BUILTIN;
                }
            });
            var debugInfos = {
                1001: "cocos2d: removeAction: Target not found",
                1002: "cc.ActionManager.removeActionByTag(): an invalid tag",
                1003: "cc.ActionManager.removeActionByTag(): target must be non-null",
                1004: "cc.ActionManager.getActionByTag(): an invalid tag",
                1005: "cocos2d : getActionByTag(tag = %s): Action not found",
                1006: "[Action step]. override me",
                1007: "[Action update]. override me",
                1008: "cocos2d: FiniteTimeAction#reverse: Implement me",
                1009: "cc.EaseElastic.reverse(): it should be overridden in subclass.",
                1010: "cc.IntervalAction: reverse not implemented.",
                1011: "cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.",
                1012: "cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.",
                1013: "The speed parameter error",
                1014: "The repeat parameter error",
                1015: "parameters should not be ending with null in Javascript",
                1016: "cc.RotateTo.reverse(): it should be overridden in subclass.",
                1019: "Failed to construct, Sequence construction needs two or more actions.",
                1020: "Failed to construct, Spawn construction needs two or more actions.",
                1021: "cc.Speed.initWithAction(): action must be non nil",
                1022: "cc.Follow.initWithAction(): followedNode must be non nil",
                1023: "cc.ActionEase.initWithAction(): action must be non nil",
                1024: "Invalid configuration. It must at least have one control point",
                1025: "cc.Sequence.initWithTwoActions(): arguments must all be non nil",
                1026: "cc.RepeatForever.initWithAction(): action must be non null",
                1027: "cc.Spawn.initWithTwoActions(): arguments must all be non null",
                1028: "cc.ReverseTime.initWithAction(): action must be non null",
                1029: "cc.ReverseTime.initWithAction(): the action was already passed in.",
                1030: "cc.Animate.initWithAnimation(): animation must be non-NULL",
                1100: "Expected 'data' dict, but not found. Config file: %s",
                1101: "Please load the resource first : %s",
                1200: "cocos2d: Director: Error in gettimeofday",
                1201: "cocos2d: Director: unrecognized projection",
                1203: "cocos2d: Director: Error in gettimeofday",
                1204: "running scene should not null",
                1205: "the scene should not null",
                1206: "loadScene: The scene index to load (%s) is out of range.",
                1207: "loadScene: Unknown name type to load: '%s'",
                1208: "loadScene: Failed to load scene '%s' because '%s' is already loading",
                1209: "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
                1210: "Failed to preload '%s', %s",
                1211: "loadScene: The scene index to load (%s) is out of range.",
                1212: "loadScene: Unknown name type to load: '%s'",
                1213: "loadScene: Failed to load scene '%s' because '%s' is already loading",
                1214: "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
                1215: "Failed to preload '%s', %s",
                1216: "Director.runSceneImmediate: scene is not valid",
                1300: "element type is wrong!",
                1400: "'%s' is deprecated, please use '%s' instead.",
                1401: "The first argument should be the destination object",
                1402: "The 'visible' property of %s is deprecated, use 'enabled' instead please.",
                1403: "Sorry, cc.audioEngine.willPlayMusic is removed.",
                1404: "cc.spriteFrameCache is removed, please use cc.loader to load and cache sprite frames of atlas format.",
                1405: "The '%s' will be removed in v2.0, please use '%s' instead.",
                1406: "'%s.%s' is removed",
                1407: "cc.pool is being removed from v2.0, you are getting cc.js.Pool instead",
                1502: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
                1503: "cc.Scheduler.pauseTarget():target should be non-null",
                1504: "cc.Scheduler.resumeTarget():target should be non-null",
                1505: "cc.Scheduler.isTargetPaused():target should be non-null",
                1506: "warning: you CANNOT change update priority in scheduled function",
                1507: "scheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f",
                1508: "Argument callback must not be empty",
                1509: "Argument target must be non-nullptr",
                1510: "cc.Scheduler: Illegal target which doesn't have id, you should do Scheduler.enableForTarget(target) before all scheduler API usage on target",
                1511: "cc.Scheduler: pause state of the scheduled task doesn't match the element pause state in Scheduler, the given paused state will be ignored.",
                1512: "cc.Scheduler: updateFunc parameter is deprecated in scheduleUpdate function, and will be removed in v2.0",
                1513: "cc.Scheduler: scheduler stopped using `__instanceId` as id since v2.0, you should do Scheduler.enableForTarget(target) before all scheduler API usage on target",
                1600: "getZOrder is deprecated. Please use getLocalZOrder instead.",
                1601: "setZOrder is deprecated. Please use setLocalZOrder instead.",
                1602: "RotationX != RotationY. Don't know which one to return",
                1603: "ScaleX != ScaleY. Don't know which one to return",
                1605: "child already added. It can't be added again",
                1606: "child must be non-null",
                1607: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
                1608: "boundingBox is deprecated. Use getBoundingBox instead",
                1609: "argument tag is an invalid tag",
                1610: "cocos2d: removeChildByTag(tag = %s): child not found!",
                1612: "cc.Node.stopActionBy(): argument tag an invalid tag",
                1613: "cc.Node.getActionByTag(): argument tag is an invalid tag",
                1614: "resumeSchedulerAndActions is deprecated, please use resume instead.",
                1615: "pauseSchedulerAndActions is deprecated, please use pause instead.",
                1617: "child must be non-null",
                1618: "cc.Node.runAction(): action must be non-null",
                1619: "callback function must be non-null",
                1620: "interval must be positive",
                1623: "Set '%s' to normal node (not persist root node).",
                1624: "Replacing with the same sgNode",
                1625: "The replacement sgNode should not contain any child.",
                1626: "Should not set alpha via 'color', set 'opacity' please.",
                1627: "Not support for asynchronous creating node in SG",
                1632: "Node name can not include '/'.",
                1633: "Internal error, should not remove unknown node from parent.",
                1634: "addChild: The child to add must be instance of cc.Node, not %s.",
                1635: "reorderChild: this child is not in children list.",
                1636: "Node's zIndex value can't be greater than cc.macro.MAX_ZINDEX, setting to the maximum value",
                1637: "Node's zIndex value can't be smaller than cc.macro.MIN_ZINDEX, setting to the minimum value",
                1638: "Private node's zIndex can't be set, it will keep cc.macro.MIN_ZINDEX as its value",
                1800: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
                1801: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
                1802: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
                1803: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
                1900: "Invalid parameter.",
                2e3: "Don't call this method if the event is for touch.",
                2200: "Resolution not valid",
                2201: "should set resolutionPolicy",
                2300: "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
                2400: "WebGL error %s",
                2602: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
                2603: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
                2604: "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
                2606: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
                2607: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
                2608: "%s is null, please check.",
                2609: "cc.Sprite.initWithFile(): filename should be non-null",
                2610: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
                2614: "cc.Sprite.addChild(): child should be non-null",
                2616: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
                2617: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
                2618: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
                2619: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
                2623: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
                2625: "too many tiles, only 16384 tiles will be show",
                2626: "Unrecognized fill type in bar fill",
                2627: "Can not generate quad",
                2628: "%s does not exist",
                2710: "Sprite.initWithTexture(): Argument must be non-nil",
                2712: "Invalid spriteFrameName",
                3002: "textureForKey is deprecated. Please use getTextureForKey instead.",
                3005: "cocos2d: '%s' id=%s %s x %s",
                3006: "cocos2d: '%s' id= HTMLCanvasElement %s x %s",
                3007: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
                3103: "cc.Texture.addImage(): path should be non-null",
                3112: "cc.Texture.addImage(): path should be non-null",
                3113: "NSInternalInconsistencyException",
                3116: "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures",
                3117: "Mimpap texture only works in POT textures",
                3119: "Lazy init texture with image element failed due to image loading failure: %s",
                3300: "Rect width exceeds maximum margin: %s",
                3400: "Rect height exceeds maximum margin: %s",
                3500: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
                3501: "Invalid listener type!",
                3502: "Can't set fixed priority with scene graph based listener.",
                3503: "Invalid parameters.",
                3504: "listener must be a cc.EventListener object when adding a fixed priority listener",
                3505: "The listener has been registered, please don't register it again.",
                3506: "Unsupported listener target.",
                3507: "Invalid scene graph priority!",
                3508: "If program goes here, there should be event in dispatch.",
                3509: "_inDispatch should be 1 here.",
                3510: "%s's scene graph node not contains in the parent's children",
                3511: "event is undefined",
                3512: "Event manager only support scene graph priority for ui nodes which contain UIComponent",
                3600: "cc.Class will automatically call super constructor of %s, you should not call it manually.",
                3601: "The editor property 'playOnFocus' should be used with 'executeInEditMode' in class '%s'",
                3602: "Unknown editor property '%s' in class '%s'.",
                3603: "Use 'cc.Float' or 'cc.Integer' instead of 'cc.Number' please.",
                3604: "Can only indicate one type attribute for %s.",
                3605: "The default value of %s is not instance of %s.",
                3606: "No needs to indicate the '%s' attribute for %s, which its default value is type of %s.",
                3607: "The default value of %s must be an empty string.",
                3608: "The type of %s must be CCString, not String.",
                3609: "The type of %s must be CCBoolean, not Boolean.",
                3610: "The type of %s must be CCFloat or CCInteger, not Number.",
                3611: "Can not indicate the '%s' attribute for %s, which its default value is type of %s.",
                3612: "%s Just set the default value to 'new %s()' and it will be handled properly.",
                3613: "'No need to use 'serializable: false' or 'editorOnly: true' for the getter of '%s.%s', every getter is actually non-serialized.",
                3614: "Should not define constructor for cc.Component %s.",
                3615: "Each script can have at most one Component.",
                3616: "Should not specify class name %s for Component which defines in project.",
                3617: "Can not instantiate CCClass '%s' with arguments.",
                3618: "ctor of '%s' can not be another CCClass",
                3619: "ctor of '%s' must be function type",
                3620: "this._super declared in '%s.%s' but no super method defined",
                3621: "Unknown type of %s.%s, maybe you want is '%s'.",
                3622: "Unknown type of %s.%s, property should be defined in 'properties' or 'ctor'",
                3623: "Can not use 'editor' attribute, '%s' not inherits from Components.",
                3624: "'%s' overrided '%s' but '%s' is defined as 'false' so the super method will not be called. You can set '%s' to null to disable this warning.",
                3625: "[isChildClassOf] superclass should be function type, not",
                3626: "Can't remove '%s' because '%s' depends on it.",
                3627: "Should not add renderer component (%s) to a Canvas node.",
                3628: "Should not add %s to a node which size is already used by its other component.",
                3629: "attribute must be type object",
                3633: "Properties function of '%s' should return an object!",
                3634: "Disallow to use '.' in property name",
                3635: "Default array must be empty, set default value of %s.%s to [], and initialize in 'onLoad' or 'ctor' please. (just like 'this.%s = [...];')",
                3636: "Do not set default value to non-empty object, unless the object defines its own 'clone' function. Set default value of %s.%s to null or {}, and initialize in 'onLoad' or 'ctor' please. (just like 'this.%s = {foo: bar};')",
                3637: "Can not declare %s.%s, it is already defined in the prototype of %s",
                3638: "'%s': the getter of '%s' is already defined!",
                3639: "Can not apply the specified attribute to the getter of '%s.%s', attribute index: %s",
                3640: "'%s': the setter of '%s' is already defined!",
                3641: "Can not construct %s because it contains object property.",
                3642: "Cannot define %s.%s because static member name can not be '%s'.",
                3643: "Can not define a member called 'constructor' in the class '%s', please use 'ctor' instead.",
                3644: "Please define 'type' parameter of %s.%s as the actual constructor.",
                3645: "Please define 'type' parameter of %s.%s as the constructor of %s.",
                3646: "Unknown 'type' parameter of %s.%s：%s",
                3647: "The length of range array must be equal or greater than 2",
                3648: "Can not declare %s.%s method, it is already defined in the properties of %s.",
                3649: "CCClass %s have conflict between its ctor and __ctor__.",
                3651: 'Can not call `_super` or `prototype.ctor` in ES6 Classes "%s", use `super` instead please.',
                3652: 'Failed to construct a dummy instance of the "%s" class using `new` behind the scenes. This is for getting default values declared in TypeScript. Please ensure the class will be able to construct during script\'s initialization. %s.',
                3653: 'Please do not specifiy "default" attribute in decorator of "%s" property in "%s" class.\nDefault value must be initialized at their declaration:\n \n// Before:\n@property({\n  type: cc.Integer\n  default: 0  // <--\n})\nvalue;\n// After:\n@property({\n  type: cc.Integer\n})\nvalue = 0;    // <--',
                3654: 'Please specifiy a default value for "%s" property at its declaration:\n \n// Before:\n@property(...)\nvalue;\n// After:\n@property(...)\nvalue = 0',
                3655: 'Can not specifiy "get" or "set"  attribute in decorator for "%s" property in "%s" class.\nPlease use:\n \n@property(...)\nget %s () {\n    ...\n}\n@property\nset %s (value) {\n    ...\n}',
                3656: "The default value of %s.%s must be an empty string. (changed since 1.8)",
                3657: "The value assigned to %s should be Texture2D object, not url string. Since 1.8,\nyou can declare a texture object directly in properties by using:\n \n{\n    default: null,\n    type: cc.Texture2D  // use 'type:' instead of 'url:'\n}",
                3658: "browser does not support getters",
                3700: "internal error: _prefab is undefined",
                3701: "Failed to load prefab asset for node '%s'",
                3800: "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
                3801: "The node can not be made persist because it's not under root node.",
                3802: "The node can not be made persist because it's not in current scene.",
                3803: "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
                3804: "getComponent: Type must be non-nil",
                3805: "Can't add component '%s' because %s already contains the same component.",
                3806: "Can't add component '%s' to %s because it conflicts with the existing '%s' derived component.",
                3807: "addComponent: Failed to get class '%s'",
                3808: "addComponent: Should not add component ('%s') when the scripts are still loading.",
                3809: "addComponent: The component to add must be a constructor",
                3810: "addComponent: The component to add must be child class of cc.Component",
                3811: "_addComponentAt: The component to add must be a constructor",
                3812: "_addComponentAt: Index out of range",
                3813: "removeComponent: Component must be non-nil",
                3814: "Argument must be non-nil",
                3815: "Component not owned by this entity",
                3816: "Node '%s' is already activating",
                3817: "Sorry, the component of '%s' which with an index of %s is corrupted! It has been removed.",
                3818: "Failed to read or parse project.json",
                3819: "Warning: target element is not a DIV or CANVAS",
                3820: "The renderer doesn't support the renderMode %s",
                3821: "Cannot change hierarchy while activating or deactivating the parent.",
                3900: "Invalid clip to add",
                3901: "Invalid clip to remove",
                3902: "clip is defaultClip, set force to true to force remove clip and animation state",
                3903: "animation state is playing, set force to true to force stop and remove clip and animation state",
                3904: "motion path of target [%s] in prop [%s] frame [%s] is not valid",
                3905: "sprite frames must be an Array.",
                3906: "Can't find easing type [%s]",
                3907: "animator not added or already removed",
                3908: "animation not added or already removed",
                3912: "already-playing",
                4e3: "Sorry, the cc.Font has been modified from Raw Asset to Asset. Please load the font asset before using.",
                4003: "Label font size can't be shirnked less than 0!",
                4004: "force notify all fonts loaded!",
                4011: "Property spriteFrame of Font '%s' is invalid. Using system font instead.",
                4012: "The texture of Font '%s' must be already loaded on JSB. Using system font instead.",
                4013: "Sorry, lineHeight of system font not supported on JSB.",
                4100: "Property padding is deprecated, please use paddingLeft, paddingRight, paddingTop and paddingBottom instead",
                4200: "MaskType: IMAGE_STENCIL only support WebGL mode.",
                4201: "The alphaThreshold invalid in Canvas Mode.",
                4202: "The inverted invalid in Canvas Mode.",
                4300: "can not found the %s page.",
                4400: "Invalid RichText img tag! The sprite frame name can't be found in the ImageAtlas!",
                4600: "Script attached to '%s' is missing or invalid.",
                4700: "The dom control is not created!",
                4800: "unknown asset type",
                4901: "loadRes: should not specify the extname in %s %s",
                4902: "No need to release non-cached asset.",
                4903: "Can not get class '%s'",
                4914: "Resources url '%s' does not exist.",
                4915: "Pack indices and data do not match in size",
                4916: "Failed to download package for %s",
                4920: "Sorry, you shouldn't use id as item identity any more, please use url or uuid instead, the current id is being set as url: (%s)",
                4921: "Invalid pipe or invalid index provided!",
                4922: "The pipe to be inserted is already in the pipeline!",
                4923: "Uuid Loader: Parse asset [ %s ] failed : %s",
                4924: "JSON Loader: Input item doesn't contain string content",
                4925: "Uuid Loader: Deserialize asset [ %s ] failed : %s",
                4926: "Audio Downloader: no web audio context.",
                4927: "Audio Downloader: audio not supported on this browser!",
                4928: "Load %s failed!",
                4929: "Load Webp ( %s ) failed",
                4930: "Load image ( %s ) failed",
                4931: "Download Uuid: can not find type of raw asset[ %s ]: %s",
                4932: 'Since v1.10, for any atlas ("%s") in the "resources" directory, it is not possible to find the contained SpriteFrames via `loadRes`, `getRes` or `releaseRes`. Load the SpriteAtlas first and then use `spriteAtlas.getSpriteFrame(name)` instead please.',
                4933: "Download Font [ %s ] failed, using Arial or system default font instead",
                4934: "Please assure that the full path of sub asset is correct!",
                5e3: "object already destroyed",
                5001: "object not yet destroyed",
                5100: "Not a plist file!",
                5200: "Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option",
                5201: "browser don't support web audio",
                5202: "This feature supports WebGL render mode only.",
                5300: "Type of target to deserialize not matched with data: target is %s, data is %s",
                5301: "Can not find script '%s'",
                5302: "Can not find class '%s'",
                5400: "'%s' is deprecated, use '%s' instead please.",
                5401: "'%s' is deprecated, use '%s' instead please.",
                5402: "cc.js.addon called on non-object:",
                5403: "cc.js.mixin: arguments must be type object:",
                5404: "The base class to extend from must be non-nil",
                5405: "The class to extend must be non-nil",
                5406: "Class should be extended before assigning any prototype members.",
                5500: "'notify' can't work with 'get/set' !",
                5501: "'notify' must work with 'default' !",
                5502: "Invalid url of %s.%s",
                5503: "The 'url' attribute of '%s.%s' is undefined when loading script.",
                5504: "The 'url' type of '%s.%s' must be child class of cc.RawAsset.",
                5505: "The 'url' type of '%s.%s' must not be child class of cc.Asset, otherwise you should use 'type: %s' instead.",
                5506: "Can not specify 'type' attribute for '%s.%s', because its 'url' is already defined.",
                5507: "The 'default' attribute of '%s.%s' must be an array",
                5508: "Invalid type of %s.%s",
                5510: "The 'type' attribute of '%s.%s' can not be 'Number', use 'Float' or 'Integer' instead please.",
                5511: "The 'type' attribute of '%s.%s' is undefined when loading script",
                5512: "Can not serialize '%s.%s' because the specified type is anonymous, please provide a class name or set the 'serializable' attribute of '%s.%s' to 'false'.",
                5513: "The 'default' value of '%s.%s' should not be used with a 'get' function.",
                5514: "The 'default' value of '%s.%s' should not be used with a 'set' function.",
                5515: "The 'default' value of '%s.%s' can not be an constructor. Set default to null please.",
                5516: "Property '%s.%s' must define at least one of 'default', 'get' or 'set'.",
                5517: "'%s.%s' hides inherited property '%s.%s'. To make the current property override that implementation, add the `override: true` attribute please.",
                5600: "Argument must be non-nil",
                5601: "Can not get current scene.",
                5602: "Scene is destroyed",
                5603: "reference node is destroyed",
                5700: "no %s or %s on %s",
                5800: "%s.lerp not yet implemented.",
                5801: "%s.clone not yet implemented.",
                5802: "%s.equals not yet implemented.",
                5900: "MotionStreak only support WebGL mode.",
                5901: "cc.MotionStreak.getOpacity has not been supported.",
                5902: "cc.MotionStreak.setOpacity has not been supported.",
                6e3: "Custom should not be false if file is not specified.",
                6001: "The new %s must not be NaN",
                6017: "Incomplete or corrupt PNG file",
                6018: "Invalid filter algorithm: %s",
                6019: "Invalid byte order value.",
                6020: "You forgot your towel!",
                6021: "Unknown Field Tag: %s",
                6022: "Too many bits requested",
                6023: "No bits requested",
                6024: "Cannot recover from missing StripByteCounts",
                6025: "Cannot handle sub-byte bits per sample",
                6026: "Cannot handle sub-byte bits per pixel",
                6027: "Palette image missing color map",
                6028: "Unknown Photometric Interpretation: %s",
                6029: "Unkown error",
                6030: "cc.ParticleSystem: error decoding or ungzipping textureImageData",
                6031: "cc.ParticleSystem: unknown image format with Data",
                6032: "cc.ParticleSystem.initWithDictionary() : error loading the texture",
                6200: "Canvas doesn't support mesh slot!",
                6300: "only cc.DrawNode is accepted as stencil",
                6301: "Stencil buffer is not enabled.",
                6302: "Nesting more than %d stencils is not supported. Everything will be drawn without stencil for this node and its children.",
                6400: "asset.url is not usable in core process",
                6401: "asset.urls is not usable in core process",
                6402: "AssetLibrary has already been initialized!",
                6500: "Widget target must be one of the parent nodes of it",
                6501: "%s's widget target must have UITransformComponent, Please add it in target",
                6600: "collider not added or already removed",
                6601: "Can't find testFunc for (%s, $s).",
                6700: "Can't init canvas '%s' because it conflicts with the existing '%s', the scene should only have one active canvas at the same time",
                6701: "Should not add Canvas to a node which already contains a renderer component (%s).",
                6702: "Should not add Canvas to a node which size is already used by its other component.",
                6703: "Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext",
                6704: "Polygon's point must greater than 2",
                6705: "Argument must be non-nil",
                6800: "Callback of event must be non-nil",
                6801: "The message must be provided",
                6900: "The thing you want to instantiate must be an object",
                6901: "The thing you want to instantiate is nil",
                6902: "The thing you want to instantiate is destroyed",
                6903: "The instantiate method for given asset do not implemented",
                6904: "Can not instantiate array",
                6905: "Can not instantiate DOM element",
                7e3: "Failed to init asset's raw path.",
                7001: "Should not load '%s' from script dynamically, unless it is placed in the 'resources' folder.",
                7002: "Sorry can not load '%s' because it is not placed in the 'resources' folder.",
                7003: "Failed to init builtin asset's raw path.",
                7100: "%s already defined in Enum.",
                7101: "Sorry, 'cc.Enum' not available on this platform, please report this error here: https://github.com/cocos-creator/engine/issues/new",
                7200: "Method 'initWithTMXFile' is no effect now, please set property 'tmxAsset' instead.",
                7201: "Method 'initWithXML' is no effect now, please set property 'tmxAsset' instead.",
                7202: "Add component TiledLayer into node failed.",
                7203: "Property 'mapLoaded' is unused now. Please write the logic to the callback 'start'.",
                7210: "TMX Hexa zOrder not supported",
                7211: "TMX invalid value",
                7214: "propertiesForGID is deprecated. Please use getPropertiesForGID instead.",
                7215: "cocos2d: Warning: TMX Layer %s has no tiles",
                7216: "cocos2d: TMXFormat: Unsupported TMX version: %s",
                7217: "cocos2d: TMXFomat: Unsupported orientation: %s",
                7218: "cc.TMXMapInfo.parseXMLFile(): unsupported compression method",
                7219: "cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported",
                7221: "cc.TMXMapInfo.parseXMLFile(): Texture '%s' not found.",
                7222: "Parse %s failed.",
                7236: "cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released",
                7237: "cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released",
                7238: "cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released",
                7239: "cc.TMXLayer.setTileGID(): invalid gid: %s",
                7240: "cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released",
                7241: "cc.TiledMap.initWithXML(): Map not found. Please check the filename.",
                7401: "Failed to set _defaultArmatureIndex for '%s' because the index is out of range.",
                7402: "Failed to set _animationIndex for '%s' because the index is out of range.",
                7501: "Failed to set _defaultSkinIndex for '%s' because the index is out of range.",
                7502: "Failed to set _animationIndex for '%s' because its skeletonData is invalid.",
                7503: "Failed to set _animationIndex for '%s' because the index is out of range.",
                7504: "Can not render dynamic created SkeletonData",
                7505: "Invalid type of atlasFile, atlas should be registered as raw asset.",
                7506: "Failed to load spine atlas '$s'",
                7507: "Please re-import '%s' because its textures is not initialized! (This workflow will be improved in the future.)",
                7508: "The atlas asset of '%s' is not exists!",
                7509: "Spine: Animation not found: %s",
                7510: "Spine: Animation not found: %s",
                7600: "The context of RenderTexture is invalid.",
                7601: "cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;",
                7602: "Could not attach texture to the framebuffer",
                7603: "clearDepth isn't supported on Cocos2d-Html5",
                7604: "saveToFile isn't supported on Cocos2d-Html5",
                7605: "newCCImage isn't supported on Cocos2d-Html5",
                7700: "On the web is always keep the aspect ratio",
                7701: "Can't know status",
                7702: "Video player's duration is not ready to get now!",
                7800: "Web does not support loading",
                7801: "Web does not support query history",
                7802: "Web does not support query history",
                7803: "The current browser does not support the GoBack",
                7804: "The current browser does not support the GoForward",
                7805: "Web does not support zoom",
                7900: "cc.math.Matrix3.assign(): current matrix equals matIn",
                7901: "cc.math.mat4Assign(): pOut equals pIn",
                7902: "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
                7903: "cc.math.Matrix4 equal: pMat1 and pMat2 are same object.",
                7904: "cc.math.Matrix4.extractPlane: Invalid plane index",
                7905: "cc.math.mat4Assign(): pOut equals pIn",
                7906: "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
                7907: "cc.math.Matrix4 equals: pMat1 and pMat2 are same object.",
                7908: "Invalid matrix mode specified",
                7909: "current quaternion is an invalid value",
                8e3: "Can't handle this field type or size",
                8001: "No bytes requested",
                8002: "Too many bytes requested",
                8003: "Missing StripByteCounts!",
                8100: "cocos2d: ERROR: Failed to compile shader:\n %s",
                8101: "cocos2d: ERROR: Failed to compile vertex shader",
                8102: "cocos2d: ERROR: Failed to compile fragment shader",
                8103: "cc.GLProgram.link(): Cannot link invalid program",
                8104: "cocos2d: ERROR: Failed to link program: %s",
                8105: "cocos2d: cc.shaderCache._loadDefaultShader, error shader type",
                8106: "Please load the resource firset : %s",
                8107: "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null",
                8108: "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized",
                8109: "modelView matrix is undefined.",
                8200: "Please set node's active instead of rigidbody's enabled.",
                8300: "Should only one camera exists, please check your project.",
                8301: "Camera does not support Canvas Mode.",
                8400: "Wrong type arguments, 'filePath' must be a String.",
                8401: "Since 1.10, `%s` accept %s instance directly, not a URL string. Please directly reference the %s object in your script, or load %s by loader first. Don't use %s's URL anymore.",
                9e3: "Stencil manager does not support level bigger than %d in this device.",
                9001: "Stencil manager is already empty, cannot pop any mask",
                9100: "texture size exceeds current device limits %d/%d",
                "0100": "%s not yet implemented.",
                "0200": "You should specify a valid DOM canvas element."
            }, logList = null, ccLog = console.log, ccWarn = console.log, ccError = console.log, ccAssert = function ccAssert(condition, message) {
                if (!condition) {
                    for (var _len = arguments.length, optionalParams = new Array(2 < _len ? _len - 2 : 0), _key = 2; _key < _len; _key++) optionalParams[_key - 2] = arguments[_key];
                    console.log("ASSERT: " + formatString.apply(void 0, [ message ].concat(optionalParams)));
                }
            };
            function formatString(message) {
                for (var _len2 = arguments.length, optionalParams = new Array(1 < _len2 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) optionalParams[_key2 - 1] = arguments[_key2];
                return cc.js.formatStr.apply(null, [ message ].concat(optionalParams));
            }
            function log(message) {
                for (var _len3 = arguments.length, optionalParams = new Array(1 < _len3 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) optionalParams[_key3 - 1] = arguments[_key3];
                return ccLog.apply(void 0, [ message ].concat(optionalParams));
            }
            function warn(message) {
                for (var _len4 = arguments.length, optionalParams = new Array(1 < _len4 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) optionalParams[_key4 - 1] = arguments[_key4];
                return ccWarn.apply(void 0, [ message ].concat(optionalParams));
            }
            function error(message) {
                for (var _len5 = arguments.length, optionalParams = new Array(1 < _len5 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) optionalParams[_key5 - 1] = arguments[_key5];
                return ccError.apply(void 0, [ message ].concat(optionalParams));
            }
            function assert(value, message) {
                for (var _len6 = arguments.length, optionalParams = new Array(2 < _len6 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) optionalParams[_key6 - 2] = arguments[_key6];
                return ccAssert.apply(void 0, [ value, message ].concat(optionalParams));
            }
            function _resetDebugSetting(mode) {
                if (ccLog = ccWarn = ccError = ccAssert = function ccAssert() {}, mode !== DebugMode.NONE) {
                    if (mode > DebugMode.ERROR) {
                        var logToWebPage = function logToWebPage(msg) {
                            if (cc.game.canvas) {
                                if (!logList) {
                                    var logDiv = document.createElement("Div");
                                    logDiv.setAttribute("id", "logInfoDiv"), logDiv.setAttribute("width", "200"), logDiv.setAttribute("height", cc.game.canvas.height);
                                    var logDivStyle = logDiv.style;
                                    logDivStyle.zIndex = "99999", logDivStyle.position = "absolute", logDivStyle.top = logDivStyle.left = "0", 
                                    (logList = document.createElement("textarea")).setAttribute("rows", "20"), logList.setAttribute("cols", "30"), 
                                    logList.setAttribute("disabled", "true");
                                    var logListStyle = logList.style;
                                    logListStyle.backgroundColor = "transparent", logListStyle.borderBottom = "1px solid #cccccc", 
                                    logListStyle.borderTopWidth = logListStyle.borderLeftWidth = logListStyle.borderRightWidth = "0px", 
                                    logListStyle.borderTopStyle = logListStyle.borderLeftStyle = logListStyle.borderRightStyle = "none", 
                                    logListStyle.padding = "0px", logListStyle.margin = "0px", logDiv.appendChild(logList), 
                                    cc.game.canvas.parentNode.appendChild(logDiv);
                                }
                                logList.value = logList.value + msg + "\r\n", logList.scrollTop = logList.scrollHeight;
                            }
                        };
                        ccError = function ccError(message) {
                            for (var _len7 = arguments.length, optionalParams = new Array(1 < _len7 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) optionalParams[_key7 - 1] = arguments[_key7];
                            logToWebPage("ERROR :  " + formatString.apply(void 0, [ message ].concat(optionalParams)));
                        }, ccAssert = function ccAssert(condition, message) {
                            if (!condition) {
                                for (var _len8 = arguments.length, optionalParams = new Array(2 < _len8 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) optionalParams[_key8 - 2] = arguments[_key8];
                                logToWebPage("ASSERT: " + formatString.apply(void 0, [ message ].concat(optionalParams)));
                            }
                        }, mode !== DebugMode.ERROR_FOR_WEB_PAGE && (ccWarn = function ccWarn(message) {
                            for (var _len9 = arguments.length, optionalParams = new Array(1 < _len9 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) optionalParams[_key9 - 1] = arguments[_key9];
                            logToWebPage("WARN :  " + formatString.apply(void 0, [ message ].concat(optionalParams)));
                        }), mode === DebugMode.INFO_FOR_WEB_PAGE && (ccLog = function ccLog(message) {
                            for (var _len10 = arguments.length, optionalParams = new Array(1 < _len10 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) optionalParams[_key10 - 1] = arguments[_key10];
                            logToWebPage(formatString.apply(void 0, [ message ].concat(optionalParams)));
                        });
                    } else console && console.log.apply && (console.error || (console.error = console.log), 
                    console.warn || (console.warn = console.log), ccError = console.error.bind ? console.error.bind(console) : function(message) {
                        for (var _len11 = arguments.length, optionalParams = new Array(1 < _len11 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) optionalParams[_key11 - 1] = arguments[_key11];
                        return console.error.apply(console, [ message ].concat(optionalParams));
                    }, ccAssert = function ccAssert(condition, message) {
                        if (!condition) {
                            for (var _len12 = arguments.length, optionalParams = new Array(2 < _len12 ? _len12 - 2 : 0), _key12 = 2; _key12 < _len12; _key12++) optionalParams[_key12 - 2] = arguments[_key12];
                            var errorText = formatString.apply(void 0, [ message ].concat(optionalParams));
                            throw new Error(errorText);
                        }
                    });
                    mode !== DebugMode.ERROR && (ccWarn = console.warn.bind ? console.warn.bind(console) : function(message) {
                        for (var _len13 = arguments.length, optionalParams = new Array(1 < _len13 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) optionalParams[_key13 - 1] = arguments[_key13];
                        return console.warn.apply(console, [ message ].concat(optionalParams));
                    }), mode === DebugMode.INFO && (ccLog = console.log.bind ? console.log.bind(console) : function ccLog(message) {
                        for (var _len15 = arguments.length, optionalParams = new Array(1 < _len15 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) optionalParams[_key15 - 1] = arguments[_key15];
                        return console.log.apply(console, [ message ].concat(optionalParams));
                    });
                }
            }
            function _throw(error_) {
                var stack = error_.stack;
                error(stack || error_);
            }
            function getTypedFormatter() {
                return function(id) {
                    for (var msg = debugInfos[id] || "unknown id", _len16 = arguments.length, args = new Array(1 < _len16 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) args[_key16 - 1] = arguments[_key16];
                    return 0 === args.length ? msg : formatString.apply(void 0, [ msg ].concat(args));
                };
            }
            var logFormatter = getTypedFormatter();
            function logID(id) {
                for (var _len17 = arguments.length, optionalParams = new Array(1 < _len17 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) optionalParams[_key17 - 1] = arguments[_key17];
                log(logFormatter.apply(void 0, [ id ].concat(optionalParams)));
            }
            var warnFormatter = getTypedFormatter();
            function warnID(id) {
                for (var _len18 = arguments.length, optionalParams = new Array(1 < _len18 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) optionalParams[_key18 - 1] = arguments[_key18];
                warn(warnFormatter.apply(void 0, [ id ].concat(optionalParams)));
            }
            var errorFormatter = getTypedFormatter();
            function errorID(id) {
                for (var _len19 = arguments.length, optionalParams = new Array(1 < _len19 ? _len19 - 1 : 0), _key19 = 1; _key19 < _len19; _key19++) optionalParams[_key19 - 1] = arguments[_key19];
                error(errorFormatter.apply(void 0, [ id ].concat(optionalParams)));
            }
            var DebugMode, assertFormatter = getTypedFormatter();
            function assertID(condition, id) {
                if (!condition) {
                    for (var _len20 = arguments.length, optionalParams = new Array(2 < _len20 ? _len20 - 2 : 0), _key20 = 2; _key20 < _len20; _key20++) optionalParams[_key20 - 2] = arguments[_key20];
                    assert(!1, assertFormatter.apply(void 0, [ id ].concat(optionalParams)));
                }
            }
            function getError(errorId) {
                for (var _len21 = arguments.length, param = new Array(1 < _len21 ? _len21 - 1 : 0), _key21 = 1; _key21 < _len21; _key21++) param[_key21 - 1] = arguments[_key21];
                return errorFormatter.apply(void 0, [ errorId ].concat(param));
            }
            function isDisplayStats() {
                return !!cc.profiler && cc.profiler.isShowingStats();
            }
            function setDisplayStats(displayStats) {
                cc.profiler && (displayStats ? cc.profiler.showStats() : cc.profiler.hideStats(), 
                cc.game.config.showFPS = !!displayStats);
            }
            !function(DebugMode) {
                DebugMode[DebugMode.NONE = 0] = "NONE", DebugMode[DebugMode.INFO = 1] = "INFO", 
                DebugMode[DebugMode.WARN = 2] = "WARN", DebugMode[DebugMode.ERROR = 3] = "ERROR", 
                DebugMode[DebugMode.INFO_FOR_WEB_PAGE = 4] = "INFO_FOR_WEB_PAGE", DebugMode[DebugMode.WARN_FOR_WEB_PAGE = 5] = "WARN_FOR_WEB_PAGE", 
                DebugMode[DebugMode.ERROR_FOR_WEB_PAGE = 6] = "ERROR_FOR_WEB_PAGE";
            }(DebugMode = DebugMode || {});
            var debug = Object.freeze({
                log: log,
                warn: warn,
                error: error,
                assert: assert,
                _resetDebugSetting: _resetDebugSetting,
                _throw: _throw,
                logID: logID,
                warnID: warnID,
                errorID: errorID,
                assertID: assertID,
                get DebugMode() {
                    return DebugMode;
                },
                getError: getError,
                isDisplayStats: isDisplayStats,
                setDisplayStats: setDisplayStats
            }), EXTNAME_RE = /(\.[^\.\/\?\\]*)(\?.*)?$/, DIRNAME_RE = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/, NORMALIZE_RE = /[^\.\/]+\/\.\.\//;
            function join() {
                for (var result = "", _len = arguments.length, segments = new Array(_len), _key = 0; _key < _len; _key++) segments[_key] = arguments[_key];
                for (var _i = 0, _segments = segments; _i < _segments.length; _i++) {
                    result = (result + ("" === result ? "" : "/") + _segments[_i]).replace(/(\/|\\\\)$/, "");
                }
                return result;
            }
            function extname(path) {
                var temp = EXTNAME_RE.exec(path);
                return temp ? temp[1] : "";
            }
            function mainFileName(fileName) {
                if (fileName) {
                    var idx = fileName.lastIndexOf(".");
                    if (-1 !== idx) return fileName.substring(0, idx);
                }
                return fileName;
            }
            function basename(path, extName) {
                var index = path.indexOf("?");
                0 < index && (path = path.substring(0, index));
                var result = /(\/|\\)([^\/\\]+)$/g.exec(path.replace(/(\/|\\)$/, ""));
                if (!result) return "";
                var baseName = result[2];
                return extName && path.substring(path.length - extName.length).toLowerCase() === extName.toLowerCase() ? baseName.substring(0, baseName.length - extName.length) : baseName;
            }
            function dirname(path) {
                var temp = DIRNAME_RE.exec(path);
                return temp ? temp[2] : "";
            }
            function changeExtname(path, extName) {
                extName = extName || "";
                var index = path.indexOf("?"), tempStr = "";
                return 0 < index && (tempStr = path.substring(index), path = path.substring(0, index)), 
                (index = path.lastIndexOf(".")) < 0 ? path + extName + tempStr : path.substring(0, index) + extName + tempStr;
            }
            function changeBasename(path, baseName, isSameExt) {
                if (0 === baseName.indexOf(".")) return changeExtname(path, baseName);
                var index = path.indexOf("?"), tempStr = "", ext = isSameExt ? extname(path) : "";
                return 0 < index && (tempStr = path.substring(index), path = path.substring(0, index)), 
                index = (index = path.lastIndexOf("/")) <= 0 ? 0 : index + 1, path.substring(0, index) + baseName + ext + tempStr;
            }
            function _normalize(url) {
                for (var oldUrl = url = String(url); url = (oldUrl = url).replace(NORMALIZE_RE, ""), 
                oldUrl.length !== url.length; ) ;
                return url;
            }
            function stripSep(path) {
                return path.replace(/[\/\\]$/, "");
            }
            function getSeperator() {
                return cc.sys.os === cc.sys.OS_WINDOWS ? "\\" : "/";
            }
            exports("path", Object.freeze({
                join: join,
                extname: extname,
                mainFileName: mainFileName,
                basename: basename,
                dirname: dirname,
                changeExtname: changeExtname,
                changeBasename: changeBasename,
                _normalize: _normalize,
                stripSep: stripSep,
                getSeperator: getSeperator
            })), cc.log = log, cc.warn = warn, cc.error = error, cc.assert = assert, cc._throw = _throw, 
            cc.logID = logID, cc.warnID = warnID, cc.errorID = errorID, cc.assertID = assertID, 
            cc.debug = debug, cc.path = {
                join: join,
                extname: extname,
                mainFileName: mainFileName,
                basename: basename,
                dirname: dirname,
                changeExtname: changeExtname,
                changeBasename: changeBasename,
                _normalize: _normalize,
                stripSep: stripSep,
                get sep() {
                    return getSeperator();
                }
            };
            function sign(v) {
                return (0 < v) - (v < 0);
            }
            function countTrailingZeros(v) {
                var c = 32;
                return (v &= -v) && c--, 65535 & v && (c -= 16), 16711935 & v && (c -= 8), 252645135 & v && (c -= 4), 
                858993459 & v && (c -= 2), 1431655765 & v && (c -= 1), c;
            }
            var REVERSE_TABLE = new Array(256);
            !function(tab) {
                for (var i = 0; i < 256; ++i) {
                    var v = i, r = i, s = 7;
                    for (v >>>= 1; v; v >>>= 1) r <<= 1, r |= 1 & v, --s;
                    tab[i] = r << s & 255;
                }
            }(REVERSE_TABLE);
            var bits = Object.freeze({
                INT_BITS: 32,
                INT_MAX: 2147483647,
                INT_MIN: -1 << 31,
                sign: sign,
                abs: function abs(v) {
                    var mask = v >> 31;
                    return (v ^ mask) - mask;
                },
                min: function min(x, y) {
                    return y ^ (x ^ y) & -(x < y);
                },
                max: function max(x, y) {
                    return x ^ (x ^ y) & -(x < y);
                },
                isPow2: function isPow2(v) {
                    return !(v & v - 1 || !v);
                },
                log2: function log2(v) {
                    var r, shift;
                    return r = (65535 < v) << 4, r |= shift = (255 < (v >>>= r)) << 3, r |= shift = (15 < (v >>>= shift)) << 2, 
                    (r |= shift = (3 < (v >>>= shift)) << 1) | (v >>>= shift) >> 1;
                },
                log10: function log10(v) {
                    return 1e9 <= v ? 9 : 1e8 <= v ? 8 : 1e7 <= v ? 7 : 1e6 <= v ? 6 : 1e5 <= v ? 5 : 1e4 <= v ? 4 : 1e3 <= v ? 3 : 100 <= v ? 2 : 10 <= v ? 1 : 0;
                },
                popCount: function popCount(v) {
                    return 16843009 * ((v = (858993459 & (v -= v >>> 1 & 1431655765)) + (v >>> 2 & 858993459)) + (v >>> 4) & 252645135) >>> 24;
                },
                countTrailingZeros: countTrailingZeros,
                nextPow2: function nextPow2(v) {
                    return v += 0 === v, --v, v |= v >>> 1, v |= v >>> 2, v |= v >>> 4, v |= v >>> 8, 
                    (v |= v >>> 16) + 1;
                },
                prevPow2: function prevPow2(v) {
                    return v |= v >>> 1, v |= v >>> 2, v |= v >>> 4, v |= v >>> 8, (v |= v >>> 16) - (v >>> 1);
                },
                parity: function parity(v) {
                    return v ^= v >>> 16, v ^= v >>> 8, v ^= v >>> 4, 27030 >>> (v &= 15) & 1;
                },
                reverse: function reverse(v) {
                    return REVERSE_TABLE[255 & v] << 24 | REVERSE_TABLE[v >>> 8 & 255] << 16 | REVERSE_TABLE[v >>> 16 & 255] << 8 | REVERSE_TABLE[v >>> 24 & 255];
                },
                interleave2: function interleave2(x, y) {
                    return (x = 1431655765 & ((x = 858993459 & ((x = 252645135 & ((x = 16711935 & ((x &= 65535) | x << 8)) | x << 4)) | x << 2)) | x << 1)) | (y = 1431655765 & ((y = 858993459 & ((y = 252645135 & ((y = 16711935 & ((y &= 65535) | y << 8)) | y << 4)) | y << 2)) | y << 1)) << 1;
                },
                deinterleave2: function deinterleave2(v, n) {
                    return (v = 65535 & ((v = 16711935 & ((v = 252645135 & ((v = 858993459 & ((v = v >>> n & 1431655765) | v >>> 1)) | v >>> 2)) | v >>> 4)) | v >>> 16)) << 16 >> 16;
                },
                interleave3: function interleave3(x, y, z) {
                    return x = 1227133513 & ((x = 3272356035 & ((x = 251719695 & ((x = 4278190335 & ((x &= 1023) | x << 16)) | x << 8)) | x << 4)) | x << 2), 
                    (x |= (y = 1227133513 & ((y = 3272356035 & ((y = 251719695 & ((y = 4278190335 & ((y &= 1023) | y << 16)) | y << 8)) | y << 4)) | y << 2)) << 1) | (z = 1227133513 & ((z = 3272356035 & ((z = 251719695 & ((z = 4278190335 & ((z &= 1023) | z << 16)) | z << 8)) | z << 4)) | z << 2)) << 2;
                },
                deinterleave3: function deinterleave3(v, n) {
                    return (v = 1023 & ((v = 4278190335 & ((v = 251719695 & ((v = 3272356035 & ((v = v >>> n & 1227133513) | v >>> 2)) | v >>> 4)) | v >>> 8)) | v >>> 16)) << 22 >> 22;
                },
                nextCombination: function nextCombination(v) {
                    var t = v | v - 1;
                    return 1 + t | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
                }
            });
            exports("bits", bits);
            var MutableForwardIterator = function() {
                function MutableForwardIterator(array) {
                    _classCallCheck(this, MutableForwardIterator), this.array = array, this.i = 0;
                }
                return _createClass(MutableForwardIterator, [ {
                    key: "remove",
                    value: function remove(value) {
                        var index = this.array.indexOf(value);
                        0 <= index && this.removeAt(index);
                    }
                }, {
                    key: "removeAt",
                    value: function removeAt(i) {
                        this.array.splice(i, 1), i <= this.i && --this.i;
                    }
                }, {
                    key: "fastRemove",
                    value: function fastRemove(value) {
                        var index = this.array.indexOf(value);
                        0 <= index && this.fastRemoveAt(index);
                    }
                }, {
                    key: "fastRemoveAt",
                    value: function fastRemoveAt(i) {
                        var array = this.array;
                        array[i] = array[array.length - 1], --array.length, i <= this.i && --this.i;
                    }
                }, {
                    key: "push",
                    value: function push(item) {
                        this.array.push(item);
                    }
                }, {
                    key: "length",
                    get: function get() {
                        return this.array.length;
                    },
                    set: function set(value) {
                        this.array.length = value, this.i >= value && (this.i = value - 1);
                    }
                } ]), MutableForwardIterator;
            }();
            function removeAt(array, index) {
                array.splice(index, 1);
            }
            function remove(array, value) {
                var index = array.indexOf(value);
                return 0 <= index && (removeAt(array, index), !0);
            }
            function contains(array, value) {
                return 0 <= array.indexOf(value);
            }
            var jsarray = Object.freeze({
                removeAt: removeAt,
                fastRemoveAt: function fastRemoveAt(array, index) {
                    var length = array.length;
                    index < 0 || length <= index || (array[index] = array[length - 1], array.length = length - 1);
                },
                remove: remove,
                fastRemove: function fastRemove(array, value) {
                    var index = array.indexOf(value);
                    0 <= index && (array[index] = array[array.length - 1], --array.length);
                },
                removeIf: function removeIf(array, predicate) {
                    var index = array.findIndex(predicate);
                    if (0 <= index) {
                        var _value = array[index];
                        return removeAt(array, index), _value;
                    }
                },
                verifyType: function verifyType(array, type) {
                    if (array && 0 < array.length) {
                        var _iterator = array, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            if (!(_ref instanceof type)) return cc.logID(1300), !1;
                        }
                    }
                    return !0;
                },
                removeArray: function removeArray(array, minusArr) {
                    for (var i = 0, l = minusArr.length; i < l; i++) remove(array, minusArr[i]);
                },
                appendObjectsAt: function appendObjectsAt(array, addObjs, index) {
                    return array.splice.apply(array, [ index, 0 ].concat(_toConsumableArray(addObjs))), 
                    array;
                },
                indexOf: function indexOf(array, searchElement, fromIndex) {
                    return Array.prototype.indexOf.call(array, [ searchElement, fromIndex ]);
                },
                contains: contains,
                copy: function copy(array) {
                    for (var len = array.length, arr_clone = new Array(len), i = 0; i < len; i += 1) arr_clone[i] = array[i];
                    return arr_clone;
                },
                MutableForwardIterator: MutableForwardIterator
            }), IDGenerator = function() {
                function IDGenerator(category) {
                    _classCallCheck(this, IDGenerator), this.id = void 0, this.prefix = void 0, this.id = 0 | 998 * Math.random(), 
                    this.prefix = category ? category + "." : "";
                }
                return _createClass(IDGenerator, [ {
                    key: "getNewId",
                    value: function getNewId() {
                        return this.prefix + ++this.id;
                    }
                } ]), IDGenerator;
            }();
            IDGenerator.global = new IDGenerator("global");
            var tempCIDGenerator = new IDGenerator("TmpCId.");
            function isNumber(object) {
                return "number" == typeof object || object instanceof Number;
            }
            function isString(object) {
                return "string" == typeof object || object instanceof String;
            }
            var descriptor, value = (descriptor = {
                value: void 0,
                enumerable: !1,
                writable: !1,
                configurable: !0
            }, function(object, propertyName, value_, writable, enumerable) {
                descriptor.value = value_, descriptor.writable = writable, descriptor.enumerable = enumerable, 
                Object.defineProperty(object, propertyName, descriptor), descriptor.value = void 0;
            }), getset = function() {
                var descriptor = {
                    get: void 0,
                    set: void 0,
                    enumerable: !1
                };
                return function(object, propertyName, getter, setter) {
                    var enumerable = 4 < arguments.length && void 0 !== arguments[4] && arguments[4], configurable = 5 < arguments.length && void 0 !== arguments[5] && arguments[5];
                    "boolean" == typeof setter && (enumerable = setter, setter = void 0), descriptor.get = getter, 
                    descriptor.set = setter, descriptor.enumerable = enumerable, descriptor.configurable = configurable, 
                    Object.defineProperty(object, propertyName, descriptor), descriptor.get = void 0, 
                    descriptor.set = void 0;
                };
            }(), get = function() {
                var descriptor = {
                    get: void 0,
                    enumerable: !1,
                    configurable: !1
                };
                return function(object, propertyName, getter, enumerable, configurable) {
                    descriptor.get = getter, descriptor.enumerable = enumerable, descriptor.configurable = configurable, 
                    Object.defineProperty(object, propertyName, descriptor), descriptor.get = void 0;
                };
            }(), set$1 = function() {
                var descriptor = {
                    set: void 0,
                    enumerable: !1,
                    configurable: !1
                };
                return function(object, propertyName, setter, enumerable, configurable) {
                    descriptor.set = setter, descriptor.enumerable = enumerable, descriptor.configurable = configurable, 
                    Object.defineProperty(object, propertyName, descriptor), descriptor.set = void 0;
                };
            }();
            function createMap(forceDictMode) {
                var map = Object.create(null);
                if (forceDictMode) {
                    map["."] = !0, map["/"] = !0, delete map["."], delete map["/"];
                }
                return map;
            }
            function getClassName(objOrCtor) {
                if ("function" != typeof objOrCtor) return objOrCtor && objOrCtor.constructor ? getClassName(objOrCtor.constructor) : "";
                var prototype = objOrCtor.prototype;
                if (prototype && prototype.hasOwnProperty("__classname__") && prototype.__classname__) return prototype.__classname__;
                var retval = "";
                if (objOrCtor.name && (retval = objOrCtor.name), objOrCtor.toString) {
                    var arr, str = objOrCtor.toString();
                    (arr = "[" === str.charAt(0) ? str.match(/\[\w+\s*(\w+)\]/) : str.match(/function\s*(\w+)/)) && 2 === arr.length && (retval = arr[1]);
                }
                return "Object" !== retval ? retval : "";
            }
            function obsolete(object, obsoleted, newExpr, writable) {
                var extractPropName = /([^.]+)$/, oldProp = extractPropName.exec(obsoleted)[0], newProp = extractPropName.exec(newExpr)[0];
                function getter() {
                    return this[newProp];
                }
                writable ? getset(object, oldProp, getter, function setter(value_) {
                    this[newProp] = value_;
                }) : get(object, oldProp, getter);
            }
            function obsoletes(obj, objName, props, writable) {
                for (var obsoleted in props) {
                    obsolete(obj, objName + "." + obsoleted, props[obsoleted], writable);
                }
            }
            var REGEXP_NUM_OR_STR = /(%d)|(%s)/, REGEXP_STR = /%s/;
            function formatStr(msg) {
                for (var _len = arguments.length, subst = new Array(1 < _len ? _len - 1 : 0), _key = 1; _key < _len; _key++) subst[_key - 1] = arguments[_key];
                if (0 === arguments.length) return "";
                if (0 === subst.length) return "" + msg;
                if ("string" == typeof msg && REGEXP_NUM_OR_STR.test(msg)) {
                    var _iterator = subst, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var arg = _ref, regExpToTest = "number" == typeof arg ? REGEXP_NUM_OR_STR : REGEXP_STR;
                        regExpToTest.test(msg) ? msg = msg.replace(regExpToTest, arg) : msg += " " + arg;
                    }
                } else {
                    var _iterator2 = subst, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        msg += " " + _ref2;
                    }
                }
                return msg;
            }
            function shiftArguments() {
                for (var len = arguments.length - 1, args = new Array(len), i = 0; i < len; ++i) args[i] = arguments[i + 1];
                return args;
            }
            function getPropertyDescriptor(object, propertyName) {
                for (;object; ) {
                    var pd = Object.getOwnPropertyDescriptor(object, propertyName);
                    if (pd) return pd;
                    object = Object.getPrototypeOf(object);
                }
                return null;
            }
            function _copyprop(name, source, target) {
                var pd = getPropertyDescriptor(source, name);
                pd && Object.defineProperty(target, name, pd);
            }
            function addon(object) {
                object = object || {};
                for (var _len2 = arguments.length, sources = new Array(1 < _len2 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) sources[_key2 - 1] = arguments[_key2];
                for (var _i3 = 0, _sources = sources; _i3 < _sources.length; _i3++) {
                    var source = _sources[_i3];
                    if (source) {
                        if ("object" !== _typeof(source)) {
                            cc.errorID(5402, source);
                            continue;
                        }
                        for (var name in source) name in object || _copyprop(name, source, object);
                    }
                }
                return object;
            }
            function mixin(object) {
                object = object || {};
                for (var _len3 = arguments.length, sources = new Array(1 < _len3 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) sources[_key3 - 1] = arguments[_key3];
                for (var _i4 = 0, _sources2 = sources; _i4 < _sources2.length; _i4++) {
                    var source = _sources2[_i4];
                    if (source) {
                        if ("object" !== _typeof(source)) {
                            cc.errorID(5403, source);
                            continue;
                        }
                        for (var name in source) _copyprop(name, source, object);
                    }
                }
                return object;
            }
            function extend(cls, base) {
                for (var p in base) base.hasOwnProperty(p) && (cls[p] = base[p]);
                return cls.prototype = Object.create(base.prototype, {
                    constructor: {
                        value: cls,
                        writable: !0,
                        configurable: !0
                    }
                }), cls;
            }
            function getSuper(constructor) {
                var proto = constructor.prototype, dunderProto = proto && Object.getPrototypeOf(proto);
                return dunderProto && dunderProto.constructor;
            }
            function isChildClassOf(subclass, superclass) {
                if (subclass && superclass) {
                    if ("function" != typeof subclass) return !1;
                    if ("function" != typeof superclass) return !1;
                    if (subclass === superclass) return !0;
                    for (;;) {
                        if (!(subclass = getSuper(subclass))) return !1;
                        if (subclass === superclass) return !0;
                    }
                }
                return !1;
            }
            function clear(object) {
                for (var _i5 = 0, _Object$keys = Object.keys(object); _i5 < _Object$keys.length; _i5++) {
                    delete object[_Object$keys[_i5]];
                }
            }
            var _idToClass = {}, _nameToClass = {};
            function _setClassId(id, constructor) {
                var key = "__cid__", table = _idToClass;
                if (constructor.prototype.hasOwnProperty(key) && delete table[constructor.prototype[key]], 
                value(constructor.prototype, key, id), id) {
                    var registered = table[id];
                    if (registered && registered !== constructor) {
                        var error = 'A Class already exists with the same __cid__ : "' + id + '".';
                        0, cc.error(error);
                    } else table[id] = constructor;
                }
            }
            function setClassName(className, constructor) {
                if (function doSetClassName(id, constructor) {
                    var key = "__classname__", table = _nameToClass;
                    if (constructor.prototype.hasOwnProperty(key) && delete table[constructor.prototype[key]], 
                    value(constructor.prototype, key, id), id) {
                        var registered = table[id];
                        if (registered && registered !== constructor) {
                            var error = "A Class already exists with the same " + key + ' : "' + id + '".';
                            0, cc.error(error);
                        } else table[id] = constructor;
                    }
                }(className, constructor), !constructor.prototype.hasOwnProperty("__cid__")) {
                    var id = className || tempCIDGenerator.getNewId();
                    id && _setClassId(id, constructor);
                }
            }
            function unregisterClass() {
                for (var _len4 = arguments.length, constructors = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) constructors[_key4] = arguments[_key4];
                for (var _i6 = 0, _constructors = constructors; _i6 < _constructors.length; _i6++) {
                    var p = _constructors[_i6].prototype, classId = p.__cid__;
                    classId && delete _idToClass[classId];
                    var classname = p.__classname__;
                    classname && delete _nameToClass[classname];
                }
            }
            function _getClassById(classId) {
                return _idToClass[classId];
            }
            function getClassByName(classname) {
                return _nameToClass[classname];
            }
            function _getClassId(obj, allowTempId) {
                if (allowTempId = void 0 === allowTempId || allowTempId, "function" == typeof obj && obj.prototype.hasOwnProperty("__cid__")) return obj.prototype.__cid__;
                if (obj && obj.constructor) {
                    var prototype = obj.constructor.prototype;
                    if (prototype && prototype.hasOwnProperty("__cid__")) return obj.__cid__;
                }
                return "";
            }
            var Pool = function() {
                function Pool(_0, _1) {
                    _classCallCheck(this, Pool), this.count = void 0, this._pool = void 0;
                    var size = (this._cleanup = void 0) === _1 ? _0 : _1, cleanupFunc = void 0 === _1 ? null : _0;
                    this.count = 0, this._pool = new Array(size), this._cleanup = cleanupFunc;
                }
                return _createClass(Pool, [ {
                    key: "get",
                    value: function get() {
                        return this._get();
                    }
                } ]), _createClass(Pool, [ {
                    key: "_get",
                    value: function _get() {
                        if (0 < this.count) {
                            --this.count;
                            var cache = this._pool[this.count];
                            return this._pool[this.count] = null, cache;
                        }
                        return null;
                    }
                }, {
                    key: "put",
                    value: function put(obj) {
                        var pool = this._pool;
                        if (this.count < pool.length) {
                            if (this._cleanup && !1 === this._cleanup(obj)) return;
                            pool[this.count] = obj, ++this.count;
                        }
                    }
                }, {
                    key: "resize",
                    value: function resize(length) {
                        0 <= length && (this._pool.length = length, this.count > length && (this.count = length));
                    }
                } ]), Pool;
            }(), array = jsarray, js = {
                IDGenerator: IDGenerator,
                Pool: Pool,
                array: jsarray,
                isNumber: isNumber,
                isString: isString,
                getPropertyDescriptor: getPropertyDescriptor,
                addon: addon,
                mixin: mixin,
                extend: extend,
                getSuper: getSuper,
                isChildClassOf: isChildClassOf,
                clear: clear,
                value: value,
                getset: getset,
                get: get,
                set: set$1,
                unregisterClass: unregisterClass,
                getClassName: getClassName,
                setClassName: setClassName,
                getClassByName: getClassByName,
                _getClassId: _getClassId,
                _setClassId: _setClassId,
                _getClassById: _getClassById,
                obsolete: obsolete,
                obsoletes: obsoletes,
                formatStr: formatStr,
                shiftArguments: shiftArguments,
                createMap: createMap
            };
            cc.js = js, exports("js", Object.freeze({
                array: array,
                js: js,
                IDGenerator: IDGenerator,
                Pool: Pool,
                isNumber: isNumber,
                isString: isString,
                value: value,
                getset: getset,
                get: get,
                set: set$1,
                createMap: createMap,
                getClassName: getClassName,
                obsolete: obsolete,
                obsoletes: obsoletes,
                formatStr: formatStr,
                shiftArguments: shiftArguments,
                getPropertyDescriptor: getPropertyDescriptor,
                addon: addon,
                mixin: mixin,
                extend: extend,
                getSuper: getSuper,
                isChildClassOf: isChildClassOf,
                clear: clear,
                _idToClass: _idToClass,
                _nameToClass: _nameToClass,
                _setClassId: _setClassId,
                setClassName: setClassName,
                unregisterClass: unregisterClass,
                _getClassById: _getClassById,
                getClassByName: getClassByName,
                _getClassId: _getClassId
            }));
            for (var BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/, values = new Array(123), i = 0; i < 123; ++i) values[i] = 64;
            for (var _i = 0; _i < 64; ++_i) values["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charCodeAt(_i)] = _i;
            var BASE64_VALUES = values;
            function propertyDefine(ctor, sameNameGetSets, diffNameGetSets) {
                function define(np, propName, getter, setter) {
                    var pd = Object.getOwnPropertyDescriptor(np, propName);
                    if (pd) pd.get && (np[getter] = pd.get), pd.set && setter && (np[setter] = pd.set); else {
                        var getterFunc = np[getter];
                        getset(np, propName, getterFunc, np[setter]);
                    }
                }
                for (var propName, np = ctor.prototype, _i2 = 0; _i2 < sameNameGetSets.length; _i2++) {
                    var suffix = (propName = sameNameGetSets[_i2])[0].toUpperCase() + propName.slice(1);
                    define(np, propName, "get" + suffix, "set" + suffix);
                }
                for (propName in diffNameGetSets) {
                    var gs = diffNameGetSets[propName];
                    define(np, propName, gs[0], gs[1]);
                }
            }
            function nextPOT(x) {
                return x -= 1, x |= x >> 1, x |= x >> 2, x |= x >> 4, x |= x >> 8, (x |= x >> 16) + 1;
            }
            function pushToMap(map, key, value, pushFront) {
                var exists = map[key];
                exists ? Array.isArray(exists) ? pushFront ? (exists.push(exists[0]), exists[0] = value) : exists.push(value) : map[key] = pushFront ? [ value, exists ] : [ exists, value ] : map[key] = value;
            }
            function contains$1(refNode, otherNode) {
                if ("function" == typeof refNode.contains) return refNode.contains(otherNode);
                if ("function" == typeof refNode.compareDocumentPosition) return !!(16 & refNode.compareDocumentPosition(otherNode));
                var node = otherNode.parentNode;
                if (node) do {
                    if (node === refNode) return !0;
                    node = node.parentNode;
                } while (null !== node);
                return !1;
            }
            function isDomNode(obj) {
                return "object" === ("undefined" == typeof window ? "undefined" : _typeof(window)) && "function" == typeof Node ? obj instanceof Node : obj && "object" === _typeof(obj) && "number" == typeof obj.nodeType && "string" == typeof obj.nodeName;
            }
            function callInNextTick(callback, p1, p2) {
                callback && setTimeout(function() {
                    callback(p1, p2);
                }, 0);
            }
            function tryCatchFunctor_EDITOR(funcName, forwardArgs, afterCall, bindArg) {
                return Function("arg", "return " + function call_FUNC_InTryCatch(_R_ARGS_) {
                    try {
                        target._FUNC_(_U_ARGS_);
                    } catch (e) {
                        cc._throw(e);
                    }
                    _AFTER_CALL_;
                }.toString().replace(/_FUNC_/g, funcName).replace("_R_ARGS_", "target" + (forwardArgs ? ", " + forwardArgs : "")).replace("_U_ARGS_", forwardArgs || "").replace("_AFTER_CALL_", afterCall || ""))(bindArg);
            }
            function isPlainEmptyObj_DEV(obj) {
                if (!obj || obj.constructor !== Object) return !1;
                for (var k in obj) return !1;
                return !0;
            }
            function cloneable_DEV(obj) {
                return obj && "function" == typeof obj.clone && (obj.constructor && obj.constructor.prototype.hasOwnProperty("clone") || obj.hasOwnProperty("clone"));
            }
            function BitMask(obj) {
                if ("__bitmask__" in obj) return obj;
                value(obj, "__bitmask__", null, !0);
                for (var lastIndex = -1, keys = Object.keys(obj), i = 0; i < keys.length; i++) {
                    var key = keys[i], val = obj[key];
                    if (-1 === val) val = ++lastIndex, obj[key] = val; else if ("number" == typeof val) lastIndex = val; else if ("string" == typeof val && Number.isInteger(parseFloat(key))) continue;
                    var reverseKey = "" + val;
                    key !== reverseKey && value(obj, reverseKey, key);
                }
                return obj;
            }
            function Enum(obj) {
                if ("__enums__" in obj) return obj;
                value(obj, "__enums__", null, !0);
                for (var lastIndex = -1, keys = Object.keys(obj), i = 0; i < keys.length; i++) {
                    var key = keys[i], val = obj[key];
                    if (-1 === val) val = ++lastIndex, obj[key] = val; else if ("number" == typeof val) lastIndex = val; else if ("string" == typeof val && Number.isInteger(parseFloat(key))) continue;
                    var reverseKey = "" + val;
                    key !== reverseKey && value(obj, reverseKey, key);
                }
                return obj;
            }
            function ccenum(enumx) {
                "__enums__" in enumx || value(enumx, "__enums__", null, !0);
            }
            cc.misc = {
                BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
                BASE64_VALUES: BASE64_VALUES,
                propertyDefine: propertyDefine,
                nextPOT: nextPOT,
                pushToMap: pushToMap,
                contains: contains$1,
                isDomNode: isDomNode,
                callInNextTick: callInNextTick,
                tryCatchFunctor_EDITOR: tryCatchFunctor_EDITOR,
                isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
                cloneable_DEV: cloneable_DEV
            }, exports("misc", Object.freeze({
                BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
                BASE64_VALUES: BASE64_VALUES,
                propertyDefine: propertyDefine,
                nextPOT: nextPOT,
                pushToMap: pushToMap,
                contains: contains$1,
                isDomNode: isDomNode,
                callInNextTick: callInNextTick,
                tryCatchFunctor_EDITOR: tryCatchFunctor_EDITOR,
                isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
                cloneable_DEV: cloneable_DEV
            })), BitMask.isBitMask = function(BitMaskType) {
                return BitMaskType && BitMaskType.hasOwnProperty("__bitmask__");
            }, BitMask.getList = function(BitMaskDef) {
                if (BitMaskDef.__bitmask__) return BitMaskDef.__bitmask__;
                var bitlist = BitMaskDef.__bitmask__ = [];
                for (var name in BitMaskDef) {
                    var v = BitMaskDef[name];
                    Number.isInteger(v) && bitlist.push({
                        name: name,
                        value: v
                    });
                }
                return bitlist.sort(function(a, b) {
                    return a.value - b.value;
                }), bitlist;
            }, cc.BitMask = BitMask, Enum.isEnum = function(enumType) {
                return enumType && enumType.hasOwnProperty("__enums__");
            }, Enum.getList = function(enumDef) {
                if (enumDef.__enums__) return enumDef.__enums__;
                var enums = enumDef.__enums__ = [];
                for (var name in enumDef) {
                    var v = enumDef[name];
                    Number.isInteger(v) && enums.push({
                        name: name,
                        value: v
                    });
                }
                return enums.sort(function(a, b) {
                    return a.value - b.value;
                }), enums;
            }, cc.Enum = Enum;
            var ValueType = exports("ValueType", function() {
                function ValueType() {
                    _classCallCheck(this, ValueType);
                }
                return _createClass(ValueType, [ {
                    key: "clone",
                    value: function clone() {
                        return errorID(100, getClassName(this) + ".clone"), this;
                    }
                }, {
                    key: "equals",
                    value: function equals() {
                        return !1;
                    }
                }, {
                    key: "set",
                    value: function set() {
                        errorID(100, getClassName(this) + ".set");
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return "" + {};
                    }
                } ]), ValueType;
            }());
            setClassName("cc.ValueType", ValueType), cc.ValueType = ValueType;
            var DELIMETER = "$_$";
            function createAttrsSingle(owner, ownerConstructor, superAttrs) {
                var AttrsCtor;
                AttrsCtor = function AttrsCtor() {}, superAttrs && extend(AttrsCtor, superAttrs.constructor);
                var attrs = new AttrsCtor();
                return value(owner, "__attrs__", attrs), attrs;
            }
            function createAttrs(subclass) {
                for (var superClass, chains = cc.Class.getInheritanceChain(subclass), i = chains.length - 1; 0 <= i; i--) {
                    var cls = chains[i];
                    cls.hasOwnProperty("__attrs__") && cls.__attrs__ || createAttrsSingle(cls, 0, (superClass = chains[i + 1]) && superClass.__attrs__);
                }
                return createAttrsSingle(subclass, 0, (superClass = chains[0]) && superClass.__attrs__), 
                subclass.__attrs__;
            }
            function attr(constructor, propertyName, newAttributes) {
                var attrs, setter;
                if ("function" == typeof constructor) setter = (attrs = getClassAttrs(constructor)).constructor.prototype; else {
                    var instance = constructor;
                    if (!(attrs = instance.__attrs__)) attrs = createAttrsSingle(instance, 0, getClassAttrs(constructor = instance.constructor));
                    setter = attrs;
                }
                if (void 0 === newAttributes) {
                    var prefix = propertyName + DELIMETER, ret = {};
                    for (var key in attrs) key.startsWith(prefix) && (ret[key.slice(prefix.length)] = attrs[key]);
                    return ret;
                }
                if ("object" === _typeof(newAttributes)) for (var _key in newAttributes) 95 !== _key.charCodeAt(0) && (setter[propertyName + DELIMETER + _key] = newAttributes[_key]); else 0;
            }
            function getClassAttrs(constructor) {
                return constructor.hasOwnProperty("__attrs__") && constructor.__attrs__ || createAttrs(constructor);
            }
            function getClassAttrsProto(constructor) {
                return getClassAttrs(constructor).constructor.prototype;
            }
            function setClassAttr(ctor, propName, key, value) {
                getClassAttrsProto(ctor)[propName + DELIMETER + key] = value;
            }
            var PrimitiveType = function() {
                function PrimitiveType(name, defaultValue) {
                    _classCallCheck(this, PrimitiveType), this.name = void 0, this.default = void 0, 
                    this.name = name, this.default = defaultValue;
                }
                return _createClass(PrimitiveType, [ {
                    key: "toString",
                    value: function toString() {
                        return this.name;
                    }
                } ]), PrimitiveType;
            }(), CCInteger = exports("CCInteger", new PrimitiveType("Integer", 0));
            cc.Integer = CCInteger, cc.CCInteger = CCInteger;
            var CCFloat = exports("CCFloat", new PrimitiveType("Float", 0));
            cc.Float = CCFloat, cc.CCFloat = CCFloat;
            var CCBoolean = exports("CCBoolean", new PrimitiveType("Boolean", !1));
            cc.Boolean = CCBoolean, cc.CCBoolean = CCBoolean;
            var CCString = exports("CCString", new PrimitiveType("String", ""));
            function getTypeChecker(type, attributeName) {
                return function(constructor, mainPropertyName) {
                    var propInfo = '"' + getClassName(constructor) + "." + mainPropertyName + '"', mainPropAttrs = attr(constructor, mainPropertyName);
                    if (!mainPropAttrs.saveUrlAsAsset) {
                        var mainPropAttrsType = mainPropAttrs.type;
                        if (mainPropAttrsType === CCInteger || mainPropAttrsType === CCFloat ? mainPropAttrsType = "Number" : mainPropAttrsType !== CCString && mainPropAttrsType !== CCBoolean || (mainPropAttrsType = mainPropAttrsType.toString()), 
                        mainPropAttrsType !== type) return void warnID(3604, propInfo);
                    }
                    if (mainPropAttrs.hasOwnProperty("default")) {
                        var defaultVal = mainPropAttrs.default;
                        if (void 0 !== defaultVal) if (!(Array.isArray(defaultVal) || isPlainEmptyObj_DEV(defaultVal))) {
                            var defaultType = _typeof(defaultVal), type_lowerCase = type.toLowerCase();
                            if (defaultType === type_lowerCase) {
                                if (!mainPropAttrs.saveUrlAsAsset) if ("object" === type_lowerCase) {
                                    if (!defaultVal || defaultVal instanceof mainPropAttrs.ctor) return;
                                    warnID(3605, propInfo, getClassName(mainPropAttrs.ctor));
                                } else "Number" !== type && warnID(3606, attributeName, propInfo, type);
                            } else {
                                if ("function" === defaultType) return;
                                type === CCString.default && null == defaultVal ? isChildClassOf(mainPropAttrs.ctor, cc.RawAsset) || warnID(3607, propInfo) : warnID(3611, attributeName, propInfo, defaultType);
                            }
                            delete mainPropAttrs.type;
                        }
                    }
                };
            }
            function getObjTypeChecker(typeCtor) {
                return function(classCtor, mainPropName) {
                    getTypeChecker("Object", "type")(classCtor, mainPropName);
                    var defaultDef = getClassAttrs(classCtor)[mainPropName + DELIMETER + "default"], defaultVal = cc.Class.getDefault(defaultDef);
                    if (!Array.isArray(defaultVal) && isChildClassOf(typeCtor, cc.ValueType)) {
                        var typename = getClassName(typeCtor), info = formatStr('No need to specify the "type" of "%s.%s" because %s is a child class of ValueType.', getClassName(classCtor), mainPropName, typename);
                        defaultDef ? log(info) : warnID(3612, info, typename, getClassName(classCtor), mainPropName, typename);
                    }
                };
            }
            cc.String = CCString, cc.CCString = CCString;
            var attributeUtils = Object.freeze({
                DELIMETER: DELIMETER,
                createAttrsSingle: createAttrsSingle,
                createAttrs: createAttrs,
                attr: attr,
                getClassAttrs: getClassAttrs,
                getClassAttrsProto: getClassAttrsProto,
                setClassAttr: setClassAttr,
                PrimitiveType: PrimitiveType,
                CCInteger: CCInteger,
                CCFloat: CCFloat,
                CCBoolean: CCBoolean,
                CCString: CCString,
                getTypeChecker: getTypeChecker,
                getObjTypeChecker: getObjTypeChecker
            }), SerializableAttrs = {
                url: {
                    canUsedInGet: !0
                },
                default: {},
                serializable: {},
                editorOnly: {},
                formerlySerializedAs: {}
            };
            function parseNotify(val, propName, notify, properties) {
                if (!val.get && !val.set) if (val.hasOwnProperty("default")) {
                    var newKey = "_N$" + propName;
                    val.get = function() {
                        return this[newKey];
                    }, val.set = function(value) {
                        var oldValue = this[newKey];
                        this[newKey] = value, notify.call(this, oldValue);
                    };
                    var newValue = {};
                    for (var attr in properties[newKey] = newValue, SerializableAttrs) {
                        var v = SerializableAttrs[attr];
                        val.hasOwnProperty(attr) && (newValue[attr] = val[attr], v.canUsedInGet || delete val[attr]);
                    }
                } else 0;
            }
            function checkUrl(val, className, propName, url) {
                Array.isArray(url) && 0 < url.length && (url = url[0]), val.type = url;
            }
            function parseType(val, type, className, propName) {
                if (Array.isArray(type)) {
                    if (!(0 < type.length)) return errorID(5508, className, propName);
                    if (cc.RawAsset.isRawAssetType(type[0])) return val.url = type[0], void delete val.type;
                    val.type = type = type[0];
                }
            }
            function getFullFormOfProperty(options) {
                if (options && options.constructor === Object) return null;
                if (Array.isArray(options) && 0 < options.length) {
                    options[0];
                    return {
                        default: [],
                        type: options,
                        _short: !0
                    };
                }
                if ("function" != typeof options) return options instanceof PrimitiveType ? {
                    default: options.default,
                    _short: !0
                } : {
                    default: options,
                    _short: !0
                };
                var _type = options;
                return cc.RawAsset.isRawAssetType(_type) ? {
                    default: "",
                    url: _type,
                    _short: !0
                } : {
                    default: isChildClassOf(_type, cc.ValueType) ? new _type() : null,
                    type: _type,
                    _short: !0
                };
            }
            function validateMethodWithProps(func) {
                return "function" == typeof func || null === func;
            }
            var requiringFrames = [];
            function peek() {
                return requiringFrames[requiringFrames.length - 1];
            }
            cc._RF = {
                push: function push(module, uuid, script) {
                    void 0 === script && (script = uuid, uuid = ""), requiringFrames.push({
                        uuid: uuid,
                        script: script,
                        module: module,
                        exports: module.exports,
                        beh: null
                    });
                },
                pop: function pop() {
                    var frameInfo = requiringFrames.pop(), module = frameInfo.module, exports = module.exports;
                    if (exports === frameInfo.exports) {
                        for (var anykey in exports) return;
                        module.exports = exports = frameInfo.cls;
                    }
                },
                peek: peek
            };
            var DELIMETER$1 = DELIMETER, BUILTIN_ENTRIES = [ "name", "extends", "mixins", "ctor", "__ctor__", "properties", "statics", "editor", "__ES6__" ];
            function pushUnique(array, item) {
                array.indexOf(item) < 0 && array.push(item);
            }
            var deferredInitializer = {
                datas: null,
                push: function push(data) {
                    if (this.datas) this.datas.push(data); else {
                        this.datas = [ data ];
                        var self = this;
                        setTimeout(function() {
                            self.init();
                        }, 0);
                    }
                },
                init: function init() {
                    var datas = this.datas;
                    if (datas) {
                        for (var i = 0; i < datas.length; ++i) {
                            var data = datas[i], cls = data.cls, properties = data.props;
                            "function" == typeof properties && (properties = properties());
                            var _name = getClassName(cls);
                            properties ? declareProperties(cls, _name, properties, cls.$super, data.mixins) : errorID(3633, _name);
                        }
                        this.datas = null;
                    }
                }
            };
            function appendProp(cls, name) {
                pushUnique(cls.__props__, name);
            }
            var tmpArray = [];
            function defineProp(cls, className, propName, val) {
                var defaultValue = val.default;
                setClassAttr(cls, propName, "default", defaultValue), appendProp(cls, propName);
                var attrs = parseAttributes(cls, val, className, propName, !1);
                if (attrs) {
                    for (var onAfterProp = tmpArray, i = 0; i < attrs.length; i++) {
                        var attr$1 = attrs[i];
                        attr(cls, propName, attr$1), !1 === attr$1.serializable && pushUnique(cls.__values__, propName), 
                        attr$1._onAfterProp && onAfterProp.push(attr$1._onAfterProp);
                    }
                    for (var c = 0; c < onAfterProp.length; c++) onAfterProp[c](cls, propName);
                    tmpArray.length = 0, attrs.length = 0;
                }
            }
            function defineGetSet(cls, name, propName, val, es6) {
                var getter = val.get, setter = val.set, proto = cls.prototype, d = Object.getOwnPropertyDescriptor(proto, propName), setterUndefined = !d;
                if (getter) {
                    0;
                    for (var attrs = parseAttributes(cls, val, name, propName, !0), i = 0; i < attrs.length; i++) attr(cls, propName, attrs[i]);
                    attrs.length = 0, setClassAttr(cls, propName, "serializable", !1), es6 || get(proto, propName, getter, setterUndefined, setterUndefined);
                }
                setter && (es6 || set$1(proto, propName, setter, setterUndefined, setterUndefined));
            }
            function getDefault(defaultVal) {
                return "function" == typeof defaultVal ? defaultVal() : defaultVal;
            }
            function mixinWithInherited(dest, src, filter) {
                for (var prop in src) dest.hasOwnProperty(prop) || filter && !filter(prop) || Object.defineProperty(dest, prop, getPropertyDescriptor(src, prop));
            }
            function doDefine(className, baseClass, mixins, options) {
                var ctors, fireClass, __ctor__ = options.__ctor__, ctor = options.ctor, __es6__ = options.__ES6__;
                __es6__ ? (ctors = [ ctor ], fireClass = ctor) : (ctors = __ctor__ ? [ __ctor__ ] : function _getAllCtors(baseClass, mixins, options) {
                    for (var ctors = [], baseOrMixins = [ baseClass ].concat(mixins), b = 0; b < baseOrMixins.length; b++) {
                        var baseOrMixin = baseOrMixins[b];
                        if (baseOrMixin) for (var baseCtors = CCClass._isCCClass(cls = baseOrMixin) ? cls.__ctors__ || [] : [ cls ], c = 0; c < baseCtors.length; c++) pushUnique(ctors, baseCtors[c]);
                    }
                    var cls;
                    var ctor = options.ctor;
                    ctor && ctors.push(ctor);
                    return ctors;
                }(baseClass, mixins, options), fireClass = _createCtor(ctors, baseClass, className, options), 
                value(fireClass, "extend", function(options) {
                    return options.extends = this, CCClass(options);
                }, !0)), value(fireClass, "__ctors__", 0 < ctors.length ? ctors : null, !0);
                var prototype = fireClass.prototype;
                if (baseClass && (__es6__ || (extend(fireClass, baseClass), prototype = fireClass.prototype), 
                fireClass.$super = baseClass), mixins) {
                    for (var _loop = function _loop(m) {
                        var mixin = mixins[m];
                        mixinWithInherited(prototype, mixin.prototype), mixinWithInherited(fireClass, mixin, function(prop) {
                            return mixin.hasOwnProperty(prop) && !0;
                        }), CCClass._isCCClass(mixin) && mixinWithInherited(getClassAttrs(fireClass).constructor.prototype, getClassAttrs(mixin).constructor.prototype);
                    }, m = mixins.length - 1; 0 <= m; m--) _loop(m);
                    prototype.constructor = fireClass;
                }
                return __es6__ || (prototype.__initProps__ = compileProps), setClassName(className, fireClass), 
                fireClass;
            }
            function getNewValueTypeCodeJit(value) {
                for (var clsName = getClassName(value), type = value.constructor, res = "new " + clsName + "(", i = 0; i < type.__props__.length; i++) {
                    var propVal = value[type.__props__[i]];
                    0, res += propVal, i < type.__props__.length - 1 && (res += ",");
                }
                return res + ")";
            }
            function escapeForJS(s) {
                return JSON.stringify(s).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
            }
            var IDENTIFIER_RE = /^[A-Za-z_$][0-9A-Za-z_$]*$/;
            function compileProps(actualClass) {
                var attrs = getClassAttrs(actualClass), propList = actualClass.__props__;
                null === propList && (deferredInitializer.init(), propList = actualClass.__props__);
                var initProps = function getInitPropsJit(attrs, propList) {
                    for (var F = [], func = "", i = 0; i < propList.length; i++) {
                        var prop = propList[i], attrKey = prop + DELIMETER$1 + "default";
                        if (attrKey in attrs) {
                            var statement = void 0;
                            statement = IDENTIFIER_RE.test(prop) ? "this." + prop + "=" : "this[" + escapeForJS(prop) + "]=";
                            var expression = void 0, def = attrs[attrKey];
                            if ("object" === _typeof(def) && def) expression = def instanceof cc.ValueType ? getNewValueTypeCodeJit(def) : Array.isArray(def) ? "[]" : "{}"; else if ("function" == typeof def) {
                                var index = F.length;
                                F.push(def), expression = "F[" + index + "]()";
                            } else expression = "string" == typeof def ? escapeForJS(def) : def;
                            func += statement = statement + expression + ";\n";
                        }
                    }
                    return 0 === F.length ? Function(func) : Function("F", "return (function(){\n" + func + "})")(F);
                }(attrs, propList);
                (actualClass.prototype.__initProps__ = initProps).call(this);
            }
            var _createCtor = function(ctors, baseClass, className, options) {
                var body = "return function CCClass(){\n";
                baseClass && boundSuperCalls(baseClass, options, className) && (body += "this._super=null;\n"), 
                body += "this.__initProps__(CCClass);\n";
                var ctorLen = ctors.length;
                if (0 < ctorLen) {
                    0;
                    var SNIPPET = "].apply(this,arguments);\n";
                    if (1 === ctorLen) body += "CCClass.__ctors__[0" + SNIPPET; else {
                        body += "var cs=CCClass.__ctors__;\n";
                        for (var i = 0; i < ctorLen; i++) body += "cs[" + i + SNIPPET;
                    }
                    0;
                }
                return body += "}", Function(body)();
            };
            var superCllRegCondition = /xyz/.test(function() {}.toString()), SuperCallReg = superCllRegCondition ? /\b\._super\b/ : /.*/;
            function boundSuperCalls(baseClass, options) {
                var hasSuperCall = !1;
                for (var funcName in options) if (!(0 <= BUILTIN_ENTRIES.indexOf(funcName))) {
                    var func = options[funcName];
                    if ("function" == typeof func) {
                        var pd = getPropertyDescriptor(baseClass.prototype, funcName);
                        if (pd) {
                            var superFunc = pd.value;
                            if ("function" == typeof superFunc) {
                                SuperCallReg.test(func) && (hasSuperCall = !0, options[funcName] = function(superFunc, func) {
                                    return function() {
                                        var tmp = this._super;
                                        this._super = superFunc;
                                        var ret = func.apply(this, arguments);
                                        return this._super = tmp, ret;
                                    };
                                }(superFunc, func));
                                continue;
                            }
                        }
                        0;
                    }
                }
                return hasSuperCall;
            }
            function declareProperties(cls, className, properties, baseClass, mixins, es6) {
                if (cls.__props__ = [], baseClass && baseClass.__props__ && (cls.__props__ = baseClass.__props__.slice()), 
                mixins) for (var m = 0; m < mixins.length; ++m) {
                    var mixin = mixins[m];
                    mixin.__props__ && (cls.__props__ = cls.__props__.concat(mixin.__props__.filter(function(x) {
                        return cls.__props__.indexOf(x) < 0;
                    })));
                }
                if (properties) for (var propName in function preprocessAttrs(properties, className) {
                    for (var propName in properties) {
                        var val = properties[propName], fullForm = getFullFormOfProperty(val);
                        if (fullForm && (val = properties[propName] = fullForm), val) {
                            var notify = val.notify;
                            notify && parseNotify(val, propName, notify, properties), "type" in val && parseType(val, val.type, className, propName), 
                            "url" in val && checkUrl(val, 0, 0, val.url), "type" in val && val.type;
                        }
                    }
                }(properties, className), properties) {
                    var val = properties[propName];
                    "default" in val ? defineProp(cls, className, propName, val) : defineGetSet(cls, className, propName, val, es6);
                }
                var attrs = getClassAttrs(cls);
                cls.__values__ = cls.__props__.filter(function(prop) {
                    return !1 !== attrs[prop + DELIMETER$1 + "serializable"];
                });
            }
            function CCClass(options) {
                var name = (options = options || {}).name, base = options.extends, mixins = options.mixins, cls = function define(className, baseClass, mixins, options) {
                    var Component = cc.Component, frame = peek();
                    if (frame && isChildClassOf(baseClass, Component)) {
                        if (isChildClassOf(frame.cls, Component)) return errorID(3615), null;
                        0, className = className || frame.script;
                    }
                    var cls = doDefine(className, baseClass, mixins, options);
                    if (frame) if (isChildClassOf(baseClass, Component)) {
                        var uuid = frame.uuid;
                        uuid && _setClassId(uuid, cls), frame.cls = cls;
                    } else isChildClassOf(frame.cls, Component) || (frame.cls = cls);
                    return cls;
                }(name, base, mixins, options);
                name = name || cc.js.getClassName(cls), cls._sealed = !0, base && (base._sealed = !1);
                var properties = options.properties;
                "function" == typeof properties || base && null === base.__props__ || mixins && mixins.some(function(x) {
                    return null === x.__props__;
                }) ? (deferredInitializer.push({
                    cls: cls,
                    props: properties,
                    mixins: mixins
                }), cls.__props__ = cls.__values__ = null) : declareProperties(cls, name, properties, base, options.mixins, options.__ES6__);
                var staticPropName, statics = options.statics;
                if (statics) for (staticPropName in statics) cls[staticPropName] = statics[staticPropName];
                for (var funcName in options) if (!(0 <= BUILTIN_ENTRIES.indexOf(funcName))) {
                    var func = options[funcName];
                    validateMethodWithProps(func) && value(cls.prototype, funcName, func, !0, !0);
                }
                var editor = options.editor;
                return editor && isChildClassOf(base, cc.Component) && cc.Component._registerEditorProps(cls, editor), 
                cls;
            }
            CCClass._isCCClass = function(constructor) {
                return constructor && constructor.hasOwnProperty && constructor.hasOwnProperty("__ctors__");
            }, CCClass.fastDefine = function(className, constructor, serializableFields) {
                setClassName(className, constructor);
                for (var props = constructor.__props__ = constructor.__values__ = Object.keys(serializableFields), attrProtos = getClassAttrsProto(constructor), i = 0; i < props.length; i++) {
                    var key = props[i];
                    attrProtos[key + DELIMETER$1 + "visible"] = !1, attrProtos[key + DELIMETER$1 + "default"] = serializableFields[key];
                }
            }, CCClass.Attr = attributeUtils, CCClass.attr = attr, CCClass.getInheritanceChain = function getInheritanceChain(constructor) {
                for (var chain = []; constructor = getSuper(constructor); ) constructor !== Object && chain.push(constructor);
                return chain;
            };
            var PrimitiveTypes = {
                Integer: "Number",
                Float: "Number",
                Boolean: "Boolean",
                String: "String"
            }, tmpAttrs = [];
            function parseAttributes(constructor, attributes, className, propertyName) {
                var attrsProto = null, attrsProtoKey = "";
                function getAttrsProto() {
                    return attrsProtoKey = propertyName + DELIMETER$1, attrsProto = getClassAttrsProto(constructor);
                }
                tmpAttrs.length = 0;
                var result = tmpAttrs, type = attributes.type;
                if (type) {
                    var primitiveType = PrimitiveTypes[type];
                    if (primitiveType) result.push({
                        type: type,
                        _onAfterProp: void 0
                    }); else if ("Object" === type) 0; else if ("object" === _typeof(type)) Enum.isEnum(type) ? result.push({
                        type: "Enum",
                        enumList: Enum.getList(type)
                    }) : BitMask.isBitMask(type) && result.push({
                        type: "BitMask",
                        bitmaskList: BitMask.getList(type)
                    }); else if ("function" == typeof type) {
                        var typeChecker;
                        0, result.push({
                            type: "Object",
                            ctor: type,
                            _onAfterProp: typeChecker
                        });
                    } else 0;
                }
                function parseSimpleAttribute(attributeName, expectType) {
                    if (attributeName in attributes) {
                        var val = attributes[attributeName];
                        _typeof(val) === expectType && ((attrsProto || getAttrsProto())[attrsProtoKey + attributeName] = val);
                    }
                }
                attributes.editorOnly && ((attrsProto || getAttrsProto())[attrsProtoKey + "editorOnly"] = !0), 
                attributes.url && ((attrsProto || getAttrsProto())[attrsProtoKey + "saveUrlAsAsset"] = !0), 
                !1 === attributes.serializable && ((attrsProto || getAttrsProto())[attrsProtoKey + "serializable"] = !1), 
                parseSimpleAttribute("formerlySerializedAs", "string");
                var range = attributes.range;
                return range && Array.isArray(range) && 2 <= range.length && ((attrsProto || getAttrsProto())[attrsProtoKey + "min"] = range[0], 
                (attrsProto || getAttrsProto())[attrsProtoKey + "max"] = range[1], 2 < range.length && ((attrsProto || getAttrsProto())[attrsProtoKey + "step"] = range[2])), 
                parseSimpleAttribute("min", "number"), parseSimpleAttribute("max", "number"), parseSimpleAttribute("step", "number"), 
                result;
            }
            CCClass.isArray = function(defaultVal) {
                return defaultVal = getDefault(defaultVal), Array.isArray(defaultVal);
            }, CCClass.getDefault = getDefault, CCClass.escapeForJS = escapeForJS, CCClass.IDENTIFIER_RE = IDENTIFIER_RE, 
            CCClass.getNewValueTypeCode = getNewValueTypeCodeJit, exports("CCClass", CCClass), 
            cc.Class = CCClass;
            var _d2r = Math.PI / 180, _r2d = 180 / Math.PI, EPSILON = exports("EPSILON", 1e-6);
            function equals(a, b) {
                return Math.abs(a - b) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
            }
            function approx(a, b, maxDiff) {
                return maxDiff = maxDiff || EPSILON, Math.abs(a - b) <= maxDiff;
            }
            function clamp(val, min, max) {
                if (max < min) {
                    var temp = min;
                    min = max, max = temp;
                }
                return val < min ? min : max < val ? max : val;
            }
            function clamp01(val) {
                return val < 0 ? 0 : 1 < val ? 1 : val;
            }
            function lerp(from, to, ratio) {
                return from + (to - from) * ratio;
            }
            function toRadian(a) {
                return a * _d2r;
            }
            function toDegree(a) {
                return a * _r2d;
            }
            var random = exports("random", Math.random);
            function randomRange(min, max) {
                return Math.random() * (max - min) + min;
            }
            function randomRangeInt(min, max) {
                return Math.floor(randomRange(min, max));
            }
            function pseudoRandom(seed) {
                return (seed = (9301 * seed + 49297) % 233280) / 233280;
            }
            function pseudoRandomRange(seed, min, max) {
                return pseudoRandom(seed) * (max - min) + min;
            }
            function pseudoRandomRangeInt(seed, min, max) {
                return Math.floor(pseudoRandomRange(seed, min, max));
            }
            function nextPow2$1(val) {
                return --val, val |= val >> 1, val |= val >> 2, val |= val >> 4, val |= val >> 8, 
                val |= val >> 16, ++val;
            }
            function repeat(t, length) {
                return t - Math.floor(t / length) * length;
            }
            function pingPong(t, length) {
                return t = repeat(t, 2 * length), t = length - Math.abs(t - length);
            }
            function inverseLerp(from, to, value) {
                return (value - from) / (to - from);
            }
            var _x = 0, _y = 0, Vec2 = exports("Vec2", function() {
                function Vec2(x, y) {
                    var _this;
                    return _classCallCheck(this, Vec2), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Vec2).call(this))).x = void 0, 
                    _this.y = void 0, x && "object" === _typeof(x) ? (_this.x = x.x, _this.y = x.y) : (_this.x = x || 0, 
                    _this.y = y || 0), _this;
                }
                return _inherits(Vec2, ValueType), _createClass(Vec2, null, [ {
                    key: "clone",
                    value: function clone(a) {
                        return new Vec2(a.x, a.y);
                    }
                }, {
                    key: "copy",
                    value: function copy(out, a) {
                        return out.x = a.x, out.y = a.y, out;
                    }
                }, {
                    key: "set",
                    value: function set(out, x, y) {
                        return out.x = x, out.y = y, out;
                    }
                }, {
                    key: "add",
                    value: function add(out, a, b) {
                        return out.x = a.x + b.x, out.y = a.y + b.y, out;
                    }
                }, {
                    key: "subtract",
                    value: function subtract(out, a, b) {
                        return out.x = a.x - b.x, out.y = a.y - b.y, out;
                    }
                }, {
                    key: "multiply",
                    value: function multiply(out, a, b) {
                        return out.x = a.x * b.x, out.y = a.y * b.y, out;
                    }
                }, {
                    key: "divide",
                    value: function divide(out, a, b) {
                        return out.x = a.x / b.x, out.y = a.y / b.y, out;
                    }
                }, {
                    key: "ceil",
                    value: function ceil(out, a) {
                        return out.x = Math.ceil(a.x), out.y = Math.ceil(a.y), out;
                    }
                }, {
                    key: "floor",
                    value: function floor(out, a) {
                        return out.x = Math.floor(a.x), out.y = Math.floor(a.y), out;
                    }
                }, {
                    key: "min",
                    value: function min(out, a, b) {
                        return out.x = Math.min(a.x, b.x), out.y = Math.min(a.y, b.y), out;
                    }
                }, {
                    key: "max",
                    value: function max(out, a, b) {
                        return out.x = Math.max(a.x, b.x), out.y = Math.max(a.y, b.y), out;
                    }
                }, {
                    key: "round",
                    value: function round(out, a) {
                        return out.x = Math.round(a.x), out.y = Math.round(a.y), out;
                    }
                }, {
                    key: "multiplyScalar",
                    value: function multiplyScalar(out, a, b) {
                        return out.x = a.x * b, out.y = a.y * b, out;
                    }
                }, {
                    key: "scaleAndAdd",
                    value: function scaleAndAdd(out, a, b, scale) {
                        return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out;
                    }
                }, {
                    key: "distance",
                    value: function distance(a, b) {
                        return _x = b.x - a.x, _y = b.y - a.y, Math.sqrt(_x * _x + _y * _y);
                    }
                }, {
                    key: "squaredDistance",
                    value: function squaredDistance(a, b) {
                        return _x = b.x - a.x, _y = b.y - a.y, _x * _x + _y * _y;
                    }
                }, {
                    key: "len",
                    value: function len(a) {
                        return _x = a.x, _y = a.y, Math.sqrt(_x * _x + _y * _y);
                    }
                }, {
                    key: "lengthSqr",
                    value: function lengthSqr(a) {
                        return _x = a.x, _y = a.y, _x * _x + _y * _y;
                    }
                }, {
                    key: "negate",
                    value: function negate(out, a) {
                        return out.x = -a.x, out.y = -a.y, out;
                    }
                }, {
                    key: "inverse",
                    value: function inverse(out, a) {
                        return out.x = 1 / a.x, out.y = 1 / a.y, out;
                    }
                }, {
                    key: "inverseSafe",
                    value: function inverseSafe(out, a) {
                        return _x = a.x, _y = a.y, Math.abs(_x) < EPSILON ? out.x = 0 : out.x = 1 / _x, 
                        Math.abs(_y) < EPSILON ? out.y = 0 : out.y = 1 / _y, out;
                    }
                }, {
                    key: "normalize",
                    value: function normalize(out, a) {
                        _x = a.x, _y = a.y;
                        var len = _x * _x + _y * _y;
                        return 0 < len && (len = 1 / Math.sqrt(len), out.x = _x * len, out.y = _y * len), 
                        out;
                    }
                }, {
                    key: "dot",
                    value: function dot(a, b) {
                        return a.x * b.x + a.y * b.y;
                    }
                }, {
                    key: "cross",
                    value: function cross(out, a, b) {
                        return out.x = out.y = 0, out.z = a.x * b.y - a.y * b.x, out;
                    }
                }, {
                    key: "lerp",
                    value: function lerp(out, a, b, t) {
                        return _x = a.x, _y = a.y, out.x = _x + t * (b.x - _x), out.y = _y + t * (b.y - _y), 
                        out;
                    }
                }, {
                    key: "random",
                    value: function random$1(out, scale) {
                        scale = scale || 1;
                        var r = 2 * random() * Math.PI;
                        return out.x = Math.cos(r) * scale, out.y = Math.sin(r) * scale, out;
                    }
                }, {
                    key: "transformMat3",
                    value: function transformMat3(out, a, m) {
                        return _x = a.x, _y = a.y, out.x = m.m00 * _x + m.m03 * _y + m.m06, out.y = m.m01 * _x + m.m04 * _y + m.m07, 
                        out;
                    }
                }, {
                    key: "transformMat4",
                    value: function transformMat4(out, a, m) {
                        return _x = a.x, _y = a.y, out.x = m.m00 * _x + m.m04 * _y + m.m12, out.y = m.m01 * _x + m.m05 * _y + m.m13, 
                        out;
                    }
                }, {
                    key: "str",
                    value: function str(a) {
                        return "Vec2(".concat(a.x, ", ").concat(a.y, ")");
                    }
                }, {
                    key: "toArray",
                    value: function toArray(out, v, argument_2) {
                        var ofs = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0;
                        return out[ofs + 0] = v.x, out[ofs + 1] = v.y, out;
                    }
                }, {
                    key: "fromArray",
                    value: function fromArray(out, arr, argument_2) {
                        var ofs = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0;
                        return out.x = arr[ofs + 0], out.y = arr[ofs + 1], out;
                    }
                }, {
                    key: "strictEquals",
                    value: function strictEquals(a, b) {
                        return a.x === b.x && a.y === b.y;
                    }
                }, {
                    key: "equals",
                    value: function equals(a, b, argument_2) {
                        var epsilon = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : EPSILON;
                        return Math.abs(a.x - b.x) <= epsilon * Math.max(1, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1, Math.abs(a.y), Math.abs(b.y));
                    }
                }, {
                    key: "angle",
                    value: function angle(a, b) {
                        Vec2.normalize(v2_1, a), Vec2.normalize(v2_2, b);
                        var cosine = Vec2.dot(v2_1, v2_2);
                        return 1 < cosine ? 0 : cosine < -1 ? Math.PI : Math.acos(cosine);
                    }
                } ]), _createClass(Vec2, [ {
                    key: "clone",
                    value: function clone() {
                        return new Vec2(this.x, this.y);
                    }
                }, {
                    key: "set",
                    value: function set(x, y) {
                        return x && "object" === _typeof(x) ? (this.x = x.x, this.y = x.y) : (this.x = x || 0, 
                        this.y = y || 0), this;
                    }
                }, {
                    key: "equals",
                    value: function equals(other, argument_1) {
                        var epsilon = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : EPSILON;
                        return Math.abs(this.x - other.x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(other.y));
                    }
                }, {
                    key: "equals2f",
                    value: function equals2f(x, y, argument_2) {
                        var epsilon = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : EPSILON;
                        return Math.abs(this.x - x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(y));
                    }
                }, {
                    key: "strictEquals",
                    value: function strictEquals(other) {
                        return other && this.x === other.x && this.y === other.y;
                    }
                }, {
                    key: "strictEquals2f",
                    value: function strictEquals2f(x, y) {
                        return this.x === x && this.y === y;
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ")");
                    }
                }, {
                    key: "lerp",
                    value: function lerp(to, ratio) {
                        return _x = this.x, _y = this.y, this.x = _x + ratio * (to.x - _x), this.y = _y + ratio * (to.y - _y), 
                        this;
                    }
                }, {
                    key: "clampf",
                    value: function clampf(minInclusive, maxInclusive) {
                        return this.x = clamp(this.x, minInclusive.x, maxInclusive.x), this.y = clamp(this.y, minInclusive.y, maxInclusive.y), 
                        this;
                    }
                }, {
                    key: "add",
                    value: function add(other) {
                        return this.x = this.x + other.x, this.y = this.y + other.y, this;
                    }
                }, {
                    key: "add2f",
                    value: function add2f(x, y) {
                        return this.x = this.x + x, this.y = this.y + y, this;
                    }
                }, {
                    key: "subtract",
                    value: function subtract(other) {
                        return this.x = this.x - other.x, this.y = this.y - other.y, this;
                    }
                }, {
                    key: "subtract2f",
                    value: function subtract2f(x, y) {
                        return this.x = this.x - x, this.y = this.y - y, this;
                    }
                }, {
                    key: "multiplyScalar",
                    value: function multiplyScalar(scalar) {
                        return "object" === _typeof(scalar) && console.warn("should use Vec2.multiply for vector * vector operation"), 
                        this.x = this.x * scalar, this.y = this.y * scalar, this;
                    }
                }, {
                    key: "multiply",
                    value: function multiply(other) {
                        return "object" !== _typeof(other) && console.warn("should use Vec2.scale for vector * scalar operation"), 
                        this.x = this.x * other.x, this.y = this.y * other.y, this;
                    }
                }, {
                    key: "multiply2f",
                    value: function multiply2f(x, y) {
                        return this.x = this.x * x, this.y = this.y * y, this;
                    }
                }, {
                    key: "divide",
                    value: function divide(other) {
                        return this.x = this.x / other.x, this.y = this.y / other.y, this;
                    }
                }, {
                    key: "divide2f",
                    value: function divide2f(x, y) {
                        return this.x = this.x / x, this.y = this.y / y, this;
                    }
                }, {
                    key: "negative",
                    value: function negative() {
                        return this.x = -this.x, this.y = -this.y, this;
                    }
                }, {
                    key: "dot",
                    value: function dot(other) {
                        return this.x * other.x + this.y * other.y;
                    }
                }, {
                    key: "cross",
                    value: function cross(other) {
                        return this.x * other.y - this.y * other.x;
                    }
                }, {
                    key: "length",
                    value: function length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y);
                    }
                }, {
                    key: "lengthSqr",
                    value: function lengthSqr() {
                        return this.x * this.x + this.y * this.y;
                    }
                }, {
                    key: "normalize",
                    value: function normalize() {
                        _x = this.x, _y = this.y;
                        var len = _x * _x + _y * _y;
                        return 0 < len && (len = 1 / Math.sqrt(len), this.x = this.x * len, this.y = this.y * len), 
                        this;
                    }
                }, {
                    key: "angle",
                    value: function angle(other) {
                        var magSqr1 = this.lengthSqr(), magSqr2 = other.lengthSqr();
                        if (0 === magSqr1 || 0 === magSqr2) return console.warn("Can't get angle between zero vector"), 
                        0;
                        var theta = this.dot(other) / Math.sqrt(magSqr1 * magSqr2);
                        return theta = clamp(theta, -1, 1), Math.acos(theta);
                    }
                }, {
                    key: "signAngle",
                    value: function signAngle(other) {
                        var angle = this.angle(other);
                        return this.cross(other) < 0 ? -angle : angle;
                    }
                }, {
                    key: "rotate",
                    value: function rotate(radians) {
                        _x = this.x, _y = this.y;
                        var sin = Math.sin(radians), cos = Math.cos(radians);
                        return this.x = cos * _x - sin * _y, this.y = sin * _x + cos * _y, this;
                    }
                }, {
                    key: "project",
                    value: function project(other) {
                        var scalar = this.dot(other) / other.dot(other);
                        return this.x = other.x * scalar, this.y = other.y * scalar, this;
                    }
                }, {
                    key: "transformMat4",
                    value: function transformMat4(matrix) {
                        return _x = this.x, _y = this.y, this.x = matrix.m00 * _x + matrix.m04 * _y + matrix.m12, 
                        this.y = matrix.m01 * _x + matrix.m05 * _y + matrix.m13, this;
                    }
                } ]), Vec2;
            }());
            Vec2.ZERO = Object.freeze(new Vec2(0, 0)), Vec2.ONE = Object.freeze(new Vec2(1, 1)), 
            Vec2.NEG_ONE = Object.freeze(new Vec2(-1, -1)), Vec2.UNIT_X = Object.freeze(new Vec2(1, 0)), 
            Vec2.UNIT_Y = Object.freeze(new Vec2(0, 1));
            var v2_1 = new Vec2(), v2_2 = new Vec2();
            function v2(x, y) {
                return new Vec2(x, y);
            }
            CCClass.fastDefine("cc.Vec2", Vec2, {
                x: 0,
                y: 0
            }), cc.Vec2 = Vec2, cc.v2 = v2;
            var _x$1 = 0, _y$1 = 0, _z = 0, Vec3 = exports("Vec3", function() {
                function Vec3(x, y, z) {
                    var _this;
                    return _classCallCheck(this, Vec3), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Vec3).call(this))).x = void 0, 
                    _this.y = void 0, _this.z = void 0, x && "object" === _typeof(x) ? (_this.x = x.x, 
                    _this.y = x.y, _this.z = x.z) : (_this.x = x || 0, _this.y = y || 0, _this.z = z || 0), 
                    _this;
                }
                return _inherits(Vec3, ValueType), _createClass(Vec3, null, [ {
                    key: "zero",
                    value: function zero(out) {
                        return out.x = 0, out.y = 0, out.z = 0, out;
                    }
                }, {
                    key: "clone",
                    value: function clone(a) {
                        return new Vec3(a.x, a.y, a.z);
                    }
                }, {
                    key: "copy",
                    value: function copy(out, a) {
                        return out.x = a.x, out.y = a.y, out.z = a.z, out;
                    }
                }, {
                    key: "set",
                    value: function set(out, x, y, z) {
                        return out.x = x, out.y = y, out.z = z, out;
                    }
                }, {
                    key: "add",
                    value: function add(out, a, b) {
                        return out.x = a.x + b.x, out.y = a.y + b.y, out.z = a.z + b.z, out;
                    }
                }, {
                    key: "subtract",
                    value: function subtract(out, a, b) {
                        return out.x = a.x - b.x, out.y = a.y - b.y, out.z = a.z - b.z, out;
                    }
                }, {
                    key: "multiply",
                    value: function multiply(out, a, b) {
                        return out.x = a.x * b.x, out.y = a.y * b.y, out.z = a.z * b.z, out;
                    }
                }, {
                    key: "divide",
                    value: function divide(out, a, b) {
                        return out.x = a.x / b.x, out.y = a.y / b.y, out.z = a.z / b.z, out;
                    }
                }, {
                    key: "ceil",
                    value: function ceil(out, a) {
                        return out.x = Math.ceil(a.x), out.y = Math.ceil(a.y), out.z = Math.ceil(a.z), out;
                    }
                }, {
                    key: "floor",
                    value: function floor(out, a) {
                        return out.x = Math.floor(a.x), out.y = Math.floor(a.y), out.z = Math.floor(a.z), 
                        out;
                    }
                }, {
                    key: "min",
                    value: function min(out, a, b) {
                        return out.x = Math.min(a.x, b.x), out.y = Math.min(a.y, b.y), out.z = Math.min(a.z, b.z), 
                        out;
                    }
                }, {
                    key: "max",
                    value: function max(out, a, b) {
                        return out.x = Math.max(a.x, b.x), out.y = Math.max(a.y, b.y), out.z = Math.max(a.z, b.z), 
                        out;
                    }
                }, {
                    key: "round",
                    value: function round(out, a) {
                        return out.x = Math.round(a.x), out.y = Math.round(a.y), out.z = Math.round(a.z), 
                        out;
                    }
                }, {
                    key: "multiplyScalar",
                    value: function multiplyScalar(out, a, b) {
                        return out.x = a.x * b, out.y = a.y * b, out.z = a.z * b, out;
                    }
                }, {
                    key: "scaleAndAdd",
                    value: function scaleAndAdd(out, a, b, scale) {
                        return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out.z = a.z + b.z * scale, 
                        out;
                    }
                }, {
                    key: "distance",
                    value: function distance(a, b) {
                        return _x$1 = b.x - a.x, _y$1 = b.y - a.y, _z = b.z - a.z, Math.sqrt(_x$1 * _x$1 + _y$1 * _y$1 + _z * _z);
                    }
                }, {
                    key: "squaredDistance",
                    value: function squaredDistance(a, b) {
                        return _x$1 = b.x - a.x, _y$1 = b.y - a.y, _z = b.z - a.z, _x$1 * _x$1 + _y$1 * _y$1 + _z * _z;
                    }
                }, {
                    key: "len",
                    value: function len(a) {
                        return _x$1 = a.x, _y$1 = a.y, _z = a.z, Math.sqrt(_x$1 * _x$1 + _y$1 * _y$1 + _z * _z);
                    }
                }, {
                    key: "lengthSqr",
                    value: function lengthSqr(a) {
                        return _x$1 = a.x, _y$1 = a.y, _z = a.z, _x$1 * _x$1 + _y$1 * _y$1 + _z * _z;
                    }
                }, {
                    key: "negate",
                    value: function negate(out, a) {
                        return out.x = -a.x, out.y = -a.y, out.z = -a.z, out;
                    }
                }, {
                    key: "invert",
                    value: function invert(out, a) {
                        return out.x = 1 / a.x, out.y = 1 / a.y, out.z = 1 / a.z, out;
                    }
                }, {
                    key: "invertSafe",
                    value: function invertSafe(out, a) {
                        return _x$1 = a.x, _y$1 = a.y, _z = a.z, Math.abs(_x$1) < EPSILON ? out.x = 0 : out.x = 1 / _x$1, 
                        Math.abs(_y$1) < EPSILON ? out.y = 0 : out.y = 1 / _y$1, Math.abs(_z) < EPSILON ? out.z = 0 : out.z = 1 / _z, 
                        out;
                    }
                }, {
                    key: "normalize",
                    value: function normalize(out, a) {
                        _x$1 = a.x, _y$1 = a.y, _z = a.z;
                        var len = _x$1 * _x$1 + _y$1 * _y$1 + _z * _z;
                        return 0 < len && (len = 1 / Math.sqrt(len), out.x = _x$1 * len, out.y = _y$1 * len, 
                        out.z = _z * len), out;
                    }
                }, {
                    key: "dot",
                    value: function dot(a, b) {
                        return a.x * b.x + a.y * b.y + a.z * b.z;
                    }
                }, {
                    key: "cross",
                    value: function cross(out, a, b) {
                        var ax = a.x, ay = a.y, az = a.z, bx = b.x, by = b.y, bz = b.z;
                        return out.x = ay * bz - az * by, out.y = az * bx - ax * bz, out.z = ax * by - ay * bx, 
                        out;
                    }
                }, {
                    key: "lerp",
                    value: function lerp(out, a, b, t) {
                        return out.x = a.x + t * (b.x - a.x), out.y = a.y + t * (b.y - a.y), out.z = a.z + t * (b.z - a.z), 
                        out;
                    }
                }, {
                    key: "random",
                    value: function random$1(out, scale) {
                        scale = scale || 1;
                        var phi = 2 * random() * Math.PI, cosTheta = 2 * random() - 1, sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
                        return out.x = sinTheta * Math.cos(phi) * scale, out.y = sinTheta * Math.sin(phi) * scale, 
                        out.z = cosTheta * scale, out;
                    }
                }, {
                    key: "transformMat4",
                    value: function transformMat4(out, a, m) {
                        _x$1 = a.x, _y$1 = a.y, _z = a.z;
                        var rhw = m.m03 * _x$1 + m.m07 * _y$1 + m.m11 * _z + m.m15;
                        return rhw = rhw ? 1 / rhw : 1, out.x = (m.m00 * _x$1 + m.m04 * _y$1 + m.m08 * _z + m.m12) * rhw, 
                        out.y = (m.m01 * _x$1 + m.m05 * _y$1 + m.m09 * _z + m.m13) * rhw, out.z = (m.m02 * _x$1 + m.m06 * _y$1 + m.m10 * _z + m.m14) * rhw, 
                        out;
                    }
                }, {
                    key: "transformMat4Normal",
                    value: function transformMat4Normal(out, a, m) {
                        _x$1 = a.x, _y$1 = a.y, _z = a.z;
                        var rhw = m.m03 * _x$1 + m.m07 * _y$1 + m.m11 * _z;
                        return rhw = rhw ? 1 / rhw : 1, out.x = (m.m00 * _x$1 + m.m04 * _y$1 + m.m08 * _z) * rhw, 
                        out.y = (m.m01 * _x$1 + m.m05 * _y$1 + m.m09 * _z) * rhw, out.z = (m.m02 * _x$1 + m.m06 * _y$1 + m.m10 * _z) * rhw, 
                        out;
                    }
                }, {
                    key: "transformMat3",
                    value: function transformMat3(out, a, m) {
                        return _x$1 = a.x, _y$1 = a.y, _z = a.z, out.x = _x$1 * m.m00 + _y$1 * m.m03 + _z * m.m06, 
                        out.y = _x$1 * m.m01 + _y$1 * m.m04 + _z * m.m07, out.z = _x$1 * m.m02 + _y$1 * m.m05 + _z * m.m08, 
                        out;
                    }
                }, {
                    key: "transformAffine",
                    value: function transformAffine(out, v, m) {
                        return _x$1 = v.x, _y$1 = v.y, _z = v.z, out.x = m.m00 * _x$1 + m.m01 * _y$1 + m.m02 * _z + m.m03, 
                        out.y = m.m04 * _x$1 + m.m05 * _y$1 + m.m06 * _z + m.m07, out.x = m.m08 * _x$1 + m.m09 * _y$1 + m.m10 * _z + m.m11, 
                        out;
                    }
                }, {
                    key: "transformQuat",
                    value: function transformQuat(out, a, q) {
                        var ix = q.w * a.x + q.y * a.z - q.z * a.y, iy = q.w * a.y + q.z * a.x - q.x * a.z, iz = q.w * a.z + q.x * a.y - q.y * a.x, iw = -q.x * a.x - q.y * a.y - q.z * a.z;
                        return out.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y, out.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z, 
                        out.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x, out;
                    }
                }, {
                    key: "transformRTS",
                    value: function transformRTS(out, a, r, t, s) {
                        var x = a.x * s.x, y = a.y * s.y, z = a.z * s.z, ix = r.w * x + r.y * z - r.z * y, iy = r.w * y + r.z * x - r.x * z, iz = r.w * z + r.x * y - r.y * x, iw = -r.x * x - r.y * y - r.z * z;
                        return out.x = ix * r.w + iw * -r.x + iy * -r.z - iz * -r.y + t.x, out.y = iy * r.w + iw * -r.y + iz * -r.x - ix * -r.z + t.y, 
                        out.z = iz * r.w + iw * -r.z + ix * -r.y - iy * -r.x + t.z, out;
                    }
                }, {
                    key: "transformInverseRTS",
                    value: function transformInverseRTS(out, a, r, t, s) {
                        var x = a.x - t.x, y = a.y - t.y, z = a.z - t.z, ix = r.w * x - r.y * z + r.z * y, iy = r.w * y - r.z * x + r.x * z, iz = r.w * z - r.x * y + r.y * x, iw = r.x * x + r.y * y + r.z * z;
                        return out.x = (ix * r.w + iw * r.x + iy * r.z - iz * r.y) / s.x, out.y = (iy * r.w + iw * r.y + iz * r.x - ix * r.z) / s.y, 
                        out.z = (iz * r.w + iw * r.z + ix * r.y - iy * r.x) / s.z, out;
                    }
                }, {
                    key: "rotateX",
                    value: function rotateX(out, v, o, a) {
                        _x$1 = v.x - o.x, _y$1 = v.y - o.y, _z = v.z - o.z;
                        var cos = Math.cos(a), sin = Math.sin(a), rx = _x$1, ry = _y$1 * cos - _z * sin, rz = _y$1 * sin + _z * cos;
                        return out.x = rx + o.x, out.y = ry + o.y, out.z = rz + o.z, out;
                    }
                }, {
                    key: "rotateY",
                    value: function rotateY(out, v, o, a) {
                        _x$1 = v.x - o.x, _y$1 = v.y - o.y, _z = v.z - o.z;
                        var cos = Math.cos(a), sin = Math.sin(a), rx = _z * sin + _x$1 * cos, ry = _y$1, rz = _z * cos - _x$1 * sin;
                        return out.x = rx + o.x, out.y = ry + o.y, out.z = rz + o.z, out;
                    }
                }, {
                    key: "rotateZ",
                    value: function rotateZ(out, v, o, a) {
                        _x$1 = v.x - o.x, _y$1 = v.y - o.y, _z = v.z - o.z;
                        var cos = Math.cos(a), sin = Math.sin(a), rx = _x$1 * cos - _y$1 * sin, ry = _x$1 * sin + _y$1 * cos, rz = _z;
                        return out.x = rx + o.x, out.y = ry + o.y, out.z = rz + o.z, out;
                    }
                }, {
                    key: "toArray",
                    value: function toArray(out, v, argument_2) {
                        var ofs = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0;
                        return out[ofs + 0] = v.x, out[ofs + 1] = v.y, out[ofs + 2] = v.z, out;
                    }
                }, {
                    key: "fromArray",
                    value: function fromArray(out, arr, argument_2) {
                        var ofs = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0;
                        return out.x = arr[ofs + 0], out.y = arr[ofs + 1], out.z = arr[ofs + 2], out;
                    }
                }, {
                    key: "strictEquals",
                    value: function strictEquals(a, b) {
                        return a.x === b.x && a.y === b.y && a.z === b.z;
                    }
                }, {
                    key: "equals",
                    value: function equals(a, b, argument_2) {
                        var epsilon = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : EPSILON, a0 = a.x, a1 = a.y, a2 = a.z, b0 = b.x, b1 = b.y, b2 = b.z;
                        return Math.abs(a0 - b0) <= epsilon * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= epsilon * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= epsilon * Math.max(1, Math.abs(a2), Math.abs(b2));
                    }
                }, {
                    key: "angle",
                    value: function angle(a, b) {
                        Vec3.normalize(v3_1, a), Vec3.normalize(v3_2, b);
                        var cosine = Vec3.dot(v3_1, v3_2);
                        return 1 < cosine ? 0 : cosine < -1 ? Math.PI : Math.acos(cosine);
                    }
                }, {
                    key: "projectOnPlane",
                    value: function projectOnPlane(out, a, n) {
                        return Vec3.subtract(out, a, Vec3.project(out, a, n));
                    }
                }, {
                    key: "project",
                    value: function project(out, a, b) {
                        var sqrLen = Vec3.lengthSqr(b);
                        return sqrLen < 1e-6 ? Vec3.set(out, 0, 0, 0) : Vec3.multiplyScalar(out, b, Vec3.dot(a, b) / sqrLen);
                    }
                } ]), _createClass(Vec3, [ {
                    key: "clone",
                    value: function clone() {
                        return new Vec3(this.x, this.y, this.z);
                    }
                }, {
                    key: "set",
                    value: function set(x, y, z) {
                        return x && "object" === _typeof(x) ? (this.x = x.x, this.y = x.y, this.z = x.z) : (this.x = x || 0, 
                        this.y = y || 0, this.z = z || 0), this;
                    }
                }, {
                    key: "equals",
                    value: function equals(other, argument_1) {
                        var epsilon = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : EPSILON;
                        return Math.abs(this.x - other.x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(other.z));
                    }
                }, {
                    key: "equals3f",
                    value: function equals3f(x, y, z, argument_3) {
                        var epsilon = 3 < arguments.length && void 0 !== argument_3 ? argument_3 : EPSILON;
                        return Math.abs(this.x - x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(y)) && Math.abs(this.z - z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(z));
                    }
                }, {
                    key: "strictEquals",
                    value: function strictEquals(other) {
                        return this.x === other.x && this.y === other.y && this.z === other.z;
                    }
                }, {
                    key: "strictEquals3f",
                    value: function strictEquals3f(x, y, z) {
                        return this.x === x && this.y === y && this.z === z;
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ", ").concat(this.z.toFixed(2), ")");
                    }
                }, {
                    key: "lerp",
                    value: function lerp(to, ratio) {
                        return this.x = this.x + ratio * (to.x - this.x), this.y = this.y + ratio * (to.y - this.y), 
                        this.z = this.z + ratio * (to.z - this.z), this;
                    }
                }, {
                    key: "add",
                    value: function add(other) {
                        return this.x = this.x + other.x, this.y = this.y + other.y, this.z = this.z + other.z, 
                        this;
                    }
                }, {
                    key: "add3f",
                    value: function add3f(x, y, z) {
                        return this.x = this.x + x, this.y = this.y + y, this.z = this.z + z, this;
                    }
                }, {
                    key: "subtract",
                    value: function subtract(other) {
                        return this.x = this.x - other.x, this.y = this.y - other.y, this.z = this.z - other.z, 
                        this;
                    }
                }, {
                    key: "subtract3f",
                    value: function subtract3f(x, y, z) {
                        return this.x = this.x - x, this.y = this.y - y, this.z = this.z - z, this;
                    }
                }, {
                    key: "multiplyScalar",
                    value: function multiplyScalar(scalar) {
                        return "object" === _typeof(scalar) && console.warn("should use Vec3.multiply for vector * vector operation"), 
                        this.x = this.x * scalar, this.y = this.y * scalar, this.z = this.z * scalar, this;
                    }
                }, {
                    key: "multiply",
                    value: function multiply(other) {
                        return "object" !== _typeof(other) && console.warn("should use Vec3.scale for vector * scalar operation"), 
                        this.x = this.x * other.x, this.y = this.y * other.y, this.z = this.z * other.z, 
                        this;
                    }
                }, {
                    key: "multiply3f",
                    value: function multiply3f(x, y, z) {
                        return this.x = this.x * x, this.y = this.y * y, this.z = this.z * z, this;
                    }
                }, {
                    key: "divide",
                    value: function divide(other) {
                        return this.x = this.x / other.x, this.y = this.y / other.y, this.z = this.z / other.z, 
                        this;
                    }
                }, {
                    key: "divide3f",
                    value: function divide3f(x, y, z) {
                        return this.x = this.x / x, this.y = this.y / y, this.z = this.z / z, this;
                    }
                }, {
                    key: "negative",
                    value: function negative() {
                        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
                    }
                }, {
                    key: "clampf",
                    value: function clampf(minInclusive, maxInclusive) {
                        return this.x = clamp(this.x, minInclusive.x, maxInclusive.x), this.y = clamp(this.y, minInclusive.y, maxInclusive.y), 
                        this.z = clamp(this.z, minInclusive.z, maxInclusive.z), this;
                    }
                }, {
                    key: "dot",
                    value: function dot(other) {
                        return this.x * other.x + this.y * other.y + this.z * other.z;
                    }
                }, {
                    key: "cross",
                    value: function cross(other) {
                        var ax = this.x, ay = this.y, az = this.z, bx = other.x, by = other.y, bz = other.z;
                        return this.x = ay * bz - az * by, this.y = az * bx - ax * bz, this.z = ax * by - ay * bx, 
                        this;
                    }
                }, {
                    key: "length",
                    value: function length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                    }
                }, {
                    key: "lengthSqr",
                    value: function lengthSqr() {
                        return this.x * this.x + this.y * this.y + this.z * this.z;
                    }
                }, {
                    key: "normalize",
                    value: function normalize() {
                        _x$1 = this.x, _y$1 = this.y, _z = this.z;
                        var len = _x$1 * _x$1 + _y$1 * _y$1 + _z * _z;
                        return 0 < len && (len = 1 / Math.sqrt(len), this.x = _x$1 * len, this.y = _y$1 * len, 
                        this.z = _z * len), this;
                    }
                }, {
                    key: "transformMat4",
                    value: function transformMat4(matrix) {
                        _x$1 = this.x, _y$1 = this.y, _z = this.z;
                        var rhw = matrix.m03 * _x$1 + matrix.m07 * _y$1 + matrix.m11 * _z + matrix.m15;
                        return rhw = rhw ? 1 / rhw : 1, this.x = (matrix.m00 * _x$1 + matrix.m04 * _y$1 + matrix.m08 * _z + matrix.m12) * rhw, 
                        this.y = (matrix.m01 * _x$1 + matrix.m05 * _y$1 + matrix.m09 * _z + matrix.m13) * rhw, 
                        this.z = (matrix.m02 * _x$1 + matrix.m06 * _y$1 + matrix.m10 * _z + matrix.m14) * rhw, 
                        this;
                    }
                } ]), Vec3;
            }());
            Vec3.UNIT_X = Object.freeze(new Vec3(1, 0, 0)), Vec3.UNIT_Y = Object.freeze(new Vec3(0, 1, 0)), 
            Vec3.UNIT_Z = Object.freeze(new Vec3(0, 0, 1)), Vec3.ZERO = Object.freeze(new Vec3(0, 0, 0)), 
            Vec3.ONE = Object.freeze(new Vec3(1, 1, 1)), Vec3.NEG_ONE = Object.freeze(new Vec3(-1, -1, -1));
            var v3_1 = new Vec3(), v3_2 = new Vec3();
            function v3(x, y, z) {
                return new Vec3(x, y, z);
            }
            CCClass.fastDefine("cc.Vec3", Vec3, {
                x: 0,
                y: 0,
                z: 0
            }), cc.Vec3 = Vec3, cc.v3 = v3;
            var _x$2 = 0, _y$2 = 0, _z$1 = 0, _w = 0, Vec4 = exports("Vec4", function() {
                function Vec4(x, y, z, w) {
                    var _this;
                    return _classCallCheck(this, Vec4), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Vec4).call(this))).x = void 0, 
                    _this.y = void 0, _this.z = void 0, _this.w = void 0, x && "object" === _typeof(x) ? (_this.x = x.x, 
                    _this.y = x.y, _this.z = x.z, _this.w = x.w) : (_this.x = x || 0, _this.y = y || 0, 
                    _this.z = z || 0, _this.w = w || 0), _this;
                }
                return _inherits(Vec4, ValueType), _createClass(Vec4, null, [ {
                    key: "clone",
                    value: function clone(a) {
                        return new Vec4(a.x, a.y, a.z, a.w);
                    }
                }, {
                    key: "copy",
                    value: function copy(out, a) {
                        return out.x = a.x, out.y = a.y, out.z = a.z, out.w = a.w, out;
                    }
                }, {
                    key: "set",
                    value: function set(out, x, y, z, w) {
                        return out.x = x, out.y = y, out.z = z, out.w = w, out;
                    }
                }, {
                    key: "add",
                    value: function add(out, a, b) {
                        return out.x = a.x + b.x, out.y = a.y + b.y, out.z = a.z + b.z, out.w = a.w + b.w, 
                        out;
                    }
                }, {
                    key: "subtract",
                    value: function subtract(out, a, b) {
                        return out.x = a.x - b.x, out.y = a.y - b.y, out.z = a.z - b.z, out.w = a.w - b.w, 
                        out;
                    }
                }, {
                    key: "multiply",
                    value: function multiply(out, a, b) {
                        return out.x = a.x * b.x, out.y = a.y * b.y, out.z = a.z * b.z, out.w = a.w * b.w, 
                        out;
                    }
                }, {
                    key: "divide",
                    value: function divide(out, a, b) {
                        return out.x = a.x / b.x, out.y = a.y / b.y, out.z = a.z / b.z, out.w = a.w / b.w, 
                        out;
                    }
                }, {
                    key: "ceil",
                    value: function ceil(out, a) {
                        return out.x = Math.ceil(a.x), out.y = Math.ceil(a.y), out.z = Math.ceil(a.z), out.w = Math.ceil(a.w), 
                        out;
                    }
                }, {
                    key: "floor",
                    value: function floor(out, a) {
                        return out.x = Math.floor(a.x), out.y = Math.floor(a.y), out.z = Math.floor(a.z), 
                        out.w = Math.floor(a.w), out;
                    }
                }, {
                    key: "min",
                    value: function min(out, a, b) {
                        return out.x = Math.min(a.x, b.x), out.y = Math.min(a.y, b.y), out.z = Math.min(a.z, b.z), 
                        out.w = Math.min(a.w, b.w), out;
                    }
                }, {
                    key: "max",
                    value: function max(out, a, b) {
                        return out.x = Math.max(a.x, b.x), out.y = Math.max(a.y, b.y), out.z = Math.max(a.z, b.z), 
                        out.w = Math.max(a.w, b.w), out;
                    }
                }, {
                    key: "round",
                    value: function round(out, a) {
                        return out.x = Math.round(a.x), out.y = Math.round(a.y), out.z = Math.round(a.z), 
                        out.w = Math.round(a.w), out;
                    }
                }, {
                    key: "multiplyScalar",
                    value: function multiplyScalar(out, a, b) {
                        return out.x = a.x * b, out.y = a.y * b, out.z = a.z * b, out.w = a.w * b, out;
                    }
                }, {
                    key: "scaleAndAdd",
                    value: function scaleAndAdd(out, a, b, scale) {
                        return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out.z = a.z + b.z * scale, 
                        out.w = a.w + b.w * scale, out;
                    }
                }, {
                    key: "distance",
                    value: function distance(a, b) {
                        var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z, w = b.w - a.w;
                        return Math.sqrt(x * x + y * y + z * z + w * w);
                    }
                }, {
                    key: "squaredDistance",
                    value: function squaredDistance(a, b) {
                        var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z, w = b.w - a.w;
                        return x * x + y * y + z * z + w * w;
                    }
                }, {
                    key: "len",
                    value: function len(a) {
                        return _x$2 = a.x, _y$2 = a.y, _z$1 = a.z, _w = a.w, Math.sqrt(_x$2 * _x$2 + _y$2 * _y$2 + _z$1 * _z$1 + _w * _w);
                    }
                }, {
                    key: "lengthSqr",
                    value: function lengthSqr(a) {
                        return _x$2 = a.x, _y$2 = a.y, _z$1 = a.z, _w = a.w, _x$2 * _x$2 + _y$2 * _y$2 + _z$1 * _z$1 + _w * _w;
                    }
                }, {
                    key: "negate",
                    value: function negate(out, a) {
                        return out.x = -a.x, out.y = -a.y, out.z = -a.z, out.w = -a.w, out;
                    }
                }, {
                    key: "inverse",
                    value: function inverse(out, a) {
                        return out.x = 1 / a.x, out.y = 1 / a.y, out.z = 1 / a.z, out.w = 1 / a.w, out;
                    }
                }, {
                    key: "inverseSafe",
                    value: function inverseSafe(out, a) {
                        return _x$2 = a.x, _y$2 = a.y, _z$1 = a.z, _w = a.w, Math.abs(_x$2) < EPSILON ? out.x = 0 : out.x = 1 / _x$2, 
                        Math.abs(_y$2) < EPSILON ? out.y = 0 : out.y = 1 / _y$2, Math.abs(_z$1) < EPSILON ? out.z = 0 : out.z = 1 / _z$1, 
                        Math.abs(_w) < EPSILON ? out.w = 0 : out.w = 1 / _w, out;
                    }
                }, {
                    key: "normalize",
                    value: function normalize(out, a) {
                        _x$2 = a.x, _y$2 = a.y, _z$1 = a.z, _w = a.w;
                        var len = _x$2 * _x$2 + _y$2 * _y$2 + _z$1 * _z$1 + _w * _w;
                        return 0 < len && (len = 1 / Math.sqrt(len), out.x = _x$2 * len, out.y = _y$2 * len, 
                        out.z = _z$1 * len, out.w = _w * len), out;
                    }
                }, {
                    key: "dot",
                    value: function dot(a, b) {
                        return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
                    }
                }, {
                    key: "lerp",
                    value: function lerp(out, a, b, t) {
                        return out.x = a.x + t * (b.x - a.x), out.y = a.y + t * (b.y - a.y), out.z = a.z + t * (b.z - a.z), 
                        out.w = a.w + t * (b.w - a.w), out;
                    }
                }, {
                    key: "random",
                    value: function random$1(out, scale) {
                        scale = scale || 1;
                        var phi = 2 * random() * Math.PI, cosTheta = 2 * random() - 1, sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
                        return out.x = sinTheta * Math.cos(phi) * scale, out.y = sinTheta * Math.sin(phi) * scale, 
                        out.z = cosTheta * scale, out.w = 0, out;
                    }
                }, {
                    key: "transformMat4",
                    value: function transformMat4(out, a, m) {
                        return _x$2 = a.x, _y$2 = a.y, _z$1 = a.z, _w = a.w, out.x = m.m00 * _x$2 + m.m04 * _y$2 + m.m08 * _z$1 + m.m12 * _w, 
                        out.y = m.m01 * _x$2 + m.m05 * _y$2 + m.m09 * _z$1 + m.m13 * _w, out.z = m.m02 * _x$2 + m.m06 * _y$2 + m.m10 * _z$1 + m.m14 * _w, 
                        out.w = m.m03 * _x$2 + m.m07 * _y$2 + m.m11 * _z$1 + m.m15 * _w, out;
                    }
                }, {
                    key: "transformAffine",
                    value: function transformAffine(out, v, m) {
                        return _x$2 = v.x, _y$2 = v.y, _z$1 = v.z, _w = v.w, out.x = m.m00 * _x$2 + m.m01 * _y$2 + m.m02 * _z$1 + m.m03 * _w, 
                        out.y = m.m04 * _x$2 + m.m05 * _y$2 + m.m06 * _z$1 + m.m07 * _w, out.x = m.m08 * _x$2 + m.m09 * _y$2 + m.m10 * _z$1 + m.m11 * _w, 
                        out.w = v.w, out;
                    }
                }, {
                    key: "transformQuat",
                    value: function transformQuat(out, a, q) {
                        var x = a.x, y = a.y, z = a.z;
                        _x$2 = q.x, _y$2 = q.y, _z$1 = q.z;
                        var ix = (_w = q.w) * x + _y$2 * z - _z$1 * y, iy = _w * y + _z$1 * x - _x$2 * z, iz = _w * z + _x$2 * y - _y$2 * x, iw = -_x$2 * x - _y$2 * y - _z$1 * z;
                        return out.x = ix * _w + iw * -_x$2 + iy * -_z$1 - iz * -_y$2, out.y = iy * _w + iw * -_y$2 + iz * -_x$2 - ix * -_z$1, 
                        out.z = iz * _w + iw * -_z$1 + ix * -_y$2 - iy * -_x$2, out.w = a.w, out;
                    }
                }, {
                    key: "toArray",
                    value: function toArray(out, v, argument_2) {
                        var ofs = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0;
                        return out[ofs + 0] = v.x, out[ofs + 1] = v.y, out[ofs + 2] = v.z, out[ofs + 3] = v.w, 
                        out;
                    }
                }, {
                    key: "fromArray",
                    value: function fromArray(out, arr, argument_2) {
                        var ofs = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0;
                        return out.x = arr[ofs + 0], out.y = arr[ofs + 1], out.z = arr[ofs + 2], out.w = arr[ofs + 3], 
                        out;
                    }
                }, {
                    key: "strictEquals",
                    value: function strictEquals(a, b) {
                        return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
                    }
                }, {
                    key: "equals",
                    value: function equals(a, b, argument_2) {
                        var epsilon = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : EPSILON;
                        return Math.abs(a.x - b.x) <= epsilon * Math.max(1, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1, Math.abs(a.w), Math.abs(b.w));
                    }
                } ]), _createClass(Vec4, [ {
                    key: "clone",
                    value: function clone() {
                        return new Vec4(this.x, this.y, this.z, this.w);
                    }
                }, {
                    key: "set",
                    value: function set(x, y, z, w) {
                        return x && "object" === _typeof(x) ? (this.x = x.x, this.y = x.y, this.z = x.z, 
                        this.w = x.w) : (this.x = x || 0, this.y = y || 0, this.z = z || 0, this.w = w || 0), 
                        this;
                    }
                }, {
                    key: "equals",
                    value: function equals(other, argument_1) {
                        var epsilon = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : EPSILON;
                        return Math.abs(this.x - other.x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(other.z)) && Math.abs(this.w - other.w) <= epsilon * Math.max(1, Math.abs(this.w), Math.abs(other.w));
                    }
                }, {
                    key: "equals4f",
                    value: function equals4f(x, y, z, w, argument_4) {
                        var epsilon = 4 < arguments.length && void 0 !== argument_4 ? argument_4 : EPSILON;
                        return Math.abs(this.x - x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(y)) && Math.abs(this.z - z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(z)) && Math.abs(this.w - w) <= epsilon * Math.max(1, Math.abs(this.w), Math.abs(w));
                    }
                }, {
                    key: "strictEquals",
                    value: function strictEquals(other) {
                        return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
                    }
                }, {
                    key: "strictEquals4f",
                    value: function strictEquals4f(x, y, z, w) {
                        return this.x === x && this.y === y && this.z === z && this.w === w;
                    }
                }, {
                    key: "lerp",
                    value: function lerp(to, ratio) {
                        return _x$2 = this.x, _y$2 = this.y, _z$1 = this.z, _w = this.w, this.x = _x$2 + ratio * (to.x - _x$2), 
                        this.y = _y$2 + ratio * (to.y - _y$2), this.z = _z$1 + ratio * (to.z - _z$1), this.w = _w + ratio * (to.w - _w), 
                        this;
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ", ").concat(this.z.toFixed(2), ", ").concat(this.w.toFixed(2), ")");
                    }
                }, {
                    key: "clampf",
                    value: function clampf(minInclusive, maxInclusive) {
                        return this.x = clamp(this.x, minInclusive.x, maxInclusive.x), this.y = clamp(this.y, minInclusive.y, maxInclusive.y), 
                        this.z = clamp(this.z, minInclusive.z, maxInclusive.z), this.w = clamp(this.w, minInclusive.w, maxInclusive.w), 
                        this;
                    }
                }, {
                    key: "add",
                    value: function add(other) {
                        return this.x = this.x + other.x, this.y = this.y + other.y, this.z = this.z + other.z, 
                        this.w = this.w + other.w, this;
                    }
                }, {
                    key: "add4f",
                    value: function add4f(x, y, z, w) {
                        return this.x = this.x + x, this.y = this.y + y, this.z = this.z + z, this.w = this.w + w, 
                        this;
                    }
                }, {
                    key: "subtract",
                    value: function subtract(other) {
                        return this.x = this.x - other.x, this.y = this.y - other.y, this.z = this.z - other.z, 
                        this.w = this.w - other.w, this;
                    }
                }, {
                    key: "subtract4f",
                    value: function subtract4f(x, y, z, w) {
                        return this.x = this.x - x, this.y = this.y - y, this.z = this.z - z, this.w = this.w - w, 
                        this;
                    }
                }, {
                    key: "multiplyScalar",
                    value: function multiplyScalar(scalar) {
                        return "object" === _typeof(scalar) && console.warn("should use Vec4.multiply for vector * vector operation"), 
                        this.x = this.x * scalar, this.y = this.y * scalar, this.z = this.z * scalar, this.w = this.w * scalar, 
                        this;
                    }
                }, {
                    key: "multiply",
                    value: function multiply(other) {
                        return "object" !== _typeof(other) && console.warn("should use Vec4.scale for vector * scalar operation"), 
                        this.x = this.x * other.x, this.y = this.y * other.y, this.z = this.z * other.z, 
                        this.w = this.w * other.w, this;
                    }
                }, {
                    key: "multiply4f",
                    value: function multiply4f(x, y, z, w) {
                        return this.x = this.x * x, this.y = this.y * y, this.z = this.z * z, this.w = this.w * w, 
                        this;
                    }
                }, {
                    key: "divide",
                    value: function divide(other) {
                        return this.x = this.x / other.x, this.y = this.y / other.y, this.z = this.z / other.z, 
                        this.w = this.w / other.w, this;
                    }
                }, {
                    key: "divide4f",
                    value: function divide4f(x, y, z, w) {
                        return this.x = this.x / x, this.y = this.y / y, this.z = this.z / z, this.w = this.w / w, 
                        this;
                    }
                }, {
                    key: "negative",
                    value: function negative() {
                        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
                    }
                }, {
                    key: "dot",
                    value: function dot(vector) {
                        return this.x * vector.x + this.y * vector.y + this.z * vector.z + this.w * vector.w;
                    }
                }, {
                    key: "cross",
                    value: function cross(vector) {
                        var ax = this.x, ay = this.y, az = this.z, bx = vector.x, by = vector.y, bz = vector.z;
                        return this.x = ay * bz - az * by, this.y = az * bx - ax * bz, this.z = ax * by - ay * bx, 
                        this;
                    }
                }, {
                    key: "length",
                    value: function length() {
                        return _x$2 = this.x, _y$2 = this.y, _z$1 = this.z, _w = this.w, Math.sqrt(_x$2 * _x$2 + _y$2 * _y$2 + _z$1 * _z$1 + _w * _w);
                    }
                }, {
                    key: "lengthSqr",
                    value: function lengthSqr() {
                        return _x$2 = this.x, _y$2 = this.y, _z$1 = this.z, _w = this.w, _x$2 * _x$2 + _y$2 * _y$2 + _z$1 * _z$1 + _w * _w;
                    }
                }, {
                    key: "normalize",
                    value: function normalize() {
                        _x$2 = this.x, _y$2 = this.y, _z$1 = this.z, _w = this.w;
                        var len = _x$2 * _x$2 + _y$2 * _y$2 + _z$1 * _z$1 + _w * _w;
                        return 0 < len && (len = 1 / Math.sqrt(len), this.x = _x$2 * len, this.y = _y$2 * len, 
                        this.z = _z$1 * len, this.w = _w * len), this;
                    }
                }, {
                    key: "transformMat4",
                    value: function transformMat4(matrix) {
                        return _x$2 = this.x, _y$2 = this.y, _z$1 = this.z, _w = this.w, this.x = matrix.m00 * _x$2 + matrix.m04 * _y$2 + matrix.m08 * _z$1 + matrix.m12 * _w, 
                        this.y = matrix.m01 * _x$2 + matrix.m05 * _y$2 + matrix.m09 * _z$1 + matrix.m13 * _w, 
                        this.z = matrix.m02 * _x$2 + matrix.m06 * _y$2 + matrix.m10 * _z$1 + matrix.m14 * _w, 
                        this.w = matrix.m03 * _x$2 + matrix.m07 * _y$2 + matrix.m11 * _z$1 + matrix.m15 * _w, 
                        this;
                    }
                } ]), Vec4;
            }());
            function v4(x, y, z, w) {
                return new Vec4(x, y, z, w);
            }
            Vec4.ZERO = Object.freeze(new Vec4(0, 0, 0, 0)), Vec4.ONE = Object.freeze(new Vec4(1, 1, 1, 1)), 
            Vec4.NEG_ONE = Object.freeze(new Vec4(-1, -1, -1, -1)), CCClass.fastDefine("cc.Vec4", Vec4, {
                x: 0,
                y: 0,
                z: 0,
                w: 0
            }), cc.Vec4 = Vec4, cc.v4 = v4;
            var _a00 = 0, _a01 = 0, _a02 = 0, _a10 = 0, _a11 = 0, _a12 = 0, _a20 = 0, _a21 = 0, _a22 = 0, Mat3 = exports("Mat3", function() {
                function Mat3() {
                    var _this, m00 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1, m01 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, m02 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, m03 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, m04 = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 1, m05 = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0, m06 = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : 0, m07 = 7 < arguments.length && void 0 !== arguments[7] ? arguments[7] : 0, m08 = 8 < arguments.length && void 0 !== arguments[8] ? arguments[8] : 1;
                    return _classCallCheck(this, Mat3), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Mat3).call(this))).m00 = void 0, 
                    _this.m01 = void 0, _this.m02 = void 0, _this.m03 = void 0, _this.m04 = void 0, 
                    _this.m05 = void 0, _this.m06 = void 0, _this.m07 = void 0, _this.m08 = void 0, 
                    "object" === _typeof(m00) ? (_this.m00 = m00.m00, _this.m01 = m00.m01, _this.m02 = m00.m02, 
                    _this.m03 = m00.m03, _this.m04 = m00.m04, _this.m05 = m00.m05, _this.m06 = m00.m06, 
                    _this.m07 = m00.m07, _this.m08 = m00.m08) : (_this.m00 = m00, _this.m01 = m01, _this.m02 = m02, 
                    _this.m03 = m03, _this.m04 = m04, _this.m05 = m05, _this.m06 = m06, _this.m07 = m07, 
                    _this.m08 = m08), _this;
                }
                return _inherits(Mat3, ValueType), _createClass(Mat3, null, [ {
                    key: "clone",
                    value: function clone(a) {
                        return new Mat3(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08);
                    }
                }, {
                    key: "copy",
                    value: function copy(out, a) {
                        return out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, out.m04 = a.m04, 
                        out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, out;
                    }
                }, {
                    key: "set",
                    value: function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
                        return out.m00 = m00, out.m01 = m01, out.m02 = m02, out.m03 = m10, out.m04 = m11, 
                        out.m05 = m12, out.m06 = m20, out.m07 = m21, out.m08 = m22, out;
                    }
                }, {
                    key: "identity",
                    value: function identity(out) {
                        return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 1, out.m05 = 0, 
                        out.m06 = 0, out.m07 = 0, out.m08 = 1, out;
                    }
                }, {
                    key: "transpose",
                    value: function transpose(out, a) {
                        return out === a ? (_a01 = a.m01, _a02 = a.m02, _a12 = a.m05, out.m01 = a.m03, out.m02 = a.m06, 
                        out.m03 = _a01, out.m05 = a.m07, out.m06 = _a02, out.m07 = _a12) : (out.m00 = a.m00, 
                        out.m01 = a.m03, out.m02 = a.m06, out.m03 = a.m01, out.m04 = a.m04, out.m05 = a.m07, 
                        out.m06 = a.m02, out.m07 = a.m05, out.m08 = a.m08), out;
                    }
                }, {
                    key: "invert",
                    value: function invert(out, a) {
                        _a00 = a.m00, _a01 = a.m01, _a02 = a.m02, _a10 = a.m03, _a11 = a.m04, _a12 = a.m05, 
                        _a20 = a.m06, _a21 = a.m07;
                        var b01 = (_a22 = a.m08) * _a11 - _a12 * _a21, b11 = -_a22 * _a10 + _a12 * _a20, b21 = _a21 * _a10 - _a11 * _a20, det = _a00 * b01 + _a01 * b11 + _a02 * b21;
                        return det && (det = 1 / det, out.m00 = b01 * det, out.m01 = (-_a22 * _a01 + _a02 * _a21) * det, 
                        out.m02 = (_a12 * _a01 - _a02 * _a11) * det, out.m03 = b11 * det, out.m04 = (_a22 * _a00 - _a02 * _a20) * det, 
                        out.m05 = (-_a12 * _a00 + _a02 * _a10) * det, out.m06 = b21 * det, out.m07 = (-_a21 * _a00 + _a01 * _a20) * det, 
                        out.m08 = (_a11 * _a00 - _a01 * _a10) * det), out;
                    }
                }, {
                    key: "determinant",
                    value: function determinant(a) {
                        return _a00 = a.m00, _a01 = a.m01, _a02 = a.m02, _a10 = a.m03, _a11 = a.m04, _a12 = a.m05, 
                        _a20 = a.m06, _a21 = a.m07, _a22 = a.m08, _a00 * (_a22 * _a11 - _a12 * _a21) + _a01 * (-_a22 * _a10 + _a12 * _a20) + _a02 * (_a21 * _a10 - _a11 * _a20);
                    }
                }, {
                    key: "multiply",
                    value: function multiply(out, a, b) {
                        _a00 = a.m00, _a01 = a.m01, _a02 = a.m02, _a10 = a.m03, _a11 = a.m04, _a12 = a.m05, 
                        _a20 = a.m06, _a21 = a.m07, _a22 = a.m08;
                        var b00 = b.m00, b01 = b.m01, b02 = b.m02, b10 = b.m03, b11 = b.m04, b12 = b.m05, b20 = b.m06, b21 = b.m07, b22 = b.m08;
                        return out.m00 = b00 * _a00 + b01 * _a10 + b02 * _a20, out.m01 = b00 * _a01 + b01 * _a11 + b02 * _a21, 
                        out.m02 = b00 * _a02 + b01 * _a12 + b02 * _a22, out.m03 = b10 * _a00 + b11 * _a10 + b12 * _a20, 
                        out.m04 = b10 * _a01 + b11 * _a11 + b12 * _a21, out.m05 = b10 * _a02 + b11 * _a12 + b12 * _a22, 
                        out.m06 = b20 * _a00 + b21 * _a10 + b22 * _a20, out.m07 = b20 * _a01 + b21 * _a11 + b22 * _a21, 
                        out.m08 = b20 * _a02 + b21 * _a12 + b22 * _a22, out;
                    }
                }, {
                    key: "multiplyMat4",
                    value: function multiplyMat4(out, a, b) {
                        _a00 = a.m00, _a01 = a.m01, _a02 = a.m02, _a10 = a.m03, _a11 = a.m04, _a12 = a.m05, 
                        _a20 = a.m06, _a21 = a.m07, _a22 = a.m08;
                        var b00 = b.m00, b01 = b.m01, b02 = b.m02, b10 = b.m04, b11 = b.m05, b12 = b.m06, b20 = b.m08, b21 = b.m09, b22 = b.m10;
                        return out.m00 = b00 * _a00 + b01 * _a10 + b02 * _a20, out.m01 = b00 * _a01 + b01 * _a11 + b02 * _a21, 
                        out.m02 = b00 * _a02 + b01 * _a12 + b02 * _a22, out.m03 = b10 * _a00 + b11 * _a10 + b12 * _a20, 
                        out.m04 = b10 * _a01 + b11 * _a11 + b12 * _a21, out.m05 = b10 * _a02 + b11 * _a12 + b12 * _a22, 
                        out.m06 = b20 * _a00 + b21 * _a10 + b22 * _a20, out.m07 = b20 * _a01 + b21 * _a11 + b22 * _a21, 
                        out.m08 = b20 * _a02 + b21 * _a12 + b22 * _a22, out;
                    }
                }, {
                    key: "transfrom",
                    value: function transfrom(out, a, v) {
                        _a00 = a.m00, _a01 = a.m01, _a02 = a.m02, _a10 = a.m03, _a11 = a.m04, _a12 = a.m05, 
                        _a20 = a.m06, _a21 = a.m07, _a22 = a.m08;
                        var x = v.x, y = v.y;
                        return out.m00 = _a00, out.m01 = _a01, out.m02 = _a02, out.m03 = _a10, out.m04 = _a11, 
                        out.m05 = _a12, out.m06 = x * _a00 + y * _a10 + _a20, out.m07 = x * _a01 + y * _a11 + _a21, 
                        out.m08 = x * _a02 + y * _a12 + _a22, out;
                    }
                }, {
                    key: "scale",
                    value: function scale(out, a, v) {
                        var x = v.x, y = v.y;
                        return out.m00 = x * a.m00, out.m01 = x * a.m01, out.m02 = x * a.m02, out.m03 = y * a.m03, 
                        out.m04 = y * a.m04, out.m05 = y * a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, 
                        out;
                    }
                }, {
                    key: "rotate",
                    value: function rotate(out, a, rad) {
                        _a00 = a.m00, _a01 = a.m01, _a02 = a.m02, _a10 = a.m03, _a11 = a.m04, _a12 = a.m05, 
                        _a20 = a.m06, _a21 = a.m07, _a22 = a.m08;
                        var s = Math.sin(rad), c = Math.cos(rad);
                        return out.m00 = c * _a00 + s * _a10, out.m01 = c * _a01 + s * _a11, out.m02 = c * _a02 + s * _a12, 
                        out.m03 = c * _a10 - s * _a00, out.m04 = c * _a11 - s * _a01, out.m05 = c * _a12 - s * _a02, 
                        out.m06 = _a20, out.m07 = _a21, out.m08 = _a22, out;
                    }
                }, {
                    key: "fromMat4",
                    value: function fromMat4(out, a) {
                        return out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m04, out.m04 = a.m05, 
                        out.m05 = a.m06, out.m06 = a.m08, out.m07 = a.m09, out.m08 = a.m10, out;
                    }
                }, {
                    key: "fromViewUp",
                    value: function fromViewUp(out, view, up) {
                        return Vec3.lengthSqr(view) < EPSILON * EPSILON ? (Mat3.identity(out), out) : (up = up || Vec3.UNIT_Y, 
                        Vec3.normalize(v3_1$1, Vec3.cross(v3_1$1, up, view)), Vec3.lengthSqr(v3_1$1) < EPSILON * EPSILON ? Mat3.identity(out) : (Vec3.cross(v3_2$1, view, v3_1$1), 
                        Mat3.set(out, v3_1$1.x, v3_1$1.y, v3_1$1.z, v3_2$1.x, v3_2$1.y, v3_2$1.z, view.x, view.y, view.z)), 
                        out);
                    }
                }, {
                    key: "fromTranslation",
                    value: function fromTranslation(out, v) {
                        return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 1, out.m05 = 0, 
                        out.m06 = v.x, out.m07 = v.y, out.m08 = 1, out;
                    }
                }, {
                    key: "fromScaling",
                    value: function fromScaling(out, v) {
                        return out.m00 = v.x, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = v.y, out.m05 = 0, 
                        out.m06 = 0, out.m07 = 0, out.m08 = 1, out;
                    }
                }, {
                    key: "fromRotation",
                    value: function fromRotation(out, rad) {
                        var s = Math.sin(rad), c = Math.cos(rad);
                        return out.m00 = c, out.m01 = s, out.m02 = 0, out.m03 = -s, out.m04 = c, out.m05 = 0, 
                        out.m06 = 0, out.m07 = 0, out.m08 = 1, out;
                    }
                }, {
                    key: "fromQuat",
                    value: function fromQuat(out, q) {
                        var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
                        return out.m00 = 1 - yy - zz, out.m03 = yx - wz, out.m06 = zx + wy, out.m01 = yx + wz, 
                        out.m04 = 1 - xx - zz, out.m07 = zy - wx, out.m02 = zx - wy, out.m05 = zy + wx, 
                        out.m08 = 1 - xx - yy, out;
                    }
                }, {
                    key: "inverseTransposeMat4",
                    value: function inverseTransposeMat4(out, a) {
                        var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15, b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                        return det ? (det = 1 / det, out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det, 
                        out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det, out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det, 
                        out.m03 = (a02 * b10 - a01 * b11 - a03 * b09) * det, out.m04 = (a00 * b11 - a02 * b08 + a03 * b07) * det, 
                        out.m05 = (a01 * b08 - a00 * b10 - a03 * b06) * det, out.m06 = (a31 * b05 - a32 * b04 + a33 * b03) * det, 
                        out.m07 = (a32 * b02 - a30 * b05 - a33 * b01) * det, out.m08 = (a30 * b04 - a31 * b02 + a33 * b00) * det, 
                        out) : null;
                    }
                }, {
                    key: "toArray",
                    value: function toArray(out, m, argument_2) {
                        var ofs = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0;
                        return out[ofs + 0] = m.m00, out[ofs + 1] = m.m01, out[ofs + 2] = m.m02, out[ofs + 3] = m.m03, 
                        out[ofs + 4] = m.m04, out[ofs + 5] = m.m05, out[ofs + 6] = m.m06, out[ofs + 7] = m.m07, 
                        out[ofs + 8] = m.m08, out;
                    }
                }, {
                    key: "fromArray",
                    value: function fromArray(out, arr, argument_2) {
                        var ofs = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0;
                        return out.m00 = arr[ofs + 0], out.m01 = arr[ofs + 1], out.m02 = arr[ofs + 2], out.m03 = arr[ofs + 3], 
                        out.m04 = arr[ofs + 4], out.m05 = arr[ofs + 5], out.m06 = arr[ofs + 6], out.m07 = arr[ofs + 7], 
                        out.m08 = arr[ofs + 8], out;
                    }
                }, {
                    key: "add",
                    value: function add(out, a, b) {
                        return out.m00 = a.m00 + b.m00, out.m01 = a.m01 + b.m01, out.m02 = a.m02 + b.m02, 
                        out.m03 = a.m03 + b.m03, out.m04 = a.m04 + b.m04, out.m05 = a.m05 + b.m05, out.m06 = a.m06 + b.m06, 
                        out.m07 = a.m07 + b.m07, out.m08 = a.m08 + b.m08, out;
                    }
                }, {
                    key: "subtract",
                    value: function subtract(out, a, b) {
                        return out.m00 = a.m00 - b.m00, out.m01 = a.m01 - b.m01, out.m02 = a.m02 - b.m02, 
                        out.m03 = a.m03 - b.m03, out.m04 = a.m04 - b.m04, out.m05 = a.m05 - b.m05, out.m06 = a.m06 - b.m06, 
                        out.m07 = a.m07 - b.m07, out.m08 = a.m08 - b.m08, out;
                    }
                }, {
                    key: "multiplyScalar",
                    value: function multiplyScalar(out, a, b) {
                        return out.m00 = a.m00 * b, out.m01 = a.m01 * b, out.m02 = a.m02 * b, out.m03 = a.m03 * b, 
                        out.m04 = a.m04 * b, out.m05 = a.m05 * b, out.m06 = a.m06 * b, out.m07 = a.m07 * b, 
                        out.m08 = a.m08 * b, out;
                    }
                }, {
                    key: "multiplyScalarAndAdd",
                    value: function multiplyScalarAndAdd(out, a, b, scale) {
                        return out.m00 = b.m00 * scale + a.m00, out.m01 = b.m01 * scale + a.m01, out.m02 = b.m02 * scale + a.m02, 
                        out.m03 = b.m03 * scale + a.m03, out.m04 = b.m04 * scale + a.m04, out.m05 = b.m05 * scale + a.m05, 
                        out.m06 = b.m06 * scale + a.m06, out.m07 = b.m07 * scale + a.m07, out.m08 = b.m08 * scale + a.m08, 
                        out;
                    }
                }, {
                    key: "strictEquals",
                    value: function strictEquals(a, b) {
                        return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08;
                    }
                }, {
                    key: "equals",
                    value: function equals(a, b, argument_2) {
                        var epsilon = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : EPSILON;
                        return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1, Math.abs(a.m08), Math.abs(b.m08));
                    }
                } ]), _createClass(Mat3, [ {
                    key: "clone",
                    value: function clone() {
                        var t = this;
                        return new Mat3(t.m00, t.m01, t.m02, t.m03, t.m04, t.m05, t.m06, t.m07, t.m08);
                    }
                }, {
                    key: "set",
                    value: function set(argument_0, argument_1, argument_2, argument_3, argument_4, argument_5, argument_6, argument_7, argument_8) {
                        var m00 = 0 < arguments.length && void 0 !== argument_0 ? argument_0 : 1, m01 = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : 0, m02 = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0, m03 = 3 < arguments.length && void 0 !== argument_3 ? argument_3 : 0, m04 = 4 < arguments.length && void 0 !== argument_4 ? argument_4 : 1, m05 = 5 < arguments.length && void 0 !== argument_5 ? argument_5 : 0, m06 = 6 < arguments.length && void 0 !== argument_6 ? argument_6 : 0, m07 = 7 < arguments.length && void 0 !== argument_7 ? argument_7 : 0, m08 = 8 < arguments.length && void 0 !== argument_8 ? argument_8 : 1;
                        return "object" === _typeof(m00) ? (this.m00 = m00.m00, this.m01 = m00.m01, this.m02 = m00.m02, 
                        this.m03 = m00.m03, this.m04 = m00.m04, this.m05 = m00.m05, this.m06 = m00.m06, 
                        this.m07 = m00.m07, this.m08 = m00.m08) : (this.m00 = m00, this.m01 = m01, this.m02 = m02, 
                        this.m03 = m03, this.m04 = m04, this.m05 = m05, this.m06 = m06, this.m07 = m07, 
                        this.m08 = m08), this;
                    }
                }, {
                    key: "equals",
                    value: function equals(other, argument_1) {
                        var epsilon = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : EPSILON;
                        return Math.abs(this.m00 - other.m00) <= epsilon * Math.max(1, Math.abs(this.m00), Math.abs(other.m00)) && Math.abs(this.m01 - other.m01) <= epsilon * Math.max(1, Math.abs(this.m01), Math.abs(other.m01)) && Math.abs(this.m02 - other.m02) <= epsilon * Math.max(1, Math.abs(this.m02), Math.abs(other.m02)) && Math.abs(this.m03 - other.m03) <= epsilon * Math.max(1, Math.abs(this.m03), Math.abs(other.m03)) && Math.abs(this.m04 - other.m04) <= epsilon * Math.max(1, Math.abs(this.m04), Math.abs(other.m04)) && Math.abs(this.m05 - other.m05) <= epsilon * Math.max(1, Math.abs(this.m05), Math.abs(other.m05)) && Math.abs(this.m06 - other.m06) <= epsilon * Math.max(1, Math.abs(this.m06), Math.abs(other.m06)) && Math.abs(this.m07 - other.m07) <= epsilon * Math.max(1, Math.abs(this.m07), Math.abs(other.m07)) && Math.abs(this.m08 - other.m08) <= epsilon * Math.max(1, Math.abs(this.m08), Math.abs(other.m08));
                    }
                }, {
                    key: "strictEquals",
                    value: function strictEquals(other) {
                        return this.m00 === other.m00 && this.m01 === other.m01 && this.m02 === other.m02 && this.m03 === other.m03 && this.m04 === other.m04 && this.m05 === other.m05 && this.m06 === other.m06 && this.m07 === other.m07 && this.m08 === other.m08;
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        var t = this;
                        return "[\n" + t.m00 + ", " + t.m01 + ", " + t.m02 + ",\n" + t.m03 + ",\n" + t.m04 + ", " + t.m05 + ",\n" + t.m06 + ", " + t.m07 + ",\n" + t.m08 + "\n]";
                    }
                }, {
                    key: "identity",
                    value: function identity() {
                        return this.m00 = 1, this.m01 = 0, this.m02 = 0, this.m03 = 0, this.m04 = 1, this.m05 = 0, 
                        this.m06 = 0, this.m07 = 0, this.m08 = 1, this;
                    }
                }, {
                    key: "transpose",
                    value: function transpose() {
                        var a01 = this.m01, a02 = this.m02, a12 = this.m05;
                        return this.m01 = this.m03, this.m02 = this.m06, this.m03 = a01, this.m05 = this.m07, 
                        this.m06 = a02, this.m07 = a12, this;
                    }
                }, {
                    key: "invert",
                    value: function invert() {
                        _a00 = this.m00, _a01 = this.m01, _a02 = this.m02, _a10 = this.m03, _a11 = this.m04, 
                        _a12 = this.m05, _a20 = this.m06, _a21 = this.m07;
                        var b01 = (_a22 = this.m08) * _a11 - _a12 * _a21, b11 = -_a22 * _a10 + _a12 * _a20, b21 = _a21 * _a10 - _a11 * _a20, det = _a00 * b01 + _a01 * b11 + _a02 * b21;
                        return det ? (det = 1 / det, this.m00 = b01 * det, this.m01 = (-_a22 * _a01 + _a02 * _a21) * det, 
                        this.m02 = (_a12 * _a01 - _a02 * _a11) * det, this.m03 = b11 * det, this.m04 = (_a22 * _a00 - _a02 * _a20) * det, 
                        this.m05 = (-_a12 * _a00 + _a02 * _a10) * det, this.m06 = b21 * det, this.m07 = (-_a21 * _a00 + _a01 * _a20) * det, 
                        this.m08 = (_a11 * _a00 - _a01 * _a10) * det, this) : null;
                    }
                }, {
                    key: "determinant",
                    value: function determinant() {
                        return _a00 = this.m00, _a01 = this.m01, _a02 = this.m02, _a10 = this.m03, _a11 = this.m04, 
                        _a12 = this.m05, _a20 = this.m06, _a21 = this.m07, _a22 = this.m08, _a00 * (_a22 * _a11 - _a12 * _a21) + _a01 * (-_a22 * _a10 + _a12 * _a20) + _a02 * (_a21 * _a10 - _a11 * _a20);
                    }
                }, {
                    key: "add",
                    value: function add(mat) {
                        return this.m00 = this.m00 + mat.m00, this.m01 = this.m01 + mat.m01, this.m02 = this.m02 + mat.m02, 
                        this.m03 = this.m03 + mat.m03, this.m04 = this.m04 + mat.m04, this.m05 = this.m05 + mat.m05, 
                        this.m06 = this.m06 + mat.m06, this.m07 = this.m07 + mat.m07, this.m08 = this.m08 + mat.m08, 
                        this;
                    }
                }, {
                    key: "subtract",
                    value: function subtract(mat) {
                        return this.m00 = this.m00 - mat.m00, this.m01 = this.m01 - mat.m01, this.m02 = this.m02 - mat.m02, 
                        this.m03 = this.m03 - mat.m03, this.m04 = this.m04 - mat.m04, this.m05 = this.m05 - mat.m05, 
                        this.m06 = this.m06 - mat.m06, this.m07 = this.m07 - mat.m07, this.m08 = this.m08 - mat.m08, 
                        this;
                    }
                }, {
                    key: "multiply",
                    value: function multiply(mat) {
                        var a00 = this.m00, a01 = this.m01, a02 = this.m02, a10 = this.m03, a11 = this.m04, a12 = this.m05, a20 = this.m06, a21 = this.m07, a22 = this.m08, b00 = mat.m00, b01 = mat.m01, b02 = mat.m02, b10 = mat.m03, b11 = mat.m04, b12 = mat.m05, b20 = mat.m06, b21 = mat.m07, b22 = mat.m08;
                        return this.m00 = b00 * a00 + b01 * a10 + b02 * a20, this.m01 = b00 * a01 + b01 * a11 + b02 * a21, 
                        this.m02 = b00 * a02 + b01 * a12 + b02 * a22, this.m03 = b10 * a00 + b11 * a10 + b12 * a20, 
                        this.m04 = b10 * a01 + b11 * a11 + b12 * a21, this.m05 = b10 * a02 + b11 * a12 + b12 * a22, 
                        this.m06 = b20 * a00 + b21 * a10 + b22 * a20, this.m07 = b20 * a01 + b21 * a11 + b22 * a21, 
                        this.m08 = b20 * a02 + b21 * a12 + b22 * a22, this;
                    }
                }, {
                    key: "multiplyScalar",
                    value: function multiplyScalar(scalar) {
                        return this.m00 = this.m00 * scalar, this.m01 = this.m01 * scalar, this.m02 = this.m02 * scalar, 
                        this.m03 = this.m03 * scalar, this.m04 = this.m04 * scalar, this.m05 = this.m05 * scalar, 
                        this.m06 = this.m06 * scalar, this.m07 = this.m07 * scalar, this.m08 = this.m08 * scalar, 
                        this;
                    }
                }, {
                    key: "scale",
                    value: function scale(vec) {
                        var x = vec.x, y = vec.y;
                        return this.m00 = x * this.m00, this.m01 = x * this.m01, this.m02 = x * this.m02, 
                        this.m03 = y * this.m03, this.m04 = y * this.m04, this.m05 = y * this.m05, this.m06 = this.m06, 
                        this.m07 = this.m07, this.m08 = this.m08, this;
                    }
                }, {
                    key: "rotate",
                    value: function rotate(rad) {
                        _a00 = this.m00, _a01 = this.m01, _a02 = this.m02, _a10 = this.m03, _a11 = this.m04, 
                        _a12 = this.m05, _a20 = this.m06, _a21 = this.m07, _a22 = this.m08;
                        var s = Math.sin(rad), c = Math.cos(rad);
                        return this.m00 = c * _a00 + s * _a10, this.m01 = c * _a01 + s * _a11, this.m02 = c * _a02 + s * _a12, 
                        this.m03 = c * _a10 - s * _a00, this.m04 = c * _a11 - s * _a01, this.m05 = c * _a12 - s * _a02, 
                        this.m06 = _a20, this.m07 = _a21, this.m08 = _a22, this;
                    }
                }, {
                    key: "fromQuat",
                    value: function fromQuat(q) {
                        var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
                        return this.m00 = 1 - yy - zz, this.m03 = yx - wz, this.m06 = zx + wy, this.m01 = yx + wz, 
                        this.m04 = 1 - xx - zz, this.m07 = zy - wx, this.m02 = zx - wy, this.m05 = zy + wx, 
                        this.m08 = 1 - xx - yy, this;
                    }
                } ]), Mat3;
            }());
            Mat3.IDENTITY = Object.freeze(new Mat3());
            var v3_1$1 = new Vec3(), v3_2$1 = new Vec3();
            CCClass.fastDefine("cc.Mat3", Mat3, {
                m00: 1,
                m01: 0,
                m02: 0,
                m03: 0,
                m04: 1,
                m05: 0,
                m06: 0,
                m07: 0,
                m08: 1
            }), cc.Mat3 = Mat3;
            var _x$3 = 0, _y$3 = 0, _z$2 = 0, _w$1 = 0, Quat = exports("Quat", function() {
                function Quat(x, y, z, w) {
                    var _this;
                    return _classCallCheck(this, Quat), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Quat).call(this))).x = void 0, 
                    _this.y = void 0, _this.z = void 0, _this.w = void 0, x && "object" === _typeof(x) ? (_this.x = x.x, 
                    _this.y = x.y, _this.z = x.z, _this.w = x.w) : (_this.x = x || 0, _this.y = y || 0, 
                    _this.z = z || 0, _this.w = w || 1), _this;
                }
                return _inherits(Quat, ValueType), _createClass(Quat, null, [ {
                    key: "clone",
                    value: function clone(a) {
                        return new Quat(a.x, a.y, a.z, a.w);
                    }
                }, {
                    key: "copy",
                    value: function copy(out, a) {
                        return out.x = a.x, out.y = a.y, out.z = a.z, out.w = a.w, out;
                    }
                }, {
                    key: "set",
                    value: function set(out, x, y, z, w) {
                        return out.x = x, out.y = y, out.z = z, out.w = w, out;
                    }
                }, {
                    key: "identity",
                    value: function identity(out) {
                        return out.x = 0, out.y = 0, out.z = 0, out.w = 1, out;
                    }
                }, {
                    key: "rotationTo",
                    value: function rotationTo(out, a, b) {
                        var dot = Vec3.dot(a, b);
                        return dot < -.999999 ? (Vec3.cross(v3_1$2, Vec3.UNIT_X, a), v3_1$2.length() < 1e-6 && Vec3.cross(v3_1$2, Vec3.UNIT_Y, a), 
                        Vec3.normalize(v3_1$2, v3_1$2), Quat.fromAxisAngle(out, v3_1$2, Math.PI), out) : .999999 < dot ? (out.x = 0, 
                        out.y = 0, out.z = 0, out.w = 1, out) : (Vec3.cross(v3_1$2, a, b), out.x = v3_1$2.x, 
                        out.y = v3_1$2.y, out.z = v3_1$2.z, out.w = 1 + dot, Quat.normalize(out, out));
                    }
                }, {
                    key: "getAxisAngle",
                    value: function getAxisAngle(outAxis, q) {
                        var rad = 2 * Math.acos(q.w), s = Math.sin(rad / 2);
                        return 0 !== s ? (outAxis.x = q.x / s, outAxis.y = q.y / s, outAxis.z = q.z / s) : (outAxis.x = 1, 
                        outAxis.y = 0, outAxis.z = 0), rad;
                    }
                }, {
                    key: "multiply",
                    value: function multiply(out, a, b) {
                        return _x$3 = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y, _y$3 = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z, 
                        _z$2 = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x, _w$1 = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z, 
                        out.x = _x$3, out.y = _y$3, out.z = _z$2, out.w = _w$1, out;
                    }
                }, {
                    key: "multiplyScalar",
                    value: function multiplyScalar(out, a, b) {
                        return out.x = a.x * b, out.y = a.y * b, out.z = a.z * b, out.w = a.w * b, out;
                    }
                }, {
                    key: "scaleAndAdd",
                    value: function scaleAndAdd(out, a, b, scale) {
                        return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out.z = a.z + b.z * scale, 
                        out.w = a.w + b.w * scale, out;
                    }
                }, {
                    key: "rotateX",
                    value: function rotateX(out, a, rad) {
                        rad *= .5;
                        var bx = Math.sin(rad), bw = Math.cos(rad);
                        return out.x = a.x * bw + a.w * bx, out.y = a.y * bw + a.z * bx, out.z = a.z * bw - a.y * bx, 
                        out.w = a.w * bw - a.x * bx, out;
                    }
                }, {
                    key: "rotateY",
                    value: function rotateY(out, a, rad) {
                        rad *= .5;
                        var by = Math.sin(rad), bw = Math.cos(rad);
                        return out.x = a.x * bw - a.z * by, out.y = a.y * bw + a.w * by, out.z = a.z * bw + a.x * by, 
                        out.w = a.w * bw - a.y * by, out;
                    }
                }, {
                    key: "rotateZ",
                    value: function rotateZ(out, a, rad) {
                        rad *= .5;
                        var bz = Math.sin(rad), bw = Math.cos(rad);
                        return out.x = a.x * bw + a.y * bz, out.y = a.y * bw - a.x * bz, out.z = a.z * bw + a.w * bz, 
                        out.w = a.w * bw - a.z * bz, out;
                    }
                }, {
                    key: "rotateAround",
                    value: function rotateAround(out, rot, axis, rad) {
                        return Quat.invert(qt_1, rot), Vec3.transformQuat(v3_1$2, axis, qt_1), Quat.fromAxisAngle(qt_1, v3_1$2, rad), 
                        Quat.multiply(out, rot, qt_1), out;
                    }
                }, {
                    key: "rotateAroundLocal",
                    value: function rotateAroundLocal(out, rot, axis, rad) {
                        return Quat.fromAxisAngle(qt_1, axis, rad), Quat.multiply(out, rot, qt_1), out;
                    }
                }, {
                    key: "calculateW",
                    value: function calculateW(out, a) {
                        return out.x = a.x, out.y = a.y, out.z = a.z, out.w = Math.sqrt(Math.abs(1 - a.x * a.x - a.y * a.y - a.z * a.z)), 
                        out;
                    }
                }, {
                    key: "dot",
                    value: function dot(a, b) {
                        return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
                    }
                }, {
                    key: "lerp",
                    value: function lerp(out, a, b, t) {
                        return out.x = a.x + t * (b.x - a.x), out.y = a.y + t * (b.y - a.y), out.z = a.z + t * (b.z - a.z), 
                        out.w = a.w + t * (b.w - a.w), out;
                    }
                }, {
                    key: "slerp",
                    value: function slerp(out, a, b, t) {
                        var scale0 = 0, scale1 = 0, cosom = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
                        if (cosom < 0 && (cosom = -cosom, b.x = -b.x, b.y = -b.y, b.z = -b.z, b.w = -b.w), 
                        1e-6 < 1 - cosom) {
                            var omega = Math.acos(cosom), sinom = Math.sin(omega);
                            scale0 = Math.sin((1 - t) * omega) / sinom, scale1 = Math.sin(t * omega) / sinom;
                        } else scale0 = 1 - t, scale1 = t;
                        return out.x = scale0 * a.x + scale1 * b.x, out.y = scale0 * a.y + scale1 * b.y, 
                        out.z = scale0 * a.z + scale1 * b.z, out.w = scale0 * a.w + scale1 * b.w, out;
                    }
                }, {
                    key: "sqlerp",
                    value: function sqlerp(out, a, b, c, d, t) {
                        return Quat.slerp(qt_1, a, d, t), Quat.slerp(qt_2, b, c, t), Quat.slerp(out, qt_1, qt_2, 2 * t * (1 - t)), 
                        out;
                    }
                }, {
                    key: "invert",
                    value: function invert(out, a) {
                        var dot = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w, invDot = dot ? 1 / dot : 0;
                        return out.x = -a.x * invDot, out.y = -a.y * invDot, out.z = -a.z * invDot, out.w = a.w * invDot, 
                        out;
                    }
                }, {
                    key: "conjugate",
                    value: function conjugate(out, a) {
                        return out.x = -a.x, out.y = -a.y, out.z = -a.z, out.w = a.w, out;
                    }
                }, {
                    key: "len",
                    value: function len(a) {
                        return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
                    }
                }, {
                    key: "lengthSqr",
                    value: function lengthSqr(a) {
                        return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
                    }
                }, {
                    key: "normalize",
                    value: function normalize(out, a) {
                        var len = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
                        return 0 < len && (len = 1 / Math.sqrt(len), out.x = a.x * len, out.y = a.y * len, 
                        out.z = a.z * len, out.w = a.w * len), out;
                    }
                }, {
                    key: "fromAxes",
                    value: function fromAxes(out, xAxis, yAxis, zAxis) {
                        return Mat3.set(m3_1, xAxis.x, xAxis.y, xAxis.z, yAxis.x, yAxis.y, yAxis.z, zAxis.x, zAxis.y, zAxis.z), 
                        Quat.normalize(out, Quat.fromMat3(out, m3_1));
                    }
                }, {
                    key: "fromViewUp",
                    value: function fromViewUp(out, view, up) {
                        return Mat3.fromViewUp(m3_1, view, up), Quat.normalize(out, Quat.fromMat3(out, m3_1));
                    }
                }, {
                    key: "fromAxisAngle",
                    value: function fromAxisAngle(out, axis, rad) {
                        rad *= .5;
                        var s = Math.sin(rad);
                        return out.x = s * axis.x, out.y = s * axis.y, out.z = s * axis.z, out.w = Math.cos(rad), 
                        out;
                    }
                }, {
                    key: "fromMat3",
                    value: function fromMat3(out, m) {
                        var m00 = m.m00, m01 = m.m03, m02 = m.m06, m10 = m.m01, m11 = m.m04, m12 = m.m07, m20 = m.m02, m21 = m.m05, m22 = m.m08, trace = m00 + m11 + m22;
                        if (0 < trace) {
                            var s = .5 / Math.sqrt(trace + 1);
                            out.w = .25 / s, out.x = (m21 - m12) * s, out.y = (m02 - m20) * s, out.z = (m10 - m01) * s;
                        } else if (m11 < m00 && m22 < m00) {
                            var _s = 2 * Math.sqrt(1 + m00 - m11 - m22);
                            out.w = (m21 - m12) / _s, out.x = .25 * _s, out.y = (m01 + m10) / _s, out.z = (m02 + m20) / _s;
                        } else if (m22 < m11) {
                            var _s2 = 2 * Math.sqrt(1 + m11 - m00 - m22);
                            out.w = (m02 - m20) / _s2, out.x = (m01 + m10) / _s2, out.y = .25 * _s2, out.z = (m12 + m21) / _s2;
                        } else {
                            var _s3 = 2 * Math.sqrt(1 + m22 - m00 - m11);
                            out.w = (m10 - m01) / _s3, out.x = (m02 + m20) / _s3, out.y = (m12 + m21) / _s3, 
                            out.z = .25 * _s3;
                        }
                        return out;
                    }
                }, {
                    key: "fromEuler",
                    value: function fromEuler(out, x, y, z) {
                        x *= halfToRad, y *= halfToRad, z *= halfToRad;
                        var sx = Math.sin(x), cx = Math.cos(x), sy = Math.sin(y), cy = Math.cos(y), sz = Math.sin(z), cz = Math.cos(z);
                        return out.x = sx * cy * cz + cx * sy * sz, out.y = cx * sy * cz + sx * cy * sz, 
                        out.z = cx * cy * sz - sx * sy * cz, out.w = cx * cy * cz - sx * sy * sz, out;
                    }
                }, {
                    key: "toAxisX",
                    value: function toAxisX(out, q) {
                        var fy = 2 * q.y, fz = 2 * q.z;
                        return out.x = 1 - fy * q.y - fz * q.z, out.y = fy * q.x + fz * q.w, out.z = fz * q.x + fy * q.w, 
                        out;
                    }
                }, {
                    key: "toAxisY",
                    value: function toAxisY(out, q) {
                        var fx = 2 * q.x, fy = 2 * q.y, fz = 2 * q.z;
                        return out.x = fy * q.x - fz * q.w, out.y = 1 - fx * q.x - fz * q.z, out.z = fz * q.y + fx * q.w, 
                        out;
                    }
                }, {
                    key: "toAxisZ",
                    value: function toAxisZ(out, q) {
                        var fx = 2 * q.x, fy = 2 * q.y, fz = 2 * q.z;
                        return out.x = fz * q.x - fy * q.w, out.y = fz * q.y - fx * q.w, out.z = 1 - fx * q.x - fy * q.y, 
                        out;
                    }
                }, {
                    key: "toEuler",
                    value: function toEuler(out, q, outerZ) {
                        var x = q.x, y = q.y, z = q.z, w = q.w, bank = 0, heading = 0, attitude = 0, test = x * y + z * w;
                        if (.499999 < test) bank = 0, heading = toDegree(2 * Math.atan2(x, w)), attitude = 90; else if (test < -.499999) bank = 0, 
                        heading = -toDegree(2 * Math.atan2(x, w)), attitude = -90; else {
                            var sqx = x * x, sqy = y * y, sqz = z * z;
                            bank = toDegree(Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz)), heading = toDegree(Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz)), 
                            attitude = toDegree(Math.asin(2 * test)), outerZ && (bank = -180 * Math.sign(bank + 1e-6) + bank, 
                            heading = -180 * Math.sign(heading + 1e-6) + heading, attitude = 180 * Math.sign(attitude + 1e-6) - attitude);
                        }
                        return out.x = bank, out.y = heading, out.z = attitude, out;
                    }
                }, {
                    key: "toArray",
                    value: function toArray(out, q, argument_2) {
                        var ofs = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0;
                        return out[ofs + 0] = q.x, out[ofs + 1] = q.y, out[ofs + 2] = q.z, out[ofs + 3] = q.w, 
                        out;
                    }
                }, {
                    key: "fromArray",
                    value: function fromArray(out, arr, argument_2) {
                        var ofs = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0;
                        return out.x = arr[ofs + 0], out.y = arr[ofs + 1], out.z = arr[ofs + 2], out.w = arr[ofs + 3], 
                        out;
                    }
                }, {
                    key: "strictEquals",
                    value: function strictEquals(a, b) {
                        return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
                    }
                }, {
                    key: "equals",
                    value: function equals(a, b, argument_2) {
                        var epsilon = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : EPSILON;
                        return Math.abs(a.x - b.x) <= epsilon * Math.max(1, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1, Math.abs(a.w), Math.abs(b.w));
                    }
                } ]), _createClass(Quat, [ {
                    key: "clone",
                    value: function clone() {
                        return new Quat(this.x, this.y, this.z, this.w);
                    }
                }, {
                    key: "set",
                    value: function set(x, y, z, w) {
                        return x && "object" === _typeof(x) ? (this.x = x.x, this.y = x.y, this.z = x.z, 
                        this.w = x.w) : (this.x = x || 0, this.y = y || 0, this.z = z || 0, this.w = w || 1), 
                        this;
                    }
                }, {
                    key: "equals",
                    value: function equals(other, argument_1) {
                        var epsilon = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : EPSILON;
                        return Math.abs(this.x - other.x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(other.z)) && Math.abs(this.w - other.w) <= epsilon * Math.max(1, Math.abs(this.w), Math.abs(other.w));
                    }
                }, {
                    key: "strictEquals",
                    value: function strictEquals(other) {
                        return other && this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
                    }
                }, {
                    key: "getEulerAngles",
                    value: function getEulerAngles(out) {
                        return Quat.toEuler(out, this);
                    }
                }, {
                    key: "lerp",
                    value: function lerp(to, ratio) {
                        var scale0 = 0, scale1 = 0, cosom = this.x * to.x + this.y * to.y + this.z * to.z + this.w * to.w;
                        if (cosom < 0 && (cosom = -cosom, to.x = -to.x, to.y = -to.y, to.z = -to.z, to.w = -to.w), 
                        1e-6 < 1 - cosom) {
                            var omega = Math.acos(cosom), sinom = Math.sin(omega);
                            scale0 = Math.sin((1 - ratio) * omega) / sinom, scale1 = Math.sin(ratio * omega) / sinom;
                        } else scale0 = 1 - ratio, scale1 = ratio;
                        return this.x = scale0 * this.x + scale1 * to.x, this.y = scale0 * this.y + scale1 * to.y, 
                        this.z = scale0 * this.z + scale1 * to.z, this.w = scale0 * this.w + scale1 * to.w, 
                        this;
                    }
                }, {
                    key: "length",
                    value: function length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                    }
                }, {
                    key: "lengthSqr",
                    value: function lengthSqr() {
                        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
                    }
                } ]), Quat;
            }());
            Quat.IDENTITY = Object.freeze(new Quat());
            var qt_1 = new Quat(), qt_2 = new Quat(), v3_1$2 = new Vec3(), m3_1 = new Mat3(), halfToRad = .5 * Math.PI / 180;
            function quat() {
                return new Quat(0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1);
            }
            CCClass.fastDefine("cc.Quat", Quat, {
                x: 0,
                y: 0,
                z: 0,
                w: 1
            }), cc.Quat = Quat, cc.quat = quat;
            var _a00$1 = 0, _a01$1 = 0, _a02$1 = 0, _a03 = 0, _a10$1 = 0, _a11$1 = 0, _a12$1 = 0, _a13 = 0, _a20$1 = 0, _a21$1 = 0, _a22$1 = 0, _a23 = 0, _a30 = 0, _a31 = 0, _a32 = 0, _a33 = 0, Mat4 = exports("Mat4", function() {
                function Mat4() {
                    var _this, m00 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1, m01 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, m02 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, m03 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, m04 = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, m05 = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 1, m06 = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : 0, m07 = 7 < arguments.length && void 0 !== arguments[7] ? arguments[7] : 0, m08 = 8 < arguments.length && void 0 !== arguments[8] ? arguments[8] : 0, m09 = 9 < arguments.length && void 0 !== arguments[9] ? arguments[9] : 0, m10 = 10 < arguments.length && void 0 !== arguments[10] ? arguments[10] : 1, m11 = 11 < arguments.length && void 0 !== arguments[11] ? arguments[11] : 0, m12 = 12 < arguments.length && void 0 !== arguments[12] ? arguments[12] : 0, m13 = 13 < arguments.length && void 0 !== arguments[13] ? arguments[13] : 0, m14 = 14 < arguments.length && void 0 !== arguments[14] ? arguments[14] : 0, m15 = 15 < arguments.length && void 0 !== arguments[15] ? arguments[15] : 1;
                    return _classCallCheck(this, Mat4), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Mat4).call(this))).m00 = void 0, 
                    _this.m01 = void 0, _this.m02 = void 0, _this.m03 = void 0, _this.m04 = void 0, 
                    _this.m05 = void 0, _this.m06 = void 0, _this.m07 = void 0, _this.m08 = void 0, 
                    _this.m09 = void 0, _this.m10 = void 0, _this.m11 = void 0, _this.m12 = void 0, 
                    _this.m13 = void 0, _this.m14 = void 0, _this.m15 = void 0, "object" === _typeof(m00) ? (_this.m01 = m00.m01, 
                    _this.m02 = m00.m02, _this.m03 = m00.m03, _this.m04 = m00.m04, _this.m05 = m00.m05, 
                    _this.m06 = m00.m06, _this.m07 = m00.m07, _this.m08 = m00.m08, _this.m09 = m00.m09, 
                    _this.m10 = m00.m10, _this.m11 = m00.m11, _this.m12 = m00.m12, _this.m13 = m00.m13, 
                    _this.m14 = m00.m14, _this.m15 = m00.m15, _this.m00 = m00.m00) : (_this.m01 = m01, 
                    _this.m02 = m02, _this.m03 = m03, _this.m04 = m04, _this.m05 = m05, _this.m06 = m06, 
                    _this.m07 = m07, _this.m08 = m08, _this.m09 = m09, _this.m10 = m10, _this.m11 = m11, 
                    _this.m12 = m12, _this.m13 = m13, _this.m14 = m14, _this.m15 = m15, _this.m00 = m00), 
                    _this;
                }
                return _inherits(Mat4, ValueType), _createClass(Mat4, null, [ {
                    key: "clone",
                    value: function clone(a) {
                        return new Mat4(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08, a.m09, a.m10, a.m11, a.m12, a.m13, a.m14, a.m15);
                    }
                }, {
                    key: "copy",
                    value: function copy(out, a) {
                        return out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, out.m04 = a.m04, 
                        out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, out.m09 = a.m09, 
                        out.m10 = a.m10, out.m11 = a.m11, out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, 
                        out.m15 = a.m15, out;
                    }
                }, {
                    key: "set",
                    value: function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
                        return out.m00 = m00, out.m01 = m01, out.m02 = m02, out.m03 = m03, out.m04 = m10, 
                        out.m05 = m11, out.m06 = m12, out.m07 = m13, out.m08 = m20, out.m09 = m21, out.m10 = m22, 
                        out.m11 = m23, out.m12 = m30, out.m13 = m31, out.m14 = m32, out.m15 = m33, out;
                    }
                }, {
                    key: "identity",
                    value: function identity(out) {
                        return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = 1, 
                        out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 1, out.m11 = 0, out.m12 = 0, 
                        out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
                    }
                }, {
                    key: "transpose",
                    value: function transpose(out, a) {
                        if (out === a) {
                            var a01 = a.m01, a02 = a.m02, a03 = a.m03, a12 = a.m06, a13 = a.m07, a23 = a.m11;
                            out.m01 = a.m04, out.m02 = a.m08, out.m03 = a.m12, out.m04 = a01, out.m06 = a.m09, 
                            out.m07 = a.m13, out.m08 = a02, out.m09 = a12, out.m11 = a.m14, out.m12 = a03, out.m13 = a13, 
                            out.m14 = a23;
                        } else out.m00 = a.m00, out.m01 = a.m04, out.m02 = a.m08, out.m03 = a.m12, out.m04 = a.m01, 
                        out.m05 = a.m05, out.m06 = a.m09, out.m07 = a.m13, out.m08 = a.m02, out.m09 = a.m06, 
                        out.m10 = a.m10, out.m11 = a.m14, out.m12 = a.m03, out.m13 = a.m07, out.m14 = a.m11, 
                        out.m15 = a.m15;
                        return out;
                    }
                }, {
                    key: "invert",
                    value: function invert(out, a) {
                        _a00$1 = a.m00, _a01$1 = a.m01, _a02$1 = a.m02, _a03 = a.m03, _a10$1 = a.m04, _a11$1 = a.m05, 
                        _a12$1 = a.m06, _a13 = a.m07, _a20$1 = a.m08, _a21$1 = a.m09, _a22$1 = a.m10, _a23 = a.m11, 
                        _a30 = a.m12, _a31 = a.m13, _a32 = a.m14, _a33 = a.m15;
                        var b00 = _a00$1 * _a11$1 - _a01$1 * _a10$1, b01 = _a00$1 * _a12$1 - _a02$1 * _a10$1, b02 = _a00$1 * _a13 - _a03 * _a10$1, b03 = _a01$1 * _a12$1 - _a02$1 * _a11$1, b04 = _a01$1 * _a13 - _a03 * _a11$1, b05 = _a02$1 * _a13 - _a03 * _a12$1, b06 = _a20$1 * _a31 - _a21$1 * _a30, b07 = _a20$1 * _a32 - _a22$1 * _a30, b08 = _a20$1 * _a33 - _a23 * _a30, b09 = _a21$1 * _a32 - _a22$1 * _a31, b10 = _a21$1 * _a33 - _a23 * _a31, b11 = _a22$1 * _a33 - _a23 * _a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                        return 0 === det || (det = 1 / det, out.m00 = (_a11$1 * b11 - _a12$1 * b10 + _a13 * b09) * det, 
                        out.m01 = (_a02$1 * b10 - _a01$1 * b11 - _a03 * b09) * det, out.m02 = (_a31 * b05 - _a32 * b04 + _a33 * b03) * det, 
                        out.m03 = (_a22$1 * b04 - _a21$1 * b05 - _a23 * b03) * det, out.m04 = (_a12$1 * b08 - _a10$1 * b11 - _a13 * b07) * det, 
                        out.m05 = (_a00$1 * b11 - _a02$1 * b08 + _a03 * b07) * det, out.m06 = (_a32 * b02 - _a30 * b05 - _a33 * b01) * det, 
                        out.m07 = (_a20$1 * b05 - _a22$1 * b02 + _a23 * b01) * det, out.m08 = (_a10$1 * b10 - _a11$1 * b08 + _a13 * b06) * det, 
                        out.m09 = (_a01$1 * b08 - _a00$1 * b10 - _a03 * b06) * det, out.m10 = (_a30 * b04 - _a31 * b02 + _a33 * b00) * det, 
                        out.m11 = (_a21$1 * b02 - _a20$1 * b04 - _a23 * b00) * det, out.m12 = (_a11$1 * b07 - _a10$1 * b09 - _a12$1 * b06) * det, 
                        out.m13 = (_a00$1 * b09 - _a01$1 * b07 + _a02$1 * b06) * det, out.m14 = (_a31 * b01 - _a30 * b03 - _a32 * b00) * det, 
                        out.m15 = (_a20$1 * b03 - _a21$1 * b01 + _a22$1 * b00) * det), out;
                    }
                }, {
                    key: "determinant",
                    value: function determinant(a) {
                        return _a00$1 = a.m00, _a01$1 = a.m01, _a02$1 = a.m02, _a03 = a.m03, _a10$1 = a.m04, 
                        _a11$1 = a.m05, _a12$1 = a.m06, _a13 = a.m07, _a20$1 = a.m08, _a21$1 = a.m09, _a22$1 = a.m10, 
                        _a23 = a.m11, _a30 = a.m12, _a31 = a.m13, _a32 = a.m14, _a33 = a.m15, (_a00$1 * _a11$1 - _a01$1 * _a10$1) * (_a22$1 * _a33 - _a23 * _a32) - (_a00$1 * _a12$1 - _a02$1 * _a10$1) * (_a21$1 * _a33 - _a23 * _a31) + (_a00$1 * _a13 - _a03 * _a10$1) * (_a21$1 * _a32 - _a22$1 * _a31) + (_a01$1 * _a12$1 - _a02$1 * _a11$1) * (_a20$1 * _a33 - _a23 * _a30) - (_a01$1 * _a13 - _a03 * _a11$1) * (_a20$1 * _a32 - _a22$1 * _a30) + (_a02$1 * _a13 - _a03 * _a12$1) * (_a20$1 * _a31 - _a21$1 * _a30);
                    }
                }, {
                    key: "multiply",
                    value: function multiply(out, a, b) {
                        _a00$1 = a.m00, _a01$1 = a.m01, _a02$1 = a.m02, _a03 = a.m03, _a10$1 = a.m04, _a11$1 = a.m05, 
                        _a12$1 = a.m06, _a13 = a.m07, _a20$1 = a.m08, _a21$1 = a.m09, _a22$1 = a.m10, _a23 = a.m11, 
                        _a30 = a.m12, _a31 = a.m13, _a32 = a.m14, _a33 = a.m15;
                        var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03;
                        return out.m00 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, out.m01 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, 
                        out.m02 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, out.m03 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, 
                        b0 = b.m04, b1 = b.m05, b2 = b.m06, b3 = b.m07, out.m04 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, 
                        out.m05 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, out.m06 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, 
                        out.m07 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, b0 = b.m08, b1 = b.m09, 
                        b2 = b.m10, b3 = b.m11, out.m08 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, 
                        out.m09 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, out.m10 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, 
                        out.m11 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, b0 = b.m12, b1 = b.m13, 
                        b2 = b.m14, b3 = b.m15, out.m12 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, 
                        out.m13 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, out.m14 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, 
                        out.m15 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, out;
                    }
                }, {
                    key: "transform",
                    value: function transform(out, a, v) {
                        var x = v.x, y = v.y, z = v.z;
                        return a === out ? (out.m12 = a.m00 * x + a.m04 * y + a.m08 * z + a.m12, out.m13 = a.m01 * x + a.m05 * y + a.m09 * z + a.m13, 
                        out.m14 = a.m02 * x + a.m06 * y + a.m10 * z + a.m14, out.m15 = a.m03 * x + a.m07 * y + a.m11 * z + a.m15) : (_a00$1 = a.m00, 
                        _a01$1 = a.m01, _a02$1 = a.m02, _a03 = a.m03, _a10$1 = a.m04, _a11$1 = a.m05, _a12$1 = a.m06, 
                        _a13 = a.m07, _a20$1 = a.m08, _a21$1 = a.m09, _a22$1 = a.m10, _a23 = a.m11, _a30 = a.m12, 
                        _a31 = a.m13, _a32 = a.m14, _a33 = a.m15, out.m00 = _a00$1, out.m01 = _a01$1, out.m02 = _a02$1, 
                        out.m03 = _a03, out.m04 = _a10$1, out.m05 = _a11$1, out.m06 = _a12$1, out.m07 = _a13, 
                        out.m08 = _a20$1, out.m09 = _a21$1, out.m10 = _a22$1, out.m11 = _a23, out.m12 = _a00$1 * x + _a10$1 * y + _a20$1 * z + a.m12, 
                        out.m13 = _a01$1 * x + _a11$1 * y + _a21$1 * z + a.m13, out.m14 = _a02$1 * x + _a12$1 * y + _a22$1 * z + a.m14, 
                        out.m15 = _a03 * x + _a13 * y + _a23 * z + a.m15), out;
                    }
                }, {
                    key: "translate",
                    value: function translate(out, a, v) {
                        return console.warn("function changed"), a === out ? (out.m12 += v.x, out.m13 += v.y, 
                        out.m14 += v.y) : (out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, 
                        out.m04 = a.m04, out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, 
                        out.m09 = a.m09, out.m10 = a.m10, out.m11 = a.m11, out.m12 += v.x, out.m13 += v.y, 
                        out.m14 += v.z, out.m15 = a.m15), out;
                    }
                }, {
                    key: "scale",
                    value: function scale(out, a, v) {
                        var x = v.x, y = v.y, z = v.z;
                        return out.m00 = a.m00 * x, out.m01 = a.m01 * x, out.m02 = a.m02 * x, out.m03 = a.m03 * x, 
                        out.m04 = a.m04 * y, out.m05 = a.m05 * y, out.m06 = a.m06 * y, out.m07 = a.m07 * y, 
                        out.m08 = a.m08 * z, out.m09 = a.m09 * z, out.m10 = a.m10 * z, out.m11 = a.m11 * z, 
                        out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15, out;
                    }
                }, {
                    key: "rotate",
                    value: function rotate(out, a, rad, axis) {
                        var x = axis.x, y = axis.y, z = axis.z, len = Math.sqrt(x * x + y * y + z * z);
                        if (Math.abs(len) < EPSILON) return null;
                        x *= len = 1 / len, y *= len, z *= len;
                        var s = Math.sin(rad), c = Math.cos(rad), t = 1 - c;
                        _a00$1 = a.m00, _a01$1 = a.m01, _a02$1 = a.m02, _a03 = a.m03, _a10$1 = a.m04, _a11$1 = a.m05, 
                        _a12$1 = a.m06, _a13 = a.m07, _a20$1 = a.m08, _a21$1 = a.m09, _a22$1 = a.m10, _a23 = a.m11;
                        var b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s, b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s, b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;
                        return out.m00 = _a00$1 * b00 + _a10$1 * b01 + _a20$1 * b02, out.m01 = _a01$1 * b00 + _a11$1 * b01 + _a21$1 * b02, 
                        out.m02 = _a02$1 * b00 + _a12$1 * b01 + _a22$1 * b02, out.m03 = _a03 * b00 + _a13 * b01 + _a23 * b02, 
                        out.m04 = _a00$1 * b10 + _a10$1 * b11 + _a20$1 * b12, out.m05 = _a01$1 * b10 + _a11$1 * b11 + _a21$1 * b12, 
                        out.m06 = _a02$1 * b10 + _a12$1 * b11 + _a22$1 * b12, out.m07 = _a03 * b10 + _a13 * b11 + _a23 * b12, 
                        out.m08 = _a00$1 * b20 + _a10$1 * b21 + _a20$1 * b22, out.m09 = _a01$1 * b20 + _a11$1 * b21 + _a21$1 * b22, 
                        out.m10 = _a02$1 * b20 + _a12$1 * b21 + _a22$1 * b22, out.m11 = _a03 * b20 + _a13 * b21 + _a23 * b22, 
                        a !== out && (out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), 
                        out;
                    }
                }, {
                    key: "rotateX",
                    value: function rotateX(out, a, rad) {
                        var s = Math.sin(rad), c = Math.cos(rad), a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11;
                        return a !== out && (out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, 
                        out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), out.m04 = a10 * c + a20 * s, 
                        out.m05 = a11 * c + a21 * s, out.m06 = a12 * c + a22 * s, out.m07 = a13 * c + a23 * s, 
                        out.m08 = a20 * c - a10 * s, out.m09 = a21 * c - a11 * s, out.m10 = a22 * c - a12 * s, 
                        out.m11 = a23 * c - a13 * s, out;
                    }
                }, {
                    key: "rotateY",
                    value: function rotateY(out, a, rad) {
                        var s = Math.sin(rad), c = Math.cos(rad), a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11;
                        return a !== out && (out.m04 = a.m04, out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, 
                        out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), out.m00 = a00 * c - a20 * s, 
                        out.m01 = a01 * c - a21 * s, out.m02 = a02 * c - a22 * s, out.m03 = a03 * c - a23 * s, 
                        out.m08 = a00 * s + a20 * c, out.m09 = a01 * s + a21 * c, out.m10 = a02 * s + a22 * c, 
                        out.m11 = a03 * s + a23 * c, out;
                    }
                }, {
                    key: "rotateZ",
                    value: function rotateZ(out, a, rad) {
                        var s = Math.sin(rad), c = Math.cos(rad), a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07;
                        return a !== out && (out.m08 = a.m08, out.m09 = a.m09, out.m10 = a.m10, out.m11 = a.m11, 
                        out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), out.m00 = a00 * c + a10 * s, 
                        out.m01 = a01 * c + a11 * s, out.m02 = a02 * c + a12 * s, out.m03 = a03 * c + a13 * s, 
                        out.m04 = a10 * c - a00 * s, out.m05 = a11 * c - a01 * s, out.m06 = a12 * c - a02 * s, 
                        out.m07 = a13 * c - a03 * s, out;
                    }
                }, {
                    key: "fromTranslation",
                    value: function fromTranslation(out, v) {
                        return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = 1, 
                        out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 1, out.m11 = 0, out.m12 = v.x, 
                        out.m13 = v.y, out.m14 = v.z, out.m15 = 1, out;
                    }
                }, {
                    key: "fromScaling",
                    value: function fromScaling(out, v) {
                        return out.m00 = v.x, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = v.y, 
                        out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = v.z, out.m11 = 0, 
                        out.m12 = 0, out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
                    }
                }, {
                    key: "fromRotation",
                    value: function fromRotation(out, rad, axis) {
                        var x = axis.x, y = axis.y, z = axis.z, len = Math.sqrt(x * x + y * y + z * z);
                        if (Math.abs(len) < EPSILON) return null;
                        x *= len = 1 / len, y *= len, z *= len;
                        var s = Math.sin(rad), c = Math.cos(rad), t = 1 - c;
                        return out.m00 = x * x * t + c, out.m01 = y * x * t + z * s, out.m02 = z * x * t - y * s, 
                        out.m03 = 0, out.m04 = x * y * t - z * s, out.m05 = y * y * t + c, out.m06 = z * y * t + x * s, 
                        out.m07 = 0, out.m08 = x * z * t + y * s, out.m09 = y * z * t - x * s, out.m10 = z * z * t + c, 
                        out.m11 = 0, out.m12 = 0, out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
                    }
                }, {
                    key: "fromXRotation",
                    value: function fromXRotation(out, rad) {
                        var s = Math.sin(rad), c = Math.cos(rad);
                        return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = c, 
                        out.m06 = s, out.m07 = 0, out.m08 = 0, out.m09 = -s, out.m10 = c, out.m11 = 0, out.m12 = 0, 
                        out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
                    }
                }, {
                    key: "fromYRotation",
                    value: function fromYRotation(out, rad) {
                        var s = Math.sin(rad), c = Math.cos(rad);
                        return out.m00 = c, out.m01 = 0, out.m02 = -s, out.m03 = 0, out.m04 = 0, out.m05 = 1, 
                        out.m06 = 0, out.m07 = 0, out.m08 = s, out.m09 = 0, out.m10 = c, out.m11 = 0, out.m12 = 0, 
                        out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
                    }
                }, {
                    key: "fromZRotation",
                    value: function fromZRotation(out, rad) {
                        var s = Math.sin(rad), c = Math.cos(rad);
                        return out.m00 = c, out.m01 = s, out.m02 = 0, out.m03 = 0, out.m04 = -s, out.m05 = c, 
                        out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 1, out.m11 = 0, out.m12 = 0, 
                        out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
                    }
                }, {
                    key: "fromRT",
                    value: function fromRT(out, q, v) {
                        var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
                        return out.m00 = 1 - (yy + zz), out.m01 = xy + wz, out.m02 = xz - wy, out.m03 = 0, 
                        out.m04 = xy - wz, out.m05 = 1 - (xx + zz), out.m06 = yz + wx, out.m07 = 0, out.m08 = xz + wy, 
                        out.m09 = yz - wx, out.m10 = 1 - (xx + yy), out.m11 = 0, out.m12 = v.x, out.m13 = v.y, 
                        out.m14 = v.z, out.m15 = 1, out;
                    }
                }, {
                    key: "getTranslation",
                    value: function getTranslation(out, mat) {
                        return out.x = mat.m12, out.y = mat.m13, out.z = mat.m14, out;
                    }
                }, {
                    key: "getScaling",
                    value: function getScaling(out, mat) {
                        var m00 = m3_1$1.m00 = mat.m00, m01 = m3_1$1.m01 = mat.m01, m02 = m3_1$1.m02 = mat.m02, m04 = m3_1$1.m03 = mat.m04, m05 = m3_1$1.m04 = mat.m05, m06 = m3_1$1.m05 = mat.m06, m08 = m3_1$1.m06 = mat.m08, m09 = m3_1$1.m07 = mat.m09, m10 = m3_1$1.m08 = mat.m10;
                        return out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02), out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06), 
                        out.z = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10), Mat3.determinant(m3_1$1) < 0 && (out.x *= -1), 
                        out;
                    }
                }, {
                    key: "getRotation",
                    value: function getRotation(out, mat) {
                        var trace = mat.m00 + mat.m05 + mat.m10, S = 0;
                        return 0 < trace ? (S = 2 * Math.sqrt(trace + 1), out.w = .25 * S, out.x = (mat.m06 - mat.m09) / S, 
                        out.y = (mat.m08 - mat.m02) / S, out.z = (mat.m01 - mat.m04) / S) : mat.m00 > mat.m05 && mat.m00 > mat.m10 ? (S = 2 * Math.sqrt(1 + mat.m00 - mat.m05 - mat.m10), 
                        out.w = (mat.m06 - mat.m09) / S, out.x = .25 * S, out.y = (mat.m01 + mat.m04) / S, 
                        out.z = (mat.m08 + mat.m02) / S) : mat.m05 > mat.m10 ? (S = 2 * Math.sqrt(1 + mat.m05 - mat.m00 - mat.m10), 
                        out.w = (mat.m08 - mat.m02) / S, out.x = (mat.m01 + mat.m04) / S, out.y = .25 * S, 
                        out.z = (mat.m06 + mat.m09) / S) : (S = 2 * Math.sqrt(1 + mat.m10 - mat.m00 - mat.m05), 
                        out.w = (mat.m01 - mat.m04) / S, out.x = (mat.m08 + mat.m02) / S, out.y = (mat.m06 + mat.m09) / S, 
                        out.z = .25 * S), out;
                    }
                }, {
                    key: "toRTS",
                    value: function toRTS(m, q, v, s) {
                        s.x = Vec3.set(v3_1$3, m.m00, m.m01, m.m02).length(), m3_1$1.m00 = m.m00 / s.x, 
                        m3_1$1.m01 = m.m01 / s.x, m3_1$1.m02 = m.m02 / s.x, s.y = Vec3.set(v3_1$3, m.m04, m.m05, m.m06).length(), 
                        m3_1$1.m03 = m.m04 / s.y, m3_1$1.m04 = m.m05 / s.y, m3_1$1.m05 = m.m06 / s.y, s.z = Vec3.set(v3_1$3, m.m08, m.m09, m.m10).length(), 
                        m3_1$1.m06 = m.m08 / s.z, m3_1$1.m07 = m.m09 / s.z, m3_1$1.m08 = m.m10 / s.z, Mat3.determinant(m3_1$1) < 0 && (s.x *= -1, 
                        m3_1$1.m00 *= -1, m3_1$1.m01 *= -1, m3_1$1.m02 *= -1), Quat.fromMat3(q, m3_1$1), 
                        Vec3.set(v, m.m12, m.m13, m.m14);
                    }
                }, {
                    key: "fromRTS",
                    value: function fromRTS(out, q, v, s) {
                        var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, sx = s.x, sy = s.y, sz = s.z;
                        return out.m00 = (1 - (yy + zz)) * sx, out.m01 = (xy + wz) * sx, out.m02 = (xz - wy) * sx, 
                        out.m03 = 0, out.m04 = (xy - wz) * sy, out.m05 = (1 - (xx + zz)) * sy, out.m06 = (yz + wx) * sy, 
                        out.m07 = 0, out.m08 = (xz + wy) * sz, out.m09 = (yz - wx) * sz, out.m10 = (1 - (xx + yy)) * sz, 
                        out.m11 = 0, out.m12 = v.x, out.m13 = v.y, out.m14 = v.z, out.m15 = 1, out;
                    }
                }, {
                    key: "fromRTSOrigin",
                    value: function fromRTSOrigin(out, q, v, s, o) {
                        var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, sx = s.x, sy = s.y, sz = s.z, ox = o.x, oy = o.y, oz = o.z;
                        return out.m00 = (1 - (yy + zz)) * sx, out.m01 = (xy + wz) * sx, out.m02 = (xz - wy) * sx, 
                        out.m03 = 0, out.m04 = (xy - wz) * sy, out.m05 = (1 - (xx + zz)) * sy, out.m06 = (yz + wx) * sy, 
                        out.m07 = 0, out.m08 = (xz + wy) * sz, out.m09 = (yz - wx) * sz, out.m10 = (1 - (xx + yy)) * sz, 
                        out.m11 = 0, out.m12 = v.x + ox - (out.m00 * ox + out.m04 * oy + out.m08 * oz), 
                        out.m13 = v.y + oy - (out.m01 * ox + out.m05 * oy + out.m09 * oz), out.m14 = v.z + oz - (out.m02 * ox + out.m06 * oy + out.m10 * oz), 
                        out.m15 = 1, out;
                    }
                }, {
                    key: "fromQuat",
                    value: function fromQuat(out, q) {
                        var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
                        return out.m00 = 1 - yy - zz, out.m01 = yx + wz, out.m02 = zx - wy, out.m03 = 0, 
                        out.m04 = yx - wz, out.m05 = 1 - xx - zz, out.m06 = zy + wx, out.m07 = 0, out.m08 = zx + wy, 
                        out.m09 = zy - wx, out.m10 = 1 - xx - yy, out.m11 = 0, out.m12 = 0, out.m13 = 0, 
                        out.m14 = 0, out.m15 = 1, out;
                    }
                }, {
                    key: "frustum",
                    value: function frustum(out, left, right, bottom, top, near, far) {
                        var rl = 1 / (right - left), tb = 1 / (top - bottom), nf = 1 / (near - far);
                        return out.m00 = 2 * near * rl, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, 
                        out.m05 = 2 * near * tb, out.m06 = 0, out.m07 = 0, out.m08 = (right + left) * rl, 
                        out.m09 = (top + bottom) * tb, out.m10 = (far + near) * nf, out.m11 = -1, out.m12 = 0, 
                        out.m13 = 0, out.m14 = far * near * 2 * nf, out.m15 = 0, out;
                    }
                }, {
                    key: "perspective",
                    value: function perspective(out, fovy, aspect, near, far) {
                        var f = 1 / Math.tan(fovy / 2), nf = 1 / (near - far);
                        return out.m00 = f / aspect, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, 
                        out.m05 = f, out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = (far + near) * nf, 
                        out.m11 = -1, out.m12 = 0, out.m13 = 0, out.m14 = 2 * far * near * nf, out.m15 = 0, 
                        out;
                    }
                }, {
                    key: "ortho",
                    value: function ortho(out, left, right, bottom, top, near, far) {
                        var lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
                        return out.m00 = -2 * lr, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = -2 * bt, 
                        out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 2 * nf, out.m11 = 0, 
                        out.m12 = (left + right) * lr, out.m13 = (top + bottom) * bt, out.m14 = (far + near) * nf, 
                        out.m15 = 1, out;
                    }
                }, {
                    key: "lookAt",
                    value: function lookAt(out, eye, center, up) {
                        var eyex = eye.x, eyey = eye.y, eyez = eye.z, upx = up.x, upy = up.y, upz = up.z, z0 = eyex - center.x, z1 = eyey - center.y, z2 = eyez - center.z, len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2), x0 = upy * (z2 *= len) - upz * (z1 *= len), x1 = upz * (z0 *= len) - upx * z2, x2 = upx * z1 - upy * z0, y0 = z1 * (x2 *= len = 1 / Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2)) - z2 * (x1 *= len), y1 = z2 * (x0 *= len) - z0 * x2, y2 = z0 * x1 - z1 * x0;
                        return out.m00 = x0, out.m01 = y0, out.m02 = z0, out.m03 = 0, out.m04 = x1, out.m05 = y1, 
                        out.m06 = z1, out.m07 = 0, out.m08 = x2, out.m09 = y2, out.m10 = z2, out.m11 = 0, 
                        out.m12 = -(x0 * eyex + x1 * eyey + x2 * eyez), out.m13 = -(y0 * eyex + y1 * eyey + y2 * eyez), 
                        out.m14 = -(z0 * eyex + z1 * eyey + z2 * eyez), out.m15 = 1, out;
                    }
                }, {
                    key: "inverseTranspose",
                    value: function inverseTranspose(out, a) {
                        _a00$1 = a.m00, _a01$1 = a.m01, _a02$1 = a.m02, _a03 = a.m03, _a10$1 = a.m04, _a11$1 = a.m05, 
                        _a12$1 = a.m06, _a13 = a.m07, _a20$1 = a.m08, _a21$1 = a.m09, _a22$1 = a.m10, _a23 = a.m11, 
                        _a30 = a.m12, _a31 = a.m13, _a32 = a.m14, _a33 = a.m15;
                        var b00 = _a00$1 * _a11$1 - _a01$1 * _a10$1, b01 = _a00$1 * _a12$1 - _a02$1 * _a10$1, b02 = _a00$1 * _a13 - _a03 * _a10$1, b03 = _a01$1 * _a12$1 - _a02$1 * _a11$1, b04 = _a01$1 * _a13 - _a03 * _a11$1, b05 = _a02$1 * _a13 - _a03 * _a12$1, b06 = _a20$1 * _a31 - _a21$1 * _a30, b07 = _a20$1 * _a32 - _a22$1 * _a30, b08 = _a20$1 * _a33 - _a23 * _a30, b09 = _a21$1 * _a32 - _a22$1 * _a31, b10 = _a21$1 * _a33 - _a23 * _a31, b11 = _a22$1 * _a33 - _a23 * _a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                        return det ? (det = 1 / det, out.m00 = (_a11$1 * b11 - _a12$1 * b10 + _a13 * b09) * det, 
                        out.m01 = (_a12$1 * b08 - _a10$1 * b11 - _a13 * b07) * det, out.m02 = (_a10$1 * b10 - _a11$1 * b08 + _a13 * b06) * det, 
                        out.m03 = 0, out.m04 = (_a02$1 * b10 - _a01$1 * b11 - _a03 * b09) * det, out.m05 = (_a00$1 * b11 - _a02$1 * b08 + _a03 * b07) * det, 
                        out.m06 = (_a01$1 * b08 - _a00$1 * b10 - _a03 * b06) * det, out.m07 = 0, out.m08 = (_a31 * b05 - _a32 * b04 + _a33 * b03) * det, 
                        out.m09 = (_a32 * b02 - _a30 * b05 - _a33 * b01) * det, out.m10 = (_a30 * b04 - _a31 * b02 + _a33 * b00) * det, 
                        out.m11 = 0, out.m12 = 0, out.m13 = 0, out.m14 = 0, out.m15 = 1, out) : null;
                    }
                }, {
                    key: "toArray",
                    value: function toArray(out, m, argument_2) {
                        var ofs = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0;
                        return out[ofs + 0] = m.m00, out[ofs + 1] = m.m01, out[ofs + 2] = m.m02, out[ofs + 3] = m.m03, 
                        out[ofs + 4] = m.m04, out[ofs + 5] = m.m05, out[ofs + 6] = m.m06, out[ofs + 7] = m.m07, 
                        out[ofs + 8] = m.m08, out[ofs + 9] = m.m09, out[ofs + 10] = m.m10, out[ofs + 11] = m.m11, 
                        out[ofs + 12] = m.m12, out[ofs + 13] = m.m13, out[ofs + 14] = m.m14, out[ofs + 15] = m.m15, 
                        out;
                    }
                }, {
                    key: "fromArray",
                    value: function fromArray(out, arr, argument_2) {
                        var ofs = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0;
                        return out.m00 = arr[ofs + 0], out.m01 = arr[ofs + 1], out.m02 = arr[ofs + 2], out.m03 = arr[ofs + 3], 
                        out.m04 = arr[ofs + 4], out.m05 = arr[ofs + 5], out.m06 = arr[ofs + 6], out.m07 = arr[ofs + 7], 
                        out.m08 = arr[ofs + 8], out.m09 = arr[ofs + 9], out.m10 = arr[ofs + 10], out.m11 = arr[ofs + 11], 
                        out.m12 = arr[ofs + 12], out.m13 = arr[ofs + 13], out.m14 = arr[ofs + 14], out.m15 = arr[ofs + 15], 
                        out;
                    }
                }, {
                    key: "add",
                    value: function add(out, a, b) {
                        return out.m00 = a.m00 + b.m00, out.m01 = a.m01 + b.m01, out.m02 = a.m02 + b.m02, 
                        out.m03 = a.m03 + b.m03, out.m04 = a.m04 + b.m04, out.m05 = a.m05 + b.m05, out.m06 = a.m06 + b.m06, 
                        out.m07 = a.m07 + b.m07, out.m08 = a.m08 + b.m08, out.m09 = a.m09 + b.m09, out.m10 = a.m10 + b.m10, 
                        out.m11 = a.m11 + b.m11, out.m12 = a.m12 + b.m12, out.m13 = a.m13 + b.m13, out.m14 = a.m14 + b.m14, 
                        out.m15 = a.m15 + b.m15, out;
                    }
                }, {
                    key: "subtract",
                    value: function subtract(out, a, b) {
                        return out.m00 = a.m00 - b.m00, out.m01 = a.m01 - b.m01, out.m02 = a.m02 - b.m02, 
                        out.m03 = a.m03 - b.m03, out.m04 = a.m04 - b.m04, out.m05 = a.m05 - b.m05, out.m06 = a.m06 - b.m06, 
                        out.m07 = a.m07 - b.m07, out.m08 = a.m08 - b.m08, out.m09 = a.m09 - b.m09, out.m10 = a.m10 - b.m10, 
                        out.m11 = a.m11 - b.m11, out.m12 = a.m12 - b.m12, out.m13 = a.m13 - b.m13, out.m14 = a.m14 - b.m14, 
                        out.m15 = a.m15 - b.m15, out;
                    }
                }, {
                    key: "multiplyScalar",
                    value: function multiplyScalar(out, a, b) {
                        return out.m00 = a.m00 * b, out.m01 = a.m01 * b, out.m02 = a.m02 * b, out.m03 = a.m03 * b, 
                        out.m04 = a.m04 * b, out.m05 = a.m05 * b, out.m06 = a.m06 * b, out.m07 = a.m07 * b, 
                        out.m08 = a.m08 * b, out.m09 = a.m09 * b, out.m10 = a.m10 * b, out.m11 = a.m11 * b, 
                        out.m12 = a.m12 * b, out.m13 = a.m13 * b, out.m14 = a.m14 * b, out.m15 = a.m15 * b, 
                        out;
                    }
                }, {
                    key: "multiplyScalarAndAdd",
                    value: function multiplyScalarAndAdd(out, a, b, scale) {
                        return out.m00 = a.m00 + b.m00 * scale, out.m01 = a.m01 + b.m01 * scale, out.m02 = a.m02 + b.m02 * scale, 
                        out.m03 = a.m03 + b.m03 * scale, out.m04 = a.m04 + b.m04 * scale, out.m05 = a.m05 + b.m05 * scale, 
                        out.m06 = a.m06 + b.m06 * scale, out.m07 = a.m07 + b.m07 * scale, out.m08 = a.m08 + b.m08 * scale, 
                        out.m09 = a.m09 + b.m09 * scale, out.m10 = a.m10 + b.m10 * scale, out.m11 = a.m11 + b.m11 * scale, 
                        out.m12 = a.m12 + b.m12 * scale, out.m13 = a.m13 + b.m13 * scale, out.m14 = a.m14 + b.m14 * scale, 
                        out.m15 = a.m15 + b.m15 * scale, out;
                    }
                }, {
                    key: "strictEquals",
                    value: function strictEquals(a, b) {
                        return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08 && a.m09 === b.m09 && a.m10 === b.m10 && a.m11 === b.m11 && a.m12 === b.m12 && a.m13 === b.m13 && a.m14 === b.m14 && a.m15 === b.m15;
                    }
                }, {
                    key: "equals",
                    value: function equals(a, b, argument_2) {
                        var epsilon = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : EPSILON;
                        return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1, Math.abs(a.m08), Math.abs(b.m08)) && Math.abs(a.m09 - b.m09) <= epsilon * Math.max(1, Math.abs(a.m09), Math.abs(b.m09)) && Math.abs(a.m10 - b.m10) <= epsilon * Math.max(1, Math.abs(a.m10), Math.abs(b.m10)) && Math.abs(a.m11 - b.m11) <= epsilon * Math.max(1, Math.abs(a.m11), Math.abs(b.m11)) && Math.abs(a.m12 - b.m12) <= epsilon * Math.max(1, Math.abs(a.m12), Math.abs(b.m12)) && Math.abs(a.m13 - b.m13) <= epsilon * Math.max(1, Math.abs(a.m13), Math.abs(b.m13)) && Math.abs(a.m14 - b.m14) <= epsilon * Math.max(1, Math.abs(a.m14), Math.abs(b.m14)) && Math.abs(a.m15 - b.m15) <= epsilon * Math.max(1, Math.abs(a.m15), Math.abs(b.m15));
                    }
                } ]), _createClass(Mat4, [ {
                    key: "clone",
                    value: function clone() {
                        var t = this;
                        return new Mat4(t.m00, t.m01, t.m02, t.m03, t.m04, t.m05, t.m06, t.m07, t.m08, t.m09, t.m10, t.m11, t.m12, t.m13, t.m14, t.m15);
                    }
                }, {
                    key: "set",
                    value: function set(argument_0, argument_1, argument_2, argument_3, argument_4, argument_5, argument_6, argument_7, argument_8, argument_9, argument_10, argument_11, argument_12, argument_13, argument_14, argument_15) {
                        var m00 = 0 < arguments.length && void 0 !== argument_0 ? argument_0 : 1, m01 = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : 0, m02 = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0, m03 = 3 < arguments.length && void 0 !== argument_3 ? argument_3 : 0, m04 = 4 < arguments.length && void 0 !== argument_4 ? argument_4 : 0, m05 = 5 < arguments.length && void 0 !== argument_5 ? argument_5 : 1, m06 = 6 < arguments.length && void 0 !== argument_6 ? argument_6 : 0, m07 = 7 < arguments.length && void 0 !== argument_7 ? argument_7 : 0, m08 = 8 < arguments.length && void 0 !== argument_8 ? argument_8 : 0, m09 = 9 < arguments.length && void 0 !== argument_9 ? argument_9 : 0, m10 = 10 < arguments.length && void 0 !== argument_10 ? argument_10 : 1, m11 = 11 < arguments.length && void 0 !== argument_11 ? argument_11 : 0, m12 = 12 < arguments.length && void 0 !== argument_12 ? argument_12 : 0, m13 = 13 < arguments.length && void 0 !== argument_13 ? argument_13 : 0, m14 = 14 < arguments.length && void 0 !== argument_14 ? argument_14 : 0, m15 = 15 < arguments.length && void 0 !== argument_15 ? argument_15 : 1;
                        return "object" === _typeof(m00) ? (this.m01 = m00.m01, this.m02 = m00.m02, this.m03 = m00.m03, 
                        this.m04 = m00.m04, this.m05 = m00.m05, this.m06 = m00.m06, this.m07 = m00.m07, 
                        this.m08 = m00.m08, this.m09 = m00.m09, this.m10 = m00.m10, this.m11 = m00.m11, 
                        this.m12 = m00.m12, this.m13 = m00.m13, this.m14 = m00.m14, this.m15 = m00.m15, 
                        this.m00 = m00.m00) : (this.m01 = m01, this.m02 = m02, this.m03 = m03, this.m04 = m04, 
                        this.m05 = m05, this.m06 = m06, this.m07 = m07, this.m08 = m08, this.m09 = m09, 
                        this.m10 = m10, this.m11 = m11, this.m12 = m12, this.m13 = m13, this.m14 = m14, 
                        this.m15 = m15, this.m00 = m00), this;
                    }
                }, {
                    key: "equals",
                    value: function equals(other, argument_1) {
                        var epsilon = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : EPSILON;
                        return Math.abs(this.m00 - other.m00) <= epsilon * Math.max(1, Math.abs(this.m00), Math.abs(other.m00)) && Math.abs(this.m01 - other.m01) <= epsilon * Math.max(1, Math.abs(this.m01), Math.abs(other.m01)) && Math.abs(this.m02 - other.m02) <= epsilon * Math.max(1, Math.abs(this.m02), Math.abs(other.m02)) && Math.abs(this.m03 - other.m03) <= epsilon * Math.max(1, Math.abs(this.m03), Math.abs(other.m03)) && Math.abs(this.m04 - other.m04) <= epsilon * Math.max(1, Math.abs(this.m04), Math.abs(other.m04)) && Math.abs(this.m05 - other.m05) <= epsilon * Math.max(1, Math.abs(this.m05), Math.abs(other.m05)) && Math.abs(this.m06 - other.m06) <= epsilon * Math.max(1, Math.abs(this.m06), Math.abs(other.m06)) && Math.abs(this.m07 - other.m07) <= epsilon * Math.max(1, Math.abs(this.m07), Math.abs(other.m07)) && Math.abs(this.m08 - other.m08) <= epsilon * Math.max(1, Math.abs(this.m08), Math.abs(other.m08)) && Math.abs(this.m09 - other.m09) <= epsilon * Math.max(1, Math.abs(this.m09), Math.abs(other.m09)) && Math.abs(this.m10 - other.m10) <= epsilon * Math.max(1, Math.abs(this.m10), Math.abs(other.m10)) && Math.abs(this.m11 - other.m11) <= epsilon * Math.max(1, Math.abs(this.m11), Math.abs(other.m11)) && Math.abs(this.m12 - other.m12) <= epsilon * Math.max(1, Math.abs(this.m12), Math.abs(other.m12)) && Math.abs(this.m13 - other.m13) <= epsilon * Math.max(1, Math.abs(this.m13), Math.abs(other.m13)) && Math.abs(this.m14 - other.m14) <= epsilon * Math.max(1, Math.abs(this.m14), Math.abs(other.m14)) && Math.abs(this.m15 - other.m15) <= epsilon * Math.max(1, Math.abs(this.m15), Math.abs(other.m15));
                    }
                }, {
                    key: "strictEquals",
                    value: function strictEquals(other) {
                        return this.m00 === other.m00 && this.m01 === other.m01 && this.m02 === other.m02 && this.m03 === other.m03 && this.m04 === other.m04 && this.m05 === other.m05 && this.m06 === other.m06 && this.m07 === other.m07 && this.m08 === other.m08 && this.m09 === other.m09 && this.m10 === other.m10 && this.m11 === other.m11 && this.m12 === other.m12 && this.m13 === other.m13 && this.m14 === other.m14 && this.m15 === other.m15;
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return "[\n" + this.m00 + ", " + this.m01 + ", " + this.m02 + ", " + this.m03 + ",\n" + this.m04 + ", " + this.m05 + ", " + this.m06 + ", " + this.m07 + ",\n" + this.m08 + ", " + this.m09 + ", " + this.m10 + ", " + this.m11 + ",\n" + this.m12 + ", " + this.m13 + ", " + this.m14 + ", " + this.m15 + "\n]";
                    }
                }, {
                    key: "identity",
                    value: function identity() {
                        return this.m00 = 1, this.m01 = 0, this.m02 = 0, this.m03 = 0, this.m04 = 0, this.m05 = 1, 
                        this.m06 = 0, this.m07 = 0, this.m08 = 0, this.m09 = 0, this.m10 = 1, this.m11 = 0, 
                        this.m12 = 0, this.m13 = 0, this.m14 = 0, this.m15 = 1, this;
                    }
                }, {
                    key: "transpose",
                    value: function transpose() {
                        var a01 = this.m01, a02 = this.m02, a03 = this.m03, a12 = this.m06, a13 = this.m07, a23 = this.m11;
                        return this.m01 = this.m04, this.m02 = this.m08, this.m03 = this.m12, this.m04 = a01, 
                        this.m06 = this.m09, this.m07 = this.m13, this.m08 = a02, this.m09 = a12, this.m11 = this.m14, 
                        this.m12 = a03, this.m13 = a13, this.m14 = a23, this;
                    }
                }, {
                    key: "invert",
                    value: function invert() {
                        _a00$1 = this.m00, _a01$1 = this.m01, _a02$1 = this.m02, _a03 = this.m03, _a10$1 = this.m04, 
                        _a11$1 = this.m05, _a12$1 = this.m06, _a13 = this.m07, _a20$1 = this.m08, _a21$1 = this.m09, 
                        _a22$1 = this.m10, _a23 = this.m11, _a30 = this.m12, _a31 = this.m13, _a32 = this.m14, 
                        _a33 = this.m15;
                        var b00 = _a00$1 * _a11$1 - _a01$1 * _a10$1, b01 = _a00$1 * _a12$1 - _a02$1 * _a10$1, b02 = _a00$1 * _a13 - _a03 * _a10$1, b03 = _a01$1 * _a12$1 - _a02$1 * _a11$1, b04 = _a01$1 * _a13 - _a03 * _a11$1, b05 = _a02$1 * _a13 - _a03 * _a12$1, b06 = _a20$1 * _a31 - _a21$1 * _a30, b07 = _a20$1 * _a32 - _a22$1 * _a30, b08 = _a20$1 * _a33 - _a23 * _a30, b09 = _a21$1 * _a32 - _a22$1 * _a31, b10 = _a21$1 * _a33 - _a23 * _a31, b11 = _a22$1 * _a33 - _a23 * _a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                        return 0 === det ? null : (det = 1 / det, this.m00 = (_a11$1 * b11 - _a12$1 * b10 + _a13 * b09) * det, 
                        this.m01 = (_a02$1 * b10 - _a01$1 * b11 - _a03 * b09) * det, this.m02 = (_a31 * b05 - _a32 * b04 + _a33 * b03) * det, 
                        this.m03 = (_a22$1 * b04 - _a21$1 * b05 - _a23 * b03) * det, this.m04 = (_a12$1 * b08 - _a10$1 * b11 - _a13 * b07) * det, 
                        this.m05 = (_a00$1 * b11 - _a02$1 * b08 + _a03 * b07) * det, this.m06 = (_a32 * b02 - _a30 * b05 - _a33 * b01) * det, 
                        this.m07 = (_a20$1 * b05 - _a22$1 * b02 + _a23 * b01) * det, this.m08 = (_a10$1 * b10 - _a11$1 * b08 + _a13 * b06) * det, 
                        this.m09 = (_a01$1 * b08 - _a00$1 * b10 - _a03 * b06) * det, this.m10 = (_a30 * b04 - _a31 * b02 + _a33 * b00) * det, 
                        this.m11 = (_a21$1 * b02 - _a20$1 * b04 - _a23 * b00) * det, this.m12 = (_a11$1 * b07 - _a10$1 * b09 - _a12$1 * b06) * det, 
                        this.m13 = (_a00$1 * b09 - _a01$1 * b07 + _a02$1 * b06) * det, this.m14 = (_a31 * b01 - _a30 * b03 - _a32 * b00) * det, 
                        this.m15 = (_a20$1 * b03 - _a21$1 * b01 + _a22$1 * b00) * det, this);
                    }
                }, {
                    key: "determinant",
                    value: function determinant() {
                        return _a00$1 = this.m00, _a01$1 = this.m01, _a02$1 = this.m02, _a03 = this.m03, 
                        _a10$1 = this.m04, _a11$1 = this.m05, _a12$1 = this.m06, _a13 = this.m07, _a20$1 = this.m08, 
                        _a21$1 = this.m09, _a22$1 = this.m10, _a23 = this.m11, _a30 = this.m12, _a31 = this.m13, 
                        _a32 = this.m14, _a33 = this.m15, (_a00$1 * _a11$1 - _a01$1 * _a10$1) * (_a22$1 * _a33 - _a23 * _a32) - (_a00$1 * _a12$1 - _a02$1 * _a10$1) * (_a21$1 * _a33 - _a23 * _a31) + (_a00$1 * _a13 - _a03 * _a10$1) * (_a21$1 * _a32 - _a22$1 * _a31) + (_a01$1 * _a12$1 - _a02$1 * _a11$1) * (_a20$1 * _a33 - _a23 * _a30) - (_a01$1 * _a13 - _a03 * _a11$1) * (_a20$1 * _a32 - _a22$1 * _a30) + (_a02$1 * _a13 - _a03 * _a12$1) * (_a20$1 * _a31 - _a21$1 * _a30);
                    }
                }, {
                    key: "add",
                    value: function add(mat) {
                        return this.m00 = this.m00 + mat.m00, this.m01 = this.m01 + mat.m01, this.m02 = this.m02 + mat.m02, 
                        this.m03 = this.m03 + mat.m03, this.m04 = this.m04 + mat.m04, this.m05 = this.m05 + mat.m05, 
                        this.m06 = this.m06 + mat.m06, this.m07 = this.m07 + mat.m07, this.m08 = this.m08 + mat.m08, 
                        this.m09 = this.m09 + mat.m09, this.m10 = this.m10 + mat.m10, this.m11 = this.m11 + mat.m11, 
                        this.m12 = this.m12 + mat.m12, this.m13 = this.m13 + mat.m13, this.m14 = this.m14 + mat.m14, 
                        this.m15 = this.m15 + mat.m15, this;
                    }
                }, {
                    key: "subtract",
                    value: function subtract(mat) {
                        return this.m00 = this.m00 - mat.m00, this.m01 = this.m01 - mat.m01, this.m02 = this.m02 - mat.m02, 
                        this.m03 = this.m03 - mat.m03, this.m04 = this.m04 - mat.m04, this.m05 = this.m05 - mat.m05, 
                        this.m06 = this.m06 - mat.m06, this.m07 = this.m07 - mat.m07, this.m08 = this.m08 - mat.m08, 
                        this.m09 = this.m09 - mat.m09, this.m10 = this.m10 - mat.m10, this.m11 = this.m11 - mat.m11, 
                        this.m12 = this.m12 - mat.m12, this.m13 = this.m13 - mat.m13, this.m14 = this.m14 - mat.m14, 
                        this.m15 = this.m15 - mat.m15, this;
                    }
                }, {
                    key: "multiply",
                    value: function multiply(mat) {
                        _a00$1 = this.m00, _a01$1 = this.m01, _a02$1 = this.m02, _a03 = this.m03, _a10$1 = this.m04, 
                        _a11$1 = this.m05, _a12$1 = this.m06, _a13 = this.m07, _a20$1 = this.m08, _a21$1 = this.m09, 
                        _a22$1 = this.m10, _a23 = this.m11, _a30 = this.m12, _a31 = this.m13, _a32 = this.m14, 
                        _a33 = this.m15;
                        var b0 = mat.m00, b1 = mat.m01, b2 = mat.m02, b3 = mat.m03;
                        return this.m00 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, this.m01 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, 
                        this.m02 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, this.m03 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, 
                        b0 = mat.m04, b1 = mat.m05, b2 = mat.m06, b3 = mat.m07, this.m04 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, 
                        this.m05 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, this.m06 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, 
                        this.m07 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, b0 = mat.m08, b1 = mat.m09, 
                        b2 = mat.m10, b3 = mat.m11, this.m08 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, 
                        this.m09 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, this.m10 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, 
                        this.m11 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, b0 = mat.m12, b1 = mat.m13, 
                        b2 = mat.m14, b3 = mat.m15, this.m12 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, 
                        this.m13 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, this.m14 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, 
                        this.m15 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, this;
                    }
                }, {
                    key: "multiplyScalar",
                    value: function multiplyScalar(scalar) {
                        return this.m00 = this.m00 * scalar, this.m01 = this.m01 * scalar, this.m02 = this.m02 * scalar, 
                        this.m03 = this.m03 * scalar, this.m04 = this.m04 * scalar, this.m05 = this.m05 * scalar, 
                        this.m06 = this.m06 * scalar, this.m07 = this.m07 * scalar, this.m08 = this.m08 * scalar, 
                        this.m09 = this.m09 * scalar, this.m10 = this.m10 * scalar, this.m11 = this.m11 * scalar, 
                        this.m12 = this.m12 * scalar, this.m13 = this.m13 * scalar, this.m14 = this.m14 * scalar, 
                        this.m15 = this.m15 * scalar, this;
                    }
                }, {
                    key: "translate",
                    value: function translate(vec) {
                        return console.warn("function changed"), this.m12 += vec.x, this.m13 += vec.y, this.m14 += vec.y, 
                        this;
                    }
                }, {
                    key: "scale",
                    value: function scale(vec) {
                        var x = vec.x, y = vec.y, z = vec.z;
                        return this.m00 = this.m00 * x, this.m01 = this.m01 * x, this.m02 = this.m02 * x, 
                        this.m03 = this.m03 * x, this.m04 = this.m04 * y, this.m05 = this.m05 * y, this.m06 = this.m06 * y, 
                        this.m07 = this.m07 * y, this.m08 = this.m08 * z, this.m09 = this.m09 * z, this.m10 = this.m10 * z, 
                        this.m11 = this.m11 * z, this.m12 = this.m12, this.m13 = this.m13, this.m14 = this.m14, 
                        this.m15 = this.m15, this;
                    }
                }, {
                    key: "rotate",
                    value: function rotate(rad, axis) {
                        var x = axis.x, y = axis.y, z = axis.z, len = Math.sqrt(x * x + y * y + z * z);
                        if (Math.abs(len) < EPSILON) return null;
                        x *= len = 1 / len, y *= len, z *= len;
                        var s = Math.sin(rad), c = Math.cos(rad), t = 1 - c;
                        _a00$1 = this.m00, _a01$1 = this.m01, _a02$1 = this.m02, _a03 = this.m03, _a10$1 = this.m04, 
                        _a11$1 = this.m05, _a12$1 = this.m06, _a13 = this.m07, _a20$1 = this.m08, _a21$1 = this.m09, 
                        _a22$1 = this.m10, _a23 = this.m11;
                        var b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s, b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s, b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;
                        return this.m00 = _a00$1 * b00 + _a10$1 * b01 + _a20$1 * b02, this.m01 = _a01$1 * b00 + _a11$1 * b01 + _a21$1 * b02, 
                        this.m02 = _a02$1 * b00 + _a12$1 * b01 + _a22$1 * b02, this.m03 = _a03 * b00 + _a13 * b01 + _a23 * b02, 
                        this.m04 = _a00$1 * b10 + _a10$1 * b11 + _a20$1 * b12, this.m05 = _a01$1 * b10 + _a11$1 * b11 + _a21$1 * b12, 
                        this.m06 = _a02$1 * b10 + _a12$1 * b11 + _a22$1 * b12, this.m07 = _a03 * b10 + _a13 * b11 + _a23 * b12, 
                        this.m08 = _a00$1 * b20 + _a10$1 * b21 + _a20$1 * b22, this.m09 = _a01$1 * b20 + _a11$1 * b21 + _a21$1 * b22, 
                        this.m10 = _a02$1 * b20 + _a12$1 * b21 + _a22$1 * b22, this.m11 = _a03 * b20 + _a13 * b21 + _a23 * b22, 
                        this;
                    }
                }, {
                    key: "getTranslation",
                    value: function getTranslation(out) {
                        return out.x = this.m12, out.y = this.m13, out.z = this.m14, out;
                    }
                }, {
                    key: "getScale",
                    value: function getScale(out) {
                        var m00 = m3_1$1.m00 = this.m00, m01 = m3_1$1.m01 = this.m01, m02 = m3_1$1.m02 = this.m02, m04 = m3_1$1.m03 = this.m04, m05 = m3_1$1.m04 = this.m05, m06 = m3_1$1.m05 = this.m06, m08 = m3_1$1.m06 = this.m08, m09 = m3_1$1.m07 = this.m09, m10 = m3_1$1.m08 = this.m10;
                        return out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02), out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06), 
                        out.z = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10), Mat3.determinant(m3_1$1) < 0 && (out.x *= -1), 
                        out;
                    }
                }, {
                    key: "getRotation",
                    value: function getRotation(out) {
                        var trace = this.m00 + this.m05 + this.m10, S = 0;
                        return 0 < trace ? (S = 2 * Math.sqrt(trace + 1), out.w = .25 * S, out.x = (this.m06 - this.m09) / S, 
                        out.y = (this.m08 - this.m02) / S, out.z = (this.m01 - this.m04) / S) : this.m00 > this.m05 && this.m00 > this.m10 ? (S = 2 * Math.sqrt(1 + this.m00 - this.m05 - this.m10), 
                        out.w = (this.m06 - this.m09) / S, out.x = .25 * S, out.y = (this.m01 + this.m04) / S, 
                        out.z = (this.m08 + this.m02) / S) : this.m05 > this.m10 ? (S = 2 * Math.sqrt(1 + this.m05 - this.m00 - this.m10), 
                        out.w = (this.m08 - this.m02) / S, out.x = (this.m01 + this.m04) / S, out.y = .25 * S, 
                        out.z = (this.m06 + this.m09) / S) : (S = 2 * Math.sqrt(1 + this.m10 - this.m00 - this.m05), 
                        out.w = (this.m01 - this.m04) / S, out.x = (this.m08 + this.m02) / S, out.y = (this.m06 + this.m09) / S, 
                        out.z = .25 * S), out;
                    }
                }, {
                    key: "fromRTS",
                    value: function fromRTS(q, v, s) {
                        var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, sx = s.x, sy = s.y, sz = s.z;
                        return this.m00 = (1 - (yy + zz)) * sx, this.m01 = (xy + wz) * sx, this.m02 = (xz - wy) * sx, 
                        this.m03 = 0, this.m04 = (xy - wz) * sy, this.m05 = (1 - (xx + zz)) * sy, this.m06 = (yz + wx) * sy, 
                        this.m07 = 0, this.m08 = (xz + wy) * sz, this.m09 = (yz - wx) * sz, this.m10 = (1 - (xx + yy)) * sz, 
                        this.m11 = 0, this.m12 = v.x, this.m13 = v.y, this.m14 = v.z, this.m15 = 1, this;
                    }
                }, {
                    key: "fromQuat",
                    value: function fromQuat(q) {
                        var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
                        return this.m00 = 1 - yy - zz, this.m01 = yx + wz, this.m02 = zx - wy, this.m03 = 0, 
                        this.m04 = yx - wz, this.m05 = 1 - xx - zz, this.m06 = zy + wx, this.m07 = 0, this.m08 = zx + wy, 
                        this.m09 = zy - wx, this.m10 = 1 - xx - yy, this.m11 = 0, this.m12 = 0, this.m13 = 0, 
                        this.m14 = 0, this.m15 = 1, this;
                    }
                } ]), Mat4;
            }());
            Mat4.IDENTITY = Object.freeze(new Mat4());
            var v3_1$3 = new Vec3(), m3_1$1 = new Mat3();
            function mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
                return new Mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
            }
            CCClass.fastDefine("cc.Mat4", Mat4, {
                m00: 1,
                m01: 0,
                m02: 0,
                m03: 0,
                m04: 0,
                m05: 1,
                m06: 0,
                m07: 0,
                m08: 0,
                m09: 0,
                m10: 1,
                m11: 0,
                m12: 0,
                m13: 0,
                m14: 0,
                m15: 1
            }), cc.Mat4 = Mat4, cc.mat4 = mat4;
            var _a = 0, _b = 0, _c = 0, _d = 0, _tx = 0, _ty = 0, AffineTransform = exports("AffineTransform", function() {
                function AffineTransform() {
                    var a = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1, b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1, tx = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, ty = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0;
                    _classCallCheck(this, AffineTransform), this.a = void 0, this.b = void 0, this.c = void 0, 
                    this.d = void 0, this.tx = void 0, this.ty = void 0, this.a = a, this.b = b, this.c = c, 
                    this.d = d, this.tx = tx, this.ty = ty;
                }
                return _createClass(AffineTransform, null, [ {
                    key: "identity",
                    value: function identity() {
                        return new AffineTransform();
                    }
                }, {
                    key: "clone",
                    value: function clone(affineTransform) {
                        return new AffineTransform(affineTransform.a, affineTransform.b, affineTransform.c, affineTransform.d, affineTransform.tx, affineTransform.ty);
                    }
                }, {
                    key: "concat",
                    value: function concat(out, t1, t2) {
                        _a = t1.a, _b = t1.b, _c = t1.c, _d = t1.d, _tx = t1.tx, _ty = t1.ty, out.a = _a * t2.a + _b * t2.c, 
                        out.b = _a * t2.b + _b * t2.d, out.c = _c * t2.a + _d * t2.c, out.d = _c * t2.b + _d * t2.d, 
                        out.tx = _tx * t2.a + _ty * t2.c + t2.tx, out.ty = _tx * t2.b + _ty * t2.d + t2.ty;
                    }
                }, {
                    key: "invert",
                    value: function invert(out, t) {
                        var determinant = 1 / (t.a * t.d - t.b * t.c);
                        out.a = determinant * t.d, out.b = -determinant * t.b, out.c = -determinant * t.c, 
                        out.d = determinant * t.a, out.tx = determinant * (t.c * t.ty - t.d * t.tx), out.ty = determinant * (t.b * t.tx - t.a * t.ty);
                    }
                }, {
                    key: "fromMat4",
                    value: function fromMat4(out, mat) {
                        out.a = mat.m00, out.b = mat.m01, out.c = mat.m04, out.d = mat.m05, out.tx = mat.m12, 
                        out.ty = mat.m13;
                    }
                }, {
                    key: "transformVec2",
                    value: function transformVec2(out, point, transOrY, t) {
                        var x, y;
                        y = void 0 === t ? (t = transOrY, x = point.x, point.y) : (x = point, transOrY), 
                        out.x = t.a * x + t.c * y + t.tx, out.y = t.b * x + t.d * y + t.ty;
                    }
                }, {
                    key: "transformSize",
                    value: function transformSize(out, size, t) {
                        out.width = t.a * size.width + t.c * size.height, out.height = t.b * size.width + t.d * size.height;
                    }
                }, {
                    key: "transformRect",
                    value: function transformRect(out, rect, t) {
                        var or = rect.x + rect.width, ot = rect.y + rect.height, lbx = t.a * rect.x + t.c * rect.y + t.tx, lby = t.b * rect.x + t.d * rect.y + t.ty, rbx = t.a * or + t.c * rect.y + t.tx, rby = t.b * or + t.d * rect.y + t.ty, ltx = t.a * rect.x + t.c * ot + t.tx, lty = t.b * rect.x + t.d * ot + t.ty, rtx = t.a * or + t.c * ot + t.tx, rty = t.b * or + t.d * ot + t.ty, minX = Math.min(lbx, rbx, ltx, rtx), maxX = Math.max(lbx, rbx, ltx, rtx), minY = Math.min(lby, rby, lty, rty), maxY = Math.max(lby, rby, lty, rty);
                        out.x = minX, out.y = minY, out.width = maxX - minX, out.height = maxY - minY;
                    }
                }, {
                    key: "transformObb",
                    value: function transformObb(out_bl, out_tl, out_tr, out_br, rect, anAffineTransform) {
                        var tx = anAffineTransform.a * rect.x + anAffineTransform.c * rect.y + anAffineTransform.tx, ty = anAffineTransform.b * rect.x + anAffineTransform.d * rect.y + anAffineTransform.ty, xa = anAffineTransform.a * rect.width, xb = anAffineTransform.b * rect.width, yc = anAffineTransform.c * rect.height, yd = anAffineTransform.d * rect.height;
                        out_tl.x = tx, out_tl.y = ty, out_tr.x = xa + tx, out_tr.y = xb + ty, out_bl.x = yc + tx, 
                        out_bl.y = yd + ty, out_br.x = xa + yc + tx, out_br.y = xb + yd + ty;
                    }
                } ]), AffineTransform;
            }());
            cc.AffineTransform = AffineTransform;
            var Size = exports("Size", function() {
                function Size(width, height) {
                    var _this;
                    return _classCallCheck(this, Size), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Size).call(this))).width = void 0, 
                    _this.height = void 0, width && "object" === _typeof(width) ? (_this.height = width.height, 
                    _this.width = width.width) : (_this.width = width || 0, _this.height = height || 0), 
                    _this;
                }
                return _inherits(Size, ValueType), _createClass(Size, [ {
                    key: "x",
                    set: function set(val) {
                        this.width = val;
                    },
                    get: function get() {
                        return this.width;
                    }
                }, {
                    key: "y",
                    set: function set(val) {
                        this.height = val;
                    },
                    get: function get() {
                        return this.height;
                    }
                } ], [ {
                    key: "lerp",
                    value: function lerp(out, from, to, ratio) {
                        return out.width = from.width + (to.width - from.width) * ratio, out.height = from.height + (to.height - from.height) * ratio, 
                        out;
                    }
                }, {
                    key: "ZERO",
                    get: function get() {
                        return new Size(0, 0);
                    }
                } ]), _createClass(Size, [ {
                    key: "clone",
                    value: function clone() {
                        return new Size(this.width, this.height);
                    }
                }, {
                    key: "set",
                    value: function set(width, height) {
                        return width && "object" === _typeof(width) ? (this.height = width.height, this.width = width.width) : (this.width = width || 0, 
                        this.height = height || 0), this;
                    }
                }, {
                    key: "equals",
                    value: function equals(other) {
                        return this.width === other.width && this.height === other.height;
                    }
                }, {
                    key: "lerp",
                    value: function lerp(to, ratio) {
                        return this.width = this.width + (to.width - this.width) * ratio, this.height = this.height + (to.height - this.height) * ratio, 
                        this;
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return "(".concat(this.width.toFixed(2), ", ").concat(this.height.toFixed(2), ")");
                    }
                } ]), Size;
            }());
            function size() {
                return new Size(0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0);
            }
            CCClass.fastDefine("cc.Size", Size, {
                width: 0,
                height: 0
            }), cc.size = size, cc.Size = Size;
            var _x$4 = 0, _y$4 = 0, _w$2 = 0, _h = 0, Rect = exports("Rect", function() {
                function Rect(x, y, width, height) {
                    var _this;
                    return _classCallCheck(this, Rect), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Rect).call(this))).x = void 0, 
                    _this.y = void 0, _this.width = void 0, _this.height = void 0, x && "object" === _typeof(x) ? (_this.y = x.y, 
                    _this.width = x.width, _this.height = x.height, _this.x = x.x) : (_this.x = x || 0, 
                    _this.y = y || 0, _this.width = width || 0, _this.height = height || 0), _this;
                }
                return _inherits(Rect, ValueType), _createClass(Rect, [ {
                    key: "xMin",
                    get: function get() {
                        return this.x;
                    },
                    set: function set(value) {
                        this.width += this.x - value, this.x = value;
                    }
                }, {
                    key: "yMin",
                    get: function get() {
                        return this.y;
                    },
                    set: function set(value) {
                        this.height += this.y - value, this.y = value;
                    }
                }, {
                    key: "xMax",
                    get: function get() {
                        return this.x + this.width;
                    },
                    set: function set(value) {
                        this.width = value - this.x;
                    }
                }, {
                    key: "yMax",
                    get: function get() {
                        return this.y + this.height;
                    },
                    set: function set(value) {
                        this.height = value - this.y;
                    }
                }, {
                    key: "center",
                    get: function get() {
                        return new Vec2(this.x + .5 * this.width, this.y + .5 * this.height);
                    },
                    set: function set(value) {
                        this.x = value.x - .5 * this.width, this.y = value.y - .5 * this.height;
                    }
                }, {
                    key: "origin",
                    get: function get() {
                        return new cc.Vec2(this.x, this.y);
                    },
                    set: function set(value) {
                        this.x = value.x, this.y = value.y;
                    }
                }, {
                    key: "size",
                    get: function get() {
                        return new Size(this.width, this.height);
                    },
                    set: function set(value) {
                        this.width = value.width, this.height = value.height;
                    }
                }, {
                    key: "z",
                    set: function set(val) {
                        this.width = val;
                    },
                    get: function get() {
                        return this.width;
                    }
                }, {
                    key: "w",
                    set: function set(val) {
                        this.height = val;
                    },
                    get: function get() {
                        return this.height;
                    }
                } ], [ {
                    key: "fromMinMax",
                    value: function fromMinMax(out, v1, v2) {
                        var minX = Math.min(v1.x, v2.x), minY = Math.min(v1.y, v2.y), maxX = Math.max(v1.x, v2.x), maxY = Math.max(v1.y, v2.y);
                        return out.x = minX, out.y = minY, out.width = maxX - minX, out.height = maxY - minY, 
                        out;
                    }
                }, {
                    key: "lerp",
                    value: function lerp(out, from, to, ratio) {
                        return _x$4 = from.x, _y$4 = from.y, _w$2 = from.width, _h = from.height, out.x = _x$4 + (to.x - _x$4) * ratio, 
                        out.y = _y$4 + (to.y - _y$4) * ratio, out.width = _w$2 + (to.width - _w$2) * ratio, 
                        out.height = _h + (to.height - _h) * ratio, out;
                    }
                }, {
                    key: "intersection",
                    value: function intersection(out, one, other) {
                        var axMin = one.x, ayMin = one.y, axMax = one.x + one.width, ayMax = one.y + one.height, bxMin = other.x, byMin = other.y, bxMax = other.x + other.width, byMax = other.y + other.height;
                        return out.x = Math.max(axMin, bxMin), out.y = Math.max(ayMin, byMin), out.width = Math.min(axMax, bxMax) - out.x, 
                        out.height = Math.min(ayMax, byMax) - out.y, out;
                    }
                }, {
                    key: "union",
                    value: function union(out, one, other) {
                        _x$4 = one.x, _y$4 = one.y, _w$2 = one.width, _h = one.height;
                        var bx = other.x, by = other.y, bw = other.width, bh = other.height;
                        return out.x = Math.min(_x$4, bx), out.y = Math.min(_y$4, by), out.width = Math.max(_x$4 + _w$2, bx + bw) - out.x, 
                        out.height = Math.max(_y$4 + _h, by + bh) - out.y, out;
                    }
                } ]), _createClass(Rect, [ {
                    key: "clone",
                    value: function clone() {
                        return new Rect(this.x, this.y, this.width, this.height);
                    }
                }, {
                    key: "set",
                    value: function set(x, y, width, height) {
                        return x && "object" === _typeof(x) ? (this.y = x.y, this.width = x.width, this.height = x.height, 
                        this.x = x.x) : (this.x = x || 0, this.y = y || 0, this.width = width || 0, this.height = height || 0), 
                        this;
                    }
                }, {
                    key: "equals",
                    value: function equals(other) {
                        return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
                    }
                }, {
                    key: "lerp",
                    value: function lerp(to, ratio) {
                        return _x$4 = this.x, _y$4 = this.y, _w$2 = this.width, _h = this.height, this.x = _x$4 + (to.x - _x$4) * ratio, 
                        this.y = _y$4 + (to.y - _y$4) * ratio, this.width = _w$2 + (to.width - _w$2) * ratio, 
                        this.height = _h + (to.height - _h) * ratio, this;
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ", ").concat(this.width.toFixed(2), ", ").concat(this.height.toFixed(2), ")");
                    }
                }, {
                    key: "intersects",
                    value: function intersects(other) {
                        var maxax = this.x + this.width, maxay = this.y + this.height, maxbx = other.x + other.width, maxby = other.y + other.height;
                        return !(maxax < other.x || maxbx < this.x || maxay < other.y || maxby < this.y);
                    }
                }, {
                    key: "contains",
                    value: function contains(point) {
                        return this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y;
                    }
                }, {
                    key: "containsRect",
                    value: function containsRect(other) {
                        return this.x <= other.x && this.x + this.width >= other.x + other.width && this.y <= other.y && this.y + this.height >= other.y + other.height;
                    }
                }, {
                    key: "transformMat4",
                    value: function transformMat4(mat) {
                        var ol = this.x, ob = this.y, or = ol + this.width, ot = ob + this.height, lbx = mat.m00 * ol + mat.m04 * ob + mat.m12, lby = mat.m01 * ol + mat.m05 * ob + mat.m13, rbx = mat.m00 * or + mat.m04 * ob + mat.m12, rby = mat.m01 * or + mat.m05 * ob + mat.m13, ltx = mat.m00 * ol + mat.m04 * ot + mat.m12, lty = mat.m01 * ol + mat.m05 * ot + mat.m13, rtx = mat.m00 * or + mat.m04 * ot + mat.m12, rty = mat.m01 * or + mat.m05 * ot + mat.m13, minX = Math.min(lbx, rbx, ltx, rtx), maxX = Math.max(lbx, rbx, ltx, rtx), minY = Math.min(lby, rby, lty, rty), maxY = Math.max(lby, rby, lty, rty);
                        return this.x = minX, this.y = minY, this.width = maxX - minX, this.height = maxY - minY, 
                        this;
                    }
                } ]), Rect;
            }());
            function rect() {
                return new Rect(0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0);
            }
            CCClass.fastDefine("cc.Rect", Rect, {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }), cc.Rect = Rect, cc.rect = rect;
            var _r = 0, _g = 0, _b$1 = 0, _a$1 = 0, Color = exports("Color", function() {
                function Color(r, g, b, a) {
                    var _this;
                    return _classCallCheck(this, Color), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Color).call(this)))._val = 0, 
                    "string" == typeof r ? _this.fromHEX(r) : ("object" === _typeof(r) && (g = r.g, 
                    b = r.b, a = r.a, r = r.r), r = r || 0, g = g || 0, b = b || 0, a = "number" == typeof a ? a : 255, 
                    _this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + r), _this;
                }
                return _inherits(Color, ValueType), _createClass(Color, [ {
                    key: "r",
                    get: function get() {
                        return 255 & this._val;
                    },
                    set: function set(red) {
                        red = ~~clamp(red, 0, 255), this._val = (4294967040 & this._val | red) >>> 0;
                    }
                }, {
                    key: "g",
                    get: function get() {
                        return (65280 & this._val) >> 8;
                    },
                    set: function set(green) {
                        green = ~~clamp(green, 0, 255), this._val = (4294902015 & this._val | green << 8) >>> 0;
                    }
                }, {
                    key: "b",
                    get: function get() {
                        return (16711680 & this._val) >> 16;
                    },
                    set: function set(blue) {
                        blue = ~~clamp(blue, 0, 255), this._val = (4278255615 & this._val | blue << 16) >>> 0;
                    }
                }, {
                    key: "a",
                    get: function get() {
                        return (4278190080 & this._val) >>> 24;
                    },
                    set: function set(alpha) {
                        alpha = ~~clamp(alpha, 0, 255), this._val = (16777215 & this._val | alpha << 24 >>> 0) >>> 0;
                    }
                }, {
                    key: "x",
                    get: function get() {
                        return this.r * (1 / 255);
                    },
                    set: function set(value) {
                        this.r = 255 * value;
                    }
                }, {
                    key: "y",
                    get: function get() {
                        return this.g * (1 / 255);
                    },
                    set: function set(value) {
                        this.g = 255 * value;
                    }
                }, {
                    key: "z",
                    get: function get() {
                        return this.b * (1 / 255);
                    },
                    set: function set(value) {
                        this.b = 255 * value;
                    }
                }, {
                    key: "w",
                    get: function get() {
                        return this.a * (1 / 255);
                    },
                    set: function set(value) {
                        this.a = 255 * value;
                    }
                } ], [ {
                    key: "clone",
                    value: function clone(a) {
                        var out = new Color();
                        return a._val ? out._val = a._val : out._val = (a.a << 24 >>> 0) + (a.b << 16) + (a.g << 8) + a.r, 
                        out;
                    }
                }, {
                    key: "copy",
                    value: function copy(out, a) {
                        return out.r = a.r, out.g = a.g, out.b = a.b, out.a = a.a, out;
                    }
                }, {
                    key: "set",
                    value: function set(out, r, g, b, a) {
                        return out.r = r, out.g = g, out.b = b, out.a = a, out;
                    }
                }, {
                    key: "fromHex",
                    value: function fromHex(out, hex) {
                        return out.r = (hex >> 24) / 255, out.g = (hex >> 16 & 255) / 255, out.b = (hex >> 8 & 255) / 255, 
                        out.a = (255 & hex) / 255, out;
                    }
                }, {
                    key: "add",
                    value: function add(out, a, b) {
                        return out.r = a.r + b.r, out.g = a.g + b.g, out.b = a.b + b.b, out.a = a.a + b.a, 
                        out;
                    }
                }, {
                    key: "subtract",
                    value: function subtract(out, a, b) {
                        return out.r = a.r - b.r, out.g = a.g - b.g, out.b = a.b - b.b, out.a = a.a - b.a, 
                        out;
                    }
                }, {
                    key: "multiply",
                    value: function multiply(out, a, b) {
                        return out.r = a.r * b.r, out.g = a.g * b.g, out.b = a.b * b.b, out.a = a.a * b.a, 
                        out;
                    }
                }, {
                    key: "divide",
                    value: function divide(out, a, b) {
                        return out.r = a.r / b.r, out.g = a.g / b.g, out.b = a.b / b.b, out.a = a.a / b.a, 
                        out;
                    }
                }, {
                    key: "scale",
                    value: function scale(out, a, b) {
                        return out.r = a.r * b, out.g = a.g * b, out.b = a.b * b, out.a = a.a * b, out;
                    }
                }, {
                    key: "lerp",
                    value: function lerp(out, from, to, ratio) {
                        return _r = from.r, _g = from.g, _b$1 = from.b, _a$1 = from.a, _r += (to.r - _r) * ratio, 
                        _g += (to.g - _g) * ratio, _b$1 += (to.b - _b$1) * ratio, _a$1 += (to.a - _a$1) * ratio, 
                        out._val = Math.floor((_a$1 << 24 >>> 0) + (_b$1 << 16) + (_g << 8) + _r), out;
                    }
                }, {
                    key: "toArray",
                    value: function toArray(out, a, argument_2) {
                        var ofs = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0, scale = a instanceof Color || 1 < a.a ? 1 / 255 : 1;
                        return out[ofs + 0] = a.r * scale, out[ofs + 1] = a.g * scale, out[ofs + 2] = a.b * scale, 
                        out[ofs + 3] = a.a * scale, out;
                    }
                }, {
                    key: "fromArray",
                    value: function fromArray(arr, out, argument_2) {
                        var ofs = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0;
                        return out.r = 255 * arr[ofs + 0], out.g = 255 * arr[ofs + 1], out.b = 255 * arr[ofs + 2], 
                        out.a = 255 * arr[ofs + 3], out;
                    }
                }, {
                    key: "strictEquals",
                    value: function strictEquals(a, b) {
                        return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
                    }
                }, {
                    key: "equals",
                    value: function equals(a, b, argument_2) {
                        var epsilon = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : EPSILON;
                        return Math.abs(a.r - b.r) <= epsilon * Math.max(1, Math.abs(a.r), Math.abs(b.r)) && Math.abs(a.g - b.g) <= epsilon * Math.max(1, Math.abs(a.g), Math.abs(b.g)) && Math.abs(a.b - b.b) <= epsilon * Math.max(1, Math.abs(a.b), Math.abs(b.b)) && Math.abs(a.a - b.a) <= epsilon * Math.max(1, Math.abs(a.a), Math.abs(b.a));
                    }
                }, {
                    key: "hex",
                    value: function hex(a) {
                        return (255 * a.r << 24 | 255 * a.g << 16 | 255 * a.b << 8 | 255 * a.a) >>> 0;
                    }
                } ]), _createClass(Color, [ {
                    key: "clone",
                    value: function clone() {
                        var ret = new Color();
                        return ret._val = this._val, ret;
                    }
                }, {
                    key: "equals",
                    value: function equals(other) {
                        return other && this._val === other._val;
                    }
                }, {
                    key: "lerp",
                    value: function lerp(to, ratio) {
                        return _r = this.r, _g = this.g, _b$1 = this.b, _a$1 = this.a, _r += (to.r - _r) * ratio, 
                        _g += (to.g - _g) * ratio, _b$1 += (to.b - _b$1) * ratio, _a$1 += (to.a - _a$1) * ratio, 
                        this._val = Math.floor((_a$1 << 24 >>> 0) + (_b$1 << 16) + (_g << 8) + _r), this;
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return "rgba(" + this.r.toFixed() + ", " + this.g.toFixed() + ", " + this.b.toFixed() + ", " + this.a.toFixed() + ")";
                    }
                }, {
                    key: "toCSS",
                    value: function toCSS(opt) {
                        return "rgba" === opt ? "rgba(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + "," + (this.a * (1 / 255)).toFixed(2) + ")" : "rgb" === opt ? "rgb(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + ")" : "#" + this.toHEX(opt);
                    }
                }, {
                    key: "fromHEX",
                    value: function fromHEX(hexString) {
                        return hexString = 0 === hexString.indexOf("#") ? hexString.substring(1) : hexString, 
                        _r = parseInt(hexString.substr(0, 2), 16) || 0, _g = parseInt(hexString.substr(2, 2), 16) || 0, 
                        _b$1 = parseInt(hexString.substr(4, 2), 16) || 0, _a$1 = parseInt(hexString.substr(6, 2), 16) || 255, 
                        this._val = (_a$1 << 24 >>> 0) + (_b$1 << 16) + (_g << 8) + _r, this;
                    }
                }, {
                    key: "toHEX",
                    value: function toHEX(fmt) {
                        var hex = [ (0 | this.r).toString(16), (0 | this.g).toString(16), (0 | this.b).toString(16) ], i = -1;
                        if ("#rrggbb" === fmt) for (i = 0; i < hex.length; ++i) 1 === hex[i].length && (hex[i] = "0" + hex[i]); else if ("#rrggbbaa" === fmt) for (hex.push((0 | this.a).toString(16)), 
                        i = 0; i < hex.length; ++i) 1 === hex[i].length && (hex[i] = "0" + hex[i]);
                        return hex.join("");
                    }
                }, {
                    key: "toRGBValue",
                    value: function toRGBValue() {
                        return 16777215 & this._val;
                    }
                }, {
                    key: "fromHSV",
                    value: function fromHSV(h, s, v) {
                        if ((_b$1 = _g = _r = 0) === s) _r = _g = _b$1 = v; else if (0 === v) _r = _g = _b$1 = 0; else {
                            1 === h && (h = 0), h *= 6, s = s, v = v;
                            var i = Math.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - s * f), t = v * (1 - s * (1 - f));
                            switch (i) {
                              case 0:
                                _r = v, _g = t, _b$1 = p;
                                break;

                              case 1:
                                _r = q, _g = v, _b$1 = p;
                                break;

                              case 2:
                                _r = p, _g = v, _b$1 = t;
                                break;

                              case 3:
                                _r = p, _g = q, _b$1 = v;
                                break;

                              case 4:
                                _r = t, _g = p, _b$1 = v;
                                break;

                              case 5:
                                _r = v, _g = p, _b$1 = q;
                            }
                        }
                        return _r *= 255, _g *= 255, _b$1 *= 255, this._val = (this.a << 24 >>> 0) + (_b$1 << 16) + (_g << 8) + _r, 
                        this;
                    }
                }, {
                    key: "toHSV",
                    value: function toHSV() {
                        _r = this.r * (1 / 255), _g = this.g * (1 / 255), _b$1 = this.b * (1 / 255);
                        var hsv = {
                            h: 0,
                            s: 0,
                            v: 0
                        }, max = Math.max(_r, _g, _b$1), min = Math.min(_r, _g, _b$1), delta = 0;
                        return hsv.v = max, hsv.s = max ? (max - min) / max : 0, hsv.s ? (delta = max - min, 
                        hsv.h = _r === max ? (_g - _b$1) / delta : _g === max ? 2 + (_b$1 - _r) / delta : 4 + (_r - _g) / delta, 
                        hsv.h /= 6, hsv.h < 0 && (hsv.h += 1)) : hsv.h = 0, hsv;
                    }
                }, {
                    key: "set",
                    value: function set(r, g, b, a) {
                        return "object" === _typeof(r) && (g = r.g, b = r.b, a = r.a, r = r.r), r = r || 0, 
                        g = g || 0, b = b || 0, a = "number" == typeof a ? a : 255, this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + r, 
                        this;
                    }
                }, {
                    key: "multiply",
                    value: function multiply(other) {
                        return _r = (255 & this._val) * other.r >> 8, _g = (65280 & this._val) * other.g >> 8, 
                        _b$1 = (16711680 & this._val) * other.b >> 8, _a$1 = ((4278190080 & this._val) >>> 8) * other.a, 
                        this._val = 4278190080 & _a$1 | 16711680 & _b$1 | 65280 & _g | 255 & _r, this;
                    }
                }, {
                    key: "_set_r_unsafe",
                    value: function _set_r_unsafe(red) {
                        return this._val = (4294967040 & this._val | red) >>> 0, this;
                    }
                }, {
                    key: "_set_g_unsafe",
                    value: function _set_g_unsafe(green) {
                        return this._val = (4294902015 & this._val | green << 8) >>> 0, this;
                    }
                }, {
                    key: "_set_b_unsafe",
                    value: function _set_b_unsafe(blue) {
                        return this._val = (4278255615 & this._val | blue << 16) >>> 0, this;
                    }
                }, {
                    key: "_set_a_unsafe",
                    value: function _set_a_unsafe(alpha) {
                        return this._val = (16777215 & this._val | alpha << 24 >>> 0) >>> 0, this;
                    }
                } ]), Color;
            }());
            function color(r, g, b, a) {
                return new Color(r, g, b, a);
            }
            Color.WHITE = Object.freeze(new Color(255, 255, 255, 255)), Color.GRAY = Object.freeze(new Color(127, 127, 127, 255)), 
            Color.BLACK = Object.freeze(new Color(0, 0, 0, 255)), Color.TRANSPARENT = Object.freeze(new Color(0, 0, 0, 0)), 
            Color.RED = Object.freeze(new Color(255, 0, 0, 255)), Color.GREEN = Object.freeze(new Color(0, 255, 0, 255)), 
            Color.BLUE = Object.freeze(new Color(0, 0, 255, 255)), Color.CYAN = Object.freeze(new Color(0, 255, 255, 255)), 
            Color.MAGENTA = Object.freeze(new Color(255, 0, 255, 255)), Color.YELLOW = Object.freeze(new Color(255, 255, 0, 255)), 
            CCClass.fastDefine("cc.Color", Color, {
                r: 0,
                g: 0,
                b: 0,
                a: 255
            }), cc.Color = Color, cc.color = color;
            var replaceProperty, removeProperty, replacePropertyLog, markAsWarningLog, removePropertyLog, defaultLogTimes = 10;
            var messageID = 0, messageMap = new Map();
            replacePropertyLog = function replacePropertyLog(n, dp, n2, newp, f, id) {
                var item = messageMap.get(id);
                item && item.logTimes > item.count && (f("'%s' is deprecated, please use '%s' instead.", "".concat(n, ".").concat(dp), "".concat(n2, ".").concat(newp)), 
                item.count++);
            }, replaceProperty = exports("replaceProperty", function replaceProperty(owner, ownerName, properties) {
                null != owner && properties.forEach(function(item) {
                    var id = messageID++;
                    messageMap.set(id, {
                        id: id,
                        count: 0,
                        logTimes: void 0 !== item.logTimes ? item.logTimes : defaultLogTimes
                    });
                    var target = null != item.target ? item.target : owner, newName = null != item.newName ? item.newName : item.name, targetName = null != item.targetName ? item.targetName : ownerName;
                    if (null != item.customFunction) owner[item.name] = function() {
                        return replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), 
                        item.customFunction.call(this, arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 2 ? void 0 : arguments[2], arguments.length <= 3 ? void 0 : arguments[3], arguments.length <= 4 ? void 0 : arguments[4], arguments.length <= 5 ? void 0 : arguments[5], arguments.length <= 6 ? void 0 : arguments[6], arguments.length <= 7 ? void 0 : arguments[7], arguments.length <= 8 ? void 0 : arguments[8], arguments.length <= 9 ? void 0 : arguments[9], arguments.length <= 10 ? void 0 : arguments[10], arguments.length <= 11 ? void 0 : arguments[11]);
                    }; else if (null != item.customSetter || null != item.customGetter) {
                        var hasSetter = null != item.customSetter, hasGetter = null != item.customGetter;
                        hasSetter && hasGetter ? Object.defineProperty(owner, item.name, {
                            get: function get() {
                                return replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), 
                                item.customGetter.call(this);
                            },
                            set: function set(v) {
                                replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), item.customSetter.call(this, v);
                            }
                        }) : hasSetter ? Object.defineProperty(owner, item.name, {
                            set: function set(v) {
                                replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), item.customSetter.call(this, v);
                            }
                        }) : hasGetter && Object.defineProperty(owner, item.name, {
                            get: function get() {
                                return replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), 
                                item.customGetter.call(this);
                            }
                        });
                    } else Object.defineProperty(owner, item.name, {
                        get: function get() {
                            return replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), 
                            target[newName];
                        },
                        set: function set(v) {
                            replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), target[newName] = v;
                        }
                    });
                });
            }), removePropertyLog = function removePropertyLog(n, dp, f, id) {
                var item = messageMap.get(id);
                item && item.logTimes > item.count && (f("'%s' has been removed.", "".concat(n, ".").concat(dp)), 
                item.count++);
            }, removeProperty = exports("removeProperty", function removeProperty(owner, ownerName, properties) {
                null != owner && properties.forEach(function(item) {
                    var id = messageID++;
                    messageMap.set(id, {
                        id: id,
                        count: 0,
                        logTimes: void 0 !== item.logTimes ? item.logTimes : defaultLogTimes
                    }), Object.defineProperty(owner, item.name, {
                        get: function get() {
                            return removePropertyLog(ownerName, item.name, error, id);
                        },
                        set: function set() {
                            removePropertyLog(ownerName, item.name, error, id);
                        }
                    });
                });
            }), markAsWarningLog = function markAsWarningLog(n, dp, f, id) {
                var item = messageMap.get(id);
                item && item.logTimes > item.count && (f("'%s' is deprecated.", "".concat(n, ".").concat(dp)), 
                item.count++);
            }, exports("markAsWarning", function markAsWarning(owner, ownerName, properties) {
                if (null != owner) {
                    var _defaultGetSet = function _defaultGetSet(o, p, d, n, dp, f, id) {
                        if (d.get) {
                            var oldGet = d.get();
                            d.get = function() {
                                return markAsWarningLog(n, dp, f, id), oldGet.call(this);
                            };
                        }
                        if (d.set) {
                            var oldSet = Object.create(d.set);
                            d.set = function(v) {
                                markAsWarningLog(n, dp, f, id), oldSet.call(this, v);
                            };
                        }
                    };
                    properties.forEach(function(item) {
                        var deprecatedProp = item.name, descriptor = Object.getOwnPropertyDescriptor(owner, deprecatedProp);
                        if (descriptor) {
                            var id = messageID++;
                            if (messageMap.set(id, {
                                id: id,
                                count: 0,
                                logTimes: void 0 !== item.logTimes ? item.logTimes : defaultLogTimes
                            }), null != descriptor.value) if ("function" == typeof descriptor.value) {
                                var oldValue = descriptor.value;
                                owner[deprecatedProp] = function() {
                                    return markAsWarningLog(ownerName, deprecatedProp, warn, id), oldValue.call(this);
                                };
                            } else _defaultGetSet(0, 0, descriptor, ownerName, deprecatedProp, warn, id); else _defaultGetSet(0, 0, descriptor, ownerName, deprecatedProp, warn, id);
                        }
                    });
                }
            }), replaceProperty(Vec2, "Vec2", [ {
                name: "sub",
                newName: "subtract",
                target: Vec2,
                targetName: "Vec2"
            }, {
                name: "mul",
                newName: "multiply",
                target: Vec2,
                targetName: "Vec2"
            }, {
                name: "div",
                newName: "divide",
                target: Vec2,
                targetName: "Vec2"
            }, {
                name: "dist",
                newName: "distance",
                target: Vec2,
                targetName: "Vec2"
            }, {
                name: "sqrDist",
                newName: "squaredDistance",
                target: Vec2,
                targetName: "Vec2"
            }, {
                name: "mag",
                newName: "len",
                target: Vec2,
                targetName: "Vec2"
            }, {
                name: "sqrMag",
                newName: "lengthSqr",
                target: Vec2,
                targetName: "Vec2"
            }, {
                name: "scale",
                newName: "multiplyScalar",
                target: Vec2,
                targetName: "Vec2"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Vec2,
                targetName: "Vec2"
            } ]), replaceProperty(Vec2.prototype, "Vec2", [ {
                name: "mag",
                newName: "length",
                target: Vec2.prototype,
                targetName: "Vec2"
            }, {
                name: "magSqr",
                newName: "lengthSqr",
                target: Vec2.prototype,
                targetName: "Vec2"
            }, {
                name: "scale",
                newName: "multiplyScalar",
                target: Vec2.prototype,
                targetName: "Vec2"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Vec2.prototype,
                targetName: "Vec2"
            } ]), removeProperty(Vec2.prototype, "vmath", [ {
                name: "divide"
            } ]), replaceProperty(Vec3, "Vec3", [ {
                name: "sub",
                newName: "subtract",
                target: Vec3,
                targetName: "Vec3"
            }, {
                name: "mul",
                newName: "multiply",
                target: Vec3,
                targetName: "Vec3"
            }, {
                name: "div",
                newName: "divide",
                target: Vec3,
                targetName: "Vec3"
            }, {
                name: "dist",
                newName: "distance",
                target: Vec3,
                targetName: "Vec3"
            }, {
                name: "sqrDist",
                newName: "squaredDistance",
                target: Vec3,
                targetName: "Vec3"
            }, {
                name: "mag",
                newName: "len",
                target: Vec3,
                targetName: "Vec3"
            }, {
                name: "sqrMag",
                newName: "lengthSqr",
                target: Vec3,
                targetName: "Vec3"
            }, {
                name: "scale",
                newName: "multiplyScalar",
                target: Vec3,
                targetName: "Vec3"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Vec3,
                targetName: "Vec3"
            } ]), replaceProperty(Vec3.prototype, "Vec3", [ {
                name: "mag",
                newName: "length",
                target: Vec3.prototype,
                targetName: "Vec3"
            }, {
                name: "magSqr",
                newName: "lengthSqr",
                target: Vec3.prototype,
                targetName: "Vec3"
            }, {
                name: "scale",
                newName: "multiplyScalar",
                target: Vec3.prototype,
                targetName: "Vec3"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Vec3.prototype,
                targetName: "Vec3"
            } ]), removeProperty(Vec3.prototype, "vmath", [ {
                name: "divide"
            } ]), replaceProperty(Vec4, "Vec4", [ {
                name: "sub",
                newName: "subtract",
                target: Vec4,
                targetName: "Vec4"
            }, {
                name: "mul",
                newName: "multiply",
                target: Vec4,
                targetName: "Vec4"
            }, {
                name: "div",
                newName: "divide",
                target: Vec4,
                targetName: "Vec4"
            }, {
                name: "dist",
                newName: "distance",
                target: Vec4,
                targetName: "Vec4"
            }, {
                name: "sqrDist",
                newName: "squaredDistance",
                target: Vec4,
                targetName: "Vec4"
            }, {
                name: "mag",
                newName: "len",
                target: Vec4,
                targetName: "Vec4"
            }, {
                name: "sqrMag",
                newName: "lengthSqr",
                target: Vec4,
                targetName: "Vec4"
            }, {
                name: "scale",
                newName: "multiplyScalar",
                target: Vec4,
                targetName: "Vec4"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Vec4,
                targetName: "Vec4"
            } ]), replaceProperty(Vec4.prototype, "Vec4", [ {
                name: "mag",
                newName: "length",
                target: Vec4.prototype,
                targetName: "Vec4"
            }, {
                name: "magSqr",
                newName: "lengthSqr",
                target: Vec4.prototype,
                targetName: "Vec4"
            }, {
                name: "scale",
                newName: "multiplyScalar",
                target: Vec4.prototype,
                targetName: "Vec4"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Vec4.prototype,
                targetName: "Vec4"
            } ]), removeProperty(Vec4.prototype, "vmath", [ {
                name: "divide"
            } ]), replaceProperty(Quat, "Quat", [ {
                name: "mag",
                newName: "len",
                target: Quat,
                targetName: "Quat"
            }, {
                name: "mul",
                newName: "multiply",
                target: Quat,
                targetName: "Quat"
            }, {
                name: "sqrMag",
                newName: "lengthSqr",
                target: Quat,
                targetName: "Quat"
            }, {
                name: "scale",
                newName: "multiplyScalar",
                target: Quat,
                targetName: "Quat"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Quat,
                targetName: "Quat"
            } ]), replaceProperty(Quat.prototype, "Quat", [ {
                name: "scale",
                newName: "multiplyScalar",
                target: Quat.prototype,
                targetName: "Quat"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Quat.prototype,
                targetName: "Quat"
            } ]), replaceProperty(Color, "Color", [ {
                name: "sub",
                newName: "subtract",
                target: Color,
                targetName: "Color"
            }, {
                name: "mul",
                newName: "multiply",
                target: Color,
                targetName: "Color"
            }, {
                name: "div",
                newName: "divide",
                target: Color,
                targetName: "Color"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Color,
                targetName: "Color"
            } ]), replaceProperty(Mat3, "Mat3", [ {
                name: "sub",
                newName: "subtract",
                target: Mat3,
                targetName: "Mat3"
            }, {
                name: "mul",
                newName: "multiply",
                target: Mat3,
                targetName: "Mat3"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Mat3,
                targetName: "Mat3"
            } ]), replaceProperty(Mat3.prototype, "Mat3", [ {
                name: "sub",
                newName: "subtract",
                target: Mat3.prototype,
                targetName: "Mat3"
            }, {
                name: "mul",
                newName: "multiply",
                target: Mat3.prototype,
                targetName: "Mat3"
            }, {
                name: "mulScalar",
                newName: "multiplyScalar",
                target: Mat3.prototype,
                targetName: "Mat3"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Mat3.prototype,
                targetName: "Mat3"
            } ]), replaceProperty(Mat4, "Mat4", [ {
                name: "sub",
                newName: "subtract",
                target: Mat4,
                targetName: "Mat4"
            }, {
                name: "mul",
                newName: "multiply",
                target: Mat4,
                targetName: "Mat4"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Mat4,
                targetName: "Mat4"
            } ]), replaceProperty(Mat4.prototype, "Mat4", [ {
                name: "sub",
                newName: "subtract",
                target: Mat4.prototype,
                targetName: "Mat4"
            }, {
                name: "mul",
                newName: "multiply",
                target: Mat4.prototype,
                targetName: "Mat4"
            }, {
                name: "mulScalar",
                newName: "multiplyScalar",
                target: Mat4.prototype,
                targetName: "Mat4"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Mat4.prototype,
                targetName: "Mat4"
            } ]);
            var math = Object.freeze({
                bits: bits,
                Vec2: Vec2,
                v2: v2,
                Vec3: Vec3,
                v3: v3,
                Vec4: Vec4,
                v4: v4,
                Quat: Quat,
                quat: quat,
                Mat3: Mat3,
                Mat4: Mat4,
                mat4: mat4,
                AffineTransform: AffineTransform,
                Size: Size,
                size: size,
                Rect: Rect,
                rect: rect,
                Color: Color,
                color: color,
                EPSILON: EPSILON,
                equals: equals,
                approx: approx,
                clamp: clamp,
                clamp01: clamp01,
                lerp: lerp,
                toRadian: toRadian,
                toDegree: toDegree,
                random: random,
                randomRange: randomRange,
                randomRangeInt: randomRangeInt,
                pseudoRandom: pseudoRandom,
                pseudoRandomRange: pseudoRandomRange,
                pseudoRandomRangeInt: pseudoRandomRangeInt,
                nextPow2: nextPow2$1,
                repeat: repeat,
                pingPong: pingPong,
                inverseLerp: inverseLerp
            });
            exports("math", math);
            var enums = {
                SHAPE_RAY: 1,
                SHAPE_LINE: 2,
                SHAPE_SPHERE: 4,
                SHAPE_AABB: 8,
                SHAPE_OBB: 16,
                SHAPE_PLANE: 32,
                SHAPE_TRIANGLE: 64,
                SHAPE_FRUSTUM: 128,
                SHAPE_FRUSTUM_ACCURATE: 256
            }, X = new Vec3(), Y = new Vec3(), Z = new Vec3(), d = new Vec3(), min$1 = new Vec3(), max$1 = new Vec3(), u = new Array(3), e = new Array(3);
            function point_plane(point, plane_) {
                return Vec3.dot(plane_.n, point) - plane_.d;
            }
            function pt_point_aabb(out, point, aabb_) {
                return Vec3.copy(out, point), Vec3.subtract(min$1, aabb_.center, aabb_.halfExtents), 
                Vec3.add(max$1, aabb_.center, aabb_.halfExtents), out.x = out.x < min$1.x ? min$1.x : out.x, 
                out.y = out.y < min$1.x ? min$1.y : out.y, out.z = out.z < min$1.x ? min$1.z : out.z, 
                out.x = out.x > max$1.x ? max$1.x : out.x, out.y = out.y > max$1.x ? max$1.y : out.y, 
                out.z = out.z > max$1.x ? max$1.z : out.z, out;
            }
            function pt_point_obb(out, point, obb_) {
                Vec3.set(X, obb_.orientation.m00, obb_.orientation.m01, obb_.orientation.m02), Vec3.set(Y, obb_.orientation.m03, obb_.orientation.m04, obb_.orientation.m05), 
                Vec3.set(Z, obb_.orientation.m06, obb_.orientation.m07, obb_.orientation.m08), u[0] = X, 
                u[1] = Y, u[2] = Z, e[0] = obb_.halfExtents.x, e[1] = obb_.halfExtents.y, e[2] = obb_.halfExtents.z, 
                Vec3.subtract(d, point, obb_.center), Vec3.set(out, obb_.center.x, obb_.center.y, obb_.center.z);
                for (var i = 0; i < 3; i++) {
                    var dist = Vec3.dot(d, u[i]);
                    dist > e[i] && (dist = e[i]), dist < -e[i] && (dist = -e[i]), out.x += dist * u[i].x, 
                    out.y += dist * u[i].y, out.z += dist * u[i].z;
                }
                return out;
            }
            var pt, ab, pq, pa, pb, pc, pd, m, tmp, aMin, aMax, bMin, bMax, distance = Object.freeze({
                point_plane: point_plane,
                pt_point_plane: function pt_point_plane(out, point, plane_) {
                    var t = point_plane(point, plane_);
                    return Vec3.subtract(out, point, Vec3.multiplyScalar(out, plane_.n, t));
                },
                pt_point_aabb: pt_point_aabb,
                pt_point_obb: pt_point_obb
            }), ray_plane = (pt = new Vec3(0, 0, 0), function(ray, plane) {
                var denom = Vec3.dot(ray.d, plane.n);
                if (Math.abs(denom) < Number.EPSILON) return 0;
                Vec3.multiplyScalar(pt, plane.n, plane.d);
                var t = Vec3.dot(Vec3.subtract(pt, pt, ray.o), plane.n) / denom;
                return t < 0 ? 0 : t;
            }), line_plane = (ab = new Vec3(0, 0, 0), function(line, plane) {
                Vec3.subtract(ab, line.e, line.s);
                var t = (plane.d - Vec3.dot(line.s, plane.n)) / Vec3.dot(ab, plane.n);
                return t < 0 || 1 < t ? 0 : t;
            }), ray_triangle = function() {
                var ab = new Vec3(0, 0, 0), ac = new Vec3(0, 0, 0), pvec = new Vec3(0, 0, 0), tvec = new Vec3(0, 0, 0), qvec = new Vec3(0, 0, 0);
                return function(ray, triangle, doubleSided) {
                    Vec3.subtract(ab, triangle.b, triangle.a), Vec3.subtract(ac, triangle.c, triangle.a), 
                    Vec3.cross(pvec, ray.d, ac);
                    var det = Vec3.dot(ab, pvec);
                    if (det < Number.EPSILON && (!doubleSided || det > -Number.EPSILON)) return 0;
                    var inv_det = 1 / det;
                    Vec3.subtract(tvec, ray.o, triangle.a);
                    var u = Vec3.dot(tvec, pvec) * inv_det;
                    if (u < 0 || 1 < u) return 0;
                    Vec3.cross(qvec, tvec, ab);
                    var v = Vec3.dot(ray.d, qvec) * inv_det;
                    if (v < 0 || 1 < u + v) return 0;
                    var t = Vec3.dot(ac, qvec) * inv_det;
                    return t < 0 ? 0 : t;
                };
            }(), line_triangle = function() {
                var ab = new Vec3(0, 0, 0), ac = new Vec3(0, 0, 0), qp = new Vec3(0, 0, 0), ap = new Vec3(0, 0, 0), n = new Vec3(0, 0, 0), e = new Vec3(0, 0, 0);
                return function(line, triangle, outPt) {
                    Vec3.subtract(ab, triangle.b, triangle.a), Vec3.subtract(ac, triangle.c, triangle.a), 
                    Vec3.subtract(qp, line.s, line.e), Vec3.cross(n, ab, ac);
                    var det = Vec3.dot(qp, n);
                    if (det <= 0) return 0;
                    Vec3.subtract(ap, line.s, triangle.a);
                    var t = Vec3.dot(ap, n);
                    if (t < 0 || det < t) return 0;
                    Vec3.cross(e, qp, ap);
                    var v = Vec3.dot(ac, e);
                    if (v < 0 || det < v) return 0;
                    var w = -Vec3.dot(ab, e);
                    if (w < 0 || det < v + w) return 0;
                    if (outPt) {
                        var invDet = 1 / det, u = 1 - (v *= invDet) - (w *= invDet);
                        Vec3.set(outPt, triangle.a.x * u + triangle.b.x * v + triangle.c.x * w, triangle.a.y * u + triangle.b.y * v + triangle.c.y * w, triangle.a.z * u + triangle.b.z * v + triangle.c.z * w);
                    }
                    return 1;
                };
            }(), line_quad = (pq = new Vec3(0, 0, 0), pa = new Vec3(0, 0, 0), pb = new Vec3(0, 0, 0), 
            pc = new Vec3(0, 0, 0), pd = new Vec3(0, 0, 0), m = new Vec3(0, 0, 0), tmp = new Vec3(0, 0, 0), 
            function(p, q, a, b, c, d, outPt) {
                Vec3.subtract(pq, q, p), Vec3.subtract(pa, a, p), Vec3.subtract(pb, b, p), Vec3.subtract(pc, c, p), 
                Vec3.cross(m, pc, pq);
                var v = Vec3.dot(pa, m);
                if (0 <= v) {
                    var u = -Vec3.dot(pb, m);
                    if (u < 0) return 0;
                    var w = Vec3.dot(Vec3.cross(tmp, pq, pb), pa);
                    if (w < 0) return 0;
                    if (outPt) {
                        var denom = 1 / (u + v + w);
                        u *= denom, v *= denom, w *= denom, Vec3.set(outPt, a.x * u + b.x * v + c.x * w, a.y * u + b.y * v + c.y * w, a.z * u + b.z * v + c.z * w);
                    }
                } else {
                    Vec3.subtract(pd, d, p);
                    var _u = Vec3.dot(pd, m);
                    if (_u < 0) return 0;
                    var _w = Vec3.dot(Vec3.cross(tmp, pq, pa), pd);
                    if (_w < 0) return 0;
                    if (outPt) {
                        var _denom = 1 / (_u + (v = -v) + _w);
                        _u *= _denom, v *= _denom, _w *= _denom, Vec3.set(outPt, a.x * _u + d.x * v + c.x * _w, a.y * _u + d.y * v + c.y * _w, a.z * _u + d.z * v + c.z * _w);
                    }
                }
                return 1;
            }), ray_sphere = function() {
                var e = new Vec3(0, 0, 0);
                return function(ray, sphere) {
                    var r = sphere.radius, c = sphere.center, o = ray.o, d = ray.d, rSq = r * r;
                    Vec3.subtract(e, c, o);
                    var eSq = e.lengthSqr(), aLength = Vec3.dot(e, d), fSq = rSq - (eSq - aLength * aLength);
                    if (fSq < 0) return 0;
                    var f = Math.sqrt(fSq), t = eSq < rSq ? aLength + f : aLength - f;
                    return t < 0 ? 0 : t;
                };
            }(), ray_aabb = function() {
                var min = new Vec3(), max = new Vec3();
                return function(ray, aabb) {
                    var o = ray.o, d = ray.d, ix = 1 / d.x, iy = 1 / d.y, iz = 1 / d.z;
                    Vec3.subtract(min, aabb.center, aabb.halfExtents), Vec3.add(max, aabb.center, aabb.halfExtents);
                    var t1 = (min.x - o.x) * ix, t2 = (max.x - o.x) * ix, t3 = (min.y - o.y) * iy, t4 = (max.y - o.y) * iy, t5 = (min.z - o.z) * iz, t6 = (max.z - o.z) * iz, tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6)), tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
                    return tmax < 0 || tmax < tmin ? 0 : tmin;
                };
            }(), ray_obb = function() {
                var center = new Vec3(), o = new Vec3(), d = new Vec3(), X = new Vec3(), Y = new Vec3(), Z = new Vec3(), p = new Vec3(), size = new Array(3), f = new Array(3), e = new Array(3), t = new Array(6);
                return function(ray, obb) {
                    size[0] = obb.halfExtents.x, size[1] = obb.halfExtents.y, size[2] = obb.halfExtents.z, 
                    center = obb.center, o = ray.o, d = ray.d, Vec3.set(X, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02), 
                    Vec3.set(Y, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05), Vec3.set(Z, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08), 
                    Vec3.subtract(p, center, o), f[0] = Vec3.dot(X, d), f[1] = Vec3.dot(Y, d), f[2] = Vec3.dot(Z, d), 
                    e[0] = Vec3.dot(X, p), e[1] = Vec3.dot(Y, p), e[2] = Vec3.dot(Z, p);
                    for (var i = 0; i < 3; ++i) {
                        if (0 === f[i]) {
                            if (0 < -e[i] - size[i] || -e[i] + size[i] < 0) return 0;
                            f[i] = 1e-7;
                        }
                        t[2 * i + 0] = (e[i] + size[i]) / f[i], t[2 * i + 1] = (e[i] - size[i]) / f[i];
                    }
                    var tmin = Math.max(Math.max(Math.min(t[0], t[1]), Math.min(t[2], t[3])), Math.min(t[4], t[5])), tmax = Math.min(Math.min(Math.max(t[0], t[1]), Math.max(t[2], t[3])), Math.max(t[4], t[5]));
                    return tmax < 0 || tmax < tmin || tmin < 0 ? 0 : tmin;
                };
            }(), aabb_aabb = (aMin = new Vec3(), aMax = new Vec3(), bMin = new Vec3(), bMax = new Vec3(), 
            function(aabb1, aabb2) {
                return Vec3.subtract(aMin, aabb1.center, aabb1.halfExtents), Vec3.add(aMax, aabb1.center, aabb1.halfExtents), 
                Vec3.subtract(bMin, aabb2.center, aabb2.halfExtents), Vec3.add(bMax, aabb2.center, aabb2.halfExtents), 
                aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
            });
            function getOBBVertices(c, e, a1, a2, a3, out) {
                Vec3.set(out[0], c.x + a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y + a3.z * e.z), 
                Vec3.set(out[1], c.x - a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y + a3.z * e.z), 
                Vec3.set(out[2], c.x + a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y + a3.z * e.z), 
                Vec3.set(out[3], c.x + a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y - a3.z * e.z), 
                Vec3.set(out[4], c.x - a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y - a3.z * e.z), 
                Vec3.set(out[5], c.x + a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y - a3.z * e.z), 
                Vec3.set(out[6], c.x - a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y - a3.z * e.z), 
                Vec3.set(out[7], c.x - a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y + a3.z * e.z);
            }
            function getInterval(vertices, axis) {
                for (var min = Vec3.dot(axis, vertices[0]), max = min, i = 1; i < 8; ++i) {
                    var projection = Vec3.dot(axis, vertices[i]);
                    min = projection < min ? projection : min, max = max < projection ? projection : max;
                }
                return [ min, max ];
            }
            function aabb_plane(aabb, plane) {
                var r = aabb.halfExtents.x * Math.abs(plane.n.x) + aabb.halfExtents.y * Math.abs(plane.n.y) + aabb.halfExtents.z * Math.abs(plane.n.z), dot = Vec3.dot(plane.n, aabb.center);
                return dot + r < plane.d ? -1 : dot - r > plane.d ? 0 : 1;
            }
            function aabb_frustum(aabb, frustum) {
                for (var i = 0; i < frustum.planes.length; i++) if (-1 === aabb_plane(aabb, frustum.planes[i])) return 0;
                return 1;
            }
            var aabb_obb = function() {
                for (var test = new Array(15), i = 0; i < 15; i++) test[i] = new Vec3(0, 0, 0);
                for (var vertices = new Array(8), vertices2 = new Array(8), _i = 0; _i < 8; _i++) vertices[_i] = new Vec3(0, 0, 0), 
                vertices2[_i] = new Vec3(0, 0, 0);
                var min = new Vec3(), max = new Vec3();
                return function(aabb, obb) {
                    Vec3.set(test[0], 1, 0, 0), Vec3.set(test[1], 0, 1, 0), Vec3.set(test[2], 0, 0, 1), 
                    Vec3.set(test[3], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02), 
                    Vec3.set(test[4], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05), 
                    Vec3.set(test[5], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
                    for (var _i2 = 0; _i2 < 3; ++_i2) Vec3.cross(test[6 + 3 * _i2 + 0], test[_i2], test[0]), 
                    Vec3.cross(test[6 + 3 * _i2 + 1], test[_i2], test[1]), Vec3.cross(test[6 + 3 * _i2 + 1], test[_i2], test[2]);
                    Vec3.subtract(min, aabb.center, aabb.halfExtents), Vec3.add(max, aabb.center, aabb.halfExtents), 
                    function getAABBVertices(min, max, out) {
                        Vec3.set(out[0], min.x, max.y, max.z), Vec3.set(out[1], min.x, max.y, min.z), Vec3.set(out[2], min.x, min.y, max.z), 
                        Vec3.set(out[3], min.x, min.y, min.z), Vec3.set(out[4], max.x, max.y, max.z), Vec3.set(out[5], max.x, max.y, min.z), 
                        Vec3.set(out[6], max.x, min.y, max.z), Vec3.set(out[7], max.x, min.y, min.z);
                    }(min, max, vertices), getOBBVertices(obb.center, obb.halfExtents, test[3], test[4], test[5], vertices2);
                    for (var j = 0; j < 15; ++j) {
                        var a = getInterval(vertices, test[j]), b = getInterval(vertices2, test[j]);
                        if (b[0] > a[1] || a[0] > b[1]) return 0;
                    }
                    return 1;
                };
            }(), aabb_frustum_accurate = function() {
                for (var tmp = new Array(8), out1 = 0, out2 = 0, i = 0; i < tmp.length; i++) tmp[i] = new Vec3(0, 0, 0);
                return function(aabb, frustum) {
                    for (var result = 0, intersects = !1, _i3 = 0; _i3 < frustum.planes.length; _i3++) {
                        if (-1 === (result = aabb_plane(aabb, frustum.planes[_i3]))) return 0;
                        1 === result && (intersects = !0);
                    }
                    if (!intersects) return 1;
                    for (var _i4 = 0; _i4 < frustum.vertices.length; _i4++) Vec3.subtract(tmp[_i4], frustum.vertices[_i4], aabb.center);
                    for (var _i5 = out2 = out1 = 0; _i5 < frustum.vertices.length; _i5++) tmp[_i5].x > aabb.halfExtents.x ? out1++ : tmp[_i5].x < -aabb.halfExtents.x && out2++;
                    if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
                    for (var _i6 = out2 = out1 = 0; _i6 < frustum.vertices.length; _i6++) tmp[_i6].y > aabb.halfExtents.y ? out1++ : tmp[_i6].y < -aabb.halfExtents.y && out2++;
                    if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
                    for (var _i7 = out2 = out1 = 0; _i7 < frustum.vertices.length; _i7++) tmp[_i7].z > aabb.halfExtents.z ? out1++ : tmp[_i7].z < -aabb.halfExtents.z && out2++;
                    return out1 === frustum.vertices.length || out2 === frustum.vertices.length ? 0 : 1;
                };
            }(), obb_point = function() {
                var tmp = new Vec3(0, 0, 0), m3 = new Mat3();
                return function(obb, point) {
                    return Vec3.subtract(tmp, point, obb.center), Vec3.transformMat3(tmp, tmp, Mat3.transpose(m3, obb.orientation)), 
                    function lessThan(a, b) {
                        return Math.abs(a.x) < b.x && Math.abs(a.y) < b.y && Math.abs(a.z) < b.z;
                    }(tmp, obb.halfExtents);
                };
            }(), obb_plane = function(obb, plane) {
                var r = obb.halfExtents.x * absDot(plane.n, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02) + obb.halfExtents.y * absDot(plane.n, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05) + obb.halfExtents.z * absDot(plane.n, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08), dot = Vec3.dot(plane.n, obb.center);
                return dot + r < plane.d ? -1 : dot - r > plane.d ? 0 : 1;
            };
            function absDot(n, x, y, z) {
                return Math.abs(n.x * x + n.y * y + n.z * z);
            }
            function obb_frustum(obb, frustum) {
                for (var i = 0; i < frustum.planes.length; i++) if (-1 === obb_plane(obb, frustum.planes[i])) return 0;
                return 1;
            }
            function sphere_plane(sphere, plane) {
                var dot = Vec3.dot(plane.n, sphere.center), r = sphere.radius * plane.n.length();
                return dot + r < plane.d ? -1 : dot - r > plane.d ? 0 : 1;
            }
            function sphere_frustum(sphere, frustum) {
                for (var i = 0; i < frustum.planes.length; i++) if (-1 === sphere_plane(sphere, frustum.planes[i])) return 0;
                return 1;
            }
            function sphere_sphere(sphere0, sphere1) {
                var r = sphere0.radius + sphere1.radius;
                return Vec3.squaredDistance(sphere0.center, sphere1.center) < r * r;
            }
            var obb_frustum_accurate = function() {
                for (var tmp = new Array(8), dist = 0, out1 = 0, out2 = 0, i = 0; i < tmp.length; i++) tmp[i] = new Vec3(0, 0, 0);
                function dot(n, x, y, z) {
                    return n.x * x + n.y * y + n.z * z;
                }
                return function(obb, frustum) {
                    for (var result = 0, intersects = !1, _i8 = 0; _i8 < frustum.planes.length; _i8++) {
                        if (-1 === (result = obb_plane(obb, frustum.planes[_i8]))) return 0;
                        1 === result && (intersects = !0);
                    }
                    if (!intersects) return 1;
                    for (var _i9 = 0; _i9 < frustum.vertices.length; _i9++) Vec3.subtract(tmp[_i9], frustum.vertices[_i9], obb.center);
                    for (var _i10 = out2 = out1 = 0; _i10 < frustum.vertices.length; _i10++) (dist = dot(tmp[_i10], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02)) > obb.halfExtents.x ? out1++ : dist < -obb.halfExtents.x && out2++;
                    if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
                    for (var _i11 = out2 = out1 = 0; _i11 < frustum.vertices.length; _i11++) (dist = dot(tmp[_i11], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05)) > obb.halfExtents.y ? out1++ : dist < -obb.halfExtents.y && out2++;
                    if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
                    for (var _i12 = out2 = out1 = 0; _i12 < frustum.vertices.length; _i12++) (dist = dot(tmp[_i12], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08)) > obb.halfExtents.z ? out1++ : dist < -obb.halfExtents.z && out2++;
                    return out1 === frustum.vertices.length || out2 === frustum.vertices.length ? 0 : 1;
                };
            }(), obb_obb = function() {
                for (var test = new Array(15), i = 0; i < 15; i++) test[i] = new Vec3(0, 0, 0);
                for (var vertices = new Array(8), vertices2 = new Array(8), _i13 = 0; _i13 < 8; _i13++) vertices[_i13] = new Vec3(0, 0, 0), 
                vertices2[_i13] = new Vec3(0, 0, 0);
                return function(obb1, obb2) {
                    Vec3.set(test[0], obb1.orientation.m00, obb1.orientation.m01, obb1.orientation.m02), 
                    Vec3.set(test[1], obb1.orientation.m03, obb1.orientation.m04, obb1.orientation.m05), 
                    Vec3.set(test[2], obb1.orientation.m06, obb1.orientation.m07, obb1.orientation.m08), 
                    Vec3.set(test[3], obb2.orientation.m00, obb2.orientation.m01, obb2.orientation.m02), 
                    Vec3.set(test[4], obb2.orientation.m03, obb2.orientation.m04, obb2.orientation.m05), 
                    Vec3.set(test[5], obb2.orientation.m06, obb2.orientation.m07, obb2.orientation.m08);
                    for (var _i14 = 0; _i14 < 3; ++_i14) Vec3.cross(test[6 + 3 * _i14 + 0], test[_i14], test[0]), 
                    Vec3.cross(test[6 + 3 * _i14 + 1], test[_i14], test[1]), Vec3.cross(test[6 + 3 * _i14 + 1], test[_i14], test[2]);
                    getOBBVertices(obb1.center, obb1.halfExtents, test[0], test[1], test[2], vertices), 
                    getOBBVertices(obb2.center, obb2.halfExtents, test[3], test[4], test[5], vertices2);
                    for (var _i15 = 0; _i15 < 15; ++_i15) {
                        var a = getInterval(vertices, test[_i15]), b = getInterval(vertices2, test[_i15]);
                        if (b[0] > a[1] || a[0] > b[1]) return 0;
                    }
                    return 1;
                };
            }(), sphere_frustum_accurate = function() {
                var pt = new Vec3(0, 0, 0), map = [ 1, -1, 1, -1, 1, -1 ];
                return function(sphere, frustum) {
                    for (var i = 0; i < 6; i++) {
                        var plane = frustum.planes[i], r = sphere.radius, c = sphere.center, n = plane.n, d = plane.d, dot = Vec3.dot(n, c);
                        if (dot + r < d) return 0;
                        if (!(d < dot - r)) {
                            Vec3.add(pt, c, Vec3.multiplyScalar(pt, n, r));
                            for (var j = 0; j < 6; j++) if (j !== i && j !== i + map[i]) {
                                var test = frustum.planes[j];
                                if (Vec3.dot(test.n, pt) < test.d) return 0;
                            }
                        }
                    }
                    return 1;
                };
            }(), sphere_aabb = function() {
                var pt = new Vec3();
                return function(sphere, aabb) {
                    return pt_point_aabb(pt, sphere.center, aabb), Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
                };
            }(), sphere_obb = function() {
                var pt = new Vec3();
                return function(sphere, obb) {
                    return pt_point_obb(pt, sphere.center, obb), Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
                };
            }(), intersect = {
                ray_sphere: ray_sphere,
                ray_aabb: ray_aabb,
                ray_obb: ray_obb,
                ray_plane: ray_plane,
                ray_triangle: ray_triangle,
                line_plane: line_plane,
                line_triangle: line_triangle,
                line_quad: line_quad,
                sphere_sphere: sphere_sphere,
                sphere_aabb: sphere_aabb,
                sphere_obb: sphere_obb,
                sphere_plane: sphere_plane,
                sphere_frustum: sphere_frustum,
                sphere_frustum_accurate: sphere_frustum_accurate,
                aabb_aabb: aabb_aabb,
                aabb_obb: aabb_obb,
                aabb_plane: aabb_plane,
                aabb_frustum: aabb_frustum,
                aabb_frustum_accurate: aabb_frustum_accurate,
                obb_obb: obb_obb,
                obb_plane: obb_plane,
                obb_frustum: obb_frustum,
                obb_frustum_accurate: obb_frustum_accurate,
                obb_point: obb_point,
                resolve: function resolve(g1, g2, argument_2) {
                    var outPt = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : null, type1 = g1._type, type2 = g2._type, resolver = this[type1 | type2];
                    return type1 < type2 ? resolver(g1, g2, outPt) : resolver(g2, g1, outPt);
                }
            };
            intersect[enums.SHAPE_RAY | enums.SHAPE_SPHERE] = ray_sphere, intersect[enums.SHAPE_RAY | enums.SHAPE_AABB] = ray_aabb, 
            intersect[enums.SHAPE_RAY | enums.SHAPE_OBB] = ray_obb, intersect[enums.SHAPE_RAY | enums.SHAPE_PLANE] = ray_plane, 
            intersect[enums.SHAPE_RAY | enums.SHAPE_TRIANGLE] = ray_triangle, intersect[enums.SHAPE_LINE | enums.SHAPE_PLANE] = line_plane, 
            intersect[enums.SHAPE_LINE | enums.SHAPE_TRIANGLE] = line_triangle, intersect[enums.SHAPE_SPHERE] = sphere_sphere, 
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_AABB] = sphere_aabb, intersect[enums.SHAPE_SPHERE | enums.SHAPE_OBB] = sphere_obb, 
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_PLANE] = sphere_plane, intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM] = sphere_frustum, 
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM_ACCURATE] = sphere_frustum_accurate, 
            intersect[enums.SHAPE_AABB] = aabb_aabb, intersect[enums.SHAPE_AABB | enums.SHAPE_OBB] = aabb_obb, 
            intersect[enums.SHAPE_AABB | enums.SHAPE_PLANE] = aabb_plane, intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM] = aabb_frustum, 
            intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM_ACCURATE] = aabb_frustum_accurate, 
            intersect[enums.SHAPE_OBB] = obb_obb, intersect[enums.SHAPE_OBB | enums.SHAPE_PLANE] = obb_plane, 
            intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM] = obb_frustum, intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM_ACCURATE] = obb_frustum_accurate;
            var line = function() {
                function line() {
                    var sx = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, sy = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, sz = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, ex = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, ey = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, ez = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : -1;
                    _classCallCheck(this, line), this.s = void 0, this.e = void 0, this._type = void 0, 
                    this._type = enums.SHAPE_LINE, this.s = new Vec3(sx, sy, sz), this.e = new Vec3(ex, ey, ez);
                }
                return _createClass(line, null, [ {
                    key: "create",
                    value: function create(sx, sy, sz, ex, ey, ez) {
                        return new line(sx, sy, sz, ex, ey, ez);
                    }
                }, {
                    key: "clone",
                    value: function clone(a) {
                        return new line(a.s.x, a.s.y, a.s.z, a.e.x, a.e.y, a.e.z);
                    }
                }, {
                    key: "copy",
                    value: function copy(out, a) {
                        return Vec3.copy(out.s, a.s), Vec3.copy(out.e, a.e), out;
                    }
                }, {
                    key: "fromPoints",
                    value: function fromPoints(out, start, end) {
                        return Vec3.copy(out.s, start), Vec3.copy(out.e, end), out;
                    }
                }, {
                    key: "set",
                    value: function set(out, sx, sy, sz, ex, ey, ez) {
                        return out.s.x = sx, out.s.y = sy, out.s.z = sz, out.e.x = ex, out.e.y = ey, out.e.z = ez, 
                        out;
                    }
                }, {
                    key: "len",
                    value: function len(a) {
                        return Vec3.distance(a.s, a.e);
                    }
                } ]), _createClass(line, [ {
                    key: "length",
                    value: function length() {
                        return Vec3.distance(this.s, this.e);
                    }
                } ]), line;
            }(), v1 = new Vec3(0, 0, 0), v2$1 = new Vec3(0, 0, 0), temp_mat = cc.mat4(), temp_vec4 = cc.v4(), plane = function() {
                function plane() {
                    var nx = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, ny = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1, nz = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0;
                    _classCallCheck(this, plane), this.n = void 0, this.d = void 0, this._type = void 0, 
                    this._type = enums.SHAPE_PLANE, this.n = new Vec3(nx, ny, nz), this.d = d;
                }
                return _createClass(plane, null, [ {
                    key: "create",
                    value: function create(nx, ny, nz, d) {
                        return new plane(nx, ny, nz, d);
                    }
                }, {
                    key: "clone",
                    value: function clone(p) {
                        return new plane(p.n.x, p.n.y, p.n.z, p.d);
                    }
                }, {
                    key: "copy",
                    value: function copy(out, p) {
                        return Vec3.copy(out.n, p.n), out.d = p.d, out;
                    }
                }, {
                    key: "fromPoints",
                    value: function fromPoints(out, a, b, c) {
                        return Vec3.subtract(v1, b, a), Vec3.subtract(v2$1, c, a), Vec3.normalize(out.n, Vec3.cross(out.n, v1, v2$1)), 
                        out.d = Vec3.dot(out.n, a), out;
                    }
                }, {
                    key: "set",
                    value: function set(out, nx, ny, nz, d) {
                        return out.n.x = nx, out.n.y = ny, out.n.z = nz, out.d = d, out;
                    }
                }, {
                    key: "fromNormalAndPoint",
                    value: function fromNormalAndPoint(out, normal, point) {
                        return Vec3.copy(out.n, normal), out.d = Vec3.dot(normal, point), out;
                    }
                }, {
                    key: "normalize",
                    value: function normalize(out, a) {
                        var len = a.n.length();
                        return Vec3.normalize(out.n, a.n), 0 < len && (out.d = a.d / len), out;
                    }
                } ]), _createClass(plane, [ {
                    key: "transform",
                    value: function transform(mat) {
                        Mat4.invert(temp_mat, mat), Mat4.transpose(temp_mat, temp_mat), Vec4.set(temp_vec4, this.n.x, this.n.y, this.n.z, this.d), 
                        Vec4.transformMat4(temp_vec4, temp_vec4, temp_mat), Vec3.set(this.n, temp_vec4.x, temp_vec4.y, temp_vec4.z), 
                        this.d = temp_vec4.w;
                    }
                } ]), plane;
            }(), ray = function() {
                function ray() {
                    var ox = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, oy = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, oz = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, dx = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, dy = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, dz = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : -1;
                    _classCallCheck(this, ray), this.o = void 0, this.d = void 0, this._type = void 0, 
                    this._type = enums.SHAPE_RAY, this.o = new Vec3(ox, oy, oz), this.d = new Vec3(dx, dy, dz);
                }
                return _createClass(ray, null, [ {
                    key: "create",
                    value: function create(argument_0, argument_1, argument_2, argument_3, argument_4, argument_5) {
                        return new ray(0 < arguments.length && void 0 !== argument_0 ? argument_0 : 0, 1 < arguments.length && void 0 !== argument_1 ? argument_1 : 0, 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0, 3 < arguments.length && void 0 !== argument_3 ? argument_3 : 0, 4 < arguments.length && void 0 !== argument_4 ? argument_4 : 0, 5 < arguments.length && void 0 !== argument_5 ? argument_5 : 1);
                    }
                }, {
                    key: "clone",
                    value: function clone(a) {
                        return new ray(a.o.x, a.o.y, a.o.z, a.d.x, a.d.y, a.d.z);
                    }
                }, {
                    key: "copy",
                    value: function copy(out, a) {
                        return Vec3.copy(out.o, a.o), Vec3.copy(out.d, a.d), out;
                    }
                }, {
                    key: "fromPoints",
                    value: function fromPoints(out, origin, target) {
                        return Vec3.copy(out.o, origin), Vec3.normalize(out.d, Vec3.subtract(out.d, target, origin)), 
                        out;
                    }
                }, {
                    key: "set",
                    value: function set(out, ox, oy, oz, dx, dy, dz) {
                        return out.o.x = ox, out.o.y = oy, out.o.z = oz, out.d.x = dx, out.d.y = dy, out.d.z = dz, 
                        out;
                    }
                } ]), ray;
            }(), triangle = function() {
                function triangle() {
                    var ax = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, ay = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, az = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, bx = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1, by = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, bz = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0, cx = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : 0, cy = 7 < arguments.length && void 0 !== arguments[7] ? arguments[7] : 1, cz = 8 < arguments.length && void 0 !== arguments[8] ? arguments[8] : 0;
                    _classCallCheck(this, triangle), this.a = void 0, this.b = void 0, this.c = void 0, 
                    this._type = void 0, this._type = enums.SHAPE_TRIANGLE, this.a = new Vec3(ax, ay, az), 
                    this.b = new Vec3(bx, by, bz), this.c = new Vec3(cx, cy, cz);
                }
                return _createClass(triangle, null, [ {
                    key: "create",
                    value: function create(argument_0, argument_1, argument_2, argument_3, argument_4, argument_5, argument_6, argument_7, argument_8) {
                        return new triangle(0 < arguments.length && void 0 !== argument_0 ? argument_0 : 1, 1 < arguments.length && void 0 !== argument_1 ? argument_1 : 0, 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0, 3 < arguments.length && void 0 !== argument_3 ? argument_3 : 0, 4 < arguments.length && void 0 !== argument_4 ? argument_4 : 0, 5 < arguments.length && void 0 !== argument_5 ? argument_5 : 0, 6 < arguments.length && void 0 !== argument_6 ? argument_6 : 0, 7 < arguments.length && void 0 !== argument_7 ? argument_7 : 0, 8 < arguments.length && void 0 !== argument_8 ? argument_8 : 1);
                    }
                }, {
                    key: "clone",
                    value: function clone(t) {
                        return new triangle(t.a.x, t.a.y, t.a.z, t.b.x, t.b.y, t.b.z, t.c.x, t.c.y, t.c.z);
                    }
                }, {
                    key: "copy",
                    value: function copy(out, t) {
                        return Vec3.copy(out.a, t.a), Vec3.copy(out.b, t.b), Vec3.copy(out.c, t.c), out;
                    }
                }, {
                    key: "fromPoints",
                    value: function fromPoints(out, a, b, c) {
                        return Vec3.copy(out.a, a), Vec3.copy(out.b, b), Vec3.copy(out.c, c), out;
                    }
                }, {
                    key: "set",
                    value: function set(out, ax, ay, az, bx, by, bz, cx, cy, cz) {
                        return out.a.x = ax, out.a.y = ay, out.a.z = az, out.b.x = bx, out.b.y = by, out.b.z = bz, 
                        out.c.x = cx, out.c.y = cy, out.c.z = cz, out;
                    }
                } ]), triangle;
            }(), _v3_tmp = new Vec3();
            function maxComponent(v) {
                return Math.max(Math.max(v.x, v.y), v.z);
            }
            function transform_extent_m4(out, extent, m4) {
                _m3_tmp.m00 = Math.abs(m4.m00), _m3_tmp.m01 = Math.abs(m4.m01), _m3_tmp.m02 = Math.abs(m4.m02), 
                _m3_tmp.m03 = Math.abs(m4.m04), _m3_tmp.m04 = Math.abs(m4.m05), _m3_tmp.m05 = Math.abs(m4.m06), 
                _m3_tmp.m06 = Math.abs(m4.m08), _m3_tmp.m07 = Math.abs(m4.m09), _m3_tmp.m08 = Math.abs(m4.m10), 
                Vec3.transformMat3(out, extent, _m3_tmp);
            }
            var sphere = function() {
                function sphere() {
                    var cx = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, cy = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, cz = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1;
                    _classCallCheck(this, sphere), this.center = void 0, this.radius = void 0, this._type = void 0, 
                    this._type = enums.SHAPE_SPHERE, this.center = new Vec3(cx, cy, cz), this.radius = r;
                }
                return _createClass(sphere, null, [ {
                    key: "create",
                    value: function create(cx, cy, cz, r) {
                        return new sphere(cx, cy, cz, r);
                    }
                }, {
                    key: "clone",
                    value: function clone(p) {
                        return new sphere(p.center.x, p.center.y, p.center.z, p.radius);
                    }
                }, {
                    key: "copy",
                    value: function copy(out, p) {
                        return Vec3.copy(out.center, p.center), out.radius = p.radius, out;
                    }
                }, {
                    key: "fromPoints",
                    value: function fromPoints(out, minPos, maxPos) {
                        return Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp, minPos, maxPos), .5), out.radius = .5 * Vec3.subtract(_v3_tmp, maxPos, minPos).length(), 
                        out;
                    }
                }, {
                    key: "set",
                    value: function set(out, cx, cy, cz, r) {
                        return out.center.x = cx, out.center.y = cy, out.center.z = cz, out.radius = r, 
                        out;
                    }
                } ]), _createClass(sphere, [ {
                    key: "clone",
                    value: function clone() {
                        return sphere.clone(this);
                    }
                }, {
                    key: "copy",
                    value: function copy(a) {
                        return sphere.copy(this, a);
                    }
                }, {
                    key: "getBoundary",
                    value: function getBoundary(minPos, maxPos) {
                        Vec3.set(minPos, this.center.x - this.radius, this.center.y - this.radius, this.center.z - this.radius), 
                        Vec3.set(maxPos, this.center.x + this.radius, this.center.y + this.radius, this.center.z + this.radius);
                    }
                }, {
                    key: "transform",
                    value: function transform(m, pos, rot, scale, out) {
                        Vec3.transformMat4(out.center, this.center, m), out.radius = this.radius * maxComponent(scale);
                    }
                }, {
                    key: "translateAndRotate",
                    value: function translateAndRotate(m, rot, out) {
                        Vec3.transformMat4(out.center, this.center, m);
                    }
                }, {
                    key: "setScale",
                    value: function setScale(scale, out) {
                        out.radius = this.radius * maxComponent(scale);
                    }
                } ]), sphere;
            }(), _v3_tmp$1 = new Vec3(), _v3_tmp2 = new Vec3(), _v3_tmp3 = new Vec3(), _v3_tmp4 = new Vec3(), _m3_tmp = new Mat3(), aabb = function() {
                function aabb() {
                    var px = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, py = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, pz = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, hw = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1, hh = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 1, hl = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 1;
                    _classCallCheck(this, aabb), this.center = void 0, this.halfExtents = void 0, this._type = enums.SHAPE_AABB, 
                    this.center = new Vec3(px, py, pz), this.halfExtents = new Vec3(hw, hh, hl);
                }
                return _createClass(aabb, [ {
                    key: "type",
                    get: function get() {
                        return this._type;
                    }
                } ], [ {
                    key: "create",
                    value: function create(px, py, pz, hw, hh, hl) {
                        return new aabb(px, py, pz, hw, hh, hl);
                    }
                }, {
                    key: "clone",
                    value: function clone(a) {
                        return new aabb(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z);
                    }
                }, {
                    key: "copy",
                    value: function copy(out, a) {
                        return Vec3.copy(out.center, a.center), Vec3.copy(out.halfExtents, a.halfExtents), 
                        out;
                    }
                }, {
                    key: "fromPoints",
                    value: function fromPoints(out, minPos, maxPos) {
                        return Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp$1, minPos, maxPos), .5), 
                        Vec3.multiplyScalar(out.halfExtents, Vec3.subtract(_v3_tmp2, maxPos, minPos), .5), 
                        out;
                    }
                }, {
                    key: "set",
                    value: function set(out, px, py, pz, hw, hh, hl) {
                        return Vec3.set(out.center, px, py, pz), Vec3.set(out.halfExtents, hw, hh, hl), 
                        out;
                    }
                }, {
                    key: "merge",
                    value: function merge(out, a, b) {
                        return Vec3.subtract(_v3_tmp$1, a.center, a.halfExtents), Vec3.subtract(_v3_tmp2, b.center, b.halfExtents), 
                        Vec3.add(_v3_tmp3, a.center, a.halfExtents), Vec3.add(_v3_tmp4, b.center, b.halfExtents), 
                        Vec3.max(_v3_tmp4, _v3_tmp3, _v3_tmp4), Vec3.min(_v3_tmp3, _v3_tmp$1, _v3_tmp2), 
                        aabb.fromPoints(out, _v3_tmp3, _v3_tmp4);
                    }
                }, {
                    key: "transform",
                    value: function transform(out, a, matrix) {
                        return Vec3.transformMat4(out.center, a.center, matrix), transform_extent_m4(out.halfExtents, a.halfExtents, matrix), 
                        out;
                    }
                } ]), _createClass(aabb, [ {
                    key: "getBoundary",
                    value: function getBoundary(minPos, maxPos) {
                        Vec3.subtract(minPos, this.center, this.halfExtents), Vec3.add(maxPos, this.center, this.halfExtents);
                    }
                }, {
                    key: "transform",
                    value: function transform(m, pos, rot, scale, out) {
                        Vec3.transformMat4(out.center, this.center, m), transform_extent_m4(out.halfExtents, this.halfExtents, m);
                    }
                }, {
                    key: "clone",
                    value: function clone() {
                        return aabb.clone(this);
                    }
                }, {
                    key: "copy",
                    value: function copy(a) {
                        return aabb.copy(this, a);
                    }
                } ]), aabb;
            }(), _v3_tmp$2 = new Vec3(), _v3_tmp2$1 = new Vec3(), _m3_tmp$1 = new Mat3(), obb = function() {
                function obb() {
                    var cx = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, cy = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, cz = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, hw = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1, hh = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 1, hl = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 1, ox_1 = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : 1, ox_2 = 7 < arguments.length && void 0 !== arguments[7] ? arguments[7] : 0, ox_3 = 8 < arguments.length && void 0 !== arguments[8] ? arguments[8] : 0, oy_1 = 9 < arguments.length && void 0 !== arguments[9] ? arguments[9] : 0, oy_2 = 10 < arguments.length && void 0 !== arguments[10] ? arguments[10] : 1, oy_3 = 11 < arguments.length && void 0 !== arguments[11] ? arguments[11] : 0, oz_1 = 12 < arguments.length && void 0 !== arguments[12] ? arguments[12] : 0, oz_2 = 13 < arguments.length && void 0 !== arguments[13] ? arguments[13] : 0, oz_3 = 14 < arguments.length && void 0 !== arguments[14] ? arguments[14] : 1;
                    _classCallCheck(this, obb), this.center = void 0, this.halfExtents = void 0, this.orientation = void 0, 
                    this._type = void 0, this._type = enums.SHAPE_OBB, this.center = new Vec3(cx, cy, cz), 
                    this.halfExtents = new Vec3(hw, hh, hl), this.orientation = new Mat3(ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
                }
                return _createClass(obb, [ {
                    key: "type",
                    get: function get() {
                        return this._type;
                    }
                } ], [ {
                    key: "create",
                    value: function create(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
                        return new obb(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
                    }
                }, {
                    key: "clone",
                    value: function clone(a) {
                        return new obb(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z, a.orientation.m00, a.orientation.m01, a.orientation.m02, a.orientation.m03, a.orientation.m04, a.orientation.m05, a.orientation.m06, a.orientation.m07, a.orientation.m08);
                    }
                }, {
                    key: "copy",
                    value: function copy(out, a) {
                        return Vec3.copy(out.center, a.center), Vec3.copy(out.halfExtents, a.halfExtents), 
                        Mat3.copy(out.orientation, a.orientation), out;
                    }
                }, {
                    key: "fromPoints",
                    value: function fromPoints(out, minPos, maxPos) {
                        return Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp$2, minPos, maxPos), .5), 
                        Vec3.multiplyScalar(out.halfExtents, Vec3.subtract(_v3_tmp2$1, maxPos, minPos), .5), 
                        Mat3.identity(out.orientation), out;
                    }
                }, {
                    key: "set",
                    value: function set(out, cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
                        return Vec3.set(out.center, cx, cy, cz), Vec3.set(out.halfExtents, hw, hh, hl), 
                        Mat3.set(out.orientation, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3), 
                        out;
                    }
                } ]), _createClass(obb, [ {
                    key: "getBoundary",
                    value: function getBoundary(minPos, maxPos) {
                        !function transform_extent_m3(out, extent, m3) {
                            _m3_tmp$1.m00 = Math.abs(m3.m00), _m3_tmp$1.m01 = Math.abs(m3.m01), _m3_tmp$1.m02 = Math.abs(m3.m02), 
                            _m3_tmp$1.m03 = Math.abs(m3.m03), _m3_tmp$1.m04 = Math.abs(m3.m04), _m3_tmp$1.m05 = Math.abs(m3.m05), 
                            _m3_tmp$1.m06 = Math.abs(m3.m06), _m3_tmp$1.m07 = Math.abs(m3.m07), _m3_tmp$1.m08 = Math.abs(m3.m08), 
                            Vec3.transformMat3(out, extent, _m3_tmp$1);
                        }(_v3_tmp$2, this.halfExtents, this.orientation), Vec3.subtract(minPos, this.center, _v3_tmp$2), 
                        Vec3.add(maxPos, this.center, _v3_tmp$2);
                    }
                }, {
                    key: "transform",
                    value: function transform(m, pos, rot, scale, out) {
                        Vec3.transformMat4(out.center, this.center, m), Mat3.fromQuat(out.orientation, rot), 
                        Vec3.multiply(out.halfExtents, this.halfExtents, scale);
                    }
                }, {
                    key: "translateAndRotate",
                    value: function translateAndRotate(m, rot, out) {
                        Vec3.transformMat4(out.center, this.center, m), Mat3.fromQuat(out.orientation, rot);
                    }
                }, {
                    key: "setScale",
                    value: function setScale(scale, out) {
                        Vec3.multiply(out.halfExtents, this.halfExtents, scale);
                    }
                } ]), obb;
            }(), _v = new Array(8);
            _v[0] = new Vec3(1, 1, 1), _v[1] = new Vec3(-1, 1, 1), _v[2] = new Vec3(-1, -1, 1), 
            _v[3] = new Vec3(1, -1, 1), _v[4] = new Vec3(1, 1, -1), _v[5] = new Vec3(-1, 1, -1), 
            _v[6] = new Vec3(-1, -1, -1), _v[7] = new Vec3(1, -1, -1);
            var frustum = function() {
                function frustum() {
                    _classCallCheck(this, frustum), this.planes = void 0, this.vertices = void 0, this._type = void 0, 
                    this._type = enums.SHAPE_FRUSTUM, this.planes = new Array(6);
                    for (var i = 0; i < 6; ++i) this.planes[i] = plane.create(0, 0, 0, 0);
                    this.vertices = new Array(8);
                    for (var _i2 = 0; _i2 < 8; ++_i2) this.vertices[_i2] = new Vec3();
                }
                return _createClass(frustum, [ {
                    key: "accurate",
                    set: function set(b) {
                        this._type = b ? enums.SHAPE_FRUSTUM_ACCURATE : enums.SHAPE_FRUSTUM;
                    }
                } ], [ {
                    key: "create",
                    value: function create() {
                        return new frustum();
                    }
                }, {
                    key: "clone",
                    value: function clone(f) {
                        return frustum.copy(new frustum(), f);
                    }
                }, {
                    key: "copy",
                    value: function copy(out, f) {
                        out._type = f._type;
                        for (var i = 0; i < 6; ++i) plane.copy(out.planes[i], f.planes[i]);
                        for (var _i = 0; _i < 8; ++_i) Vec3.copy(out.vertices[_i], f.vertices[_i]);
                        return out;
                    }
                } ]), _createClass(frustum, [ {
                    key: "update",
                    value: function update(m, inv) {
                        if (Vec3.set(this.planes[0].n, m.m03 + m.m00, m.m07 + m.m04, m.m11 + m.m08), this.planes[0].d = -(m.m15 + m.m12), 
                        Vec3.set(this.planes[1].n, m.m03 - m.m00, m.m07 - m.m04, m.m11 - m.m08), this.planes[1].d = -(m.m15 - m.m12), 
                        Vec3.set(this.planes[2].n, m.m03 + m.m01, m.m07 + m.m05, m.m11 + m.m09), this.planes[2].d = -(m.m15 + m.m13), 
                        Vec3.set(this.planes[3].n, m.m03 - m.m01, m.m07 - m.m05, m.m11 - m.m09), this.planes[3].d = -(m.m15 - m.m13), 
                        Vec3.set(this.planes[4].n, m.m03 + m.m02, m.m07 + m.m06, m.m11 + m.m10), this.planes[4].d = -(m.m15 + m.m14), 
                        Vec3.set(this.planes[5].n, m.m03 - m.m02, m.m07 - m.m06, m.m11 - m.m10), this.planes[5].d = -(m.m15 - m.m14), 
                        this._type === enums.SHAPE_FRUSTUM_ACCURATE) {
                            for (var i = 0; i < 6; i++) {
                                var pl = this.planes[i], invDist = 1 / pl.n.length();
                                Vec3.multiplyScalar(pl.n, pl.n, invDist), pl.d *= invDist;
                            }
                            for (var _i3 = 0; _i3 < 8; _i3++) Vec3.transformMat4(this.vertices[_i3], _v[_i3], inv);
                        }
                    }
                }, {
                    key: "transform",
                    value: function transform(mat) {
                        if (this._type === enums.SHAPE_FRUSTUM_ACCURATE) {
                            for (var i = 0; i < 8; i++) Vec3.transformMat4(this.vertices[i], this.vertices[i], mat);
                            plane.fromPoints(this.planes[0], this.vertices[1], this.vertices[5], this.vertices[6]), 
                            plane.fromPoints(this.planes[1], this.vertices[3], this.vertices[7], this.vertices[4]), 
                            plane.fromPoints(this.planes[2], this.vertices[6], this.vertices[7], this.vertices[3]), 
                            plane.fromPoints(this.planes[3], this.vertices[0], this.vertices[4], this.vertices[5]), 
                            plane.fromPoints(this.planes[4], this.vertices[2], this.vertices[3], this.vertices[0]), 
                            plane.fromPoints(this.planes[0], this.vertices[7], this.vertices[6], this.vertices[5]);
                        }
                    }
                } ]), frustum;
            }();
            frustum.createOrtho = function() {
                var _temp_v3 = new Vec3();
                return function(out, width, height, near, far, transform) {
                    var halfWidth = width / 2, halfHeight = height / 2;
                    Vec3.set(_temp_v3, halfWidth, halfHeight, near), Vec3.transformMat4(out.vertices[0], _temp_v3, transform), 
                    Vec3.set(_temp_v3, -halfWidth, halfHeight, near), Vec3.transformMat4(out.vertices[1], _temp_v3, transform), 
                    Vec3.set(_temp_v3, -halfWidth, -halfHeight, near), Vec3.transformMat4(out.vertices[2], _temp_v3, transform), 
                    Vec3.set(_temp_v3, halfWidth, -halfHeight, near), Vec3.transformMat4(out.vertices[3], _temp_v3, transform), 
                    Vec3.set(_temp_v3, halfWidth, halfHeight, far), Vec3.transformMat4(out.vertices[4], _temp_v3, transform), 
                    Vec3.set(_temp_v3, -halfWidth, halfHeight, far), Vec3.transformMat4(out.vertices[5], _temp_v3, transform), 
                    Vec3.set(_temp_v3, -halfWidth, -halfHeight, far), Vec3.transformMat4(out.vertices[6], _temp_v3, transform), 
                    Vec3.set(_temp_v3, halfWidth, -halfHeight, far), Vec3.transformMat4(out.vertices[7], _temp_v3, transform), 
                    plane.fromPoints(out.planes[0], out.vertices[1], out.vertices[6], out.vertices[5]), 
                    plane.fromPoints(out.planes[1], out.vertices[3], out.vertices[4], out.vertices[7]), 
                    plane.fromPoints(out.planes[2], out.vertices[6], out.vertices[3], out.vertices[7]), 
                    plane.fromPoints(out.planes[3], out.vertices[0], out.vertices[5], out.vertices[4]), 
                    plane.fromPoints(out.planes[4], out.vertices[2], out.vertices[0], out.vertices[3]), 
                    plane.fromPoints(out.planes[0], out.vertices[7], out.vertices[5], out.vertices[6]);
                };
            }();
            exports("CircularPool", function() {
                function CircularPool(fn, size) {
                    _classCallCheck(this, CircularPool), this._cursor = void 0, this._data = void 0, 
                    this._cursor = 0, this._data = new Array(size);
                    for (var i = 0; i < size; ++i) this._data[i] = fn();
                }
                return _createClass(CircularPool, [ {
                    key: "request",
                    value: function request() {
                        var item = this._data[this._cursor];
                        return this._cursor = (this._cursor + 1) % this._data.length, item;
                    }
                } ]), CircularPool;
            }());
            var DEFAULT_MIN_MERGE = 32, POWERS_OF_TEN = [ 1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9 ];
            function log10$1(x) {
                return x < 1e5 ? x < 100 ? x < 10 ? 0 : 1 : x < 1e4 ? x < 1e3 ? 2 : 3 : 4 : x < 1e7 ? x < 1e6 ? 5 : 6 : x < 1e9 ? x < 1e8 ? 7 : 8 : 9;
            }
            function alphabeticalCompare(a, b) {
                if (a === b) return 0;
                if (~~a === a && ~~b === b) {
                    if (0 === a || 0 === b) return a < b ? -1 : 1;
                    if (a < 0 || b < 0) {
                        if (0 <= b) return -1;
                        if (0 <= a) return 1;
                        a = -a, b = -b;
                    }
                    var al = log10$1(a), bl = log10$1(b), t = 0;
                    return al < bl ? (a *= POWERS_OF_TEN[bl - al - 1], b /= 10, t = -1) : bl < al && (b *= POWERS_OF_TEN[al - bl - 1], 
                    a /= 10, t = 1), a === b ? t : a < b ? -1 : 1;
                }
                var aStr = String(a), bStr = String(b);
                return aStr === bStr ? 0 : aStr < bStr ? -1 : 1;
            }
            function makeAscendingRun(array, lo, hi, compare) {
                var runHi = lo + 1;
                if (runHi === hi) return 1;
                if (compare(array[runHi++], array[lo]) < 0) {
                    for (;runHi < hi && compare(array[runHi], array[runHi - 1]) < 0; ) runHi++;
                    !function reverseRun(array, lo, hi) {
                        hi--;
                        for (;lo < hi; ) {
                            var t = array[lo];
                            array[lo++] = array[hi], array[hi--] = t;
                        }
                    }(array, lo, runHi);
                } else for (;runHi < hi && 0 <= compare(array[runHi], array[runHi - 1]); ) runHi++;
                return runHi - lo;
            }
            function binaryInsertionSort(array, lo, hi, start, compare) {
                for (start === lo && start++; start < hi; start++) {
                    for (var pivot = array[start], left = lo, right = start; left < right; ) {
                        var mid = left + right >>> 1;
                        compare(pivot, array[mid]) < 0 ? right = mid : left = 1 + mid;
                    }
                    var n = start - left;
                    switch (n) {
                      case 3:
                        array[left + 3] = array[left + 2];

                      case 2:
                        array[left + 2] = array[left + 1];

                      case 1:
                        array[left + 1] = array[left];
                        break;

                      default:
                        for (;0 < n; ) array[left + n] = array[left + n - 1], n--;
                    }
                    array[left] = pivot;
                }
            }
            function gallopLeft(value, array, start, length, hint, compare) {
                var lastOffset = 0, maxOffset = 0, offset = 1;
                if (0 < compare(value, array[start + hint])) {
                    for (maxOffset = length - hint; offset < maxOffset && 0 < compare(value, array[start + hint + offset]); ) (offset = 1 + ((lastOffset = offset) << 1)) <= 0 && (offset = maxOffset);
                    maxOffset < offset && (offset = maxOffset), lastOffset += hint, offset += hint;
                } else {
                    for (maxOffset = hint + 1; offset < maxOffset && compare(value, array[start + hint - offset]) <= 0; ) (offset = 1 + ((lastOffset = offset) << 1)) <= 0 && (offset = maxOffset);
                    maxOffset < offset && (offset = maxOffset);
                    var tmp = lastOffset;
                    lastOffset = hint - offset, offset = hint - tmp;
                }
                for (lastOffset++; lastOffset < offset; ) {
                    var m = lastOffset + (offset - lastOffset >>> 1);
                    0 < compare(value, array[start + m]) ? lastOffset = m + 1 : offset = m;
                }
                return offset;
            }
            function gallopRight(value, array, start, length, hint, compare) {
                var lastOffset = 0, maxOffset = 0, offset = 1;
                if (compare(value, array[start + hint]) < 0) {
                    for (maxOffset = hint + 1; offset < maxOffset && compare(value, array[start + hint - offset]) < 0; ) (offset = 1 + ((lastOffset = offset) << 1)) <= 0 && (offset = maxOffset);
                    maxOffset < offset && (offset = maxOffset);
                    var tmp = lastOffset;
                    lastOffset = hint - offset, offset = hint - tmp;
                } else {
                    for (maxOffset = length - hint; offset < maxOffset && 0 <= compare(value, array[start + hint + offset]); ) (offset = 1 + ((lastOffset = offset) << 1)) <= 0 && (offset = maxOffset);
                    maxOffset < offset && (offset = maxOffset), lastOffset += hint, offset += hint;
                }
                for (lastOffset++; lastOffset < offset; ) {
                    var m = lastOffset + (offset - lastOffset >>> 1);
                    compare(value, array[start + m]) < 0 ? offset = m : lastOffset = m + 1;
                }
                return offset;
            }
            var TimSort = function() {
                function TimSort(array, compare) {
                    _classCallCheck(this, TimSort), this.array = void 0, this.compare = void 0, this.minGallop = void 0, 
                    this.length = void 0, this.tmpStorageLength = void 0, this.tmp = void 0, this.stackLength = void 0, 
                    this.runStart = void 0, this.runLength = void 0, this.stackSize = void 0, this.array = array, 
                    this.compare = compare, this.minGallop = 7, this.length = array.length, this.tmpStorageLength = 256, 
                    this.length < 512 && (this.tmpStorageLength = this.length >>> 1), this.tmp = new Array(this.tmpStorageLength), 
                    this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40, 
                    this.runStart = new Array(this.stackLength), this.runLength = new Array(this.stackLength), 
                    this.stackSize = 0;
                }
                return _createClass(TimSort, [ {
                    key: "pushRun",
                    value: function pushRun(runStart, runLength) {
                        this.runStart[this.stackSize] = runStart, this.runLength[this.stackSize] = runLength, 
                        this.stackSize += 1;
                    }
                }, {
                    key: "mergeRuns",
                    value: function mergeRuns() {
                        for (;1 < this.stackSize; ) {
                            var n = this.stackSize - 2;
                            if (1 <= n && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || 2 <= n && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) this.runLength[n - 1] < this.runLength[n + 1] && n--; else if (this.runLength[n] > this.runLength[n + 1]) break;
                            this.mergeAt(n);
                        }
                    }
                }, {
                    key: "forceMergeRuns",
                    value: function forceMergeRuns() {
                        for (;1 < this.stackSize; ) {
                            var n = this.stackSize - 2;
                            0 < n && this.runLength[n - 1] < this.runLength[n + 1] && n--, this.mergeAt(n);
                        }
                    }
                }, {
                    key: "mergeAt",
                    value: function mergeAt(i) {
                        var compare = this.compare, array = this.array, start1 = this.runStart[i], length1 = this.runLength[i], start2 = this.runStart[i + 1], length2 = this.runLength[i + 1];
                        this.runLength[i] = length1 + length2, i === this.stackSize - 3 && (this.runStart[i + 1] = this.runStart[i + 2], 
                        this.runLength[i + 1] = this.runLength[i + 2]), this.stackSize--;
                        var k = gallopRight(array[start2], array, start1, length1, 0, compare);
                        start1 += k, 0 !== (length1 -= k) && 0 !== (length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare)) && (length1 <= length2 ? this.mergeLow(start1, length1, start2, length2) : this.mergeHigh(start1, length1, start2, length2));
                    }
                }, {
                    key: "mergeLow",
                    value: function mergeLow(start1, length1, start2, length2) {
                        var compare = this.compare, array = this.array, tmp = this.tmp, i = 0;
                        for (i = 0; i < length1; i++) tmp[i] = array[start1 + i];
                        var cursor1 = 0, cursor2 = start2, dest = start1;
                        if (array[dest++] = array[cursor2++], 0 != --length2) if (1 !== length1) {
                            for (var minGallop = this.minGallop; ;) {
                                var count1 = 0, count2 = 0, exit = !1;
                                do {
                                    if (compare(array[cursor2], tmp[cursor1]) < 0) {
                                        if (array[dest++] = array[cursor2++], count2++, (count1 = 0) == --length2) {
                                            exit = !0;
                                            break;
                                        }
                                    } else if (array[dest++] = tmp[cursor1++], count1++, count2 = 0, 1 == --length1) {
                                        exit = !0;
                                        break;
                                    }
                                } while ((count1 | count2) < minGallop);
                                if (exit) break;
                                do {
                                    if (0 !== (count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare))) {
                                        for (i = 0; i < count1; i++) array[dest + i] = tmp[cursor1 + i];
                                        if (dest += count1, cursor1 += count1, (length1 -= count1) <= 1) {
                                            exit = !0;
                                            break;
                                        }
                                    }
                                    if (array[dest++] = array[cursor2++], 0 == --length2) {
                                        exit = !0;
                                        break;
                                    }
                                    if (0 !== (count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare))) {
                                        for (i = 0; i < count2; i++) array[dest + i] = array[cursor2 + i];
                                        if (dest += count2, cursor2 += count2, 0 === (length2 -= count2)) {
                                            exit = !0;
                                            break;
                                        }
                                    }
                                    if (array[dest++] = tmp[cursor1++], 1 == --length1) {
                                        exit = !0;
                                        break;
                                    }
                                    minGallop--;
                                } while (7 <= count1 || 7 <= count2);
                                if (exit) break;
                                minGallop < 0 && (minGallop = 0), minGallop += 2;
                            }
                            if ((this.minGallop = minGallop) < 1 && (this.minGallop = 1), 1 === length1) {
                                for (i = 0; i < length2; i++) array[dest + i] = array[cursor2 + i];
                                array[dest + length2] = tmp[cursor1];
                            } else {
                                if (0 === length1) throw new Error("mergeLow preconditions were not respected");
                                for (i = 0; i < length1; i++) array[dest + i] = tmp[cursor1 + i];
                            }
                        } else {
                            for (i = 0; i < length2; i++) array[dest + i] = array[cursor2 + i];
                            array[dest + length2] = tmp[cursor1];
                        } else for (i = 0; i < length1; i++) array[dest + i] = tmp[cursor1 + i];
                    }
                }, {
                    key: "mergeHigh",
                    value: function mergeHigh(start1, length1, start2, length2) {
                        var compare = this.compare, array = this.array, tmp = this.tmp, i = 0;
                        for (i = 0; i < length2; i++) tmp[i] = array[start2 + i];
                        var cursor1 = start1 + length1 - 1, cursor2 = length2 - 1, dest = start2 + length2 - 1, customCursor = 0, customDest = 0;
                        if (array[dest--] = array[cursor1--], 0 != --length1) if (1 !== length2) {
                            for (var minGallop = this.minGallop; ;) {
                                var count1 = 0, count2 = 0, exit = !1;
                                do {
                                    if (compare(tmp[cursor2], array[cursor1]) < 0) {
                                        if (array[dest--] = array[cursor1--], count1++, (count2 = 0) == --length1) {
                                            exit = !0;
                                            break;
                                        }
                                    } else if (array[dest--] = tmp[cursor2--], count2++, count1 = 0, 1 == --length2) {
                                        exit = !0;
                                        break;
                                    }
                                } while ((count1 | count2) < minGallop);
                                if (exit) break;
                                do {
                                    if (0 !== (count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare))) {
                                        for (length1 -= count1, customDest = (dest -= count1) + 1, customCursor = (cursor1 -= count1) + 1, 
                                        i = count1 - 1; 0 <= i; i--) array[customDest + i] = array[customCursor + i];
                                        if (0 === length1) {
                                            exit = !0;
                                            break;
                                        }
                                    }
                                    if (array[dest--] = tmp[cursor2--], 1 == --length2) {
                                        exit = !0;
                                        break;
                                    }
                                    if (0 !== (count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare))) {
                                        for (length2 -= count2, customDest = (dest -= count2) + 1, customCursor = (cursor2 -= count2) + 1, 
                                        i = 0; i < count2; i++) array[customDest + i] = tmp[customCursor + i];
                                        if (length2 <= 1) {
                                            exit = !0;
                                            break;
                                        }
                                    }
                                    if (array[dest--] = array[cursor1--], 0 == --length1) {
                                        exit = !0;
                                        break;
                                    }
                                    minGallop--;
                                } while (7 <= count1 || 7 <= count2);
                                if (exit) break;
                                minGallop < 0 && (minGallop = 0), minGallop += 2;
                            }
                            if ((this.minGallop = minGallop) < 1 && (this.minGallop = 1), 1 === length2) {
                                for (customDest = (dest -= length1) + 1, customCursor = (cursor1 -= length1) + 1, 
                                i = length1 - 1; 0 <= i; i--) array[customDest + i] = array[customCursor + i];
                                array[dest] = tmp[cursor2];
                            } else {
                                if (0 === length2) throw new Error("mergeHigh preconditions were not respected");
                                for (customCursor = dest - (length2 - 1), i = 0; i < length2; i++) array[customCursor + i] = tmp[i];
                            }
                        } else {
                            for (customDest = (dest -= length1) + 1, customCursor = (cursor1 -= length1) + 1, 
                            i = length1 - 1; 0 <= i; i--) array[customDest + i] = array[customCursor + i];
                            array[dest] = tmp[cursor2];
                        } else for (customCursor = dest - (length2 - 1), i = 0; i < length2; i++) array[customCursor + i] = tmp[i];
                    }
                } ]), TimSort;
            }();
            function _sort(array, lo, hi, compare) {
                if (!Array.isArray(array)) throw new TypeError("Can only sort arrays");
                void 0 === lo && (lo = 0), void 0 === hi && (hi = array.length), void 0 === compare && (compare = alphabeticalCompare);
                var remaining = hi - lo;
                if (!(remaining < 2)) {
                    var runLength = 0;
                    if (remaining < DEFAULT_MIN_MERGE) binaryInsertionSort(array, lo, hi, lo + (runLength = makeAscendingRun(array, lo, hi, compare)), compare); else {
                        var ts = new TimSort(array, compare), minRun = function minRunLength(n) {
                            for (var r = 0; DEFAULT_MIN_MERGE <= n; ) r |= 1 & n, n >>= 1;
                            return n + r;
                        }(remaining);
                        do {
                            if ((runLength = makeAscendingRun(array, lo, hi, compare)) < minRun) {
                                var force = remaining;
                                minRun < force && (force = minRun), binaryInsertionSort(array, lo, lo + force, lo + runLength, compare), 
                                runLength = force;
                            }
                            ts.pushRun(lo, runLength), ts.mergeRuns(), remaining -= runLength, lo += runLength;
                        } while (0 !== remaining);
                        ts.forceMergeRuns();
                    }
                }
            }
            for (var FixedArray = exports("FixedArray", function() {
                function FixedArray(size) {
                    _classCallCheck(this, FixedArray), this._count = void 0, this._data = void 0, this._count = 0, 
                    this._data = new Array(size);
                }
                return _createClass(FixedArray, [ {
                    key: "_resize",
                    value: function _resize(size) {
                        if (size > this._data.length) for (var i = this._data.length; i < size; ++i) this._data[i] = void 0;
                    }
                }, {
                    key: "reset",
                    value: function reset() {
                        for (var i = 0; i < this._count; ++i) this._data[i] = void 0;
                        this._count = 0;
                    }
                }, {
                    key: "push",
                    value: function push(val) {
                        this._count >= this._data.length && this._resize(2 * this._data.length), this._data[this._count] = val, 
                        ++this._count;
                    }
                }, {
                    key: "pop",
                    value: function pop() {
                        --this._count, this._count < 0 && (this._count = 0);
                        var ret = this._data[this._count];
                        return this._data[this._count] = void 0, ret;
                    }
                }, {
                    key: "fastRemove",
                    value: function fastRemove(idx) {
                        if (!(idx >= this._count || idx < 0)) {
                            var last = this._count - 1;
                            this._data[idx] = this._data[last], this._data[last] = void 0, this._count -= 1;
                        }
                    }
                }, {
                    key: "indexOf",
                    value: function indexOf(val) {
                        return this._data.indexOf(val);
                    }
                }, {
                    key: "sort",
                    value: function sort(cmp) {
                        return _sort(this._data, 0, this._count, cmp);
                    }
                }, {
                    key: "length",
                    get: function get() {
                        return this._count;
                    }
                }, {
                    key: "data",
                    get: function get() {
                        return this._data;
                    }
                } ]), FixedArray;
            }()), Pool$1 = exports("Pool", function() {
                function Pool(fn, size) {
                    _classCallCheck(this, Pool), this._fn = void 0, this._idx = void 0, this._frees = void 0, 
                    this._fn = fn, this._idx = size - 1, this._frees = new Array(size);
                    for (var i = 0; i < size; ++i) this._frees[i] = fn();
                }
                return _createClass(Pool, [ {
                    key: "alloc",
                    value: function alloc() {
                        this._idx < 0 && this._expand(Math.round(1.2 * this._frees.length) + 1);
                        var ret = this._frees[this._idx];
                        return this._frees.splice(this._idx), --this._idx, ret;
                    }
                }, {
                    key: "free",
                    value: function free(obj) {
                        ++this._idx, this._frees[this._idx] = obj;
                    }
                }, {
                    key: "clear",
                    value: function clear(fn) {
                        for (var i = 0; i <= this._idx; i++) fn && fn(this._frees[i]);
                        this._frees.splice(0), this._idx = -1;
                    }
                }, {
                    key: "_expand",
                    value: function _expand(size) {
                        var old = this._frees;
                        this._frees = new Array(size);
                        for (var len = size - old.length, i = 0; i < len; ++i) this._frees[i] = this._fn();
                        for (var _i = len, j = 0; _i < size; ++_i, ++j) this._frees[_i] = old[j];
                        this._idx += len;
                    }
                } ]), Pool;
            }()), RecyclePool = (exports("LinkedArray", function() {
                function LinkedArray(fn, size) {
                    _classCallCheck(this, LinkedArray), this._fn = void 0, this._count = void 0, this._head = void 0, 
                    this._tail = void 0, this._pool = void 0, this._fn = fn, this._count = 0, this._head = null, 
                    this._tail = null, this._pool = new Pool$1(fn, size);
                }
                return _createClass(LinkedArray, [ {
                    key: "add",
                    value: function add() {
                        var node = this._pool.alloc();
                        return this._tail ? (this._tail._next = node)._prev = this._tail : this._head = node, 
                        this._tail = node, this._count += 1, node;
                    }
                }, {
                    key: "remove",
                    value: function remove(node) {
                        node._prev ? node._prev._next = node._next : this._head = node._next, node._next ? node._next._prev = node._prev : this._tail = node._prev, 
                        node._next = null, node._prev = null, this._pool.free(node), this._count -= 1;
                    }
                }, {
                    key: "forEach",
                    value: function forEach(fn, binder) {
                        var cursor = this._head;
                        if (cursor) {
                            binder && (fn = fn.bind(binder));
                            for (var idx = 0, next = cursor; cursor; ) next = cursor._next, fn(cursor, idx, this), 
                            cursor = next, ++idx;
                        }
                    }
                }, {
                    key: "head",
                    get: function get() {
                        return this._head;
                    }
                }, {
                    key: "tail",
                    get: function get() {
                        return this._tail;
                    }
                }, {
                    key: "length",
                    get: function get() {
                        return this._count;
                    }
                } ]), LinkedArray;
            }()), exports("RecyclePool", function() {
                function RecyclePool(fn, size) {
                    _classCallCheck(this, RecyclePool), this._fn = void 0, this._count = 0, this._data = void 0, 
                    this._fn = fn, this._data = new Array(size);
                    for (var i = 0; i < size; ++i) this._data[i] = fn();
                }
                return _createClass(RecyclePool, [ {
                    key: "reset",
                    value: function reset() {
                        this._count = 0;
                    }
                }, {
                    key: "resize",
                    value: function resize(size) {
                        if (size > this._data.length) for (var i = this._data.length; i < size; ++i) this._data[i] = this._fn();
                    }
                }, {
                    key: "add",
                    value: function add() {
                        return this._count >= this._data.length && this.resize(2 * this._data.length), this._data[this._count++];
                    }
                }, {
                    key: "removeAt",
                    value: function removeAt(idx) {
                        if (!(idx >= this._count)) {
                            var last = this._count - 1, tmp = this._data[idx];
                            this._data[idx] = this._data[last], this._data[last] = tmp, this._count -= 1;
                        }
                    }
                }, {
                    key: "sort",
                    value: function sort(compare) {
                        return _sort(this._data, 0, this._count, compare);
                    }
                }, {
                    key: "length",
                    get: function get() {
                        return this._count;
                    }
                }, {
                    key: "data",
                    get: function get() {
                        return this._data;
                    }
                } ]), RecyclePool;
            }())), _bufferPools = Array(8), i$1 = 0; i$1 < 8; ++i$1) _bufferPools[i$1] = [];
            function _log2(v) {
                var r = (65535 < v) << 4, shift = (255 < (v >>>= r)) << 3;
                return r |= shift, r |= shift = (15 < (v >>>= shift)) << 2, (r |= shift = (3 < (v >>>= shift)) << 1) | (v >>>= shift) >> 1;
            }
            function _alloc(n) {
                var sz = function _nextPow16(v) {
                    for (var _i = 16; _i <= 1 << 28; _i *= 16) if (v <= _i) return _i;
                    return 0;
                }(n), bin = _bufferPools[_log2(sz) >> 2];
                return 0 < bin.length ? bin.pop() : new ArrayBuffer(sz);
            }
            function mul(out, v, x, y, z) {
                return Vec3.set(out, v.x * x, v.y * y, v.z * z);
            }
            exports("TypedArrayPool", {
                alloc_int8: function alloc_int8(n) {
                    var result = new Int8Array(_alloc(n), 0, n);
                    return result.length !== n ? result.subarray(0, n) : result;
                },
                alloc_uint8: function alloc_uint8(n) {
                    var result = new Uint8Array(_alloc(n), 0, n);
                    return result.length !== n ? result.subarray(0, n) : result;
                },
                alloc_int16: function alloc_int16(n) {
                    var result = new Int16Array(_alloc(2 * n), 0, n);
                    return result.length !== n ? result.subarray(0, n) : result;
                },
                alloc_uint16: function alloc_uint16(n) {
                    var result = new Uint16Array(_alloc(2 * n), 0, n);
                    return result.length !== n ? result.subarray(0, n) : result;
                },
                alloc_int32: function alloc_int32(n) {
                    var result = new Int32Array(_alloc(4 * n), 0, n);
                    return result.length !== n ? result.subarray(0, n) : result;
                },
                alloc_uint32: function alloc_uint32(n) {
                    var result = new Uint32Array(_alloc(4 * n), 0, n);
                    return result.length !== n ? result.subarray(0, n) : result;
                },
                alloc_float32: function alloc_float32(n) {
                    var result = new Float32Array(_alloc(4 * n), 0, n);
                    return result.length !== n ? result.subarray(0, n) : result;
                },
                alloc_float64: function alloc_float64(n) {
                    var result = new Float64Array(_alloc(8 * n), 0, n);
                    return result.length !== n ? result.subarray(0, n) : result;
                },
                free: function free(array) {
                    !function _free(buf) {
                        _bufferPools[_log2(buf.byteLength) >> 2].push(buf);
                    }(array.buffer);
                },
                reset: function reset() {
                    _bufferPools = Array(8);
                    for (var _i2 = 0; _i2 < 8; ++_i2) _bufferPools[_i2] = [];
                }
            });
            function Keyframe() {
                _classCallCheck(this, Keyframe), this.time = 0, this.value = 0, this.inTangent = 0, 
                this.outTangent = 0;
            }
            var OctreeBlock = function() {
                function OctreeBlock(minPos, maxPos, capacity, depth, maxDepth, getBoundingShape) {
                    _classCallCheck(this, OctreeBlock), this.minPos = void 0, this.maxPos = void 0, 
                    this.boundingBox = void 0, this.capacity = void 0, this.depth = void 0, this.maxDepth = void 0, 
                    this.blocks = void 0, this.entries = void 0, this._getBoundingShape = void 0, this.minPos = minPos, 
                    this.maxPos = maxPos, this.boundingBox = aabb.fromPoints(aabb.create(), minPos, maxPos), 
                    this.capacity = capacity, this.depth = depth, this.maxDepth = maxDepth, this._getBoundingShape = getBoundingShape, 
                    this.blocks = null, this.entries = new FixedArray(this.capacity);
                }
                return _createClass(OctreeBlock, [ {
                    key: "addEntry",
                    value: function addEntry(entry) {
                        if (this.blocks) {
                            var _iterator = this.blocks, _isArray = Array.isArray(_iterator), _i = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i >= _iterator.length) break;
                                    _ref = _iterator[_i++];
                                } else {
                                    if ((_i = _iterator.next()).done) break;
                                    _ref = _i.value;
                                }
                                _ref.addEntry(entry);
                            }
                        } else {
                            var shape = this._getBoundingShape(entry);
                            if (!intersect.resolve(this.boundingBox, shape)) return;
                            this.entries.push(entry), this.entries.length >= this.capacity && this.depth < this.maxDepth && (this.blocks = Octree.createBlocks(this.minPos, this.maxPos, this.entries, this.capacity, this.depth, this.maxDepth, this._getBoundingShape), 
                            this.entries.reset());
                        }
                    }
                }, {
                    key: "removeEntry",
                    value: function removeEntry(entry) {
                        if (this.blocks) {
                            var _iterator2 = this.blocks, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                                var _ref2;
                                if (_isArray2) {
                                    if (_i2 >= _iterator2.length) break;
                                    _ref2 = _iterator2[_i2++];
                                } else {
                                    if ((_i2 = _iterator2.next()).done) break;
                                    _ref2 = _i2.value;
                                }
                                _ref2.removeEntry(entry);
                            }
                        } else this.entries.fastRemove(this.entries.indexOf(entry));
                    }
                }, {
                    key: "select",
                    value: function select(out, shape) {
                        if (intersect.resolve(this.boundingBox, shape)) if (this.blocks) {
                            var _iterator3 = this.blocks, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                                var _ref3;
                                if (_isArray3) {
                                    if (_i3 >= _iterator3.length) break;
                                    _ref3 = _iterator3[_i3++];
                                } else {
                                    if ((_i3 = _iterator3.next()).done) break;
                                    _ref3 = _i3.value;
                                }
                                _ref3.select(out, shape);
                            }
                        } else for (var i = 0; i < this.entries.length; i++) out.add(this.entries.data[i]);
                    }
                }, {
                    key: "frustumSelect",
                    value: function frustumSelect(out, frustum) {
                        if (intersect.aabb_frustum(this.boundingBox, frustum)) if (this.blocks) {
                            var _iterator4 = this.blocks, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                            for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                                var _ref4;
                                if (_isArray4) {
                                    if (_i4 >= _iterator4.length) break;
                                    _ref4 = _iterator4[_i4++];
                                } else {
                                    if ((_i4 = _iterator4.next()).done) break;
                                    _ref4 = _i4.value;
                                }
                                _ref4.frustumSelect(out, frustum);
                            }
                        } else for (var i = 0; i < this.entries.length; i++) out.add(this.entries.data[i]);
                    }
                } ]), OctreeBlock;
            }(), Octree = function() {
                function Octree() {
                    var _this = this, blockCapacity = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 32, maxDepth = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 5;
                    _classCallCheck(this, Octree), this.blockCapacity = void 0, this.maxDepth = void 0, 
                    this.blocks = void 0, this.dynamics = void 0, this._selection = void 0, this._getBoundingShape = void 0, 
                    this.blockCapacity = blockCapacity, this.maxDepth = maxDepth, this.blocks = [], 
                    this.dynamics = [], this._selection = new Set(), this._getBoundingShape = function() {
                        return _this._getBoundingShape;
                    };
                }
                return _createClass(Octree, null, [ {
                    key: "createBlocks",
                    value: function createBlocks(worldMin, worldMax, entries, blockCapacity, curDepth, maxDepth, getBoundingShape) {
                        var blocks = [], blockSize = new Vec3();
                        Vec3.multiplyScalar(blockSize, Vec3.subtract(blockSize, worldMax, worldMin), .5);
                        for (var x = 0; x < 2; x++) for (var y = 0; y < 2; y++) for (var z = 0; z < 2; z++) {
                            var localMin = new Vec3(), localMax = new Vec3();
                            Vec3.add(localMin, worldMin, mul(localMin, blockSize, x, y, z)), Vec3.add(localMax, worldMin, mul(localMax, blockSize, x + 1, y + 1, z + 1));
                            for (var block = new OctreeBlock(localMin, localMax, blockCapacity, curDepth + 1, maxDepth, getBoundingShape), i = 0; i < entries.length; i++) {
                                var entry = (entries.data || entries)[i];
                                block.addEntry(entry);
                            }
                            blocks.push(block);
                        }
                        return blocks;
                    }
                } ]), _createClass(Octree, [ {
                    key: "build",
                    value: function build(entries, getBoundingShape) {
                        var worldMin = new Vec3(1 / 0, 1 / 0, 1 / 0), worldMax = new Vec3(-1 / 0, -1 / 0, -1 / 0), minPos = new Vec3(), maxPos = new Vec3(), staticEntries = [];
                        this.dynamics = [];
                        for (var i = 0; i < entries.length; i++) {
                            var entry = (entries.data || entries)[i], shape = getBoundingShape(entry);
                            shape ? (shape.getBoundary(minPos, maxPos), Vec3.min(worldMin, worldMin, minPos), 
                            Vec3.max(worldMax, worldMax, maxPos), staticEntries.push(entry)) : this.dynamics.push(entry);
                        }
                        this.blocks = Octree.createBlocks(worldMin, worldMax, staticEntries, this.blockCapacity, 0, this.maxDepth, getBoundingShape), 
                        this._getBoundingShape = getBoundingShape;
                    }
                }, {
                    key: "addEntry",
                    value: function addEntry(entry) {
                        if (this._getBoundingShape(entry).shape) {
                            var _iterator5 = this.blocks, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                            for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                                var _ref5;
                                if (_isArray5) {
                                    if (_i5 >= _iterator5.length) break;
                                    _ref5 = _iterator5[_i5++];
                                } else {
                                    if ((_i5 = _iterator5.next()).done) break;
                                    _ref5 = _i5.value;
                                }
                                _ref5.addEntry(entry);
                            }
                        } else this.dynamics.push(entry);
                    }
                }, {
                    key: "removeEntry",
                    value: function removeEntry(entry) {
                        if (this._getBoundingShape(entry).shape) {
                            var _iterator6 = this.blocks, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                            for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                                var _ref6;
                                if (_isArray6) {
                                    if (_i6 >= _iterator6.length) break;
                                    _ref6 = _iterator6[_i6++];
                                } else {
                                    if ((_i6 = _iterator6.next()).done) break;
                                    _ref6 = _i6.value;
                                }
                                _ref6.removeEntry(entry);
                            }
                        } else this.dynamics.splice(this.dynamics.indexOf(entry), 1);
                    }
                }, {
                    key: "select",
                    value: function select(shape) {
                        this._selection.clear();
                        var _iterator7 = this.blocks, _isArray7 = Array.isArray(_iterator7), _i7 = 0;
                        for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                            var _ref7;
                            if (_isArray7) {
                                if (_i7 >= _iterator7.length) break;
                                _ref7 = _iterator7[_i7++];
                            } else {
                                if ((_i7 = _iterator7.next()).done) break;
                                _ref7 = _i7.value;
                            }
                            _ref7.select(this._selection, shape);
                        }
                        var _iterator8 = this.dynamics, _isArray8 = Array.isArray(_iterator8), _i8 = 0;
                        for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                            var _ref8;
                            if (_isArray8) {
                                if (_i8 >= _iterator8.length) break;
                                _ref8 = _iterator8[_i8++];
                            } else {
                                if ((_i8 = _iterator8.next()).done) break;
                                _ref8 = _i8.value;
                            }
                            var dynamic = _ref8;
                            this._selection.add(dynamic);
                        }
                        return this._selection;
                    }
                }, {
                    key: "frustumSelect",
                    value: function frustumSelect(frustum) {
                        this._selection.clear();
                        var _iterator9 = this.blocks, _isArray9 = Array.isArray(_iterator9), _i9 = 0;
                        for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                            var _ref9;
                            if (_isArray9) {
                                if (_i9 >= _iterator9.length) break;
                                _ref9 = _iterator9[_i9++];
                            } else {
                                if ((_i9 = _iterator9.next()).done) break;
                                _ref9 = _i9.value;
                            }
                            _ref9.frustumSelect(this._selection, frustum);
                        }
                        var _iterator10 = this.dynamics, _isArray10 = Array.isArray(_iterator10), _i10 = 0;
                        for (_iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator](); ;) {
                            var _ref10;
                            if (_isArray10) {
                                if (_i10 >= _iterator10.length) break;
                                _ref10 = _iterator10[_i10++];
                            } else {
                                if ((_i10 = _iterator10.next()).done) break;
                                _ref10 = _i10.value;
                            }
                            var dynamic = _ref10;
                            this._selection.add(dynamic);
                        }
                        return this._selection;
                    }
                } ]), Octree;
            }(), WrapMode = Enum({
                Default: 0,
                Once: 1,
                Loop: 2,
                PingPong: 3,
                ClampForever: 4
            });
            CCClass.fastDefine("cc.Keyframe", Keyframe, {
                time: 0,
                value: 0,
                inTangent: 0,
                outTangent: 0
            });
            var OptimizedKey = function() {
                function OptimizedKey() {
                    _classCallCheck(this, OptimizedKey), this.index = void 0, this.time = void 0, this.endTime = void 0, 
                    this.coefficient = void 0, this.index = -1, this.time = 0, this.endTime = 0, this.coefficient = new Float32Array(4);
                }
                return _createClass(OptimizedKey, [ {
                    key: "evaluate",
                    value: function evaluate(T) {
                        return function evalOptCurve(t, coefs) {
                            return t * (t * (t * coefs[0] + coefs[1]) + coefs[2]) + coefs[3];
                        }(T - this.time, this.coefficient);
                    }
                } ]), OptimizedKey;
            }();
            var AnimationCurve = function() {
                function AnimationCurve() {
                    var keyFrames = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : null;
                    _classCallCheck(this, AnimationCurve), this.keyFrames = void 0, this.preWrapMode = WrapMode.Loop, 
                    this.postWrapMode = WrapMode.Loop, this.cachedKey = void 0, this.keyFrames = keyFrames || [].concat(AnimationCurve.defaultKF), 
                    this.cachedKey = new OptimizedKey();
                }
                return _createClass(AnimationCurve, [ {
                    key: "addKey",
                    value: function addKey(keyFrame) {
                        null == this.keyFrames && (this.keyFrames = []), this.keyFrames.push(keyFrame);
                    }
                }, {
                    key: "evaluate_slow",
                    value: function evaluate_slow(time) {
                        var wrappedTime = time, wrapMode = time < 0 ? this.preWrapMode : this.postWrapMode, startTime = this.keyFrames[0].time, endTime = this.keyFrames[this.keyFrames.length - 1].time;
                        switch (wrapMode) {
                          case WrapMode.Loop:
                            wrappedTime = repeat(time - startTime, endTime - startTime) + startTime;
                            break;

                          case WrapMode.PingPong:
                            wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
                            break;

                          case WrapMode.ClampForever:
                            wrappedTime = clamp(time, startTime, endTime);
                        }
                        var preKFIndex = 0;
                        if (wrappedTime > this.keyFrames[0].time) if (wrappedTime >= this.keyFrames[this.keyFrames.length - 1].time) preKFIndex = this.keyFrames.length - 2; else for (var i = 0; i < this.keyFrames.length - 1; i++) if (wrappedTime >= this.keyFrames[0].time && wrappedTime <= this.keyFrames[i + 1].time) {
                            preKFIndex = i;
                            break;
                        }
                        var keyframe0 = this.keyFrames[preKFIndex], keyframe1 = this.keyFrames[preKFIndex + 1], t = inverseLerp(keyframe0.time, keyframe1.time, wrappedTime), dt = keyframe1.time - keyframe0.time, m0 = keyframe0.outTangent * dt, m1 = keyframe1.inTangent * dt, t2 = t * t, t3 = t2 * t, b = t3 - 2 * t2 + t, c = t3 - t2, d = -2 * t3 + 3 * t2;
                        return (2 * t3 - 3 * t2 + 1) * keyframe0.value + b * m0 + c * m1 + d * keyframe1.value;
                    }
                }, {
                    key: "evaluate",
                    value: function evaluate(time) {
                        var wrappedTime = time, wrapMode = time < 0 ? this.preWrapMode : this.postWrapMode, startTime = this.keyFrames[0].time, endTime = this.keyFrames[this.keyFrames.length - 1].time;
                        switch (wrapMode) {
                          case WrapMode.Loop:
                            wrappedTime = repeat(time - startTime, endTime - startTime) + startTime;
                            break;

                          case WrapMode.PingPong:
                            wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
                            break;

                          case WrapMode.ClampForever:
                            wrappedTime = clamp(time, startTime, endTime);
                        }
                        if (wrappedTime >= this.cachedKey.time && wrappedTime < this.cachedKey.endTime) return this.cachedKey.evaluate(wrappedTime);
                        var leftIndex = this.findIndex(this.cachedKey, wrappedTime), rightIndex = leftIndex + 1;
                        return rightIndex === this.keyFrames.length && (rightIndex -= 1), this.calcOptimizedKey(this.cachedKey, leftIndex, rightIndex), 
                        this.cachedKey.evaluate(wrappedTime);
                    }
                }, {
                    key: "calcOptimizedKey",
                    value: function calcOptimizedKey(optKey, leftIndex, rightIndex) {
                        var lhs = this.keyFrames[leftIndex], rhs = this.keyFrames[rightIndex];
                        optKey.index = leftIndex, optKey.time = lhs.time, optKey.endTime = rhs.time;
                        var dx = rhs.time - lhs.time, dy = rhs.value - lhs.value, length = 1 / (dx * dx), d1 = lhs.outTangent * dx, d2 = rhs.inTangent * dx;
                        optKey.coefficient[0] = (d1 + d2 - dy - dy) * length / dx, optKey.coefficient[1] = (dy + dy + dy - d1 - d1 - d2) * length, 
                        optKey.coefficient[2] = lhs.outTangent, optKey.coefficient[3] = lhs.value;
                    }
                }, {
                    key: "findIndex",
                    value: function findIndex(optKey, t) {
                        var cachedIndex = optKey.index;
                        if (-1 !== cachedIndex) if (this.keyFrames[cachedIndex].time < t) for (var i = 0; i < 3; i++) {
                            var currIndex = cachedIndex + i;
                            if (currIndex + 1 < this.keyFrames.length && this.keyFrames[currIndex + 1].time > t) return currIndex;
                        } else for (var _i = 0; _i < 3; _i++) {
                            var _currIndex = cachedIndex - _i;
                            if (0 <= _currIndex && this.keyFrames[_currIndex - 1].time <= t) return _currIndex - 1;
                        }
                        for (var left = 0, right = this.keyFrames.length, mid = Math.floor((left + right) / 2); 1 < right - left; ) this.keyFrames[mid].time >= t ? right = mid : left = mid + 1, 
                        mid = Math.floor((left + right) / 2);
                        return left;
                    }
                } ]), AnimationCurve;
            }();
            AnimationCurve.defaultKF = [ {
                time: 0,
                value: 1,
                inTangent: 0,
                outTangent: 0
            }, {
                time: 1,
                value: 1,
                inTangent: 0,
                outTangent: 0
            } ], CCClass.fastDefine("cc.AnimationCurve", AnimationCurve, {
                preWrapMode: WrapMode.Default,
                postWrapMode: WrapMode.Default,
                keyFrames: []
            }), replaceProperty(line.prototype, "line", [ {
                name: "mag",
                newName: "len"
            }, {
                name: "magnitude",
                newName: "len"
            } ]);
            var geometry = Object.freeze({
                distance: distance,
                enums: enums,
                intersect: intersect,
                line: line,
                plane: plane,
                ray: ray,
                triangle: triangle,
                sphere: sphere,
                aabb: aabb,
                obb: obb,
                frustum: frustum,
                Octree: Octree,
                Keyframe: Keyframe,
                AnimationCurve: AnimationCurve
            });
            exports("geometry", geometry);
            var WORD_REG = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûа-яА-ЯЁё]+|\S)/, SYMBOL_REG = /^[!,.:;'}\]%\?>、‘“》？。，！]/, LAST_WORD_REG = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁё]+|\S)$/, LAST_ENGLISH_REG = /[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁё]+$/, FIRST_ENGLISH_REG = /^[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁё]/;
            function isUnicodeCJK(ch) {
                return /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/.test(ch) || /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g.test(ch) || /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/.test(ch);
            }
            function isUnicodeSpace(ch) {
                var chCode = ch.charCodeAt(0);
                return 9 <= chCode && chCode <= 13 || 32 === chCode || 133 === chCode || 160 === chCode || 5760 === chCode || 8192 <= chCode && chCode <= 8202 || 8232 === chCode || 8233 === chCode || 8239 === chCode || 8287 === chCode || 12288 === chCode;
            }
            function safeMeasureText(ctx, string) {
                var metric = ctx.measureText(string);
                return metric && metric.width || 0;
            }
            function fragmentText(stringToken, allWidth, maxWidth, measureText) {
                var wrappedWords = [];
                if (0 === stringToken.length || maxWidth < 0) return wrappedWords.push(""), wrappedWords;
                for (var text = stringToken; maxWidth < allWidth && 1 < text.length; ) {
                    for (var fuzzyLen = text.length * (maxWidth / allWidth) | 0, tmpText = text.substr(fuzzyLen), width = allWidth - measureText(tmpText), sLine = tmpText, pushNum = 0, checkWhile = 0; maxWidth < width && checkWhile++ < 10; ) fuzzyLen *= maxWidth / width, 
                    fuzzyLen |= 0, width = allWidth - measureText(tmpText = text.substr(fuzzyLen));
                    for (checkWhile = 0; width <= maxWidth && checkWhile++ < 10; ) {
                        if (tmpText) {
                            var exec = WORD_REG.exec(tmpText);
                            pushNum = exec ? exec[0].length : 1, sLine = tmpText;
                        }
                        fuzzyLen += pushNum, width = allWidth - measureText(tmpText = text.substr(fuzzyLen));
                    }
                    0 === (fuzzyLen -= pushNum) && (fuzzyLen = 1, sLine = sLine.substr(1));
                    var sText = text.substr(0, fuzzyLen), result = void 0;
                    SYMBOL_REG.test(sLine || tmpText) && (0 === (fuzzyLen -= (result = LAST_WORD_REG.exec(sText)) ? result[0].length : 0) && (fuzzyLen = 1), 
                    sLine = text.substr(fuzzyLen), sText = text.substr(0, fuzzyLen)), FIRST_ENGLISH_REG.test(sLine) && (result = LAST_ENGLISH_REG.exec(sText)) && sText !== result[0] && (fuzzyLen -= result[0].length, 
                    sLine = text.substr(fuzzyLen), sText = text.substr(0, fuzzyLen)), 0 === wrappedWords.length ? wrappedWords.push(sText) : 0 < (sText = sText.trim()).length && wrappedWords.push(sText), 
                    allWidth = measureText(text = sLine || tmpText);
                }
                return 0 === wrappedWords.length ? wrappedWords.push(text) : 0 < (text = text.trim()).length && wrappedWords.push(text), 
                wrappedWords;
            }
            var eventRegx = /^(click)(\s)*=|(param)(\s)*=/, imageAttrReg = /(\s)*src(\s)*=|(\s)*height(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/, HtmlTextParser = exports("HtmlTextParser", function() {
                function HtmlTextParser() {
                    _classCallCheck(this, HtmlTextParser), this._specialSymbolArray = [], this._stack = [], 
                    this._resultObjectArray = [], this._specialSymbolArray.push([ /&lt;/g, "<" ]), this._specialSymbolArray.push([ /&gt;/g, ">" ]), 
                    this._specialSymbolArray.push([ /&amp;/g, "&" ]), this._specialSymbolArray.push([ /&quot;/g, '"' ]), 
                    this._specialSymbolArray.push([ /&apos;/g, "'" ]);
                }
                return _createClass(HtmlTextParser, [ {
                    key: "parse",
                    value: function parse(htmlString) {
                        this._resultObjectArray.length = 0;
                        for (var startIndex = this._stack.length = 0, length = htmlString.length; startIndex < length; ) {
                            var tagBeginIndex = htmlString.indexOf("<", startIndex);
                            if (tagBeginIndex < 0) this._stack.pop(), this._processResult(htmlString.substring(startIndex)), 
                            startIndex = length; else {
                                this._processResult(htmlString.substring(startIndex, tagBeginIndex));
                                var tagEndIndex = htmlString.indexOf(">", startIndex);
                                -1 === tagEndIndex ? tagEndIndex = tagBeginIndex : "/" === htmlString.charAt(tagBeginIndex + 1) ? this._stack.pop() : this._addToStack(htmlString.substring(tagBeginIndex + 1, tagEndIndex)), 
                                startIndex = tagEndIndex + 1;
                            }
                        }
                        return this._resultObjectArray;
                    }
                }, {
                    key: "_attributeToObject",
                    value: function _attributeToObject(attribute) {
                        var obj = {}, header = (attribute = attribute.trim()).match(/^(color|size)(\s)*=/), tagName = "", nextSpace = 0, eventHanlderString = "";
                        if (header) {
                            if (tagName = header[0], "" === (attribute = attribute.substring(tagName.length).trim())) return obj;
                            switch (nextSpace = attribute.indexOf(" "), tagName[0]) {
                              case "c":
                                obj.color = -1 < nextSpace ? attribute.substring(0, nextSpace).trim() : attribute;
                                break;

                              case "s":
                                obj.size = parseInt(attribute);
                            }
                            return -1 < nextSpace && (eventHanlderString = attribute.substring(nextSpace + 1).trim(), 
                            obj.event = this._processEventHandler(eventHanlderString)), obj;
                        }
                        if ((header = attribute.match(/^(br(\s)*\/)/)) && 0 < header[0].length && (tagName = header[0].trim()).startsWith("br") && "/" === tagName[tagName.length - 1]) return obj.isNewLine = !0, 
                        this._resultObjectArray.push({
                            text: "",
                            style: {
                                newline: !0
                            }
                        }), obj;
                        var remainingArgument = "";
                        if ((header = attribute.match(/^(img(\s)*src(\s)*=[^>]+\/)/)) && 0 < header[0].length && (tagName = header[0].trim()).startsWith("img") && "/" === tagName[tagName.length - 1]) {
                            var tagValue;
                            header = attribute.match(imageAttrReg);
                            for (var isValidImageTag = !1; header; ) tagName = (attribute = attribute.substring(attribute.indexOf(header[0]))).substr(0, header[0].length), 
                            tagValue = -1 < (nextSpace = (remainingArgument = attribute.substring(tagName.length).trim()).indexOf(" ")) ? remainingArgument.substr(0, nextSpace) : remainingArgument, 
                            tagName = (tagName = tagName.replace(/[^a-zA-Z]/g, "").trim()).toLocaleLowerCase(), 
                            attribute = remainingArgument.substring(nextSpace).trim(), "src" === tagName ? (obj.isImage = !0, 
                            tagValue.endsWith("/") && (tagValue = tagValue.substring(0, tagValue.length - 1)), 
                            0 === tagValue.indexOf("'") ? (isValidImageTag = !0, tagValue = tagValue.substring(1, tagValue.length - 1)) : 0 === tagValue.indexOf('"') && (isValidImageTag = !0, 
                            tagValue = tagValue.substring(1, tagValue.length - 1)), obj.src = tagValue) : "height" === tagName ? obj.imageHeight = parseInt(tagValue) : "width" === tagName ? obj.imageWidth = parseInt(tagValue) : "click" === tagName && (obj.event = this._processEventHandler(tagName + "=" + tagValue)), 
                            obj.event && "param" === tagName && (obj.event[tagName] = tagValue.replace(/^\"|\"$/g, "")), 
                            header = attribute.match(imageAttrReg);
                            return isValidImageTag && obj.isImage && this._resultObjectArray.push({
                                text: "",
                                style: obj
                            }), {};
                        }
                        if (header = attribute.match(/^(outline(\s)*[^>]*)/)) {
                            var defaultOutlineObject = {
                                color: "#ffffff",
                                width: 1
                            };
                            if (attribute = header[0].substring("outline".length).trim()) {
                                var _tagValue, outlineAttrReg = /(\s)*color(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
                                for (header = attribute.match(outlineAttrReg); header; ) tagName = (attribute = attribute.substring(attribute.indexOf(header[0]))).substr(0, header[0].length), 
                                _tagValue = -1 < (nextSpace = (remainingArgument = attribute.substring(tagName.length).trim()).indexOf(" ")) ? remainingArgument.substr(0, nextSpace) : remainingArgument, 
                                tagName = (tagName = tagName.replace(/[^a-zA-Z]/g, "").trim()).toLocaleLowerCase(), 
                                attribute = remainingArgument.substring(nextSpace).trim(), "click" === tagName ? obj.event = this._processEventHandler(tagName + "=" + _tagValue) : "color" === tagName ? defaultOutlineObject.color = _tagValue : "width" === tagName && (defaultOutlineObject.width = parseInt(_tagValue)), 
                                obj.event && "param" === tagName && (obj.event[tagName] = _tagValue.replace(/^\"|\"$/g, "")), 
                                header = attribute.match(outlineAttrReg);
                            }
                            obj.outline = defaultOutlineObject;
                        }
                        if ((header = attribute.match(/^(on|u|b|i)(\s)*/)) && 0 < header[0].length) {
                            switch (tagName = header[0], attribute = attribute.substring(tagName.length).trim(), 
                            tagName[0]) {
                              case "u":
                                obj.underline = !0;
                                break;

                              case "i":
                                obj.italic = !0;
                                break;

                              case "b":
                                obj.bold = !0;
                            }
                            if ("" === attribute) return obj;
                            obj.event = this._processEventHandler(attribute);
                        }
                        return obj;
                    }
                }, {
                    key: "_processEventHandler",
                    value: function _processEventHandler(eventString) {
                        for (var index = 0, obj = new Map(), eventNames = eventString.match(eventRegx), isValidTag = !1; eventNames; ) {
                            var eventName = eventNames[0], eventValue = "";
                            if (isValidTag = !1, '"' === (eventString = eventString.substring(eventName.length).trim()).charAt(0)) -1 < (index = eventString.indexOf('"', 1)) && (eventValue = eventString.substring(1, index).trim(), 
                            isValidTag = !0), index++; else if ("'" === eventString.charAt(0)) -1 < (index = eventString.indexOf("'", 1)) && (eventValue = eventString.substring(1, index).trim(), 
                            isValidTag = !0), index++; else {
                                var match = eventString.match(/(\S)+/);
                                index = (eventValue = match ? match[0] : "").length;
                            }
                            isValidTag && (obj[eventName = eventName.substring(0, eventName.length - 1).trim()] = eventValue), 
                            eventNames = (eventString = eventString.substring(index).trim()).match(eventRegx);
                        }
                        return obj;
                    }
                }, {
                    key: "_addToStack",
                    value: function _addToStack(attribute) {
                        var obj = this._attributeToObject(attribute);
                        if (0 === this._stack.length) this._stack.push(obj); else {
                            if (obj.isNewLine || obj.isImage) return;
                            var previousTagObj = this._stack[this._stack.length - 1];
                            for (var key in previousTagObj) obj[key] || (obj[key] = previousTagObj[key]);
                            this._stack.push(obj);
                        }
                    }
                }, {
                    key: "_processResult",
                    value: function _processResult(value) {
                        0 !== value.length && (value = this._escapeSpecialSymbol(value), 0 < this._stack.length ? this._resultObjectArray.push({
                            text: value,
                            style: this._stack[this._stack.length - 1]
                        }) : this._resultObjectArray.push({
                            text: value
                        }));
                    }
                }, {
                    key: "_escapeSpecialSymbol",
                    value: function _escapeSpecialSymbol(str) {
                        var _iterator = this._specialSymbolArray, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var symbolArr = _ref, key = symbolArr[0], value = symbolArr[1];
                            str = str.replace(key, value);
                        }
                        return str;
                    }
                } ]), HtmlTextParser;
            }());
            var CACHE_KEY = "__ccclassCache__";
            function fNOP(ctor) {
                return ctor;
            }
            function getSubDict(obj, key) {
                return obj[key] || (obj[key] = {});
            }
            function checkCtorArgument(decorate) {
                return function(target) {
                    return "function" == typeof target ? decorate(target) : function(ctor) {
                        return decorate(ctor, target);
                    };
                };
            }
            function _checkNormalArgument(validator_DEV, decorate, decoratorName) {
                return function(target) {
                    return function(ctor) {
                        return decorate(ctor, target);
                    };
                };
            }
            var checkCompArgument = _checkNormalArgument.bind(null, !1);
            function _argumentChecker() {
                return _checkNormalArgument.bind(null, !1);
            }
            var checkStringArgument = _argumentChecker(), checkNumberArgument = _argumentChecker();
            function getClassCache(ctor) {
                return getSubDict(ctor, CACHE_KEY);
            }
            function genProperty(ctor, properties, propName, options, desc, cache) {
                var fullOptions;
                options && (fullOptions = (fullOptions = getFullFormOfProperty(options)) || options);
                var prop = mixin(properties[propName] || {}, fullOptions || {});
                if (desc && (desc.get || desc.set)) {
                    desc.get && (prop.get = desc.get), desc.set && (prop.set = desc.set);
                } else {
                    var defaultValue;
                    0;
                    if (desc) desc.initializer && (defaultValue = function getDefaultFromInitializer(initializer) {
                        var value;
                        try {
                            value = initializer();
                        } catch (e) {
                            return initializer;
                        }
                        return "object" !== _typeof(value) || null === value ? value : initializer;
                    }(desc.initializer), !0); else {
                        var actualDefaultValues = cache.default || (cache.default = function extractActualDefaultValues(ctor) {
                            var dummyObj;
                            try {
                                dummyObj = new ctor();
                            } catch (e) {
                                return {};
                            }
                            return dummyObj;
                        }(ctor));
                        actualDefaultValues.hasOwnProperty(propName) && (defaultValue = actualDefaultValues[propName], 
                        !0);
                    }
                    0, prop.default = defaultValue;
                }
                properties[propName] = prop;
            }
            var ccclass = checkCtorArgument(function(ctor, name) {
                var base = getSuper(ctor);
                base === Object && (base = null);
                var proto = {
                    name: name,
                    extends: base,
                    ctor: ctor,
                    __ES6__: !0
                }, cache = ctor[CACHE_KEY];
                if (cache) {
                    var decoratedProto = cache.proto;
                    decoratedProto && mixin(proto, decoratedProto), ctor[CACHE_KEY] = void 0;
                }
                return cc.Class(proto);
            });
            function property(ctorProtoOrOptions, propName, desc) {
                var options = null;
                function normalized(ctorProto, propName, desc) {
                    var cache = getClassCache(ctorProto.constructor);
                    if (cache) {
                        var properties = getSubDict(getSubDict(cache, "proto"), "properties");
                        genProperty(ctorProto.constructor, properties, propName, options, desc, cache);
                    }
                }
                if (void 0 === propName) return options = ctorProtoOrOptions, normalized;
                normalized(ctorProtoOrOptions, propName, desc);
            }
            function createEditorDecorator(argCheckFunc, editorPropName, staticValue) {
                return argCheckFunc(function(ctor, decoratedValue) {
                    var cache = getClassCache(ctor);
                    if (cache) {
                        var value = void 0 !== staticValue ? staticValue : decoratedValue;
                        getSubDict(getSubDict(cache, "proto"), "editor")[editorPropName] = value;
                    }
                }, editorPropName);
            }
            function createDummyDecorator(argCheckFunc) {
                return argCheckFunc(fNOP);
            }
            var executeInEditMode = createDummyDecorator(checkCtorArgument), requireComponent = createEditorDecorator(checkCompArgument, "requireComponent"), menu = createDummyDecorator(checkStringArgument), executionOrder = createEditorDecorator(checkNumberArgument, "executionOrder"), disallowMultiple = createDummyDecorator(checkCtorArgument), playOnFocus = createDummyDecorator(checkCtorArgument), inspector = createDummyDecorator(checkStringArgument), icon = createDummyDecorator(checkStringArgument), help = createDummyDecorator(checkStringArgument);
            var _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _decorator = Object.freeze({
                ccclass: ccclass,
                property: property,
                executeInEditMode: executeInEditMode,
                requireComponent: requireComponent,
                menu: menu,
                executionOrder: executionOrder,
                disallowMultiple: disallowMultiple,
                playOnFocus: playOnFocus,
                inspector: inspector,
                icon: icon,
                help: help,
                mixins: function mixins() {
                    for (var mixins = [], i = 0; i < arguments.length; i++) mixins[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                    return function(ctor) {
                        var cache = getClassCache(ctor);
                        cache && (getSubDict(cache, "proto").mixins = mixins);
                    };
                }
            });
            exports("_decorator", _decorator);
            var PrefabInfo = exports("PrefabInfo", ccclass("cc.PrefabInfo")((_descriptor = _applyDecoratedDescriptor((_class2 = function PrefabInfo() {
                _classCallCheck(this, PrefabInfo), _initializerDefineProperty(this, "root", _descriptor, this), 
                _initializerDefineProperty(this, "asset", _descriptor2, this), _initializerDefineProperty(this, "fileId", _descriptor3, this), 
                _initializerDefineProperty(this, "sync", _descriptor4, this), _initializerDefineProperty(this, "_synced", _descriptor5, this);
            }).prototype, "root", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "asset", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "fileId", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return "";
                }
            }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "sync", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "_synced", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return {
                        default: !1,
                        serializable: !1
                    };
                }
            }), _class = _class2)) || _class);
            cc._PrefabInfo = PrefabInfo;
            var _temp_vec3_1 = new Vec3();
            function WorldNode3DToLocalNodeUI(mainCamera, wpos, uiNode, out) {
                out = out || new Vec3(), mainCamera.worldToScreen(wpos, _temp_vec3_1), _temp_vec3_1.x = _temp_vec3_1.x / cc.view.getScaleX(), 
                _temp_vec3_1.y = _temp_vec3_1.y / cc.view.getScaleY();
                var cmp = uiNode.getComponent("cc.UITransformComponent");
                if (!cmp) return out;
                cmp.convertToNodeSpaceAR(_temp_vec3_1, out);
                var targetPos = uiNode.getPosition();
                return out.add(targetPos), out;
            }
            function WorldNode3DToWorldNodeUI(mainCamera, wpos, out) {
                return out = out || new Vec3(), mainCamera.worldToScreen(wpos, out), out.x = out.x / cc.view.getScaleX(), 
                out.y = out.y / cc.view.getScaleY(), out;
            }
            var convertUtils = exports("convertUtils", {
                WorldNode3DToLocalNodeUI: WorldNode3DToLocalNodeUI,
                WorldNode3DToWorldNodeUI: WorldNode3DToWorldNodeUI
            });
            cc.pipelineUtils = convertUtils;
            var objectsToDestroy = [];
            var CCObject = exports("CCObject", function() {
                function CCObject() {
                    var name = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "";
                    _classCallCheck(this, CCObject), this._objFlags = void 0, this._name = void 0, this._name = name, 
                    this._objFlags = 0;
                }
                return _createClass(CCObject, null, [ {
                    key: "_deferredDestroy",
                    value: function _deferredDestroy() {
                        for (var deleteCount = objectsToDestroy.length, i = 0; i < deleteCount; ++i) {
                            var obj = objectsToDestroy[i];
                            1 & obj._objFlags || obj._destroyImmediate();
                        }
                        deleteCount === objectsToDestroy.length ? objectsToDestroy.length = 0 : objectsToDestroy.splice(0, deleteCount);
                    }
                } ]), _createClass(CCObject, [ {
                    key: "destroy",
                    value: function destroy() {
                        return 1 & this._objFlags ? (cc.warnID(5e3), !1) : !(4 & this._objFlags) && (this._objFlags |= 4, 
                        objectsToDestroy.push(this), !0);
                    }
                }, {
                    key: "_destruct",
                    value: function _destruct() {
                        var ctor = this.constructor, destruct = ctor.__destruct__;
                        destruct || (destruct = function compileDestruct(obj, ctor) {
                            var key, shouldSkipId = obj instanceof cc._BaseNode || obj instanceof cc.Component, idToSkip = shouldSkipId ? "_id" : null, propsToReset = {};
                            for (key in obj) if (obj.hasOwnProperty(key)) {
                                if (key === idToSkip) continue;
                                switch (_typeof(obj[key])) {
                                  case "string":
                                    propsToReset[key] = "";
                                    break;

                                  case "object":
                                  case "function":
                                    propsToReset[key] = null;
                                }
                            }
                            if (CCClass._isCCClass(ctor)) for (var attrs = cc.Class.Attr.getClassAttrs(ctor), propList = ctor.__props__, i = 0; i < propList.length; i++) {
                                var attrKey = (key = propList[i]) + cc.Class.Attr.DELIMETER + "default";
                                if (attrKey in attrs) {
                                    if (shouldSkipId && "_id" === key) continue;
                                    switch (_typeof(attrs[attrKey])) {
                                      case "string":
                                        propsToReset[key] = "";
                                        break;

                                      case "object":
                                      case "function":
                                        propsToReset[key] = null;
                                        break;

                                      case "undefined":
                                        propsToReset[key] = void 0;
                                    }
                                }
                            }
                            var func = "";
                            for (key in propsToReset) {
                                var statement = void 0;
                                statement = CCClass.IDENTIFIER_RE.test(key) ? "o." + key + "=" : "o[" + CCClass.escapeForJS(key) + "]=";
                                var val = propsToReset[key];
                                "" === val && (val = '""'), func += statement + val + ";\n";
                            }
                            return Function("o", func);
                        }(this, ctor), value(ctor, "__destruct__", destruct, !0)), destruct(this);
                    }
                }, {
                    key: "_destroyImmediate",
                    value: function _destroyImmediate() {
                        1 & this._objFlags ? cc.errorID(5e3) : (this._onPreDestroy && this._onPreDestroy(), 
                        this._destruct(), this._objFlags |= 1);
                    }
                }, {
                    key: "name",
                    get: function get() {
                        return this._name;
                    },
                    set: function set(value) {
                        this._name = value;
                    }
                }, {
                    key: "isValid",
                    get: function get() {
                        return !(1 & this._objFlags);
                    }
                } ]), CCObject;
            }()), prototype = CCObject.prototype;
            prototype._deserialize = null, prototype._onPreDestroy = null, CCClass.fastDefine("cc.Object", CCObject, {
                _name: "",
                _objFlags: 0
            }), value(CCObject, "Flags", {
                Destroyed: 1,
                DontSave: 8,
                EditorOnly: 16,
                Dirty: 32,
                DontDestroy: 64,
                PersistentMask: -4192741,
                Destroying: 128,
                Deactivating: 256,
                LockedInEditor: 512,
                HideInHierarchy: 1024,
                IsPreloadStarted: 8192,
                IsOnLoadStarted: 32768,
                IsOnLoadCalled: 16384,
                IsOnEnableCalled: 2048,
                IsStartCalled: 65536,
                IsEditorOnEnableCalled: 4096,
                IsPositionLocked: 1 << 21,
                IsRotationLocked: 1 << 17,
                IsScaleLocked: 1 << 18,
                IsAnchorLocked: 1 << 19,
                IsSizeLocked: 1 << 20
            }), cc.isValid = function(value, strictMode) {
                return "object" === _typeof(value) ? !(!value || value._objFlags & (strictMode ? 5 : 1)) : void 0 !== value;
            }, cc.Object = CCObject;
            var Details = function() {
                function Details() {
                    _classCallCheck(this, Details), this.assignAssetsBy = void 0, this.uuidList = void 0, 
                    this.uuidObjList = void 0, this.uuidPropList = void 0, this._stillUseUrl = void 0, 
                    this.uuidList = [], this.uuidObjList = [], this.uuidPropList = [], this._stillUseUrl = createMap(!0);
                }
                return _createClass(Details, [ {
                    key: "reset",
                    value: function reset() {
                        this.uuidList.length = 0, this.uuidObjList.length = 0, this.uuidPropList.length = 0, 
                        clear(this._stillUseUrl);
                    }
                }, {
                    key: "push",
                    value: function push(obj, propName, uuid, _stillUseUrl) {
                        _stillUseUrl && (this._stillUseUrl[this.uuidList.length] = !0), this.uuidList.push(uuid), 
                        this.uuidObjList.push(obj), this.uuidPropList.push(propName);
                    }
                } ]), Details;
            }();
            function compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, assumeHavePropIfIsValue, stillUseUrl) {
                if (defaultValue instanceof cc.ValueType) {
                    assumeHavePropIfIsValue || sources.push("if(prop){");
                    var ctorCode = getClassName(defaultValue);
                    sources.push("s._deserializeTypedObject(o".concat(accessorToSet, ",prop,").concat(ctorCode, ");")), 
                    assumeHavePropIfIsValue || sources.push("}else o" + accessorToSet + "=null;");
                } else sources.push("if(prop){"), sources.push("s._deserializeObjField(o,prop," + propNameLiteralToSet + ",null," + !!stillUseUrl + ");"), 
                sources.push("}else o" + accessorToSet + "=null;");
            }
            Details.pool = void 0, Details.pool = new Pool(function(obj) {
                obj.reset();
            }, 10), Details.pool.get = function() {
                return this._get() || new Details();
            };
            var compileDeserialize = function(self, klass) {
                for (var TYPE = DELIMETER + "type", DEFAULT = DELIMETER + "default", SAVE_URL_AS_ASSET = DELIMETER + "saveUrlAsAsset", FORMERLY_SERIALIZED_AS = DELIMETER + "formerlySerializedAs", attrs = getClassAttrs(klass), props = klass.__values__, sources = [ "var prop;" ], fastMode = BUILTIN_CLASSID_RE.test(_getClassId(klass)), p = 0; p < props.length; p++) {
                    var propName = props[p];
                    0;
                    var accessorToSet = void 0, propNameLiteralToSet = void 0, accessorToGet = accessorToSet = CCClass.IDENTIFIER_RE.test(propName) ? (propNameLiteralToSet = '"' + propName + '"', 
                    "." + propName) : "[" + (propNameLiteralToSet = CCClass.escapeForJS(propName)) + "]";
                    if (attrs[propName + FORMERLY_SERIALIZED_AS]) {
                        var propNameToRead = attrs[propName + FORMERLY_SERIALIZED_AS];
                        accessorToGet = CCClass.IDENTIFIER_RE.test(propNameToRead) ? "." + propNameToRead : "[" + CCClass.escapeForJS(propNameToRead) + "]";
                    }
                    sources.push("prop=d" + accessorToGet + ";"), sources.push("if(typeof ".concat("prop", '!=="undefined"){'));
                    var stillUseUrl = attrs[propName + SAVE_URL_AS_ASSET], defaultValue = CCClass.getDefault(attrs[propName + DEFAULT]);
                    if (fastMode) {
                        var isPrimitiveType = void 0, userType = attrs[propName + TYPE];
                        if (void 0 === defaultValue && userType) isPrimitiveType = userType === cc.String || userType === cc.Integer || userType === cc.Float || userType === cc.Boolean; else {
                            var defaultType = _typeof(defaultValue);
                            isPrimitiveType = "string" === defaultType && !stillUseUrl || "number" === defaultType || "boolean" === defaultType;
                        }
                        isPrimitiveType ? sources.push("o".concat(accessorToSet, "=prop;")) : compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, !0, stillUseUrl);
                    } else sources.push("if(typeof ".concat("prop", '!=="object"){') + "o" + accessorToSet + "=prop;}else{"), 
                    compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, !1, stillUseUrl), 
                    sources.push("}");
                    sources.push("}");
                }
                (cc.js.isChildClassOf(klass, cc._BaseNode) || cc.js.isChildClassOf(klass, cc.Component)) && sources.push("d._id&&(o._id=d._id);");
                return "_$erialized" === props[props.length - 1] && (sources.push("o._$erialized=JSON.parse(JSON.stringify(d));"), 
                sources.push("s._deserializePrimitiveObject(o._$erialized,d);")), Function("s", "o", "d", "k", "t", sources.join(""));
            };
            function _deserializeFireClass(self, obj, serialized, klass, target) {
                var deserialize;
                klass.hasOwnProperty("__deserialize__") ? deserialize = klass.__deserialize__ : (deserialize = compileDeserialize(self, klass), 
                value(klass, "__deserialize__", deserialize, !0)), deserialize(self, obj, serialized, klass, target), 
                obj.__postDeserialize && obj.__postDeserialize();
            }
            var _Deserializer = function() {
                function _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly) {
                    _classCallCheck(this, _Deserializer), this.result = void 0, this.customEnv = void 0, 
                    this.deserializedList = void 0, this.deserializedData = void 0, this._classFinder = void 0, 
                    this._target = void 0, this._ignoreEditorOnly = void 0, this._idList = void 0, this._idObjList = void 0, 
                    this._idPropList = void 0, this.result = result, this.customEnv = customEnv, this.deserializedList = [], 
                    this.deserializedData = null, this._classFinder = classFinder, this._idList = [], 
                    this._idObjList = [], this._idPropList = [];
                }
                return _createClass(_Deserializer, [ {
                    key: "deserialize",
                    value: function deserialize(jsonObj) {
                        if (Array.isArray(jsonObj)) {
                            var jsonArray = jsonObj, refCount = jsonArray.length;
                            this.deserializedList.length = refCount;
                            for (var i = 0; i < refCount; i++) {
                                if (jsonArray[i]) this.deserializedList[i] = this._deserializeObject(jsonArray[i], !1);
                            }
                            this.deserializedData = 0 < refCount ? this.deserializedList[0] : [];
                        } else this.deserializedList.length = 1, this.deserializedData = jsonObj ? this._deserializeObject(jsonObj, !1) : null, 
                        this.deserializedList[0] = this.deserializedData;
                        return function _dereference(self) {
                            var i, propName, id, deserializedList = self.deserializedList, idPropList = self._idPropList, idList = self._idList, idObjList = self._idObjList;
                            for (self._classFinder && self._classFinder.onDereferenced, i = 0; i < idList.length; i++) propName = idPropList[i], 
                            id = idList[i], idObjList[i][propName] = deserializedList[id];
                        }(this), this.deserializedData;
                    }
                }, {
                    key: "_deserializeObject",
                    value: function _deserializeObject(serialized, _stillUseUrl, target, owner, propName) {
                        var prop, obj = null, klass = null, type = serialized.__type__;
                        if ("TypedArray" === type) {
                            var array = serialized.array;
                            obj = new window[serialized.ctor](array.length);
                            for (var i = 0; i < array.length; ++i) obj[i] = array[i];
                            return obj;
                        }
                        if (type) {
                            var deserializeByType = function deserializeByType() {
                                (obj = new klass())._deserialize ? obj._deserialize(serialized.content, self) : cc.Class._isCCClass(klass) ? _deserializeFireClass(self, obj, serialized, klass, target) : self._deserializeTypedObject(obj, serialized, klass);
                            };
                            if (!(klass = this._classFinder(type, serialized, owner, propName))) return this._classFinder === _getClassById && cc.deserialize.reportMissingClass(type), 
                            null;
                            var self = this;
                            deserializeByType();
                        } else if (Array.isArray(serialized)) {
                            obj = new Array(serialized.length);
                            for (var _i2 = 0; _i2 < serialized.length; _i2++) "object" === _typeof(prop = serialized[_i2]) && prop ? this._deserializeObjField(obj, prop, "" + _i2, null, _stillUseUrl) : obj[_i2] = prop;
                        } else obj = {}, this._deserializePrimitiveObject(obj, serialized);
                        return obj;
                    }
                }, {
                    key: "_deserializeObjField",
                    value: function _deserializeObjField(obj, jsonObj, propName, target, _stillUseUrl) {
                        var id = jsonObj.__id__;
                        if (void 0 === id) {
                            var uuid = jsonObj.__uuid__;
                            uuid ? this.result.push(obj, propName, uuid, _stillUseUrl) : obj[propName] = this._deserializeObject(jsonObj, _stillUseUrl);
                        } else {
                            var dObj = this.deserializedList[id];
                            dObj ? obj[propName] = dObj : (this._idList.push(id), this._idObjList.push(obj), 
                            this._idPropList.push(propName));
                        }
                    }
                }, {
                    key: "_deserializePrimitiveObject",
                    value: function _deserializePrimitiveObject(instance, serialized) {
                        for (var propName in serialized) if (serialized.hasOwnProperty(propName)) {
                            var prop = serialized[propName];
                            "object" !== _typeof(prop) ? "__type__" !== propName && (instance[propName] = prop) : prop ? this._deserializeObjField(instance, prop, propName) : instance[propName] = null;
                        }
                    }
                }, {
                    key: "_deserializeTypedObject",
                    value: function _deserializeTypedObject(instance, serialized, klass) {
                        if (klass === cc.Vec2) return instance.x = serialized.x || 0, void (instance.y = serialized.y || 0);
                        if (klass === cc.Vec3) return instance.x = serialized.x || 0, instance.y = serialized.y || 0, 
                        void (instance.z = serialized.z || 0);
                        if (klass !== cc.Color) {
                            if (klass === cc.Size) return instance.width = serialized.width || 0, void (instance.height = serialized.height || 0);
                            for (var DEFAULT = DELIMETER + "default", attrs = getClassAttrs(klass), fastDefinedProps = klass.__props__ || Object.keys(instance), i = 0; i < fastDefinedProps.length; i++) {
                                var propName = fastDefinedProps[i], value = serialized[propName];
                                void 0 !== value && serialized.hasOwnProperty(propName) || (value = CCClass.getDefault(attrs[propName + DEFAULT])), 
                                "object" !== _typeof(value) ? instance[propName] = value : value ? this._deserializeObjField(instance, value, propName) : instance[propName] = null;
                            }
                        } else {
                            instance.r = serialized.r || 0, instance.g = serialized.g || 0, instance.b = serialized.b || 0;
                            var a = serialized.a;
                            instance.a = void 0 === a ? 255 : a;
                        }
                    }
                } ]), _Deserializer;
            }();
            function deserialize(data, details, options) {
                var classFinder = (options = options || {}).classFinder || _getClassById, createAssetRefs = options.createAssetRefs || cc.sys.platform === cc.sys.EDITOR_CORE, customEnv = options.customEnv, ignoreEditorOnly = options.ignoreEditorOnly;
                "string" == typeof data && (data = JSON.parse(data));
                var tempDetails = !details;
                details = details || Details.pool.get();
                var deserializer = _Deserializer.pool.get(details, !1, classFinder, customEnv, ignoreEditorOnly);
                cc.game._isCloning = !0;
                var res = deserializer.deserialize(data);
                return cc.game._isCloning = !1, _Deserializer.pool.put(deserializer), createAssetRefs && details.assignAssetsBy(Editor.serialize.asAsset), 
                tempDetails && Details.pool.put(details), res;
            }
            _Deserializer.pool = void 0, _Deserializer.pool = new Pool(function(obj) {
                obj.result = null, obj.customEnv = null, obj.deserializedList.length = 0, obj.deserializedData = null, 
                obj._classFinder = null, obj._idList.length = 0, obj._idObjList.length = 0, obj._idPropList.length = 0;
            }, 1), _Deserializer.pool.get = function(result, target, classFinder, customEnv, ignoreEditorOnly) {
                var cache = this._get();
                return cache ? (cache.result = result, cache.customEnv = customEnv, cache._classFinder = classFinder, 
                cache) : new _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly);
            }, deserialize.Details = Details, deserialize.reportMissingClass = function(id) {
                cc.warnID(5302, id);
            }, cc.deserialize = deserialize, exports("deserialize", deserialize);
            var Destroyed$1 = CCObject.Flags.Destroyed, PersistentMask$1 = CCObject.Flags.PersistentMask, objsToClearTmpVar = [];
            function instantiate(original, internal_force) {
                if (!internal_force) {
                    if ("object" !== _typeof(original) || Array.isArray(original)) return null;
                    if (!original) return null;
                    if (!cc.isValid(original)) return null;
                    0;
                }
                var clone;
                if (original instanceof CCObject) {
                    if ((original = original)._instantiate) return cc.game._isCloning = !0, clone = original._instantiate(), 
                    cc.game._isCloning = !1, clone;
                    if (original instanceof cc.Asset) return null;
                }
                return cc.game._isCloning = !0, clone = doInstantiate(original), cc.game._isCloning = !1, 
                clone;
            }
            function doInstantiate(obj, parent) {
                if (Array.isArray(obj)) return null;
                if (isDomNode(obj)) return null;
                var clone;
                if (obj._iN$t) clone = obj._iN$t; else if (obj.constructor) {
                    clone = new obj.constructor();
                } else clone = Object.create(null);
                enumerateObject(obj, clone, parent);
                for (var i = 0, len = objsToClearTmpVar.length; i < len; ++i) objsToClearTmpVar[i]._iN$t = null;
                return objsToClearTmpVar.length = 0, clone;
            }
            function enumerateObject(obj, clone, parent) {
                value(obj, "_iN$t", clone, !0), objsToClearTmpVar.push(obj);
                var klass = obj.constructor;
                if (cc.Class._isCCClass(klass)) !function enumerateCCClass(klass, obj, clone, parent) {
                    for (var props = klass.__values__, p = 0; p < props.length; p++) {
                        var key = props[p], value = obj[key];
                        if ("object" === _typeof(value) && value) {
                            var initValue = clone[key];
                            initValue instanceof ValueType && initValue.constructor === value.constructor ? initValue.set(value) : clone[key] = value._iN$t || instantiateObj(value, parent);
                        } else clone[key] = value;
                    }
                }(klass, obj, clone, parent); else for (var key in obj) if (obj.hasOwnProperty(key) && (95 !== key.charCodeAt(0) || 95 !== key.charCodeAt(1) || "__type__" === key)) {
                    var value$1 = obj[key];
                    if ("object" === _typeof(value$1) && value$1) {
                        if (value$1 === clone) continue;
                        clone[key] = value$1._iN$t || instantiateObj(value$1, parent);
                    } else clone[key] = value$1;
                }
                obj instanceof CCObject && (clone._objFlags &= PersistentMask$1);
            }
            function instantiateObj(obj, parent) {
                if (obj instanceof ValueType) return obj.clone();
                if (obj instanceof cc.Asset) return obj;
                var clone;
                if (Array.isArray(obj)) {
                    var len = obj.length;
                    clone = new Array(len), obj._iN$t = clone;
                    for (var i = 0; i < len; ++i) {
                        var value = obj[i];
                        "object" === _typeof(value) && value ? clone[i] = value._iN$t || instantiateObj(value, parent) : clone[i] = value;
                    }
                    return objsToClearTmpVar.push(obj), clone;
                }
                if (obj._objFlags & Destroyed$1) return null;
                var ctor = obj.constructor;
                if (cc.Class._isCCClass(ctor)) {
                    if (parent) if (parent instanceof cc.Component) {
                        if (obj instanceof cc._BaseNode || obj instanceof cc.Component) return obj;
                    } else if (parent instanceof cc._BaseNode) if (obj instanceof cc._BaseNode) {
                        if (!obj.isChildOf(parent)) return obj;
                    } else if (obj instanceof cc.Component && !obj.node.isChildOf(parent)) return obj;
                    clone = new ctor();
                } else if (ctor === Object) clone = {}; else {
                    if (ctor) return obj;
                    clone = Object.create(null);
                }
                return enumerateObject(obj, clone, parent), clone;
            }
            instantiate._clone = doInstantiate, cc.instantiate = instantiate, exports("instantiate", instantiate), 
            cc._decorator = _decorator;
            var Event = exports("Event", function() {
                function Event(type, bubbles) {
                    _classCallCheck(this, Event), this.type = void 0, this.bubbles = void 0, this.target = null, 
                    this.currentTarget = null, this.eventPhase = 0, this.propagationStopped = !1, this.propagationImmediateStopped = !1, 
                    this.type = type, this.bubbles = !!bubbles;
                }
                return _createClass(Event, [ {
                    key: "unuse",
                    value: function unuse() {
                        this.type = Event.NO_TYPE, this.target = null, this.currentTarget = null, this.eventPhase = Event.NONE, 
                        this.propagationStopped = !1, this.propagationImmediateStopped = !1;
                    }
                }, {
                    key: "reuse",
                    value: function reuse(type, bubbles) {
                        this.type = type, this.bubbles = bubbles || !1;
                    }
                }, {
                    key: "isStopped",
                    value: function isStopped() {
                        return this.propagationStopped || this.propagationImmediateStopped;
                    }
                }, {
                    key: "getCurrentTarget",
                    value: function getCurrentTarget() {
                        return this.currentTarget;
                    }
                }, {
                    key: "getType",
                    value: function getType() {
                        return this.type;
                    }
                } ]), Event;
            }());
            Event.NO_TYPE = "no_type", Event.TOUCH = "touch", Event.MOUSE = "mouse", Event.KEYBOARD = "keyboard", 
            Event.ACCELERATION = "acceleration", Event.NONE = 0, Event.CAPTURING_PHASE = 1, 
            Event.AT_TARGET = 2, Event.BUBBLING_PHASE = 3, cc.Event = Event;
            var fastRemoveAt$1 = array.fastRemoveAt;
            function empty() {}
            var CallbackInfo = function() {
                function CallbackInfo() {
                    _classCallCheck(this, CallbackInfo), this.callback = empty, this.target = void 0, 
                    this.once = !1;
                }
                return _createClass(CallbackInfo, [ {
                    key: "set",
                    value: function set(callback, target, once) {
                        this.callback = callback, this.target = target, this.once = !!once;
                    }
                } ]), CallbackInfo;
            }(), callbackInfoPool = new Pool$1(function() {
                return new CallbackInfo();
            }, 32), CallbackList = function() {
                function CallbackList() {
                    _classCallCheck(this, CallbackList), this.callbackInfos = [], this.isInvoking = !1, 
                    this.containCanceled = !1;
                }
                return _createClass(CallbackList, [ {
                    key: "removeByCallback",
                    value: function removeByCallback(cb) {
                        for (var i = 0; i < this.callbackInfos.length; ++i) {
                            var info = this.callbackInfos[i];
                            info && info.callback === cb && (callbackInfoPool.free(info), fastRemoveAt$1(this.callbackInfos, i), 
                            --i);
                        }
                    }
                }, {
                    key: "removeByTarget",
                    value: function removeByTarget(target) {
                        for (var i = 0; i < this.callbackInfos.length; ++i) {
                            var info = this.callbackInfos[i];
                            info && info.target === target && (callbackInfoPool.free(info), fastRemoveAt$1(this.callbackInfos, i), 
                            --i);
                        }
                    }
                }, {
                    key: "cancel",
                    value: function cancel(index) {
                        var info = this.callbackInfos[index];
                        info && (callbackInfoPool.free(info), this.callbackInfos[index] = null), this.containCanceled = !0;
                    }
                }, {
                    key: "cancelAll",
                    value: function cancelAll() {
                        for (var i = 0; i < this.callbackInfos.length; i++) {
                            var info = this.callbackInfos[i];
                            info && (callbackInfoPool.free(info), this.callbackInfos[i] = null);
                        }
                        this.containCanceled = !0;
                    }
                }, {
                    key: "purgeCanceled",
                    value: function purgeCanceled() {
                        for (var i = this.callbackInfos.length - 1; 0 <= i; --i) {
                            this.callbackInfos[i] || fastRemoveAt$1(this.callbackInfos, i);
                        }
                        this.containCanceled = !1;
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        this.cancelAll(), this.callbackInfos.length = 0, this.isInvoking = !1, this.containCanceled = !1;
                    }
                } ]), CallbackList;
            }(), callbackListPool = new Pool$1(function() {
                return new CallbackList();
            }, 16), CallbacksInvoker = function() {
                function CallbacksInvoker() {
                    _classCallCheck(this, CallbacksInvoker), this._callbackTable = createMap(!0);
                }
                return _createClass(CallbacksInvoker, [ {
                    key: "on",
                    value: function on(key, callback, target, once) {
                        var list = this._callbackTable[key];
                        list = list || (this._callbackTable[key] = callbackListPool.alloc());
                        var info = callbackInfoPool.alloc();
                        info.set(callback, target, once), list.callbackInfos.push(info);
                    }
                }, {
                    key: "hasEventListener",
                    value: function hasEventListener(key, callback, argument_2) {
                        var target = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : null, list = this._callbackTable[key];
                        if (!list) return !1;
                        var infos = list.callbackInfos;
                        if (!callback) {
                            if (list.isInvoking) {
                                var _iterator = infos, _isArray = Array.isArray(_iterator), _i = 0;
                                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                    var _ref;
                                    if (_isArray) {
                                        if (_i >= _iterator.length) break;
                                        _ref = _iterator[_i++];
                                    } else {
                                        if ((_i = _iterator.next()).done) break;
                                        _ref = _i.value;
                                    }
                                    if (_ref) return !0;
                                }
                                return !1;
                            }
                            return 0 < infos.length;
                        }
                        var _iterator2 = infos, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            var _info = _ref2;
                            if (_info && _info.callback === callback && _info.target === target) return !0;
                        }
                        return !1;
                    }
                }, {
                    key: "removeAll",
                    value: function removeAll(keyOrTarget) {
                        if ("string" == typeof keyOrTarget) {
                            var list = this._callbackTable[keyOrTarget];
                            list && (list.isInvoking ? list.cancelAll() : (list.clear(), callbackListPool.free(list), 
                            delete this._callbackTable[keyOrTarget]));
                        } else if (keyOrTarget) for (var key in this._callbackTable) {
                            var _list = this._callbackTable[key];
                            if (_list.isInvoking) for (var infos = _list.callbackInfos, i = 0; i < infos.length; ++i) {
                                var info = infos[i];
                                info && info.target === keyOrTarget && _list.cancel(i);
                            } else _list.removeByTarget(keyOrTarget);
                        }
                    }
                }, {
                    key: "off",
                    value: function off(key, callback, target) {
                        var list = this._callbackTable[key];
                        if (list) {
                            var infos = list.callbackInfos;
                            if (callback) for (var i = 0; i < infos.length; ++i) {
                                var info = infos[i];
                                if (info && info.callback === callback && info.target === target) {
                                    list.isInvoking ? list.cancel(i) : (fastRemoveAt$1(infos, i), callbackInfoPool.free(info));
                                    break;
                                }
                            } else this.removeAll(key);
                        }
                    }
                }, {
                    key: "emit",
                    value: function emit(key) {
                        var list = this._callbackTable[key];
                        if (list) {
                            var rootInvoker = !list.isInvoking;
                            list.isInvoking = !0;
                            for (var infos = list.callbackInfos, _len = arguments.length, args = new Array(1 < _len ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                            for (var i = 0, len = infos.length; i < len; ++i) {
                                var info = infos[i];
                                if (info) {
                                    var callback = info.callback, target = info.target;
                                    info.once && this.off(key, callback, target), target ? callback.call.apply(callback, [ target ].concat(args)) : callback.apply(void 0, args);
                                }
                            }
                            rootInvoker && (list.isInvoking = !1, list.containCanceled && list.purgeCanceled());
                        }
                    }
                } ]), CallbacksInvoker;
            }();
            var fastRemove$1 = array.fastRemove, EventTarget = exports("EventTarget", function() {
                function EventTarget() {
                    return _classCallCheck(this, EventTarget), _possibleConstructorReturn(this, _getPrototypeOf(EventTarget).apply(this, arguments));
                }
                return _inherits(EventTarget, CallbacksInvoker), _createClass(EventTarget, [ {
                    key: "on",
                    value: function on(type, callback, target) {
                        if (callback) {
                            if (!this.hasEventListener(type, callback, target)) {
                                _get(_getPrototypeOf(EventTarget.prototype), "on", this).call(this, type, callback, target);
                                var targetImpl = target;
                                target && (targetImpl.__eventTargets ? targetImpl.__eventTargets.push(this) : targetImpl.node && targetImpl.node.__eventTargets && targetImpl.node.__eventTargets.push(this));
                            }
                            return callback;
                        }
                        cc.errorID(6800);
                    }
                }, {
                    key: "off",
                    value: function off(type, callback, target) {
                        if (callback) {
                            _get(_getPrototypeOf(EventTarget.prototype), "off", this).call(this, type, callback, target);
                            var targetImpl = target;
                            target && (targetImpl.__eventTargets ? fastRemove$1(targetImpl.__eventTargets, this) : targetImpl.node && targetImpl.node.__eventTargets && fastRemove$1(targetImpl.node.__eventTargets, this));
                        } else this.removeAll(type);
                    }
                }, {
                    key: "targetOff",
                    value: function targetOff(keyOrTarget) {
                        this.removeAll(keyOrTarget);
                    }
                }, {
                    key: "once",
                    value: function once(type, callback, target) {
                        if (callback) {
                            if (!this.hasEventListener(type, callback, target)) {
                                _get(_getPrototypeOf(EventTarget.prototype), "on", this).call(this, type, callback, target, !0);
                                var targetImpl = target;
                                target && (targetImpl.__eventTargets ? targetImpl.__eventTargets.push(this) : targetImpl.node && targetImpl.node.__eventTargets && targetImpl.node.__eventTargets.push(this));
                            }
                            return callback;
                        }
                        cc.errorID(6800);
                    }
                } ]), EventTarget;
            }());
            cc.EventTarget = EventTarget;
            var buffer, sys = {};
            sys.LANGUAGE_ENGLISH = "en", sys.LANGUAGE_CHINESE = "zh", sys.LANGUAGE_FRENCH = "fr", 
            sys.LANGUAGE_ITALIAN = "it", sys.LANGUAGE_GERMAN = "de", sys.LANGUAGE_SPANISH = "es", 
            sys.LANGUAGE_DUTCH = "du", sys.LANGUAGE_RUSSIAN = "ru", sys.LANGUAGE_KOREAN = "ko", 
            sys.LANGUAGE_JAPANESE = "ja", sys.LANGUAGE_HUNGARIAN = "hu", sys.LANGUAGE_PORTUGUESE = "pt", 
            sys.LANGUAGE_ARABIC = "ar", sys.LANGUAGE_NORWEGIAN = "no", sys.LANGUAGE_POLISH = "pl", 
            sys.LANGUAGE_TURKISH = "tr", sys.LANGUAGE_UKRAINIAN = "uk", sys.LANGUAGE_ROMANIAN = "ro", 
            sys.LANGUAGE_BULGARIAN = "bg", sys.LANGUAGE_UNKNOWN = "unknown", sys.OS_IOS = "iOS", 
            sys.OS_ANDROID = "Android", sys.OS_WINDOWS = "Windows", sys.OS_MARMALADE = "Marmalade", 
            sys.OS_LINUX = "Linux", sys.OS_BADA = "Bada", sys.OS_BLACKBERRY = "Blackberry", 
            sys.OS_OSX = "OS X", sys.OS_WP8 = "WP8", sys.OS_WINRT = "WINRT", sys.OS_UNKNOWN = "Unknown", 
            sys.UNKNOWN = -1, sys.WIN32 = 0, sys.LINUX = 1, sys.MACOS = 2, sys.ANDROID = 3, 
            sys.IPHONE = 4, sys.IPAD = 5, sys.BLACKBERRY = 6, sys.NACL = 7, sys.EMSCRIPTEN = 8, 
            sys.TIZEN = 9, sys.WINRT = 10, sys.WP8 = 11, sys.MOBILE_BROWSER = 100, sys.DESKTOP_BROWSER = 101, 
            sys.EDITOR_PAGE = 102, sys.EDITOR_CORE = 103, sys.WECHAT_GAME = 104, sys.QQ_PLAY = 105, 
            sys.BROWSER_TYPE_WECHAT = "wechat", sys.BROWSER_TYPE_WECHAT_GAME = "wechatgame", 
            sys.BROWSER_TYPE_WECHAT_GAME_SUB = "wechatgamesub", sys.BROWSER_TYPE_QQ_PLAY = "qqplay", 
            sys.BROWSER_TYPE_ANDROID = "androidbrowser", sys.BROWSER_TYPE_IE = "ie", sys.BROWSER_TYPE_QQ = "qqbrowser", 
            sys.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser", sys.BROWSER_TYPE_UC = "ucbrowser", sys.BROWSER_TYPE_UCBS = "ucbs", 
            sys.BROWSER_TYPE_360 = "360browser", sys.BROWSER_TYPE_BAIDU_APP = "baiduboxapp", 
            sys.BROWSER_TYPE_BAIDU = "baidubrowser", sys.BROWSER_TYPE_MAXTHON = "maxthon", sys.BROWSER_TYPE_OPERA = "opera", 
            sys.BROWSER_TYPE_OUPENG = "oupeng", sys.BROWSER_TYPE_MIUI = "miuibrowser", sys.BROWSER_TYPE_FIREFOX = "firefox", 
            sys.BROWSER_TYPE_SAFARI = "safari", sys.BROWSER_TYPE_CHROME = "chrome", sys.BROWSER_TYPE_LIEBAO = "liebao", 
            sys.BROWSER_TYPE_QZONE = "qzone", sys.BROWSER_TYPE_SOUGOU = "sogou", sys.BROWSER_TYPE_UNKNOWN = "unknown", 
            sys.isNative = !1, sys.isBrowser = "object" === ("undefined" == typeof window ? "undefined" : _typeof(window)) && "object" === ("undefined" == typeof document ? "undefined" : _typeof(document)) && !0, 
            sys.isLittleEndian = (buffer = new ArrayBuffer(2), new DataView(buffer).setInt16(0, 256, !0), 
            256 === new Int16Array(buffer)[0]);
            var win = window, nav = win.navigator, doc = document, docEle = doc.documentElement, ua = nav.userAgent.toLowerCase();
            sys.isMobile = /mobile|android|iphone|ipad/.test(ua), sys.platform = sys.isMobile ? sys.MOBILE_BROWSER : sys.DESKTOP_BROWSER;
            var currLanguage = nav.language;
            currLanguage = (currLanguage = currLanguage || nav.browserLanguage) ? currLanguage.split("-")[0] : sys.LANGUAGE_ENGLISH, 
            sys.language = currLanguage;
            var isAndroid = !1, iOS = !1, osVersion = "", osMainVersion = 0, uaResult = /android (\d+(?:\.\d+)+)/i.exec(ua) || /android (\d+(?:\.\d+)+)/i.exec(nav.platform);
            uaResult && (isAndroid = !0, osVersion = uaResult[1] || "", osMainVersion = parseInt(osVersion) || 0), 
            (uaResult = /(iPad|iPhone|iPod).*OS ((\d+_?){2,3})/i.exec(ua)) ? (iOS = !0, osVersion = uaResult[2] || "", 
            osMainVersion = parseInt(osVersion) || 0) : /(iPhone|iPad|iPod)/.exec(nav.platform) && (iOS = !0, 
            osVersion = "", osMainVersion = 0);
            var osName = sys.OS_UNKNOWN;
            -1 !== nav.appVersion.indexOf("Win") ? osName = sys.OS_WINDOWS : iOS ? osName = sys.OS_IOS : -1 !== nav.appVersion.indexOf("Mac") ? osName = sys.OS_OSX : -1 !== nav.appVersion.indexOf("X11") && -1 === nav.appVersion.indexOf("Linux") ? osName = sys.OS_UNIX : isAndroid ? osName = sys.OS_ANDROID : -1 === nav.appVersion.indexOf("Linux") && -1 === ua.indexOf("ubuntu") || (osName = sys.OS_LINUX), 
            sys.os = osName, sys.osVersion = osVersion, sys.osMainVersion = osMainVersion, sys.browserType = sys.BROWSER_TYPE_UNKNOWN, 
            browserTypes = /mqqbrowser|micromessenger|qq|sogou|qzone|liebao|maxthon|ucbs|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|mxbrowser|miuibrowser/i.exec(ua), 
            "micromessenger" === (browserType = (browserTypes = (browserTypes = browserTypes || /qqbrowser|ucbrowser/i.exec(ua)) || /chrome|safari|firefox|trident|opera|opr\/|oupeng/i.exec(ua)) ? browserTypes[0].toLowerCase() : sys.BROWSER_TYPE_UNKNOWN) ? browserType = sys.BROWSER_TYPE_WECHAT : "safari" === browserType && isAndroid ? browserType = sys.BROWSER_TYPE_ANDROID : "qq" === browserType && ua.match(/android.*applewebkit/i) ? browserType = sys.BROWSER_TYPE_ANDROID : "trident" === browserType ? browserType = sys.BROWSER_TYPE_IE : "360 aphone" === browserType ? browserType = sys.BROWSER_TYPE_360 : "mxbrowser" === browserType ? browserType = sys.BROWSER_TYPE_MAXTHON : "opr/" === browserType && (browserType = sys.BROWSER_TYPE_OPERA), 
            sys.browserType = browserType, sys.browserVersion = "", function() {
                var tmp = ua.match(/(mqqbrowser|micromessenger|qq|sogou|qzone|liebao|maxthon|uc|ucbs|360 aphone|360|baiduboxapp|baidu|maxthon|mxbrowser|miui)(mobile)?(browser)?\/?([\d.]+)/i);
                tmp = tmp || ua.match(/(qqbrowser|chrome|safari|firefox|trident|opera|opr\/|oupeng)(mobile)?(browser)?\/?([\d.]+)/i), 
                sys.browserVersion = tmp ? tmp[4] : "";
            }();
            var _w3 = window.innerWidth || document.documentElement.clientWidth, _h3 = window.innerHeight || document.documentElement.clientHeight, _ratio3 = window.devicePixelRatio || 1;
            sys.windowPixelResolution = {
                width: _ratio3 * _w3,
                height: _ratio3 * _h3
            }, sys._checkWebGLRenderMode = function() {
                if (cc.game.renderType !== cc.game.RENDER_TYPE_WEBGL) throw new Error("This feature supports WebGL render mode only.");
            };
            var _tmpCanvas1 = document.createElement("canvas");
            try {
                var localStorage = sys.localStorage = win.localStorage;
                localStorage.setItem("storage", ""), localStorage.removeItem("storage"), localStorage = null;
            } catch (e) {
                var warn$1 = function warn() {
                    cc.warnID(5200);
                };
                sys.localStorage = {
                    getItem: warn$1,
                    setItem: warn$1,
                    removeItem: warn$1,
                    clear: warn$1
                };
            }
            var _supportWebp = _tmpCanvas1.toDataURL("image/webp").startsWith("data:image/webp"), _supportCanvas = !!_tmpCanvas1.getContext("2d"), _supportWebGL = !1;
            if (sys.browserType === sys.BROWSER_TYPE_WECHAT_GAME) _supportWebGL = !0; else if (win.WebGLRenderingContext && (function create3DContext(canvas, opt_attribs, opt_contextType) {
                if (!opt_contextType) return create3DContext(canvas, opt_attribs, "webgl") || create3DContext(canvas, opt_attribs, "experimental-webgl") || create3DContext(canvas, opt_attribs, "webkit-3d") || create3DContext(canvas, opt_attribs, "moz-webgl") || null;
                try {
                    return canvas.getContext(opt_contextType, opt_attribs);
                } catch (e) {
                    return null;
                }
            }(document.createElement("CANVAS")) && (_supportWebGL = !0), _supportWebGL && sys.os === sys.OS_ANDROID)) {
                var browserVer = parseFloat(sys.browserVersion);
                switch (sys.browserType) {
                  case sys.BROWSER_TYPE_MOBILE_QQ:
                  case sys.BROWSER_TYPE_BAIDU:
                  case sys.BROWSER_TYPE_BAIDU_APP:
                    _supportWebGL = 6.2 <= browserVer;
                    break;

                  case sys.BROWSER_TYPE_ANDROID:
                    sys.osMainVersion && 5 <= sys.osMainVersion && (_supportWebGL = !0);
                    break;

                  case sys.BROWSER_TYPE_CHROME:
                    _supportWebGL = 30 <= browserVer;
                    break;

                  case sys.BROWSER_TYPE_UC:
                    _supportWebGL = 11 < browserVer;
                    break;

                  case sys.BROWSER_TYPE_360:
                    _supportWebGL = !1;
                }
            }
            var __audioSupport, _capabilities = sys.capabilities = {
                canvas: _supportCanvas,
                opengl: _supportWebGL,
                webp: _supportWebp
            };
            void 0 === docEle.ontouchstart && void 0 === doc.ontouchstart && !nav.msPointerEnabled || (_capabilities.touches = !0), 
            void 0 !== docEle.onmouseup && (_capabilities.mouse = !0), void 0 !== docEle.onkeyup && (_capabilities.keyboard = !0), 
            (win.DeviceMotionEvent || win.DeviceOrientationEvent) && (_capabilities.accelerometer = !0), 
            supportWebAudio = sys.browserType !== sys.BROWSER_TYPE_WECHAT_GAME && !!(window.AudioContext || window.webkitAudioContext || window.mozAudioContext), 
            __audioSupport = {
                ONLY_ONE: !1,
                WEB_AUDIO: supportWebAudio,
                DELAY_CREATE_CTX: !1
            }, sys.os === sys.OS_IOS && (__audioSupport.USE_LOADER_EVENT = "loadedmetadata"), 
            sys.browserType === sys.BROWSER_TYPE_FIREFOX && (__audioSupport.DELAY_CREATE_CTX = !0, 
            __audioSupport.USE_LOADER_EVENT = "canplay"), sys.os === sys.OS_ANDROID && sys.browserType === sys.BROWSER_TYPE_UC && (__audioSupport.ONE_SOURCE = !0);
            try {
                __audioSupport.WEB_AUDIO && (__audioSupport._context = null, Object.defineProperty(__audioSupport, "context", {
                    get: function get() {
                        return this._context ? this._context : this._context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();
                    }
                }));
            } catch (error) {
                __audioSupport.WEB_AUDIO = !1, cc.logID(5201);
            }
            var audio, supportWebAudio, browserTypes, browserType, formatSupport = [];
            (audio = document.createElement("audio")).canPlayType && (audio.canPlayType('audio/ogg; codecs="vorbis"') && formatSupport.push(".ogg"), 
            audio.canPlayType("audio/mpeg") && formatSupport.push(".mp3"), audio.canPlayType('audio/wav; codecs="1"') && formatSupport.push(".wav"), 
            audio.canPlayType("audio/mp4") && formatSupport.push(".mp4"), audio.canPlayType("audio/x-m4a") && formatSupport.push(".m4a")), 
            __audioSupport.format = formatSupport, sys.__audioSupport = __audioSupport, sys.NetworkType = {
                NONE: 0,
                LAN: 1,
                WWAN: 2
            }, sys.getNetworkType = function() {
                return sys.NetworkType.LAN;
            }, sys.getBatteryLevel = function() {
                return 1;
            }, sys.garbageCollect = function() {}, sys.dumpRoot = function() {}, sys.restartVM = function() {}, 
            sys.cleanScript = function(jsfile) {}, sys.isObjectValid = function(obj) {
                return !!obj;
            }, sys.dump = function() {
                var str = "";
                str += "isMobile : " + this.isMobile + "\r\n", str += "language : " + this.language + "\r\n", 
                str += "browserType : " + this.browserType + "\r\n", str += "browserVersion : " + this.browserVersion + "\r\n", 
                str += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n", str += "os : " + this.os + "\r\n", 
                str += "osVersion : " + this.osVersion + "\r\n", str += "platform : " + this.platform + "\r\n", 
                str += "Using " + (cc.game.renderType === cc.game.RENDER_TYPE_WEBGL ? "WEBGL" : "CANVAS") + " renderer.\r\n", 
                cc.log(str);
            }, sys.openURL = function(url) {
                window.open(url);
            }, sys.now = function() {
                return Date.now ? Date.now() : +new Date();
            }, cc.sys = sys;
            var ImageFormat = cc.Enum({
                JPG: 0,
                PNG: 1,
                TIFF: 2,
                WEBP: 3,
                PVR: 4,
                ETC: 5,
                S3TC: 6,
                ATITC: 7,
                TGA: 8,
                RAWDATA: 9,
                UNKNOWN: 10
            }), macro = exports("macro", {
                SUPPORT_TEXTURE_FORMATS: [ ".pkm", ".pvr", ".webp", ".jpg", ".jpeg", ".bmp", ".png" ],
                KEY: {
                    none: 0,
                    back: 6,
                    menu: 18,
                    backspace: 8,
                    tab: 9,
                    enter: 13,
                    shift: 16,
                    ctrl: 17,
                    alt: 18,
                    pause: 19,
                    capslock: 20,
                    escape: 27,
                    space: 32,
                    pageup: 33,
                    pagedown: 34,
                    end: 35,
                    home: 36,
                    left: 37,
                    up: 38,
                    right: 39,
                    down: 40,
                    select: 41,
                    insert: 45,
                    Delete: 46,
                    0: 48,
                    1: 49,
                    2: 50,
                    3: 51,
                    4: 52,
                    5: 53,
                    6: 54,
                    7: 55,
                    8: 56,
                    9: 57,
                    a: 65,
                    b: 66,
                    c: 67,
                    d: 68,
                    e: 69,
                    f: 70,
                    g: 71,
                    h: 72,
                    i: 73,
                    j: 74,
                    k: 75,
                    l: 76,
                    m: 77,
                    n: 78,
                    o: 79,
                    p: 80,
                    q: 81,
                    r: 82,
                    s: 83,
                    t: 84,
                    u: 85,
                    v: 86,
                    w: 87,
                    x: 88,
                    y: 89,
                    z: 90,
                    num0: 96,
                    num1: 97,
                    num2: 98,
                    num3: 99,
                    num4: 100,
                    num5: 101,
                    num6: 102,
                    num7: 103,
                    num8: 104,
                    num9: 105,
                    "*": 106,
                    "+": 107,
                    "-": 109,
                    numdel: 110,
                    "/": 111,
                    f1: 112,
                    f2: 113,
                    f3: 114,
                    f4: 115,
                    f5: 116,
                    f6: 117,
                    f7: 118,
                    f8: 119,
                    f9: 120,
                    f10: 121,
                    f11: 122,
                    f12: 123,
                    numlock: 144,
                    scrolllock: 145,
                    ";": 186,
                    semicolon: 186,
                    equal: 187,
                    "=": 187,
                    ",": 188,
                    comma: 188,
                    dash: 189,
                    ".": 190,
                    period: 190,
                    forwardslash: 191,
                    grave: 192,
                    "[": 219,
                    openbracket: 219,
                    backslash: 220,
                    "]": 221,
                    closebracket: 221,
                    quote: 222,
                    dpadLeft: 1e3,
                    dpadRight: 1001,
                    dpadUp: 1003,
                    dpadDown: 1004,
                    dpadCenter: 1005
                },
                ImageFormat: ImageFormat,
                RAD: Math.PI / 180,
                DEG: 180 / Math.PI,
                REPEAT_FOREVER: Number.MAX_VALUE - 1,
                FLT_EPSILON: 1.192092896e-7,
                MIN_ZINDEX: -Math.pow(2, 15),
                MAX_ZINDEX: Math.pow(2, 15) - 1,
                ORIENTATION_PORTRAIT: 1,
                ORIENTATION_LANDSCAPE: 2,
                ORIENTATION_AUTO: 3,
                DENSITYDPI_DEVICE: "device-dpi",
                DENSITYDPI_HIGH: "high-dpi",
                DENSITYDPI_MEDIUM: "medium-dpi",
                DENSITYDPI_LOW: "low-dpi",
                FIX_ARTIFACTS_BY_STRECHING_TEXEL_TMX: !0,
                DIRECTOR_STATS_POSITION: new Vec2(0, 0),
                ENABLE_STACKABLE_ACTIONS: !0,
                TOUCH_TIMEOUT: 5e3,
                BATCH_VERTEX_COUNT: 2e4,
                ENABLE_TILEDMAP_CULLING: !0,
                DOWNLOAD_MAX_CONCURRENT: 64,
                ENABLE_TRANSPARENT_CANVAS: !1,
                ENABLE_WEBGL_ANTIALIAS: !1,
                ENABLE_CULLING: !1,
                CLEANUP_IMAGE_CACHE: !1,
                SHOW_MESH_WIREFRAME: !1
            });
            cc.macro = macro;
            var visibleRect = {
                topLeft: cc.v2(0, 0),
                topRight: cc.v2(0, 0),
                top: cc.v2(0, 0),
                bottomLeft: cc.v2(0, 0),
                bottomRight: cc.v2(0, 0),
                bottom: cc.v2(0, 0),
                center: cc.v2(0, 0),
                left: cc.v2(0, 0),
                right: cc.v2(0, 0),
                width: 0,
                height: 0,
                init: function init(visibleRect_) {
                    var w = this.width = visibleRect_.width, h = this.height = visibleRect_.height, l = visibleRect_.x, b = visibleRect_.y, t = b + h, r = l + w;
                    this.topLeft.x = l, this.topLeft.y = t, this.topRight.x = r, this.topRight.y = t, 
                    this.top.x = l + w / 2, this.top.y = t, this.bottomLeft.x = l, this.bottomLeft.y = b, 
                    this.bottomRight.x = r, this.bottomRight.y = b, this.bottom.x = l + w / 2, this.bottom.y = b, 
                    this.center.x = l + w / 2, this.center.y = b + h / 2, this.left.x = l, this.left.y = b + h / 2, 
                    this.right.x = r, this.right.y = b + h / 2;
                }
            };
            cc.visibleRect = visibleRect;
            var GFXObjectType, GFXStatus, GFX_MAX_VERTEX_ATTRIBUTES = exports("GFX_MAX_VERTEX_ATTRIBUTES", 16), GFX_MAX_TEXTURE_UNITS = exports("GFX_MAX_TEXTURE_UNITS", 16), GFX_MAX_ATTACHMENTS = exports("GFX_MAX_ATTACHMENTS", 4), GFX_MAX_BUFFER_BINDINGS = exports("GFX_MAX_BUFFER_BINDINGS", 24);
            !function(GFXObjectType) {
                GFXObjectType[GFXObjectType.UNKNOWN = 0] = "UNKNOWN", GFXObjectType[GFXObjectType.BUFFER = 1] = "BUFFER", 
                GFXObjectType[GFXObjectType.TEXTURE = 2] = "TEXTURE", GFXObjectType[GFXObjectType.TEXTURE_VIEW = 3] = "TEXTURE_VIEW", 
                GFXObjectType[GFXObjectType.RENDER_PASS = 4] = "RENDER_PASS", GFXObjectType[GFXObjectType.FRAMEBUFFER = 5] = "FRAMEBUFFER", 
                GFXObjectType[GFXObjectType.SAMPLER = 6] = "SAMPLER", GFXObjectType[GFXObjectType.SHADER = 7] = "SHADER", 
                GFXObjectType[GFXObjectType.PIPELINE_LAYOUT = 8] = "PIPELINE_LAYOUT", GFXObjectType[GFXObjectType.PIPELINE_STATE = 9] = "PIPELINE_STATE", 
                GFXObjectType[GFXObjectType.BINDING_LAYOUT = 10] = "BINDING_LAYOUT", GFXObjectType[GFXObjectType.INPUT_ASSEMBLER = 11] = "INPUT_ASSEMBLER", 
                GFXObjectType[GFXObjectType.COMMAND_ALLOCATOR = 12] = "COMMAND_ALLOCATOR", GFXObjectType[GFXObjectType.COMMAND_BUFFER = 13] = "COMMAND_BUFFER", 
                GFXObjectType[GFXObjectType.QUEUE = 14] = "QUEUE", GFXObjectType[GFXObjectType.WINDOW = 15] = "WINDOW";
            }(GFXObjectType = GFXObjectType || exports("GFXObjectType", {})), function(GFXStatus) {
                GFXStatus[GFXStatus.UNREADY = 0] = "UNREADY", GFXStatus[GFXStatus.FAILED = 1] = "FAILED", 
                GFXStatus[GFXStatus.SUCCESS = 2] = "SUCCESS";
            }(GFXStatus = GFXStatus || exports("GFXStatus", {}));
            var GFXAttributeName, GFXType, GFXFormat, GFXBufferUsageBit, GFXMemoryUsageBit, GFXBufferFlagBit, GFXBufferAccessBit, GFXPrimitiveMode, GFXPolygonMode, GFXShadeModel, GFXCullMode, GFXComparisonFunc, GFXStencilOp, GFXBlendOp, GFXBlendFactor, GFXColorMask, GFXFilter, GFXAddress, GFXTextureType, GFXTextureUsageBit, GFXSampleCount, GFXTextureFlagBit, GFXTextureViewType, GFXShaderType, GFXBindingType, GFXCommandBufferType, GFXLoadOp, GFXStoreOp, GFXTextureLayout, GFXPipelineBindPoint, GFXDynamicState, GFXStencilFace, GFXQueueType, GFXClearFlag, GFXObject = exports("GFXObject", function() {
                function GFXObject(gfxType) {
                    _classCallCheck(this, GFXObject), this._gfxType = GFXObjectType.UNKNOWN, this._status = GFXStatus.UNREADY, 
                    this._gfxType = gfxType;
                }
                return _createClass(GFXObject, [ {
                    key: "gfxType",
                    get: function get() {
                        return this._gfxType;
                    }
                }, {
                    key: "status",
                    get: function get() {
                        return this._status;
                    }
                } ]), GFXObject;
            }());
            !function(GFXAttributeName) {
                GFXAttributeName.ATTR_POSITION = "a_position", GFXAttributeName.ATTR_NORMAL = "a_normal", 
                GFXAttributeName.ATTR_TANGENT = "a_tangent", GFXAttributeName.ATTR_BITANGENT = "a_bitangent", 
                GFXAttributeName.ATTR_WEIGHTS = "a_weights", GFXAttributeName.ATTR_JOINTS = "a_joints", 
                GFXAttributeName.ATTR_COLOR = "a_color", GFXAttributeName.ATTR_COLOR1 = "a_color1", 
                GFXAttributeName.ATTR_COLOR2 = "a_color2", GFXAttributeName.ATTR_TEX_COORD = "a_texCoord", 
                GFXAttributeName.ATTR_TEX_COORD1 = "a_texCoord1", GFXAttributeName.ATTR_TEX_COORD2 = "a_texCoord2", 
                GFXAttributeName.ATTR_TEX_COORD3 = "a_texCoord3", GFXAttributeName.ATTR_TEX_COORD4 = "a_texCoord4", 
                GFXAttributeName.ATTR_TEX_COORD5 = "a_texCoord5", GFXAttributeName.ATTR_TEX_COORD6 = "a_texCoord6", 
                GFXAttributeName.ATTR_TEX_COORD7 = "a_texCoord7", GFXAttributeName.ATTR_TEX_COORD8 = "a_texCoord8", 
                GFXAttributeName.ATTR_BATCH_ID = "a_batch_id", GFXAttributeName.ATTR_BATCH_UV = "a_batch_uv";
            }(GFXAttributeName = GFXAttributeName || exports("GFXAttributeName", {})), function(GFXType) {
                GFXType[GFXType.UNKNOWN = 0] = "UNKNOWN", GFXType[GFXType.BOOL = 1] = "BOOL", GFXType[GFXType.BOOL2 = 2] = "BOOL2", 
                GFXType[GFXType.BOOL3 = 3] = "BOOL3", GFXType[GFXType.BOOL4 = 4] = "BOOL4", GFXType[GFXType.INT = 5] = "INT", 
                GFXType[GFXType.INT2 = 6] = "INT2", GFXType[GFXType.INT3 = 7] = "INT3", GFXType[GFXType.INT4 = 8] = "INT4", 
                GFXType[GFXType.UINT = 9] = "UINT", GFXType[GFXType.UINT2 = 10] = "UINT2", GFXType[GFXType.UINT3 = 11] = "UINT3", 
                GFXType[GFXType.UINT4 = 12] = "UINT4", GFXType[GFXType.FLOAT = 13] = "FLOAT", GFXType[GFXType.FLOAT2 = 14] = "FLOAT2", 
                GFXType[GFXType.FLOAT3 = 15] = "FLOAT3", GFXType[GFXType.FLOAT4 = 16] = "FLOAT4", 
                GFXType[GFXType.MAT2 = 17] = "MAT2", GFXType[GFXType.MAT2X3 = 18] = "MAT2X3", GFXType[GFXType.MAT2X4 = 19] = "MAT2X4", 
                GFXType[GFXType.MAT3X2 = 20] = "MAT3X2", GFXType[GFXType.MAT3 = 21] = "MAT3", GFXType[GFXType.MAT3X4 = 22] = "MAT3X4", 
                GFXType[GFXType.MAT4X2 = 23] = "MAT4X2", GFXType[GFXType.MAT4X3 = 24] = "MAT4X3", 
                GFXType[GFXType.MAT4 = 25] = "MAT4", GFXType[GFXType.SAMPLER1D = 26] = "SAMPLER1D", 
                GFXType[GFXType.SAMPLER1D_ARRAY = 27] = "SAMPLER1D_ARRAY", GFXType[GFXType.SAMPLER2D = 28] = "SAMPLER2D", 
                GFXType[GFXType.SAMPLER2D_ARRAY = 29] = "SAMPLER2D_ARRAY", GFXType[GFXType.SAMPLER3D = 30] = "SAMPLER3D", 
                GFXType[GFXType.SAMPLER_CUBE = 31] = "SAMPLER_CUBE", GFXType[GFXType.COUNT = 32] = "COUNT";
            }(GFXType = GFXType || exports("GFXType", {})), function(GFXFormat) {
                GFXFormat[GFXFormat.UNKNOWN = 0] = "UNKNOWN", GFXFormat[GFXFormat.A8 = 1] = "A8", 
                GFXFormat[GFXFormat.L8 = 2] = "L8", GFXFormat[GFXFormat.LA8 = 3] = "LA8", GFXFormat[GFXFormat.R8 = 4] = "R8", 
                GFXFormat[GFXFormat.R8SN = 5] = "R8SN", GFXFormat[GFXFormat.R8UI = 6] = "R8UI", 
                GFXFormat[GFXFormat.R8I = 7] = "R8I", GFXFormat[GFXFormat.R16F = 8] = "R16F", GFXFormat[GFXFormat.R16UI = 9] = "R16UI", 
                GFXFormat[GFXFormat.R16I = 10] = "R16I", GFXFormat[GFXFormat.R32F = 11] = "R32F", 
                GFXFormat[GFXFormat.R32UI = 12] = "R32UI", GFXFormat[GFXFormat.R32I = 13] = "R32I", 
                GFXFormat[GFXFormat.RG8 = 14] = "RG8", GFXFormat[GFXFormat.RG8SN = 15] = "RG8SN", 
                GFXFormat[GFXFormat.RG8UI = 16] = "RG8UI", GFXFormat[GFXFormat.RG8I = 17] = "RG8I", 
                GFXFormat[GFXFormat.RG16F = 18] = "RG16F", GFXFormat[GFXFormat.RG16UI = 19] = "RG16UI", 
                GFXFormat[GFXFormat.RG16I = 20] = "RG16I", GFXFormat[GFXFormat.RG32F = 21] = "RG32F", 
                GFXFormat[GFXFormat.RG32UI = 22] = "RG32UI", GFXFormat[GFXFormat.RG32I = 23] = "RG32I", 
                GFXFormat[GFXFormat.RGB8 = 24] = "RGB8", GFXFormat[GFXFormat.SRGB8 = 25] = "SRGB8", 
                GFXFormat[GFXFormat.RGB8SN = 26] = "RGB8SN", GFXFormat[GFXFormat.RGB8UI = 27] = "RGB8UI", 
                GFXFormat[GFXFormat.RGB8I = 28] = "RGB8I", GFXFormat[GFXFormat.RGB16F = 29] = "RGB16F", 
                GFXFormat[GFXFormat.RGB16UI = 30] = "RGB16UI", GFXFormat[GFXFormat.RGB16I = 31] = "RGB16I", 
                GFXFormat[GFXFormat.RGB32F = 32] = "RGB32F", GFXFormat[GFXFormat.RGB32UI = 33] = "RGB32UI", 
                GFXFormat[GFXFormat.RGB32I = 34] = "RGB32I", GFXFormat[GFXFormat.RGBA8 = 35] = "RGBA8", 
                GFXFormat[GFXFormat.SRGB8_A8 = 36] = "SRGB8_A8", GFXFormat[GFXFormat.RGBA8SN = 37] = "RGBA8SN", 
                GFXFormat[GFXFormat.RGBA8UI = 38] = "RGBA8UI", GFXFormat[GFXFormat.RGBA8I = 39] = "RGBA8I", 
                GFXFormat[GFXFormat.RGBA16F = 40] = "RGBA16F", GFXFormat[GFXFormat.RGBA16UI = 41] = "RGBA16UI", 
                GFXFormat[GFXFormat.RGBA16I = 42] = "RGBA16I", GFXFormat[GFXFormat.RGBA32F = 43] = "RGBA32F", 
                GFXFormat[GFXFormat.RGBA32UI = 44] = "RGBA32UI", GFXFormat[GFXFormat.RGBA32I = 45] = "RGBA32I", 
                GFXFormat[GFXFormat.R5G6B5 = 46] = "R5G6B5", GFXFormat[GFXFormat.R11G11B10F = 47] = "R11G11B10F", 
                GFXFormat[GFXFormat.RGB5A1 = 48] = "RGB5A1", GFXFormat[GFXFormat.RGBA4 = 49] = "RGBA4", 
                GFXFormat[GFXFormat.RGB10A2 = 50] = "RGB10A2", GFXFormat[GFXFormat.RGB10A2UI = 51] = "RGB10A2UI", 
                GFXFormat[GFXFormat.RGB9E5 = 52] = "RGB9E5", GFXFormat[GFXFormat.D16 = 53] = "D16", 
                GFXFormat[GFXFormat.D16S8 = 54] = "D16S8", GFXFormat[GFXFormat.D24 = 55] = "D24", 
                GFXFormat[GFXFormat.D24S8 = 56] = "D24S8", GFXFormat[GFXFormat.D32F = 57] = "D32F", 
                GFXFormat[GFXFormat.D32F_S8 = 58] = "D32F_S8", GFXFormat[GFXFormat.BC1 = 59] = "BC1", 
                GFXFormat[GFXFormat.BC1_ALPHA = 60] = "BC1_ALPHA", GFXFormat[GFXFormat.BC1_SRGB = 61] = "BC1_SRGB", 
                GFXFormat[GFXFormat.BC1_SRGB_ALPHA = 62] = "BC1_SRGB_ALPHA", GFXFormat[GFXFormat.BC2 = 63] = "BC2", 
                GFXFormat[GFXFormat.BC2_SRGB = 64] = "BC2_SRGB", GFXFormat[GFXFormat.BC3 = 65] = "BC3", 
                GFXFormat[GFXFormat.BC3_SRGB = 66] = "BC3_SRGB", GFXFormat[GFXFormat.BC4 = 67] = "BC4", 
                GFXFormat[GFXFormat.BC4_SNORM = 68] = "BC4_SNORM", GFXFormat[GFXFormat.BC5 = 69] = "BC5", 
                GFXFormat[GFXFormat.BC5_SNORM = 70] = "BC5_SNORM", GFXFormat[GFXFormat.BC6H_UF16 = 71] = "BC6H_UF16", 
                GFXFormat[GFXFormat.BC6H_SF16 = 72] = "BC6H_SF16", GFXFormat[GFXFormat.BC7 = 73] = "BC7", 
                GFXFormat[GFXFormat.BC7_SRGB = 74] = "BC7_SRGB", GFXFormat[GFXFormat.ETC_RGB8 = 75] = "ETC_RGB8", 
                GFXFormat[GFXFormat.ETC2_RGB8 = 76] = "ETC2_RGB8", GFXFormat[GFXFormat.ETC2_SRGB8 = 77] = "ETC2_SRGB8", 
                GFXFormat[GFXFormat.ETC2_RGB8_A1 = 78] = "ETC2_RGB8_A1", GFXFormat[GFXFormat.ETC2_SRGB8_A1 = 79] = "ETC2_SRGB8_A1", 
                GFXFormat[GFXFormat.ETC2_RGBA8 = 80] = "ETC2_RGBA8", GFXFormat[GFXFormat.ETC2_SRGB8_A8 = 81] = "ETC2_SRGB8_A8", 
                GFXFormat[GFXFormat.EAC_R11 = 82] = "EAC_R11", GFXFormat[GFXFormat.EAC_R11SN = 83] = "EAC_R11SN", 
                GFXFormat[GFXFormat.EAC_RG11 = 84] = "EAC_RG11", GFXFormat[GFXFormat.EAC_RG11SN = 85] = "EAC_RG11SN", 
                GFXFormat[GFXFormat.PVRTC_RGB2 = 86] = "PVRTC_RGB2", GFXFormat[GFXFormat.PVRTC_RGBA2 = 87] = "PVRTC_RGBA2", 
                GFXFormat[GFXFormat.PVRTC_RGB4 = 88] = "PVRTC_RGB4", GFXFormat[GFXFormat.PVRTC_RGBA4 = 89] = "PVRTC_RGBA4", 
                GFXFormat[GFXFormat.PVRTC2_2BPP = 90] = "PVRTC2_2BPP", GFXFormat[GFXFormat.PVRTC2_4BPP = 91] = "PVRTC2_4BPP";
            }(GFXFormat = GFXFormat || exports("GFXFormat", {})), function(GFXBufferUsageBit) {
                GFXBufferUsageBit[GFXBufferUsageBit.NONE = 0] = "NONE", GFXBufferUsageBit[GFXBufferUsageBit.TRANSFER_SRC = 1] = "TRANSFER_SRC", 
                GFXBufferUsageBit[GFXBufferUsageBit.TRANSFER_DST = 2] = "TRANSFER_DST", GFXBufferUsageBit[GFXBufferUsageBit.INDEX = 4] = "INDEX", 
                GFXBufferUsageBit[GFXBufferUsageBit.VERTEX = 8] = "VERTEX", GFXBufferUsageBit[GFXBufferUsageBit.UNIFORM = 16] = "UNIFORM", 
                GFXBufferUsageBit[GFXBufferUsageBit.STORAGE = 32] = "STORAGE", GFXBufferUsageBit[GFXBufferUsageBit.INDIRECT = 64] = "INDIRECT";
            }(GFXBufferUsageBit = GFXBufferUsageBit || exports("GFXBufferUsageBit", {})), function(GFXMemoryUsageBit) {
                GFXMemoryUsageBit[GFXMemoryUsageBit.NONE = 0] = "NONE", GFXMemoryUsageBit[GFXMemoryUsageBit.DEVICE = 1] = "DEVICE", 
                GFXMemoryUsageBit[GFXMemoryUsageBit.HOST = 2] = "HOST";
            }(GFXMemoryUsageBit = GFXMemoryUsageBit || exports("GFXMemoryUsageBit", {})), function(GFXBufferFlagBit) {
                GFXBufferFlagBit[GFXBufferFlagBit.NONE = 0] = "NONE", GFXBufferFlagBit[GFXBufferFlagBit.BAKUP_BUFFER = 4] = "BAKUP_BUFFER";
            }(GFXBufferFlagBit = GFXBufferFlagBit || exports("GFXBufferFlagBit", {})), function(GFXBufferAccessBit) {
                GFXBufferAccessBit[GFXBufferAccessBit.NONE = 0] = "NONE", GFXBufferAccessBit[GFXBufferAccessBit.READ = 1] = "READ", 
                GFXBufferAccessBit[GFXBufferAccessBit.WRITE = 2] = "WRITE";
            }(GFXBufferAccessBit = GFXBufferAccessBit || exports("GFXBufferAccessBit", {})), 
            function(GFXPrimitiveMode) {
                GFXPrimitiveMode[GFXPrimitiveMode.POINT_LIST = 0] = "POINT_LIST", GFXPrimitiveMode[GFXPrimitiveMode.LINE_LIST = 1] = "LINE_LIST", 
                GFXPrimitiveMode[GFXPrimitiveMode.LINE_STRIP = 2] = "LINE_STRIP", GFXPrimitiveMode[GFXPrimitiveMode.LINE_LOOP = 3] = "LINE_LOOP", 
                GFXPrimitiveMode[GFXPrimitiveMode.LINE_LIST_ADJACENCY = 4] = "LINE_LIST_ADJACENCY", 
                GFXPrimitiveMode[GFXPrimitiveMode.LINE_STRIP_ADJACENCY = 5] = "LINE_STRIP_ADJACENCY", 
                GFXPrimitiveMode[GFXPrimitiveMode.ISO_LINE_LIST = 6] = "ISO_LINE_LIST", GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_LIST = 7] = "TRIANGLE_LIST", 
                GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_STRIP = 8] = "TRIANGLE_STRIP", GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_FAN = 9] = "TRIANGLE_FAN", 
                GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_LIST_ADJACENCY = 10] = "TRIANGLE_LIST_ADJACENCY", 
                GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_STRIP_ADJACENCY = 11] = "TRIANGLE_STRIP_ADJACENCY", 
                GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_PATCH_ADJACENCY = 12] = "TRIANGLE_PATCH_ADJACENCY", 
                GFXPrimitiveMode[GFXPrimitiveMode.QUAD_PATCH_LIST = 13] = "QUAD_PATCH_LIST";
            }(GFXPrimitiveMode = GFXPrimitiveMode || exports("GFXPrimitiveMode", {})), function(GFXPolygonMode) {
                GFXPolygonMode[GFXPolygonMode.FILL = 0] = "FILL", GFXPolygonMode[GFXPolygonMode.POINT = 1] = "POINT", 
                GFXPolygonMode[GFXPolygonMode.LINE = 2] = "LINE";
            }(GFXPolygonMode = GFXPolygonMode || exports("GFXPolygonMode", {})), function(GFXShadeModel) {
                GFXShadeModel[GFXShadeModel.GOURAND = 0] = "GOURAND", GFXShadeModel[GFXShadeModel.FLAT = 1] = "FLAT";
            }(GFXShadeModel = GFXShadeModel || exports("GFXShadeModel", {})), function(GFXCullMode) {
                GFXCullMode[GFXCullMode.NONE = 0] = "NONE", GFXCullMode[GFXCullMode.FRONT = 1] = "FRONT", 
                GFXCullMode[GFXCullMode.BACK = 2] = "BACK";
            }(GFXCullMode = GFXCullMode || exports("GFXCullMode", {})), function(GFXComparisonFunc) {
                GFXComparisonFunc[GFXComparisonFunc.NEVER = 0] = "NEVER", GFXComparisonFunc[GFXComparisonFunc.LESS = 1] = "LESS", 
                GFXComparisonFunc[GFXComparisonFunc.EQUAL = 2] = "EQUAL", GFXComparisonFunc[GFXComparisonFunc.LESS_EQUAL = 3] = "LESS_EQUAL", 
                GFXComparisonFunc[GFXComparisonFunc.GREATER = 4] = "GREATER", GFXComparisonFunc[GFXComparisonFunc.NOT_EQUAL = 5] = "NOT_EQUAL", 
                GFXComparisonFunc[GFXComparisonFunc.GREATER_EQUAL = 6] = "GREATER_EQUAL", GFXComparisonFunc[GFXComparisonFunc.ALWAYS = 7] = "ALWAYS";
            }(GFXComparisonFunc = GFXComparisonFunc || exports("GFXComparisonFunc", {})), function(GFXStencilOp) {
                GFXStencilOp[GFXStencilOp.ZERO = 0] = "ZERO", GFXStencilOp[GFXStencilOp.KEEP = 1] = "KEEP", 
                GFXStencilOp[GFXStencilOp.REPLACE = 2] = "REPLACE", GFXStencilOp[GFXStencilOp.INCR = 3] = "INCR", 
                GFXStencilOp[GFXStencilOp.DECR = 4] = "DECR", GFXStencilOp[GFXStencilOp.INVERT = 5] = "INVERT", 
                GFXStencilOp[GFXStencilOp.INCR_WRAP = 6] = "INCR_WRAP", GFXStencilOp[GFXStencilOp.DECR_WRAP = 7] = "DECR_WRAP";
            }(GFXStencilOp = GFXStencilOp || exports("GFXStencilOp", {})), function(GFXBlendOp) {
                GFXBlendOp[GFXBlendOp.ADD = 0] = "ADD", GFXBlendOp[GFXBlendOp.SUB = 1] = "SUB", 
                GFXBlendOp[GFXBlendOp.REV_SUB = 2] = "REV_SUB", GFXBlendOp[GFXBlendOp.MIN = 3] = "MIN", 
                GFXBlendOp[GFXBlendOp.MAX = 4] = "MAX";
            }(GFXBlendOp = GFXBlendOp || exports("GFXBlendOp", {})), function(GFXBlendFactor) {
                GFXBlendFactor[GFXBlendFactor.ZERO = 0] = "ZERO", GFXBlendFactor[GFXBlendFactor.ONE = 1] = "ONE", 
                GFXBlendFactor[GFXBlendFactor.SRC_ALPHA = 2] = "SRC_ALPHA", GFXBlendFactor[GFXBlendFactor.DST_ALPHA = 3] = "DST_ALPHA", 
                GFXBlendFactor[GFXBlendFactor.ONE_MINUS_SRC_ALPHA = 4] = "ONE_MINUS_SRC_ALPHA", 
                GFXBlendFactor[GFXBlendFactor.ONE_MINUS_DST_ALPHA = 5] = "ONE_MINUS_DST_ALPHA", 
                GFXBlendFactor[GFXBlendFactor.SRC_COLOR = 6] = "SRC_COLOR", GFXBlendFactor[GFXBlendFactor.DST_COLOR = 7] = "DST_COLOR", 
                GFXBlendFactor[GFXBlendFactor.ONE_MINUS_SRC_COLOR = 8] = "ONE_MINUS_SRC_COLOR", 
                GFXBlendFactor[GFXBlendFactor.ONE_MINUS_DST_COLOR = 9] = "ONE_MINUS_DST_COLOR", 
                GFXBlendFactor[GFXBlendFactor.SRC_ALPHA_SATURATE = 10] = "SRC_ALPHA_SATURATE", GFXBlendFactor[GFXBlendFactor.CONSTANT_COLOR = 11] = "CONSTANT_COLOR", 
                GFXBlendFactor[GFXBlendFactor.ONE_MINUS_CONSTANT_COLOR = 12] = "ONE_MINUS_CONSTANT_COLOR", 
                GFXBlendFactor[GFXBlendFactor.CONSTANT_ALPHA = 13] = "CONSTANT_ALPHA", GFXBlendFactor[GFXBlendFactor.ONE_MINUS_CONSTANT_ALPHA = 14] = "ONE_MINUS_CONSTANT_ALPHA";
            }(GFXBlendFactor = GFXBlendFactor || exports("GFXBlendFactor", {})), function(GFXColorMask) {
                GFXColorMask[GFXColorMask.NONE = 0] = "NONE", GFXColorMask[GFXColorMask.R = 1] = "R", 
                GFXColorMask[GFXColorMask.G = 2] = "G", GFXColorMask[GFXColorMask.B = 4] = "B", 
                GFXColorMask[GFXColorMask.A = 8] = "A", GFXColorMask[GFXColorMask.ALL = 15] = "ALL";
            }(GFXColorMask = GFXColorMask || exports("GFXColorMask", {})), function(GFXFilter) {
                GFXFilter[GFXFilter.NONE = 0] = "NONE", GFXFilter[GFXFilter.POINT = 1] = "POINT", 
                GFXFilter[GFXFilter.LINEAR = 2] = "LINEAR", GFXFilter[GFXFilter.ANISOTROPIC = 3] = "ANISOTROPIC";
            }(GFXFilter = GFXFilter || exports("GFXFilter", {})), function(GFXAddress) {
                GFXAddress[GFXAddress.WRAP = 0] = "WRAP", GFXAddress[GFXAddress.MIRROR = 1] = "MIRROR", 
                GFXAddress[GFXAddress.CLAMP = 2] = "CLAMP", GFXAddress[GFXAddress.BORDER = 3] = "BORDER";
            }(GFXAddress = GFXAddress || exports("GFXAddress", {})), function(GFXTextureType) {
                GFXTextureType[GFXTextureType.TEX1D = 0] = "TEX1D", GFXTextureType[GFXTextureType.TEX2D = 1] = "TEX2D", 
                GFXTextureType[GFXTextureType.TEX3D = 2] = "TEX3D";
            }(GFXTextureType = GFXTextureType || exports("GFXTextureType", {})), function(GFXTextureUsageBit) {
                GFXTextureUsageBit[GFXTextureUsageBit.NONE = 0] = "NONE", GFXTextureUsageBit[GFXTextureUsageBit.TRANSFER_SRC = 1] = "TRANSFER_SRC", 
                GFXTextureUsageBit[GFXTextureUsageBit.TRANSFER_DST = 2] = "TRANSFER_DST", GFXTextureUsageBit[GFXTextureUsageBit.SAMPLED = 4] = "SAMPLED", 
                GFXTextureUsageBit[GFXTextureUsageBit.STORAGE = 8] = "STORAGE", GFXTextureUsageBit[GFXTextureUsageBit.COLOR_ATTACHMENT = 16] = "COLOR_ATTACHMENT", 
                GFXTextureUsageBit[GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT = 32] = "DEPTH_STENCIL_ATTACHMENT", 
                GFXTextureUsageBit[GFXTextureUsageBit.TRANSIENT_ATTACHMENT = 64] = "TRANSIENT_ATTACHMENT", 
                GFXTextureUsageBit[GFXTextureUsageBit.INPUT_ATTACHMENT = 128] = "INPUT_ATTACHMENT";
            }(GFXTextureUsageBit = GFXTextureUsageBit || exports("GFXTextureUsageBit", {})), 
            function(GFXSampleCount) {
                GFXSampleCount[GFXSampleCount.X1 = 0] = "X1", GFXSampleCount[GFXSampleCount.X2 = 1] = "X2", 
                GFXSampleCount[GFXSampleCount.X4 = 2] = "X4", GFXSampleCount[GFXSampleCount.X8 = 3] = "X8", 
                GFXSampleCount[GFXSampleCount.X16 = 4] = "X16", GFXSampleCount[GFXSampleCount.X32 = 5] = "X32", 
                GFXSampleCount[GFXSampleCount.X64 = 6] = "X64";
            }(GFXSampleCount = GFXSampleCount || exports("GFXSampleCount", {})), function(GFXTextureFlagBit) {
                GFXTextureFlagBit[GFXTextureFlagBit.NONE = 0] = "NONE", GFXTextureFlagBit[GFXTextureFlagBit.GEN_MIPMAP = 1] = "GEN_MIPMAP", 
                GFXTextureFlagBit[GFXTextureFlagBit.CUBEMAP = 2] = "CUBEMAP", GFXTextureFlagBit[GFXTextureFlagBit.BAKUP_BUFFER = 4] = "BAKUP_BUFFER";
            }(GFXTextureFlagBit = GFXTextureFlagBit || exports("GFXTextureFlagBit", {})), function(GFXTextureViewType) {
                GFXTextureViewType[GFXTextureViewType.TV1D = 0] = "TV1D", GFXTextureViewType[GFXTextureViewType.TV2D = 1] = "TV2D", 
                GFXTextureViewType[GFXTextureViewType.TV3D = 2] = "TV3D", GFXTextureViewType[GFXTextureViewType.CUBE = 3] = "CUBE", 
                GFXTextureViewType[GFXTextureViewType.TV1D_ARRAY = 4] = "TV1D_ARRAY", GFXTextureViewType[GFXTextureViewType.TV2D_ARRAY = 5] = "TV2D_ARRAY";
            }(GFXTextureViewType = GFXTextureViewType || exports("GFXTextureViewType", {})), 
            function(GFXShaderType) {
                GFXShaderType[GFXShaderType.VERTEX = 0] = "VERTEX", GFXShaderType[GFXShaderType.HULL = 1] = "HULL", 
                GFXShaderType[GFXShaderType.DOMAIN = 2] = "DOMAIN", GFXShaderType[GFXShaderType.GEOMETRY = 3] = "GEOMETRY", 
                GFXShaderType[GFXShaderType.FRAGMENT = 4] = "FRAGMENT", GFXShaderType[GFXShaderType.COMPUTE = 5] = "COMPUTE", 
                GFXShaderType[GFXShaderType.COUNT = 6] = "COUNT";
            }(GFXShaderType = GFXShaderType || exports("GFXShaderType", {})), function(GFXBindingType) {
                GFXBindingType[GFXBindingType.UNKNOWN = 0] = "UNKNOWN", GFXBindingType[GFXBindingType.UNIFORM_BUFFER = 1] = "UNIFORM_BUFFER", 
                GFXBindingType[GFXBindingType.SAMPLER = 2] = "SAMPLER", GFXBindingType[GFXBindingType.STORAGE_BUFFER = 3] = "STORAGE_BUFFER";
            }(GFXBindingType = GFXBindingType || exports("GFXBindingType", {})), function(GFXCommandBufferType) {
                GFXCommandBufferType[GFXCommandBufferType.PRIMARY = 0] = "PRIMARY", GFXCommandBufferType[GFXCommandBufferType.SECONDARY = 1] = "SECONDARY";
            }(GFXCommandBufferType = GFXCommandBufferType || exports("GFXCommandBufferType", {})), 
            function(GFXLoadOp) {
                GFXLoadOp[GFXLoadOp.LOAD = 0] = "LOAD", GFXLoadOp[GFXLoadOp.CLEAR = 1] = "CLEAR", 
                GFXLoadOp[GFXLoadOp.DISCARD = 2] = "DISCARD";
            }(GFXLoadOp = GFXLoadOp || exports("GFXLoadOp", {})), function(GFXStoreOp) {
                GFXStoreOp[GFXStoreOp.STORE = 0] = "STORE", GFXStoreOp[GFXStoreOp.DISCARD = 1] = "DISCARD";
            }(GFXStoreOp = GFXStoreOp || exports("GFXStoreOp", {})), function(GFXTextureLayout) {
                GFXTextureLayout[GFXTextureLayout.UNDEFINED = 0] = "UNDEFINED", GFXTextureLayout[GFXTextureLayout.GENERAL = 1] = "GENERAL", 
                GFXTextureLayout[GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL = 2] = "COLOR_ATTACHMENT_OPTIMAL", 
                GFXTextureLayout[GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3] = "DEPTH_STENCIL_ATTACHMENT_OPTIMAL", 
                GFXTextureLayout[GFXTextureLayout.DEPTH_STENCIL_READONLY_OPTIMAL = 4] = "DEPTH_STENCIL_READONLY_OPTIMAL", 
                GFXTextureLayout[GFXTextureLayout.SHADER_READONLY_OPTIMAL = 5] = "SHADER_READONLY_OPTIMAL", 
                GFXTextureLayout[GFXTextureLayout.TRANSFER_SRC_OPTIMAL = 6] = "TRANSFER_SRC_OPTIMAL", 
                GFXTextureLayout[GFXTextureLayout.TRANSFER_DST_OPTIMAL = 7] = "TRANSFER_DST_OPTIMAL", 
                GFXTextureLayout[GFXTextureLayout.PREINITIALIZED = 8] = "PREINITIALIZED", GFXTextureLayout[GFXTextureLayout.PRESENT_SRC = 9] = "PRESENT_SRC";
            }(GFXTextureLayout = GFXTextureLayout || exports("GFXTextureLayout", {})), function(GFXPipelineBindPoint) {
                GFXPipelineBindPoint[GFXPipelineBindPoint.GRAPHICS = 0] = "GRAPHICS", GFXPipelineBindPoint[GFXPipelineBindPoint.COMPUTE = 1] = "COMPUTE", 
                GFXPipelineBindPoint[GFXPipelineBindPoint.RAY_TRACING = 2] = "RAY_TRACING";
            }(GFXPipelineBindPoint = GFXPipelineBindPoint || exports("GFXPipelineBindPoint", {})), 
            function(GFXDynamicState) {
                GFXDynamicState[GFXDynamicState.VIEWPORT = 0] = "VIEWPORT", GFXDynamicState[GFXDynamicState.SCISSOR = 1] = "SCISSOR", 
                GFXDynamicState[GFXDynamicState.LINE_WIDTH = 2] = "LINE_WIDTH", GFXDynamicState[GFXDynamicState.DEPTH_BIAS = 3] = "DEPTH_BIAS", 
                GFXDynamicState[GFXDynamicState.BLEND_CONSTANTS = 4] = "BLEND_CONSTANTS", GFXDynamicState[GFXDynamicState.DEPTH_BOUNDS = 5] = "DEPTH_BOUNDS", 
                GFXDynamicState[GFXDynamicState.STENCIL_WRITE_MASK = 6] = "STENCIL_WRITE_MASK", 
                GFXDynamicState[GFXDynamicState.STENCIL_COMPARE_MASK = 7] = "STENCIL_COMPARE_MASK";
            }(GFXDynamicState = GFXDynamicState || exports("GFXDynamicState", {})), function(GFXStencilFace) {
                GFXStencilFace[GFXStencilFace.FRONT = 0] = "FRONT", GFXStencilFace[GFXStencilFace.BACK = 1] = "BACK", 
                GFXStencilFace[GFXStencilFace.ALL = 2] = "ALL";
            }(GFXStencilFace = GFXStencilFace || exports("GFXStencilFace", {})), function(GFXQueueType) {
                GFXQueueType[GFXQueueType.GRAPHICS = 0] = "GRAPHICS", GFXQueueType[GFXQueueType.COMPUTE = 1] = "COMPUTE", 
                GFXQueueType[GFXQueueType.TRANSFER = 2] = "TRANSFER";
            }(GFXQueueType = GFXQueueType || exports("GFXQueueType", {})), function(GFXClearFlag) {
                GFXClearFlag[GFXClearFlag.NONE = 0] = "NONE", GFXClearFlag[GFXClearFlag.COLOR = 1] = "COLOR", 
                GFXClearFlag[GFXClearFlag.DEPTH = 2] = "DEPTH", GFXClearFlag[GFXClearFlag.STENCIL = 4] = "STENCIL", 
                GFXClearFlag[GFXClearFlag.DEPTH_STENCIL = 6] = "DEPTH_STENCIL", GFXClearFlag[GFXClearFlag.ALL = 7] = "ALL";
            }(GFXClearFlag = GFXClearFlag || exports("GFXClearFlag", {}));
            var GFXFormatType, GFXTextureSubres = exports("GFXTextureSubres", function GFXTextureSubres() {
                _classCallCheck(this, GFXTextureSubres), this.baseMipLevel = 0, this.levelCount = 1, 
                this.baseArrayLayer = 0, this.layerCount = 1;
            }), GFXTextureCopy = exports("GFXTextureCopy", function GFXTextureCopy() {
                _classCallCheck(this, GFXTextureCopy), this.srcSubres = new GFXTextureSubres(), 
                this.srcOffset = {
                    x: 0,
                    y: 0,
                    z: 0
                }, this.dstSubres = new GFXTextureSubres(), this.dstOffset = {
                    x: 0,
                    y: 0,
                    z: 0
                }, this.extent = {
                    width: 0,
                    height: 0,
                    depth: 0
                };
            }), GFXBufferTextureCopy = exports("GFXBufferTextureCopy", function GFXBufferTextureCopy() {
                _classCallCheck(this, GFXBufferTextureCopy), this.buffOffset = 0, this.buffStride = 0, 
                this.buffTexHeight = 0, this.texOffset = {
                    x: 0,
                    y: 0,
                    z: 0
                }, this.texExtent = {
                    width: 0,
                    height: 0,
                    depth: 0
                }, this.texSubres = new GFXTextureSubres();
            });
            !function(GFXFormatType) {
                GFXFormatType[GFXFormatType.NONE = 0] = "NONE", GFXFormatType[GFXFormatType.UNORM = 1] = "UNORM", 
                GFXFormatType[GFXFormatType.SNORM = 2] = "SNORM", GFXFormatType[GFXFormatType.UINT = 3] = "UINT", 
                GFXFormatType[GFXFormatType.INT = 4] = "INT", GFXFormatType[GFXFormatType.UFLOAT = 5] = "UFLOAT", 
                GFXFormatType[GFXFormatType.FLOAT = 6] = "FLOAT";
            }(GFXFormatType = GFXFormatType || exports("GFXFormatType", {}));
            var GFXFormatInfos = exports("GFXFormatInfos", [ {
                name: "UNKNOWN",
                size: 0,
                count: 0,
                type: GFXFormatType.NONE,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "A8",
                size: 1,
                count: 1,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "L8",
                size: 1,
                count: 1,
                type: GFXFormatType.UNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "LA8",
                size: 1,
                count: 2,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "R8",
                size: 1,
                count: 1,
                type: GFXFormatType.UNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "R8SN",
                size: 1,
                count: 1,
                type: GFXFormatType.SNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "R8UI",
                size: 1,
                count: 1,
                type: GFXFormatType.UINT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "R8I",
                size: 1,
                count: 1,
                type: GFXFormatType.INT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "R16F",
                size: 2,
                count: 1,
                type: GFXFormatType.FLOAT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "R16UI",
                size: 2,
                count: 1,
                type: GFXFormatType.UINT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "R16I",
                size: 2,
                count: 1,
                type: GFXFormatType.INT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "R32F",
                size: 4,
                count: 1,
                type: GFXFormatType.FLOAT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "R32UI",
                size: 4,
                count: 1,
                type: GFXFormatType.UINT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "R32I",
                size: 4,
                count: 1,
                type: GFXFormatType.INT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RG8",
                size: 2,
                count: 2,
                type: GFXFormatType.UNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RG8SN",
                size: 2,
                count: 2,
                type: GFXFormatType.SNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RG8UI",
                size: 2,
                count: 2,
                type: GFXFormatType.UINT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RG8I",
                size: 2,
                count: 2,
                type: GFXFormatType.INT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RG16F",
                size: 4,
                count: 2,
                type: GFXFormatType.FLOAT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RG16UI",
                size: 4,
                count: 2,
                type: GFXFormatType.UINT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RG16I",
                size: 4,
                count: 2,
                type: GFXFormatType.INT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RG32F",
                size: 8,
                count: 2,
                type: GFXFormatType.FLOAT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RG32UI",
                size: 8,
                count: 2,
                type: GFXFormatType.UINT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RG32I",
                size: 8,
                count: 2,
                type: GFXFormatType.INT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGB8",
                size: 3,
                count: 3,
                type: GFXFormatType.UNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "SRGB8",
                size: 3,
                count: 3,
                type: GFXFormatType.UNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGB8SN",
                size: 3,
                count: 3,
                type: GFXFormatType.SNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGB8UI",
                size: 3,
                count: 3,
                type: GFXFormatType.UINT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGB8I",
                size: 3,
                count: 3,
                type: GFXFormatType.INT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGB16F",
                size: 6,
                count: 3,
                type: GFXFormatType.FLOAT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGB16UI",
                size: 6,
                count: 3,
                type: GFXFormatType.UINT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGB16I",
                size: 6,
                count: 3,
                type: GFXFormatType.INT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGB32F",
                size: 12,
                count: 3,
                type: GFXFormatType.FLOAT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGB32UI",
                size: 12,
                count: 3,
                type: GFXFormatType.UINT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGB32I",
                size: 12,
                count: 3,
                type: GFXFormatType.INT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGBA8",
                size: 4,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "SRGB8_A8",
                size: 4,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGBA8SN",
                size: 4,
                count: 4,
                type: GFXFormatType.SNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGBA8UI",
                size: 4,
                count: 4,
                type: GFXFormatType.UINT,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGBA8I",
                size: 4,
                count: 4,
                type: GFXFormatType.INT,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGBA16F",
                size: 8,
                count: 4,
                type: GFXFormatType.FLOAT,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGBA16UI",
                size: 8,
                count: 4,
                type: GFXFormatType.UINT,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGBA16I",
                size: 8,
                count: 4,
                type: GFXFormatType.INT,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGBA32F",
                size: 16,
                count: 4,
                type: GFXFormatType.FLOAT,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGBA32UI",
                size: 16,
                count: 4,
                type: GFXFormatType.UINT,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGBA32I",
                size: 16,
                count: 4,
                type: GFXFormatType.INT,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "R5G6B5",
                size: 2,
                count: 3,
                type: GFXFormatType.UNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "R11G11B10F",
                size: 4,
                count: 3,
                type: GFXFormatType.FLOAT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGB5A1",
                size: 2,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGBA4",
                size: 2,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGB10A2",
                size: 2,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGB10A2UI",
                size: 2,
                count: 4,
                type: GFXFormatType.UINT,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "RGB9E5",
                size: 2,
                count: 4,
                type: GFXFormatType.FLOAT,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "D16",
                size: 2,
                count: 1,
                type: GFXFormatType.UINT,
                hasAlpha: !1,
                hasDepth: !0,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "D16S8",
                size: 3,
                count: 2,
                type: GFXFormatType.UINT,
                hasAlpha: !1,
                hasDepth: !0,
                hasStencil: !0,
                isCompressed: !1
            }, {
                name: "D24",
                size: 3,
                count: 1,
                type: GFXFormatType.UINT,
                hasAlpha: !1,
                hasDepth: !0,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "D24S8",
                size: 4,
                count: 2,
                type: GFXFormatType.UINT,
                hasAlpha: !1,
                hasDepth: !0,
                hasStencil: !0,
                isCompressed: !1
            }, {
                name: "D32F",
                size: 4,
                count: 1,
                type: GFXFormatType.FLOAT,
                hasAlpha: !1,
                hasDepth: !0,
                hasStencil: !1,
                isCompressed: !1
            }, {
                name: "D32FS8",
                size: 5,
                count: 2,
                type: GFXFormatType.FLOAT,
                hasAlpha: !1,
                hasDepth: !0,
                hasStencil: !0,
                isCompressed: !1
            }, {
                name: "BC1",
                size: 1,
                count: 3,
                type: GFXFormatType.UNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "BC1_ALPHA",
                size: 1,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "BC1_SRGB",
                size: 1,
                count: 3,
                type: GFXFormatType.UNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "BC1_SRGB_ALPHA",
                size: 1,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "BC2",
                size: 1,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "BC2_SRGB",
                size: 1,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "BC3",
                size: 1,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "BC3_SRGB",
                size: 1,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "BC4",
                size: 1,
                count: 1,
                type: GFXFormatType.UNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "BC4_SNORM",
                size: 1,
                count: 1,
                type: GFXFormatType.SNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "BC5",
                size: 1,
                count: 2,
                type: GFXFormatType.UNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "BC5_SNORM",
                size: 1,
                count: 2,
                type: GFXFormatType.SNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "BC6H_UF16",
                size: 1,
                count: 3,
                type: GFXFormatType.UFLOAT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "BC6H_SF16",
                size: 1,
                count: 3,
                type: GFXFormatType.FLOAT,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "BC7",
                size: 1,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "BC7_SRGB",
                size: 1,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "ETC_RGB8",
                size: 1,
                count: 3,
                type: GFXFormatType.UNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "ETC2_RGB8",
                size: 1,
                count: 3,
                type: GFXFormatType.UNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "ETC2_SRGB8",
                size: 1,
                count: 3,
                type: GFXFormatType.UNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "ETC2_RGB8_A1",
                size: 1,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "ETC2_SRGB8_A1",
                size: 1,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "ETC2_RGBA8",
                size: 2,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "ETC2_SRGB8_A8",
                size: 2,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "EAC_R11",
                size: 1,
                count: 1,
                type: GFXFormatType.UNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "EAC_R11SN",
                size: 1,
                count: 1,
                type: GFXFormatType.SNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "EAC_RG11",
                size: 2,
                count: 2,
                type: GFXFormatType.UNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "EAC_RG11SN",
                size: 2,
                count: 2,
                type: GFXFormatType.SNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "PVRTC_RGB2",
                size: 2,
                count: 3,
                type: GFXFormatType.UNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "PVRTC_RGBA2",
                size: 2,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "PVRTC_RGB4",
                size: 2,
                count: 3,
                type: GFXFormatType.UNORM,
                hasAlpha: !1,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "PVRTC_RGBA4",
                size: 2,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "PVRTC2_2BPP",
                size: 2,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            }, {
                name: "PVRTC2_4BPP",
                size: 2,
                count: 4,
                type: GFXFormatType.UNORM,
                hasAlpha: !0,
                hasDepth: !1,
                hasStencil: !1,
                isCompressed: !0
            } ]);
            function GFXFormatSize(format, width, height, depth) {
                if (!GFXFormatInfos[format].isCompressed) return width * height * depth * GFXFormatInfos[format].size;
                switch (format) {
                  case GFXFormat.BC1:
                  case GFXFormat.BC1_ALPHA:
                  case GFXFormat.BC1_SRGB:
                  case GFXFormat.BC1_SRGB_ALPHA:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

                  case GFXFormat.BC2:
                  case GFXFormat.BC2_SRGB:
                  case GFXFormat.BC3:
                  case GFXFormat.BC3_SRGB:
                  case GFXFormat.BC4:
                  case GFXFormat.BC4_SNORM:
                  case GFXFormat.BC6H_SF16:
                  case GFXFormat.BC6H_UF16:
                  case GFXFormat.BC7:
                  case GFXFormat.BC7_SRGB:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

                  case GFXFormat.BC5:
                  case GFXFormat.BC5_SNORM:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 32 * depth;

                  case GFXFormat.ETC_RGB8:
                  case GFXFormat.ETC2_RGB8:
                  case GFXFormat.ETC2_SRGB8:
                  case GFXFormat.ETC2_RGB8_A1:
                  case GFXFormat.ETC2_SRGB8_A1:
                  case GFXFormat.EAC_R11:
                  case GFXFormat.EAC_R11SN:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

                  case GFXFormat.EAC_RG11:
                  case GFXFormat.EAC_RG11SN:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

                  case GFXFormat.PVRTC_RGB2:
                  case GFXFormat.PVRTC_RGBA2:
                  case GFXFormat.PVRTC2_2BPP:
                    return Math.ceil(Math.max(width, 16) * Math.max(height, 8) / 4) * depth;

                  case GFXFormat.PVRTC_RGB4:
                  case GFXFormat.PVRTC_RGBA4:
                  case GFXFormat.PVRTC2_4BPP:
                    return Math.ceil(Math.max(width, 16) * Math.max(height, 8) / 2) * depth;

                  default:
                    return 0;
                }
            }
            function GFXFormatSurfaceSize(format, width, height, depth, mips) {
                for (var size = 0, i = 0; i < mips; ++i) size += GFXFormatSize(format, width, height, depth), 
                width = Math.max(width >> 1, 1), height = Math.max(height >> 1, 1), depth = Math.max(depth >> 1, 1);
                return size;
            }
            var _type2size = [ 0, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 16, 24, 32, 24, 36, 48, 32, 48, 64, 4, 4, 4, 4, 4, 4 ];
            function GFXGetTypeSize(type) {
                return _type2size[type] || 0;
            }
            var GFXAPI, GFXFeature, GFXDefines = Object.freeze({
                GFX_MAX_VERTEX_ATTRIBUTES: GFX_MAX_VERTEX_ATTRIBUTES,
                GFX_MAX_TEXTURE_UNITS: GFX_MAX_TEXTURE_UNITS,
                GFX_MAX_ATTACHMENTS: GFX_MAX_ATTACHMENTS,
                GFX_MAX_BUFFER_BINDINGS: GFX_MAX_BUFFER_BINDINGS,
                get GFXObjectType() {
                    return GFXObjectType;
                },
                get GFXStatus() {
                    return GFXStatus;
                },
                GFXObject: GFXObject,
                get GFXAttributeName() {
                    return GFXAttributeName;
                },
                get GFXType() {
                    return GFXType;
                },
                get GFXFormat() {
                    return GFXFormat;
                },
                get GFXBufferUsageBit() {
                    return GFXBufferUsageBit;
                },
                get GFXMemoryUsageBit() {
                    return GFXMemoryUsageBit;
                },
                get GFXBufferFlagBit() {
                    return GFXBufferFlagBit;
                },
                get GFXBufferAccessBit() {
                    return GFXBufferAccessBit;
                },
                get GFXPrimitiveMode() {
                    return GFXPrimitiveMode;
                },
                get GFXPolygonMode() {
                    return GFXPolygonMode;
                },
                get GFXShadeModel() {
                    return GFXShadeModel;
                },
                get GFXCullMode() {
                    return GFXCullMode;
                },
                get GFXComparisonFunc() {
                    return GFXComparisonFunc;
                },
                get GFXStencilOp() {
                    return GFXStencilOp;
                },
                get GFXBlendOp() {
                    return GFXBlendOp;
                },
                get GFXBlendFactor() {
                    return GFXBlendFactor;
                },
                get GFXColorMask() {
                    return GFXColorMask;
                },
                get GFXFilter() {
                    return GFXFilter;
                },
                get GFXAddress() {
                    return GFXAddress;
                },
                get GFXTextureType() {
                    return GFXTextureType;
                },
                get GFXTextureUsageBit() {
                    return GFXTextureUsageBit;
                },
                get GFXSampleCount() {
                    return GFXSampleCount;
                },
                get GFXTextureFlagBit() {
                    return GFXTextureFlagBit;
                },
                get GFXTextureViewType() {
                    return GFXTextureViewType;
                },
                get GFXShaderType() {
                    return GFXShaderType;
                },
                get GFXBindingType() {
                    return GFXBindingType;
                },
                get GFXCommandBufferType() {
                    return GFXCommandBufferType;
                },
                get GFXLoadOp() {
                    return GFXLoadOp;
                },
                get GFXStoreOp() {
                    return GFXStoreOp;
                },
                get GFXTextureLayout() {
                    return GFXTextureLayout;
                },
                get GFXPipelineBindPoint() {
                    return GFXPipelineBindPoint;
                },
                get GFXDynamicState() {
                    return GFXDynamicState;
                },
                get GFXStencilFace() {
                    return GFXStencilFace;
                },
                get GFXQueueType() {
                    return GFXQueueType;
                },
                get GFXClearFlag() {
                    return GFXClearFlag;
                },
                GFXTextureSubres: GFXTextureSubres,
                GFXTextureCopy: GFXTextureCopy,
                GFXBufferTextureCopy: GFXBufferTextureCopy,
                get GFXFormatType() {
                    return GFXFormatType;
                },
                GFXFormatInfos: GFXFormatInfos,
                GFXFormatSize: GFXFormatSize,
                GFXFormatSurfaceSize: GFXFormatSurfaceSize,
                GFXGetTypeSize: GFXGetTypeSize
            });
            function murmurhash2_32_gc(str, seed) {
                for (var l = str.length, h = seed ^ l, i = 0; 4 <= l; ) {
                    var k = 255 & str.charCodeAt(i) | (255 & str.charCodeAt(++i)) << 8 | (255 & str.charCodeAt(++i)) << 16 | (255 & str.charCodeAt(++i)) << 24;
                    k = 1540483477 * (65535 & k) + ((1540483477 * (k >>> 16) & 65535) << 16), h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16) ^ (k = 1540483477 * (65535 & (k ^= k >>> 24)) + ((1540483477 * (k >>> 16) & 65535) << 16)), 
                    l -= 4, ++i;
                }
                switch (l) {
                  case 3:
                    h ^= (255 & str.charCodeAt(i + 2)) << 16;

                  case 2:
                    h ^= (255 & str.charCodeAt(i + 1)) << 8;

                  case 1:
                    h = 1540483477 * (65535 & (h ^= 255 & str.charCodeAt(i))) + ((1540483477 * (h >>> 16) & 65535) << 16);
                }
                return h = 1540483477 * (65535 & (h ^= h >>> 13)) + ((1540483477 * (h >>> 16) & 65535) << 16), 
                (h ^= h >>> 15) >>> 0;
            }
            ccenum(GFXFormat), function(GFXAPI) {
                GFXAPI[GFXAPI.UNKNOWN = 0] = "UNKNOWN", GFXAPI[GFXAPI.WEBGL = 1] = "WEBGL", GFXAPI[GFXAPI.WEBGL2 = 2] = "WEBGL2";
            }(GFXAPI = GFXAPI || {}), function(GFXFeature) {
                GFXFeature[GFXFeature.COLOR_FLOAT = 0] = "COLOR_FLOAT", GFXFeature[GFXFeature.COLOR_HALF_FLOAT = 1] = "COLOR_HALF_FLOAT", 
                GFXFeature[GFXFeature.TEXTURE_FLOAT = 2] = "TEXTURE_FLOAT", GFXFeature[GFXFeature.TEXTURE_HALF_FLOAT = 3] = "TEXTURE_HALF_FLOAT", 
                GFXFeature[GFXFeature.TEXTURE_FLOAT_LINEAR = 4] = "TEXTURE_FLOAT_LINEAR", GFXFeature[GFXFeature.TEXTURE_HALF_FLOAT_LINEAR = 5] = "TEXTURE_HALF_FLOAT_LINEAR", 
                GFXFeature[GFXFeature.FORMAT_R11G11B10F = 6] = "FORMAT_R11G11B10F", GFXFeature[GFXFeature.FORMAT_D24S8 = 7] = "FORMAT_D24S8", 
                GFXFeature[GFXFeature.FORMAT_ETC1 = 8] = "FORMAT_ETC1", GFXFeature[GFXFeature.FORMAT_ETC2 = 9] = "FORMAT_ETC2", 
                GFXFeature[GFXFeature.FORMAT_DXT = 10] = "FORMAT_DXT", GFXFeature[GFXFeature.FORMAT_PVRTC = 11] = "FORMAT_PVRTC", 
                GFXFeature[GFXFeature.FORMAT_ASTC = 12] = "FORMAT_ASTC", GFXFeature[GFXFeature.MSAA = 13] = "MSAA", 
                GFXFeature[GFXFeature.COUNT = 14] = "COUNT";
            }(GFXFeature = GFXFeature || {});
            var _class$1, GFXDevice = exports("GFXDevice", function() {
                function GFXDevice() {
                    _classCallCheck(this, GFXDevice), this._canvas = null, this._canvas2D = null, this._gfxAPI = GFXAPI.UNKNOWN, 
                    this._deviceName = "", this._renderer = "", this._vendor = "", this._version = "", 
                    this._features = new Array(GFXFeature.COUNT), this._queue = null, this._devicePixelRatio = 1, 
                    this._width = 0, this._height = 0, this._nativeWidth = 0, this._nativeHeight = 0, 
                    this._mainWindow = null, this._cmdAllocator = null, this._maxVertexAttributes = 0, 
                    this._maxVertexUniformVectors = 0, this._maxFragmentUniformVectors = 0, this._maxTextureUnits = 0, 
                    this._maxVertexTextureUnits = 0, this._maxUniformBufferBindings = GFX_MAX_BUFFER_BINDINGS, 
                    this._maxUniformBlockSize = 0, this._maxTextureSize = 0, this._maxCubeMapTextureSize = 0, 
                    this._depthBits = 0, this._stencilBits = 0, this._colorFmt = GFXFormat.UNKNOWN, 
                    this._depthStencilFmt = GFXFormat.UNKNOWN, this._shaderIdGen = 0, this._macros = new Map(), 
                    this._numDrawCalls = 0, this._numTris = 0, this._memoryStatus = {
                        bufferSize: 0,
                        textureSize: 0
                    };
                }
                return _createClass(GFXDevice, [ {
                    key: "hasFeature",
                    value: function hasFeature(feature) {
                        return this._features[feature];
                    }
                }, {
                    key: "genShaderId",
                    value: function genShaderId() {
                        return this._shaderIdGen++;
                    }
                }, {
                    key: "defineMacro",
                    value: function defineMacro(macro, value) {
                        var val = void 0 !== value ? value : "";
                        this._macros.set(macro, val);
                    }
                }, {
                    key: "canvas",
                    get: function get() {
                        return this._canvas;
                    }
                }, {
                    key: "canvas2D",
                    get: function get() {
                        return this._canvas2D;
                    }
                }, {
                    key: "gfxAPI",
                    get: function get() {
                        return this._gfxAPI;
                    }
                }, {
                    key: "queue",
                    get: function get() {
                        return this._queue;
                    }
                }, {
                    key: "devicePixelRatio",
                    get: function get() {
                        return this._devicePixelRatio;
                    }
                }, {
                    key: "width",
                    get: function get() {
                        return this._width;
                    }
                }, {
                    key: "height",
                    get: function get() {
                        return this._height;
                    }
                }, {
                    key: "nativeWidth",
                    get: function get() {
                        return this._nativeWidth;
                    }
                }, {
                    key: "nativeHeight",
                    get: function get() {
                        return this._nativeHeight;
                    }
                }, {
                    key: "mainWindow",
                    get: function get() {
                        return this._mainWindow;
                    }
                }, {
                    key: "commandAllocator",
                    get: function get() {
                        return this._cmdAllocator;
                    }
                }, {
                    key: "renderer",
                    get: function get() {
                        return this._renderer;
                    }
                }, {
                    key: "vendor",
                    get: function get() {
                        return this._vendor;
                    }
                }, {
                    key: "maxVertexAttributes",
                    get: function get() {
                        return this._maxVertexAttributes;
                    }
                }, {
                    key: "maxVertexUniformVectors",
                    get: function get() {
                        return this._maxVertexUniformVectors;
                    }
                }, {
                    key: "maxFragmentUniformVectors",
                    get: function get() {
                        return this._maxFragmentUniformVectors;
                    }
                }, {
                    key: "maxTextureUnits",
                    get: function get() {
                        return this._maxTextureUnits;
                    }
                }, {
                    key: "maxVertexTextureUnits",
                    get: function get() {
                        return this._maxVertexTextureUnits;
                    }
                }, {
                    key: "maxUniformBufferBindings",
                    get: function get() {
                        return this._maxUniformBufferBindings;
                    }
                }, {
                    key: "maxUniformBlockSize",
                    get: function get() {
                        return this._maxUniformBlockSize;
                    }
                }, {
                    key: "maxTextureSize",
                    get: function get() {
                        return this._maxTextureSize;
                    }
                }, {
                    key: "maxCubeMapTextureSize",
                    get: function get() {
                        return this._maxCubeMapTextureSize;
                    }
                }, {
                    key: "depthBits",
                    get: function get() {
                        return this._depthBits;
                    }
                }, {
                    key: "stencilBits",
                    get: function get() {
                        return this._stencilBits;
                    }
                }, {
                    key: "colorFormat",
                    get: function get() {
                        return this._colorFmt;
                    }
                }, {
                    key: "depthStencilFormat",
                    get: function get() {
                        return this._depthStencilFmt;
                    }
                }, {
                    key: "macros",
                    get: function get() {
                        return this._macros;
                    }
                }, {
                    key: "numDrawCalls",
                    get: function get() {
                        return this._numDrawCalls;
                    }
                }, {
                    key: "numTris",
                    get: function get() {
                        return this._numTris;
                    }
                }, {
                    key: "memoryStatus",
                    get: function get() {
                        return this._memoryStatus;
                    }
                } ]), GFXDevice;
            }());
            function applyMixins(derivedCtor, baseCtors) {
                baseCtors.forEach(function(baseCtor) {
                    Object.getOwnPropertyNames(baseCtor.prototype).forEach(function(name) {
                        "constructor" !== name && Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
                    });
                });
            }
            var _dec$2, _dec2, _class$2, _class2$1, _descriptor$1, _class3, _temp$2, RawAsset = exports("RawAsset", ccclass("cc.RawAsset")(_class$1 = function() {
                function RawAsset() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, RawAsset);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RawAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._uuid = void 0, 
                    Object.defineProperty(_assertThisInitialized(_this), "_uuid", {
                        value: "",
                        writable: !0
                    }), _this;
                }
                return _inherits(RawAsset, CCObject), _createClass(RawAsset, null, [ {
                    key: "isRawAssetType",
                    value: function isRawAssetType(ctor) {
                        return isChildClassOf(ctor, cc.RawAsset) && !isChildClassOf(ctor, cc.Asset);
                    }
                } ]), RawAsset;
            }()) || _class$1);
            cc.RawAsset = RawAsset;
            var PixelFormat, WrapMode$1, Filter, DepthStencilFormat, _dec$3, _dec2$1, _class$3, _class2$2, _class3$1, _temp$3, Asset = exports("Asset", (_dec$2 = ccclass("cc.Asset"), 
            _dec2 = property({
                visible: !1
            }), _dec$2((_temp$2 = _class3 = function() {
                function Asset() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, Asset);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Asset)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).loaded = !0, 
                    _initializerDefineProperty(_this, "_native", _descriptor$1, _assertThisInitialized(_this)), 
                    _this._file = null, _this._callbackTable = createMap(!0), _this;
                }
                return _inherits(Asset, RawAsset), _createClass(Asset, null, [ {
                    key: "deserialize",
                    value: function deserialize(data) {
                        return cc.deserialize(data);
                    }
                } ]), _createClass(Asset, [ {
                    key: "on",
                    value: function on() {}
                }, {
                    key: "off",
                    value: function off() {}
                }, {
                    key: "targetOff",
                    value: function targetOff() {}
                }, {
                    key: "once",
                    value: function once() {}
                }, {
                    key: "dispatchEvent",
                    value: function dispatchEvent() {}
                }, {
                    key: "hasEventListener",
                    value: function hasEventListener() {
                        return !1;
                    }
                }, {
                    key: "removeAll",
                    value: function removeAll() {}
                }, {
                    key: "emit",
                    value: function emit() {}
                }, {
                    key: "toString",
                    value: function toString() {
                        return this.nativeUrl;
                    }
                }, {
                    key: "_setRawAsset",
                    value: function _setRawAsset(filename, argument_1) {
                        var inLibrary = !(1 < arguments.length && void 0 !== argument_1) || argument_1;
                        this._native = !1 !== inLibrary ? filename || void 0 : "/" + filename;
                    }
                }, {
                    key: "nativeUrl",
                    get: function get() {
                        if (this._native) {
                            var name = this._native;
                            if (47 === name.charCodeAt(0)) return name.slice(1);
                            if (cc.AssetLibrary) {
                                var base = cc.AssetLibrary.getLibUrlNoExt(this._uuid, !0);
                                return 46 === name.charCodeAt(0) ? base + name : base + "/" + name;
                            }
                            cc.errorID(6400);
                        }
                        return "";
                    }
                }, {
                    key: "_nativeAsset",
                    get: function get() {
                        return this._file;
                    },
                    set: function set(obj) {
                        this._file = obj;
                    }
                } ]), Asset;
            }(), _class3.preventDeferredLoadDependents = !1, _class3.preventPreloadNativeObject = !1, 
            _descriptor$1 = _applyDecoratedDescriptor((_class2$1 = _temp$2).prototype, "_native", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return "";
                }
            }), _applyDecoratedDescriptor(_class2$1.prototype, "nativeUrl", [ _dec2 ], Object.getOwnPropertyDescriptor(_class2$1.prototype, "nativeUrl"), _class2$1.prototype), 
            _applyDecoratedDescriptor(_class2$1.prototype, "_nativeAsset", [ property ], Object.getOwnPropertyDescriptor(_class2$1.prototype, "_nativeAsset"), _class2$1.prototype), 
            _class$2 = _class2$1)) || _class$2));
            applyMixins(Asset, [ CallbacksInvoker, EventTarget ]), Asset.prototype.createNode = null, 
            cc.Asset = Asset, function(PixelFormat) {
                PixelFormat[PixelFormat.RGB565 = GFXFormat.R5G6B5] = "RGB565", PixelFormat[PixelFormat.RGB5A1 = GFXFormat.RGB5A1] = "RGB5A1", 
                PixelFormat[PixelFormat.RGBA4444 = GFXFormat.RGBA4] = "RGBA4444", PixelFormat[PixelFormat.RGB888 = GFXFormat.RGB8] = "RGB888", 
                PixelFormat[PixelFormat.RGBA8888 = GFXFormat.RGBA8] = "RGBA8888", PixelFormat[PixelFormat.RGBA32F = GFXFormat.RGBA32F] = "RGBA32F", 
                PixelFormat[PixelFormat.A8 = GFXFormat.A8] = "A8", PixelFormat[PixelFormat.I8 = GFXFormat.L8] = "I8", 
                PixelFormat[PixelFormat.AI8 = GFXFormat.LA8] = "AI8", PixelFormat[PixelFormat.RGB_PVRTC_2BPPV1 = GFXFormat.PVRTC_RGB2] = "RGB_PVRTC_2BPPV1", 
                PixelFormat[PixelFormat.RGBA_PVRTC_2BPPV1 = GFXFormat.PVRTC_RGBA2] = "RGBA_PVRTC_2BPPV1", 
                PixelFormat[PixelFormat.RGB_PVRTC_4BPPV1 = GFXFormat.PVRTC_RGB4] = "RGB_PVRTC_4BPPV1", 
                PixelFormat[PixelFormat.RGBA_PVRTC_4BPPV1 = GFXFormat.PVRTC_RGBA4] = "RGBA_PVRTC_4BPPV1", 
                PixelFormat[PixelFormat.RGB_ETC1 = GFXFormat.ETC_RGB8] = "RGB_ETC1", PixelFormat[PixelFormat.RGB_ETC2 = GFXFormat.ETC2_RGB8] = "RGB_ETC2", 
                PixelFormat[PixelFormat.RGBA_ETC2 = GFXFormat.ETC2_RGBA8] = "RGBA_ETC2";
            }(PixelFormat = PixelFormat || {}), function(WrapMode) {
                WrapMode[WrapMode.REPEAT = GFXAddress.WRAP] = "REPEAT", WrapMode[WrapMode.CLAMP_TO_EDGE = GFXAddress.CLAMP] = "CLAMP_TO_EDGE", 
                WrapMode[WrapMode.MIRRORED_REPEAT = GFXAddress.MIRROR] = "MIRRORED_REPEAT", WrapMode[WrapMode.CLAMP_TO_BORDER = GFXAddress.BORDER] = "CLAMP_TO_BORDER";
            }(WrapMode$1 = WrapMode$1 || {}), function(Filter) {
                Filter[Filter.NONE = GFXFilter.NONE] = "NONE", Filter[Filter.LINEAR = GFXFilter.LINEAR] = "LINEAR", 
                Filter[Filter.NEAREST = GFXFilter.POINT] = "NEAREST";
            }(Filter = Filter || {}), function(DepthStencilFormat) {
                DepthStencilFormat[DepthStencilFormat.NONE = GFXFormat.UNKNOWN] = "NONE", DepthStencilFormat[DepthStencilFormat.DEPTH_16 = GFXFormat.D16] = "DEPTH_16", 
                DepthStencilFormat[DepthStencilFormat.DEPTH_24 = GFXFormat.D24] = "DEPTH_24", DepthStencilFormat[DepthStencilFormat.DEPTH_32 = GFXFormat.D32F] = "DEPTH_32", 
                DepthStencilFormat[DepthStencilFormat.DEPTH_16_STENCIL_8 = GFXFormat.D16S8] = "DEPTH_16_STENCIL_8", 
                DepthStencilFormat[DepthStencilFormat.DEPTH_24_STENCIL_8 = GFXFormat.D24S8] = "DEPTH_24_STENCIL_8", 
                DepthStencilFormat[DepthStencilFormat.DEPTH_32_STENCIL_8 = GFXFormat.D32F_S8] = "DEPTH_32_STENCIL_8";
            }(DepthStencilFormat = DepthStencilFormat || {});
            var SamplerInfoIndex, ImageAsset = exports("ImageAsset", (_dec$3 = ccclass("cc.ImageAsset"), 
            _dec2$1 = property({
                override: !0
            }), _dec$3((_temp$3 = _class3$1 = function() {
                function ImageAsset(nativeAsset) {
                    var _this;
                    return _classCallCheck(this, ImageAsset), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ImageAsset).call(this)))._nativeData = void 0, 
                    _this._tex = void 0, _this._url = void 0, _this._exportedExts = void 0, _this._format = PixelFormat.RGBA8888, 
                    _this._width = 0, _this._height = 0, _this._url = "", _this.loaded = !1, _this._nativeData = {
                        _data: null,
                        width: 0,
                        height: 0,
                        format: 0,
                        _compressed: !1
                    }, void 0 !== nativeAsset && (_this._nativeAsset = nativeAsset), _this;
                }
                return _inherits(ImageAsset, Asset), _createClass(ImageAsset, [ {
                    key: "_nativeAsset",
                    get: function get() {
                        return this._nativeData;
                    },
                    set: function set(value) {
                        this.reset(value);
                    }
                }, {
                    key: "data",
                    get: function get() {
                        var data = this._nativeData._data;
                        return ArrayBuffer.isView(data) || data instanceof ArrayBuffer ? data : this._nativeData;
                    }
                }, {
                    key: "width",
                    get: function get() {
                        return this._nativeData.width || this._width;
                    }
                }, {
                    key: "height",
                    get: function get() {
                        return this._nativeData.height || this._height;
                    }
                }, {
                    key: "format",
                    get: function get() {
                        return this._format;
                    }
                }, {
                    key: "isCompressed",
                    get: function get() {
                        return this._format >= PixelFormat.RGB_ETC1 && this._format <= PixelFormat.RGBA_PVRTC_4BPPV1;
                    }
                }, {
                    key: "url",
                    get: function get() {
                        return this._url;
                    }
                }, {
                    key: "_texture",
                    set: function set(tex) {
                        this._tex = tex;
                    },
                    get: function get() {
                        if (!this._tex) {
                            var tex = new cc.Texture2D();
                            tex.name = this._url, (tex.image = this)._tex = tex;
                        }
                        return this._tex;
                    }
                } ]), _createClass(ImageAsset, [ {
                    key: "reset",
                    value: function reset(data) {
                        var _this2 = this;
                        data instanceof HTMLElement ? (this._nativeData = data).complete || data instanceof HTMLCanvasElement ? this._onDataComplete() : (this.loaded = !1, 
                        data.addEventListener("load", function() {
                            _this2._onDataComplete();
                        }), data.addEventListener("error", function(err) {
                            cc.warnID(3119, err.message);
                        })) : (this._nativeData = data, this._nativeData.format = this._format, this._onDataComplete());
                    }
                }, {
                    key: "_serialize",
                    value: function _serialize() {
                        var targetExtensions = this._exportedExts;
                        if (!targetExtensions && this._native && (targetExtensions = [ this._native ]), 
                        !targetExtensions) return "";
                        var extensionIndices = [], _iterator = targetExtensions, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var targetExtension = _ref, extensionFormat = targetExtension.split("@"), i = ImageAsset.extnames.indexOf(extensionFormat[0]), exportedExtensionID = i < 0 ? targetExtension : "".concat(i);
                            extensionFormat[1] && (exportedExtensionID += "@" + extensionFormat[1]), extensionIndices.push(exportedExtensionID);
                        }
                        return {
                            fmt: extensionIndices.join("_"),
                            w: this.width,
                            h: this.height
                        };
                    }
                }, {
                    key: "_deserialize",
                    value: function _deserialize(data, handle) {
                        var fmtStr = "";
                        fmtStr = "string" == typeof data ? data : (this._width = data.w, this._height = data.h, 
                        data.fmt);
                        var device = function _getGlobalDevice() {
                            return cc.director.root ? cc.director.root.device : null;
                        }(), extensionIDs = fmtStr.split("_"), preferedExtensionIndex = Number.MAX_VALUE, format = this._format, ext = "", SupportTextureFormats = cc.macro.SUPPORT_TEXTURE_FORMATS, _iterator2 = extensionIDs, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            var extFormat = _ref2.split("@"), i = parseInt(extFormat[0], void 0), tmpExt = ImageAsset.extnames[i] || extFormat.join(), index = SupportTextureFormats.indexOf(tmpExt);
                            if (-1 !== index && index < preferedExtensionIndex) {
                                var fmt = extFormat[1] ? parseInt(extFormat[1]) : this._format;
                                if (!(".pvr" !== tmpExt || device && device.hasFeature(GFXFeature.FORMAT_PVRTC))) continue;
                                if (!(fmt !== PixelFormat.RGB_ETC1 || device && device.hasFeature(GFXFeature.FORMAT_ETC1))) continue;
                                if (!(fmt !== PixelFormat.RGB_ETC2 && fmt !== PixelFormat.RGBA_ETC2 || device && device.hasFeature(GFXFeature.FORMAT_ETC2))) continue;
                                if (".webp" === tmpExt && !cc.sys.capabilities.webp) continue;
                                preferedExtensionIndex = index, ext = tmpExt, format = fmt;
                            }
                        }
                        ext && (this._setRawAsset(ext), this._format = format);
                        var loadingItem = handle.customEnv, uuid = loadingItem && loadingItem.uuid;
                        uuid && (this._uuid = uuid, this._url = this.nativeUrl);
                    }
                }, {
                    key: "_onDataComplete",
                    value: function _onDataComplete() {
                        this.loaded = !0, this.emit("load");
                    }
                } ]), ImageAsset;
            }(), _class3$1.extnames = [ ".png", ".jpg", ".jpeg", ".bmp", ".webp", ".pvr", ".pkm" ], 
            _applyDecoratedDescriptor((_class2$2 = _temp$3).prototype, "_nativeAsset", [ _dec2$1 ], Object.getOwnPropertyDescriptor(_class2$2.prototype, "_nativeAsset"), _class2$2.prototype), 
            _class$3 = _class2$2)) || _class$3));
            cc.ImageAsset = ImageAsset, function(SamplerInfoIndex) {
                SamplerInfoIndex[SamplerInfoIndex.minFilter = 0] = "minFilter", SamplerInfoIndex[SamplerInfoIndex.magFilter = 1] = "magFilter", 
                SamplerInfoIndex[SamplerInfoIndex.mipFilter = 2] = "mipFilter", SamplerInfoIndex[SamplerInfoIndex.addressU = 3] = "addressU", 
                SamplerInfoIndex[SamplerInfoIndex.addressV = 4] = "addressV", SamplerInfoIndex[SamplerInfoIndex.addressW = 5] = "addressW", 
                SamplerInfoIndex[SamplerInfoIndex.maxAnisotropy = 6] = "maxAnisotropy", SamplerInfoIndex[SamplerInfoIndex.cmpFunc = 7] = "cmpFunc", 
                SamplerInfoIndex[SamplerInfoIndex.minLOD = 8] = "minLOD", SamplerInfoIndex[SamplerInfoIndex.maxLOD = 9] = "maxLOD", 
                SamplerInfoIndex[SamplerInfoIndex.mipLODBias = 10] = "mipLODBias", SamplerInfoIndex[SamplerInfoIndex.borderColor = 11] = "borderColor", 
                SamplerInfoIndex[SamplerInfoIndex.total = 15] = "total";
            }(SamplerInfoIndex = SamplerInfoIndex || {});
            var defaultInfo = [ GFXFilter.LINEAR, GFXFilter.LINEAR, GFXFilter.NONE, GFXAddress.WRAP, GFXAddress.WRAP, GFXAddress.WRAP, 16, GFXComparisonFunc.NEVER, 0, 0, 0, 0, 0, 0, 0 ], gfxInfo = {};
            function genSamplerHash(info) {
                for (var value = 0, hash = 0, i = 0; i < defaultInfo.length; i++) switch (value = info[i] || defaultInfo[i], 
                i) {
                  case SamplerInfoIndex.minFilter:
                    hash |= value;
                    break;

                  case SamplerInfoIndex.magFilter:
                    hash |= value << 2;
                    break;

                  case SamplerInfoIndex.mipFilter:
                    hash |= value << 4;
                    break;

                  case SamplerInfoIndex.addressU:
                    hash |= value << 6;
                    break;

                  case SamplerInfoIndex.addressV:
                    hash |= value << 8;
                    break;

                  case SamplerInfoIndex.addressW:
                    hash |= value << 10;
                    break;

                  case SamplerInfoIndex.maxAnisotropy:
                    hash |= value << 12;
                    break;

                  case SamplerInfoIndex.cmpFunc:
                    hash |= value << 16;
                    break;

                  case SamplerInfoIndex.minLOD:
                    hash |= value << 20;
                    break;

                  case SamplerInfoIndex.maxLOD:
                    hash |= value << 24;
                    break;

                  case SamplerInfoIndex.mipLODBias:
                    hash |= value << 28;
                }
                return hash;
            }
            var _class$4, _class2$3, _descriptor$2, _descriptor2$1, _descriptor3$1, _descriptor4$1, _descriptor5$1, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _class3$2, _temp$4, _class$5, _class2$4, _descriptor$3, _class3$3, _temp$5, samplerLib = new (function() {
                function SamplerLib() {
                    _classCallCheck(this, SamplerLib), this._cache = {};
                }
                return _createClass(SamplerLib, [ {
                    key: "getSampler",
                    value: function getSampler(device, hash) {
                        var cache = this._cache[hash];
                        return cache || (0 === hash && (hash = genSamplerHash(defaultInfo)), gfxInfo.minFilter = 3 & hash, 
                        gfxInfo.magFilter = hash >> 2 & 3, gfxInfo.mipFilter = hash >> 4 & 3, gfxInfo.addressU = hash >> 6 & 3, 
                        gfxInfo.addressV = hash >> 8 & 3, gfxInfo.addressW = hash >> 10 & 3, gfxInfo.maxAnisotropy = hash >> 12 & 15, 
                        gfxInfo.cmpFunc = hash >> 16 & 15, gfxInfo.minLOD = hash >> 20 & 15, gfxInfo.maxLOD = hash >> 24 & 15, 
                        gfxInfo.mipLODBias = hash >> 28 & 15, gfxInfo.borderColor = {
                            r: 0,
                            g: 0,
                            b: 0,
                            a: 0
                        }, this._cache[hash] = device.createSampler(gfxInfo));
                    }
                } ]), SamplerLib;
            }())(), idGenerator = new IDGenerator("Tex"), TextureBase = ccclass("cc.TextureBase")((_temp$4 = _class3$2 = function() {
                function TextureBase() {
                    var _this, flipY = 0 < arguments.length && void 0 !== arguments[0] && arguments[0];
                    return _classCallCheck(this, TextureBase), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(TextureBase).call(this)), "_format", _descriptor$2, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_premultiplyAlpha", _descriptor2$1, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_flipY", _descriptor3$1, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_minFilter", _descriptor4$1, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_magFilter", _descriptor5$1, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_mipFilter", _descriptor6, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_wrapS", _descriptor7, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_wrapT", _descriptor8, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_wrapR", _descriptor9, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_anisotropy", _descriptor10, _assertThisInitialized(_this)), 
                    _this._width = 0, _this._height = 0, _this._id = void 0, _this._samplerInfo = [], 
                    _this._samplerHash = 0, _this._flipY = flipY, _this._id = idGenerator.getNewId(), 
                    _this.loaded = !1, _this;
                }
                return _inherits(TextureBase, Asset), _createClass(TextureBase, [ {
                    key: "isCompressed",
                    get: function get() {
                        return this._format >= PixelFormat.RGB_ETC1 && this._format <= PixelFormat.RGBA_PVRTC_4BPPV1;
                    }
                }, {
                    key: "width",
                    get: function get() {
                        return this._width;
                    }
                }, {
                    key: "height",
                    get: function get() {
                        return this._height;
                    }
                } ]), _createClass(TextureBase, [ {
                    key: "getId",
                    value: function getId() {
                        return this._id;
                    }
                }, {
                    key: "getPixelFormat",
                    value: function getPixelFormat() {
                        return this._format;
                    }
                }, {
                    key: "hasPremultipliedAlpha",
                    value: function hasPremultipliedAlpha() {
                        return this._premultiplyAlpha || !1;
                    }
                }, {
                    key: "getAnisotropy",
                    value: function getAnisotropy() {
                        return this._anisotropy;
                    }
                }, {
                    key: "setWrapMode",
                    value: function setWrapMode(wrapS, wrapT, wrapR) {
                        this._wrapS = wrapS, this._samplerInfo[SamplerInfoIndex.addressU] = wrapS, this._wrapT = wrapT, 
                        this._samplerInfo[SamplerInfoIndex.addressV] = wrapT, void 0 !== wrapR && (this._wrapR = wrapR, 
                        this._samplerInfo[SamplerInfoIndex.addressW] = wrapR), this._samplerHash = genSamplerHash(this._samplerInfo);
                    }
                }, {
                    key: "setFilters",
                    value: function setFilters(minFilter, magFilter) {
                        this._minFilter = minFilter, this._samplerInfo[SamplerInfoIndex.minFilter] = minFilter, 
                        this._magFilter = magFilter, this._samplerInfo[SamplerInfoIndex.magFilter] = magFilter, 
                        this._samplerHash = genSamplerHash(this._samplerInfo);
                    }
                }, {
                    key: "setMipFilter",
                    value: function setMipFilter(mipFilter) {
                        this._mipFilter = mipFilter, this._samplerInfo[SamplerInfoIndex.mipFilter] = mipFilter, 
                        this._samplerInfo[SamplerInfoIndex.maxLOD] = mipFilter === Filter.NONE ? 0 : 1e3, 
                        this._samplerHash = genSamplerHash(this._samplerInfo);
                    }
                }, {
                    key: "setFlipY",
                    value: function setFlipY(flipY) {
                        this._flipY = flipY;
                    }
                }, {
                    key: "setPremultiplyAlpha",
                    value: function setPremultiplyAlpha(premultiply) {
                        this._premultiplyAlpha = premultiply;
                    }
                }, {
                    key: "setAnisotropy",
                    value: function setAnisotropy(anisotropy) {
                        this._anisotropy = anisotropy, this._samplerInfo[SamplerInfoIndex.maxAnisotropy] = anisotropy, 
                        this._samplerHash = genSamplerHash(this._samplerInfo);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        return _get(_getPrototypeOf(TextureBase.prototype), "destroy", this).call(this);
                    }
                }, {
                    key: "getGFXTextureView",
                    value: function getGFXTextureView() {
                        return null;
                    }
                }, {
                    key: "getSamplerHash",
                    value: function getSamplerHash() {
                        return this._samplerHash;
                    }
                }, {
                    key: "_serialize",
                    value: function _serialize() {
                        return this._minFilter + "," + this._magFilter + "," + this._wrapS + "," + this._wrapT + "," + (this._premultiplyAlpha ? 1 : 0) + "," + this._mipFilter + "," + this._anisotropy + "," + (this._flipY ? 1 : 0);
                    }
                }, {
                    key: "_deserialize",
                    value: function _deserialize(serializedData) {
                        var fields = serializedData.split(",");
                        fields.unshift(""), 6 <= fields.length && (this.setFilters(parseInt(fields[1]), parseInt(fields[2])), 
                        this.setWrapMode(parseInt(fields[3]), parseInt(fields[4])), this._premultiplyAlpha = 49 === fields[5].charCodeAt(0)), 
                        8 <= fields.length && (this.setMipFilter(parseInt(fields[6])), this.setAnisotropy(parseInt(fields[7]))), 
                        9 <= fields.length && (this._flipY = 49 === fields[8].charCodeAt(0));
                    }
                }, {
                    key: "_getGFXDevice",
                    value: function _getGFXDevice() {
                        return cc.director.root && cc.director.root.device;
                    }
                }, {
                    key: "_getGFXFormat",
                    value: function _getGFXFormat() {
                        return this._format;
                    }
                }, {
                    key: "_setGFXFormat",
                    value: function _setGFXFormat(format) {
                        this._format = void 0 === format ? PixelFormat.RGBA8888 : format;
                    }
                } ]), TextureBase;
            }(), _class3$2.PixelFormat = PixelFormat, _class3$2.WrapMode = WrapMode$1, _class3$2.Filter = Filter, 
            _descriptor$2 = _applyDecoratedDescriptor((_class2$3 = _temp$4).prototype, "_format", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return PixelFormat.RGBA8888;
                }
            }), _descriptor2$1 = _applyDecoratedDescriptor(_class2$3.prototype, "_premultiplyAlpha", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor3$1 = _applyDecoratedDescriptor(_class2$3.prototype, "_flipY", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor4$1 = _applyDecoratedDescriptor(_class2$3.prototype, "_minFilter", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Filter.LINEAR;
                }
            }), _descriptor5$1 = _applyDecoratedDescriptor(_class2$3.prototype, "_magFilter", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Filter.LINEAR;
                }
            }), _descriptor6 = _applyDecoratedDescriptor(_class2$3.prototype, "_mipFilter", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Filter.NONE;
                }
            }), _descriptor7 = _applyDecoratedDescriptor(_class2$3.prototype, "_wrapS", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return WrapMode$1.REPEAT;
                }
            }), _descriptor8 = _applyDecoratedDescriptor(_class2$3.prototype, "_wrapT", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return WrapMode$1.REPEAT;
                }
            }), _descriptor9 = _applyDecoratedDescriptor(_class2$3.prototype, "_wrapR", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return WrapMode$1.REPEAT;
                }
            }), _descriptor10 = _applyDecoratedDescriptor(_class2$3.prototype, "_anisotropy", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 16;
                }
            }), _class$4 = _class2$3)) || _class$4;
            cc.TextureBase = TextureBase, ccenum(DepthStencilFormat);
            var _class$6, RenderTexture = exports("RenderTexture", ccclass("cc.RenderTexture")((_temp$5 = _class3$3 = function() {
                function RenderTexture() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, RenderTexture);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RenderTexture)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._window = null, 
                    _initializerDefineProperty(_this, "_depthStencilFormat", _descriptor$3, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(RenderTexture, TextureBase), _createClass(RenderTexture, [ {
                    key: "getGFXWindow",
                    value: function getGFXWindow() {
                        return this._window;
                    }
                }, {
                    key: "getGFXTextureView",
                    value: function getGFXTextureView() {
                        return this._window ? this._window.colorTexView : null;
                    }
                }, {
                    key: "getGFXStencilTexture",
                    value: function getGFXStencilTexture() {
                        return this._window ? this._window.depthStencilTexView : null;
                    }
                }, {
                    key: "reset",
                    value: function reset(info) {
                        info && (this._width = info.width, this._height = info.height, info.colorFormat && (this._format = info.colorFormat), 
                        info.depthStencilFormat && (this._depthStencilFormat = info.depthStencilFormat), 
                        this._tryResetWindow(), this.emit("resize", this));
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        return this._window && (cc.director.root.destroyWindow(this._window), this._window = null), 
                        _get(_getPrototypeOf(RenderTexture.prototype), "destroy", this).call(this);
                    }
                }, {
                    key: "onLoaded",
                    value: function onLoaded() {
                        this._tryResetWindow(), this.loaded = !0, this.emit("load");
                    }
                }, {
                    key: "_serialize",
                    value: function _serialize() {
                        return {
                            base: _get(_getPrototypeOf(RenderTexture.prototype), "_serialize", this).call(this),
                            name: this._name,
                            width: this._width,
                            height: this._height,
                            colorFormat: this._format,
                            depthStencilFormat: this._depthStencilFormat
                        };
                    }
                }, {
                    key: "_deserialize",
                    value: function _deserialize(serializeData, handle) {
                        _get(_getPrototypeOf(RenderTexture.prototype), "_deserialize", this).call(this, serializeData.base, handle);
                        var data = serializeData;
                        this.name = data.name || "", this._width = data.width, this._height = data.height, 
                        this._format = data.colorFormat, this._depthStencilFormat = data.depthStencilFormat;
                    }
                }, {
                    key: "_tryResetWindow",
                    value: function _tryResetWindow() {
                        var device = this._getGFXDevice();
                        device && (this._window && this._window.destroy(), this._createWindow(device));
                    }
                }, {
                    key: "_createWindow",
                    value: function _createWindow() {
                        var config = {
                            title: this.name,
                            isOffscreen: !0,
                            width: this._width,
                            height: this._height,
                            colorFmt: this._format,
                            depthStencilFmt: this._depthStencilFormat
                        };
                        if (this._window) return this._window.initialize(config), this._window;
                        this._window = cc.director.root.createWindow(config);
                    }
                }, {
                    key: "width",
                    get: function get() {
                        return this._width;
                    },
                    set: function set(value) {
                        this._width = value, this.reset();
                    }
                }, {
                    key: "height",
                    get: function get() {
                        return this._height;
                    },
                    set: function set(value) {
                        this._height = value, this.reset();
                    }
                }, {
                    key: "depthStencilFormat",
                    get: function get() {
                        return this._depthStencilFormat;
                    },
                    set: function set(value) {
                        this._depthStencilFormat = value, this.reset();
                    }
                } ]), RenderTexture;
            }(), _class3$3.DepthStencilFormat = DepthStencilFormat, _descriptor$3 = _applyDecoratedDescriptor((_class2$4 = _temp$5).prototype, "_depthStencilFormat", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return DepthStencilFormat.NONE;
                }
            }), _applyDecoratedDescriptor(_class2$4.prototype, "width", [ property ], Object.getOwnPropertyDescriptor(_class2$4.prototype, "width"), _class2$4.prototype), 
            _applyDecoratedDescriptor(_class2$4.prototype, "height", [ property ], Object.getOwnPropertyDescriptor(_class2$4.prototype, "height"), _class2$4.prototype), 
            _applyDecoratedDescriptor(_class2$4.prototype, "depthStencilFormat", [ property ], Object.getOwnPropertyDescriptor(_class2$4.prototype, "depthStencilFormat"), _class2$4.prototype), 
            _class$5 = _class2$4)) || _class$5);
            cc.RenderTexture = RenderTexture;
            var _regions = [ {
                buffOffset: 0,
                buffStride: 0,
                buffTexHeight: 0,
                texOffset: {
                    x: 0,
                    y: 0,
                    z: 0
                },
                texExtent: {
                    width: 1,
                    height: 1,
                    depth: 1
                },
                texSubres: {
                    baseMipLevel: 1,
                    levelCount: 1,
                    baseArrayLayer: 0,
                    layerCount: 1
                }
            } ];
            function isPOT(n) {
                return n && 0 == (n & n - 1);
            }
            var _dec$7, _dec2$2, _class$7, _class2$5, _descriptor$4, SimpleTexture = ccclass("cc.SimpleTexture")(_class$6 = function() {
                function SimpleTexture() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, SimpleTexture);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SimpleTexture)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._gfxTexture = null, 
                    _this._gfxTextureView = null, _this._mipmapLevel = 1, _this;
                }
                return _inherits(SimpleTexture, TextureBase), _createClass(SimpleTexture, [ {
                    key: "getGFXTexture",
                    value: function getGFXTexture() {
                        return this._gfxTexture;
                    }
                }, {
                    key: "getGFXTextureView",
                    value: function getGFXTextureView() {
                        return this._gfxTextureView;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        return this._tryDestroyTexture(), _get(_getPrototypeOf(SimpleTexture.prototype), "destroy", this).call(this);
                    }
                }, {
                    key: "updateImage",
                    value: function updateImage() {
                        this.updateMipmaps(0);
                    }
                }, {
                    key: "updateMipmaps",
                    value: function updateMipmaps() {}
                }, {
                    key: "uploadData",
                    value: function uploadData(source, argument_1, argument_2) {
                        var level = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : 0, arrayIndex = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 0;
                        if (this._gfxTexture && !(this._gfxTexture.mipLevel <= level)) {
                            var gfxDevice = this._getGFXDevice();
                            if (gfxDevice) {
                                var region = _regions[0];
                                region.texExtent.width = this._gfxTexture.width >> level, region.texExtent.height = this._gfxTexture.height >> level, 
                                region.texSubres.baseMipLevel = level, region.texSubres.baseArrayLayer = arrayIndex, 
                                source instanceof ArrayBuffer ? gfxDevice.copyBuffersToTexture([ source ], this._gfxTexture, _regions) : gfxDevice.copyTexImagesToTexture([ source ], this._gfxTexture, _regions);
                            }
                        }
                    }
                }, {
                    key: "_assignImage",
                    value: function _assignImage(image, level, arrayIndex) {
                        function upload() {
                            var source, data = image.data;
                            data && (source = ArrayBuffer.isView(data) ? data.buffer : data, _this2.uploadData(source, level, arrayIndex), 
                            _this2._checkTextureLoaded());
                        }
                        var _this2 = this;
                        if (image.loaded) upload(); else {
                            if (image.once("load", function() {
                                upload();
                            }), !this.isCompressed) {
                                var defaultImg = cc.builtinResMgr.get("black-texture").image;
                                this.uploadData(defaultImg.data, level, arrayIndex);
                            }
                            cc.textureUtil.postLoadImage(image);
                        }
                    }
                }, {
                    key: "_checkTextureLoaded",
                    value: function _checkTextureLoaded() {
                        this._textureReady();
                    }
                }, {
                    key: "_textureReady",
                    value: function _textureReady() {
                        this.loaded = !0, this.emit("load");
                    }
                }, {
                    key: "_setMipmapLevel",
                    value: function _setMipmapLevel(value) {
                        this._mipmapLevel = value < 1 ? 1 : value;
                    }
                }, {
                    key: "_getGfxTextureCreateInfo",
                    value: function _getGfxTextureCreateInfo() {
                        return null;
                    }
                }, {
                    key: "_getGfxTextureViewCreateInfo",
                    value: function _getGfxTextureViewCreateInfo() {
                        return null;
                    }
                }, {
                    key: "_tryReset",
                    value: function _tryReset() {
                        this._tryDestroyTexture();
                        var device = this._getGFXDevice();
                        device && this._createTexture(device);
                    }
                }, {
                    key: "_createTexture",
                    value: function _createTexture(device) {
                        var flags = GFXTextureFlagBit.NONE;
                        this._mipFilter !== Filter.NONE && isPOT(this._width) && isPOT(this._height) && (this._mipmapLevel = function getMipLevel(width, height) {
                            for (var size = Math.max(width, height), level = 0; size; ) size >>= 1, level++;
                            return level;
                        }(this._width, this._height), flags = GFXTextureFlagBit.GEN_MIPMAP);
                        var textureCreateInfo = this._getGfxTextureCreateInfo({
                            usage: GFXTextureUsageBit.SAMPLED | GFXTextureUsageBit.TRANSFER_DST,
                            format: this._getGFXFormat(),
                            mipLevel: this._mipmapLevel,
                            flags: flags
                        });
                        if (textureCreateInfo) {
                            var texture = device.createTexture(textureCreateInfo), textureViewCreateInfo = this._getGfxTextureViewCreateInfo({
                                texture: texture,
                                format: this._getGFXFormat()
                            });
                            if (textureViewCreateInfo) {
                                var view = device.createTextureView(textureViewCreateInfo);
                                view ? (this._gfxTexture = texture, this._gfxTextureView = view) : texture.destroy();
                            } else texture.destroy();
                        }
                    }
                }, {
                    key: "_tryDestroyTexture",
                    value: function _tryDestroyTexture() {
                        this._gfxTexture && (this._gfxTexture.destroy(), this._gfxTexture = null), this._gfxTextureView && (this._gfxTextureView.destroy(), 
                        this._gfxTextureView = null);
                    }
                }, {
                    key: "mipmapLevel",
                    get: function get() {
                        return this._mipmapLevel;
                    }
                } ]), SimpleTexture;
            }()) || _class$6;
            cc.SimpleTexture = SimpleTexture;
            var _class$8, Texture2D = exports("Texture2D", (_dec$7 = ccclass("cc.Texture2D"), 
            _dec2$2 = property([ ImageAsset ]), _dec$7((_descriptor$4 = _applyDecoratedDescriptor((_class2$5 = function() {
                function Texture2D() {
                    var _this;
                    return _classCallCheck(this, Texture2D), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Texture2D).call(this, !0)), "_mipmaps", _descriptor$4, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(Texture2D, SimpleTexture), _createClass(Texture2D, [ {
                    key: "mipmaps",
                    get: function get() {
                        return this._mipmaps;
                    },
                    set: function set(value) {
                        var _this2 = this;
                        if (this._mipmaps = value, this._setMipmapLevel(this._mipmaps.length), 0 < this._mipmaps.length) {
                            var imageAsset = this._mipmaps[0];
                            this.reset({
                                width: imageAsset.width,
                                height: imageAsset.height,
                                format: imageAsset.format,
                                mipmapLevel: this._mipmaps.length
                            }), this._mipmaps.forEach(function(mipmap, level) {
                                _this2._assignImage(mipmap, level);
                            });
                        } else this.reset({
                            width: 0,
                            height: 0,
                            mipmapLevel: this._mipmaps.length
                        });
                    }
                }, {
                    key: "image",
                    get: function get() {
                        return 0 === this._mipmaps.length ? null : this._mipmaps[0];
                    },
                    set: function set(value) {
                        this.mipmaps = value ? [ value ] : [];
                    }
                } ]), _createClass(Texture2D, [ {
                    key: "onLoaded",
                    value: function onLoaded() {
                        this.initialize();
                    }
                }, {
                    key: "reset",
                    value: function reset(info) {
                        this._width = info.width, this._height = info.height, this._setGFXFormat(info.format), 
                        this._setMipmapLevel(info.mipmapLevel || 1), this._tryReset();
                    }
                }, {
                    key: "create",
                    value: function create(width, height, argument_2, argument_3) {
                        var format = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : PixelFormat.RGBA8888, mipmapLevel = 3 < arguments.length && void 0 !== argument_3 ? argument_3 : 1;
                        this.reset({
                            width: width,
                            height: height,
                            format: format,
                            mipmapLevel: mipmapLevel
                        });
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return 0 !== this._mipmaps.length ? this._mipmaps[0].url : "";
                    }
                }, {
                    key: "updateMipmaps",
                    value: function updateMipmaps(argument_0, argument_1) {
                        var firstLevel = 0 < arguments.length && void 0 !== argument_0 ? argument_0 : 0, count = 1 < arguments.length ? argument_1 : void 0;
                        if (!(firstLevel >= this._mipmaps.length)) for (var nUpdate = Math.min(void 0 === count ? this._mipmaps.length : count, this._mipmaps.length - firstLevel), i = 0; i < nUpdate; ++i) {
                            var level = firstLevel + i;
                            this._assignImage(this._mipmaps[level], level);
                        }
                    }
                }, {
                    key: "getHtmlElementObj",
                    value: function getHtmlElementObj() {
                        return this._mipmaps[0] && this._mipmaps[0].data instanceof HTMLElement ? this._mipmaps[0].data : null;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        return this._mipmaps = [], _get(_getPrototypeOf(Texture2D.prototype), "destroy", this).call(this);
                    }
                }, {
                    key: "description",
                    value: function description() {
                        var url = this._mipmaps[0] ? this._mipmaps[0].url : "";
                        return "<cc.Texture2D | Name = ".concat(url, " | Dimension = ").concat(this.width, " x ").concat(this.height, ">");
                    }
                }, {
                    key: "releaseTexture",
                    value: function releaseTexture() {
                        this.destroy();
                    }
                }, {
                    key: "_serialize",
                    value: function _serialize(exporting) {
                        return {
                            base: _get(_getPrototypeOf(Texture2D.prototype), "_serialize", this).call(this, exporting),
                            mipmaps: this._mipmaps.map(function(mipmap) {
                                return mipmap && mipmap._uuid ? exporting ? Editor.Utils.UuidUtils.compressUuid(mipmap._uuid, !0) : mipmap._uuid : null;
                            })
                        };
                    }
                }, {
                    key: "_deserialize",
                    value: function _deserialize(serializedData, handle) {
                        var data = serializedData;
                        _get(_getPrototypeOf(Texture2D.prototype), "_deserialize", this).call(this, data.base, handle), 
                        this._mipmaps = new Array(data.mipmaps.length);
                        for (var i = 0; i < data.mipmaps.length; ++i) if (this._mipmaps[i] = new ImageAsset(), 
                        data.mipmaps[i]) {
                            var mipmapUUID = data.mipmaps[i];
                            handle.result.push(this._mipmaps, "".concat(i), mipmapUUID), this._mipmaps[i]._texture = this;
                        }
                    }
                }, {
                    key: "initialize",
                    value: function initialize() {
                        this.mipmaps = this._mipmaps;
                    }
                }, {
                    key: "_getGfxTextureCreateInfo",
                    value: function _getGfxTextureCreateInfo(presumed) {
                        return Object.assign({
                            type: GFXTextureType.TEX2D,
                            width: this._width,
                            height: this._height
                        }, presumed);
                    }
                }, {
                    key: "_getGfxTextureViewCreateInfo",
                    value: function _getGfxTextureViewCreateInfo(presumed) {
                        return Object.assign({
                            type: GFXTextureViewType.TV2D
                        }, presumed);
                    }
                }, {
                    key: "_checkTextureLoaded",
                    value: function _checkTextureLoaded() {
                        for (var ready = !0, i = 0; i < this._mipmaps.length; ++i) {
                            if (!this._mipmaps[i].loaded) {
                                ready = !1;
                                break;
                            }
                        }
                        ready && _get(_getPrototypeOf(Texture2D.prototype), "_textureReady", this).call(this);
                    }
                } ]), Texture2D;
            }()).prototype, "_mipmaps", [ _dec2$2 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _class$7 = _class2$5)) || _class$7));
            cc.Texture2D = Texture2D;
            var _class$9, _class2$6, _descriptor$5, _class3$4, _temp$9, FaceIndex, temp_uvs = [ {
                u: 0,
                v: 0
            }, {
                u: 0,
                v: 0
            }, {
                u: 0,
                v: 0
            }, {
                u: 0,
                v: 0
            } ], SpriteFrame = exports("SpriteFrame", ccclass("cc.SpriteFrame")(_class$8 = function() {
                function SpriteFrame() {
                    var _this;
                    return _classCallCheck(this, SpriteFrame), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SpriteFrame).call(this))).vertices = null, 
                    _this.uv = [], _this.uvHash = 0, _this._image = null, _this.uvSliced = [], _this._rect = new Rect(), 
                    _this._offset = new Vec2(), _this._originalSize = new Size(), _this._rotated = !1, 
                    _this._capInsets = [ 0, 0, 0, 0 ], _this._atlasUuid = "", _this._texture = void 0, 
                    _this._flipUv = !1, _this;
                }
                return _inherits(SpriteFrame, Asset), _createClass(SpriteFrame, [ {
                    key: "insetTop",
                    get: function get() {
                        return this._capInsets[1];
                    },
                    set: function set(value) {
                        this._capInsets[1] = value, this._calculateSlicedUV();
                    }
                }, {
                    key: "insetBottom",
                    get: function get() {
                        return this._capInsets[3];
                    },
                    set: function set(value) {
                        this._capInsets[3] = value, this._calculateSlicedUV();
                    }
                }, {
                    key: "insetLeft",
                    get: function get() {
                        return this._capInsets[0];
                    },
                    set: function set(value) {
                        this._capInsets[0] = value, this._calculateSlicedUV();
                    }
                }, {
                    key: "insetRight",
                    get: function get() {
                        return this._capInsets[2];
                    },
                    set: function set(value) {
                        this._capInsets[2] = value, this._calculateSlicedUV();
                    }
                }, {
                    key: "rect",
                    get: function get() {
                        return this._rect;
                    },
                    set: function set(value) {
                        this._rect.set(value), this._calculateUV();
                    }
                }, {
                    key: "originalSize",
                    get: function get() {
                        return this._originalSize;
                    },
                    set: function set(value) {
                        this._originalSize.set(value), this._calculateUV();
                    }
                }, {
                    key: "_imageSource",
                    set: function set(value) {
                        this._image = value, window.Editor && Editor.isBuilder || (this._texture = value._texture, 
                        this._texture.on("load", this._textureLoaded, this), this._calculateUV());
                    }
                }, {
                    key: "texture",
                    get: function get() {
                        return this._texture || (this._texture = !this._image || window.Editor && Editor.isBuilder ? new Texture2D() : this._image._texture, 
                        this._texture.on("load", this._textureLoaded, this)), this._texture;
                    },
                    set: function set(value) {
                        value ? (this.reset({
                            texture: value
                        }, !0), this._texture instanceof RenderTexture && this.onLoaded()) : console.warn("Error Texture in ".concat(this.name));
                    }
                }, {
                    key: "atlasUuid",
                    get: function get() {
                        return this._atlasUuid;
                    },
                    set: function set(value) {
                        this._atlasUuid = value;
                    }
                }, {
                    key: "width",
                    get: function get() {
                        return this._texture.width;
                    }
                }, {
                    key: "height",
                    get: function get() {
                        return this._texture.height;
                    }
                } ]), _createClass(SpriteFrame, [ {
                    key: "textureLoaded",
                    value: function textureLoaded() {
                        return this.loaded;
                    }
                }, {
                    key: "isRotated",
                    value: function isRotated() {
                        return this._rotated;
                    }
                }, {
                    key: "setRotated",
                    value: function setRotated(rotated) {
                        this._rotated = rotated;
                    }
                }, {
                    key: "getRect",
                    value: function getRect(out) {
                        return out ? (out.set(this._rect), out) : this._rect.clone();
                    }
                }, {
                    key: "setRect",
                    value: function setRect(rect) {
                        this._rect.set(rect);
                    }
                }, {
                    key: "getOriginalSize",
                    value: function getOriginalSize(out) {
                        return out ? (out.set(this._originalSize), out) : this._originalSize.clone();
                    }
                }, {
                    key: "setOriginalSize",
                    value: function setOriginalSize(size) {
                        this._originalSize.set(size);
                    }
                }, {
                    key: "getOffset",
                    value: function getOffset(out) {
                        return out ? (out.set(this._offset), out) : this._offset.clone();
                    }
                }, {
                    key: "setOffset",
                    value: function setOffset(offsets) {
                        this._offset.set(offsets);
                    }
                }, {
                    key: "getGFXTextureView",
                    value: function getGFXTextureView() {
                        return this._texture.getGFXTextureView();
                    }
                }, {
                    key: "reset",
                    value: function reset(info, argument_1) {
                        var calUV = !1;
                        1 < arguments.length && void 0 !== argument_1 && argument_1 && (this._originalSize.set(0, 0), 
                        this._rect.set(0, 0, 0, 0), this._offset.set(0, 0), this._capInsets = [ 0, 0, 0, 0 ], 
                        calUV = !(this._rotated = !1)), info && (info.texture && (this._rect.x = this._rect.y = 0, 
                        this._rect.width = info.texture.width, this._rect.height = info.texture.height, 
                        this._texture && this._texture.off("load"), this._texture = info.texture, this.checkRect(this._texture), 
                        this._texture.on("load", this._textureLoaded, this)), info.originalSize && this._originalSize.set(info.originalSize), 
                        info.rect && this._rect.set(info.rect), info.offset && this._offset.set(info.offset), 
                        void 0 !== info.borderTop && (this._capInsets[1] = info.borderTop), void 0 !== info.borderBottom && (this._capInsets[3] = info.borderBottom), 
                        void 0 !== info.borderLeft && (this._capInsets[0] = info.borderLeft), void 0 !== info.borderRight && (this._capInsets[2] = info.borderRight), 
                        void 0 !== info.isRotate && (this._rotated = !!info.isRotate), void 0 !== info.isFlipUv && (this._flipUv = !!info.isFlipUv), 
                        this._texture instanceof RenderTexture && (this._flipUv = !0), calUV = !0), calUV && this._calculateUV();
                    }
                }, {
                    key: "checkRect",
                    value: function checkRect(texture) {
                        var rect = this._rect, maxX = rect.x, maxY = rect.y;
                        return this._rotated ? (maxX += rect.height, maxY += rect.width) : (maxX += rect.width, 
                        maxY += rect.height), maxX > texture.width ? (cc.errorID(3300, this.name + "/" + texture.name, maxX, texture.width), 
                        !1) : !(maxY > texture.height) || (cc.errorID(3400, this.name + "/" + texture.name, maxY, texture.height), 
                        !1);
                    }
                }, {
                    key: "onLoaded",
                    value: function onLoaded() {
                        this.loaded = !0, this.emit("load");
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        return this._texture && this._texture.off("load"), _get(_getPrototypeOf(SpriteFrame.prototype), "destroy", this).call(this);
                    }
                }, {
                    key: "_calculateSlicedUV",
                    value: function _calculateSlicedUV() {
                        var rect = this._rect, tex = this.texture, atlasWidth = tex.width, atlasHeight = tex.height, leftWidth = this._capInsets[0], rightWidth = this._capInsets[2], centerWidth = rect.width - leftWidth - rightWidth, topHeight = this._capInsets[1], bottomHeight = this._capInsets[3], centerHeight = rect.height - topHeight - bottomHeight, uvSliced = this.uvSliced;
                        if (uvSliced.length = 0, this._rotated) {
                            temp_uvs[0].u = (rect.x + rect.height) / atlasWidth, temp_uvs[1].u = (rect.x + bottomHeight + centerHeight) / atlasWidth, 
                            temp_uvs[2].u = (rect.x + bottomHeight) / atlasWidth, temp_uvs[3].u = rect.x / atlasWidth, 
                            temp_uvs[3].v = (rect.y + rect.width) / atlasHeight, temp_uvs[2].v = (rect.y + leftWidth + centerWidth) / atlasHeight, 
                            temp_uvs[1].v = (rect.y + leftWidth) / atlasHeight, temp_uvs[0].v = rect.y / atlasHeight;
                            for (var row = 0; row < 4; ++row) for (var rowD = temp_uvs[row], col = 0; col < 4; ++col) {
                                var colD = temp_uvs[3 - col];
                                uvSliced.push({
                                    u: rowD.u,
                                    v: colD.v
                                });
                            }
                        } else {
                            temp_uvs[0].u = rect.x / atlasWidth, temp_uvs[1].u = (rect.x + leftWidth) / atlasWidth, 
                            temp_uvs[2].u = (rect.x + leftWidth + centerWidth) / atlasWidth, temp_uvs[3].u = (rect.x + rect.width) / atlasWidth, 
                            temp_uvs[3].v = rect.y / atlasHeight, temp_uvs[2].v = (rect.y + topHeight) / atlasHeight, 
                            temp_uvs[1].v = (rect.y + topHeight + centerHeight) / atlasHeight, temp_uvs[0].v = (rect.y + rect.height) / atlasHeight;
                            for (var _row = 0; _row < 4; ++_row) for (var _rowD = temp_uvs[_row], _col = 0; _col < 4; ++_col) {
                                var _colD = temp_uvs[_col];
                                uvSliced.push({
                                    u: _colD.u,
                                    v: _rowD.v
                                });
                            }
                        }
                    }
                }, {
                    key: "_calculateUV",
                    value: function _calculateUV() {
                        var rect = this._rect, uv = this.uv, tex = this.texture, texw = tex.width, texh = tex.height;
                        if (this._rotated) {
                            var l = 0 === texw ? 0 : rect.x / texw, r = 0 === texw ? 0 : (rect.x + rect.height) / texw, t = 0 === texh ? 0 : rect.y / texh, b = 0 === texh ? 0 : (rect.y + rect.width) / texh;
                            this._flipUv ? (uv[0] = l, uv[1] = t, uv[2] = l, uv[3] = b, uv[4] = r, uv[5] = t, 
                            uv[6] = r, uv[7] = b) : (uv[0] = r, uv[1] = b, uv[2] = r, uv[3] = t, uv[4] = l, 
                            uv[5] = b, uv[6] = l, uv[7] = t);
                        } else {
                            var _l = 0 === texw ? 0 : rect.x / texw, _r = 0 === texw ? 0 : (rect.x + rect.width) / texw, _b = 0 === texh ? 0 : (rect.y + rect.height) / texh, _t = 0 === texh ? 0 : rect.y / texh;
                            this._flipUv ? (uv[0] = _l, uv[1] = _t, uv[2] = _r, uv[3] = _t, uv[4] = _l, uv[5] = _b, 
                            uv[6] = _r, uv[7] = _b) : (uv[0] = _l, uv[1] = _b, uv[2] = _r, uv[3] = _b, uv[4] = _l, 
                            uv[5] = _t, uv[6] = _r, uv[7] = _t);
                        }
                        for (var uvHashStr = "", i = 0; i < uv.length; i++) uvHashStr += uv[i];
                        this.uvHash = murmurhash2_32_gc(uvHashStr, 666);
                        var vertices = this.vertices;
                        if (vertices) {
                            vertices.nu.length = 0;
                            for (var _i = vertices.nv.length = 0; _i < vertices.u.length; _i++) vertices.nu[_i] = vertices.u[_i] / texw, 
                            vertices.nv[_i] = vertices.v[_i] / texh;
                        }
                        this._calculateSlicedUV();
                    }
                }, {
                    key: "_serialize",
                    value: function _serialize(exporting) {
                        var vertices, rect = this._rect, offset = this._offset, originalSize = this._originalSize, uuid = this._uuid;
                        return uuid && exporting && (uuid = Editor.Utils.UuidUtils.compressUuid(uuid, !0)), 
                        this.vertices && (vertices = {
                            triangles: this.vertices.triangles,
                            x: this.vertices.x,
                            y: this.vertices.y,
                            u: this.vertices.u,
                            v: this.vertices.v
                        }), {
                            image: this._image ? exporting ? Editor.Utils.UuidUtils.compressUuid(this._image._uuid, !0) : this._image._uuid : void 0,
                            name: this._name,
                            atlas: exporting ? void 0 : this._atlasUuid,
                            rect: rect,
                            offset: offset,
                            originalSize: originalSize,
                            rotated: this._rotated,
                            capInsets: this._capInsets,
                            vertices: vertices
                        };
                    }
                }, {
                    key: "_deserialize",
                    value: function _deserialize(serializeData, handle) {
                        var data = serializeData, rect = data.rect;
                        rect && this.setRect(new Rect(rect.x, rect.y, rect.width, rect.height));
                        var offset = data.offset;
                        data.offset && this.setOffset(new Vec2(offset.x, offset.y));
                        var originalSize = data.originalSize;
                        data.originalSize && this.setOriginalSize(new Size(originalSize.width, originalSize.height)), 
                        this._rotated = !!data.rotated, this._name = data.name;
                        var capInsets = data.capInsets;
                        capInsets && (this._capInsets[0] = capInsets[0], this._capInsets[1] = capInsets[1], 
                        this._capInsets[2] = capInsets[2], this._capInsets[3] = capInsets[3]), handle.result.push(this, "_imageSource", data.image), 
                        this.vertices = data.vertices, this.vertices && (this.vertices.nu = [], this.vertices.nv = []);
                    }
                }, {
                    key: "_textureLoaded",
                    value: function _textureLoaded() {
                        var tex = this._texture, config = {}, isReset = !1;
                        0 !== this._rect.width && 0 !== this._rect.height && this.checkRect(tex) || (config.rect = new Rect(0, 0, tex.width, tex.height), 
                        isReset = !0), 0 !== this._originalSize.width && 0 !== this._originalSize.height && !isReset || (config.originalSize = new Size(tex.width, tex.height), 
                        isReset = !0), isReset && (this.reset(config), this.onLoaded());
                    }
                } ]), SpriteFrame;
            }()) || _class$8);
            cc.SpriteFrame = SpriteFrame, function(FaceIndex) {
                FaceIndex[FaceIndex.right = 0] = "right", FaceIndex[FaceIndex.left = 1] = "left", 
                FaceIndex[FaceIndex.top = 2] = "top", FaceIndex[FaceIndex.bottom = 3] = "bottom", 
                FaceIndex[FaceIndex.front = 4] = "front", FaceIndex[FaceIndex.back = 5] = "back";
            }(FaceIndex = FaceIndex || {});
            var TextureCube = exports("TextureCube", ccclass("cc.TextureCube")((_temp$9 = _class3$4 = function() {
                function TextureCube() {
                    var _this;
                    return _classCallCheck(this, TextureCube), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(TextureCube).call(this)), "_mipmaps", _descriptor$5, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(TextureCube, SimpleTexture), _createClass(TextureCube, [ {
                    key: "mipmaps",
                    get: function get() {
                        return this._mipmaps;
                    },
                    set: function set(value) {
                        var _this2 = this;
                        if (this._mipmaps = value, this._setMipmapLevel(this._mipmaps.length), 0 < this._mipmaps.length) {
                            var imageAsset = this._mipmaps[0].front;
                            this.reset({
                                width: imageAsset.width,
                                height: imageAsset.height,
                                format: imageAsset.format,
                                mipmapLevel: this._mipmaps.length
                            }), this._mipmaps.forEach(function(mipmap, level) {
                                _forEachFace(mipmap, function(face, faceIndex) {
                                    _this2._assignImage(face, level, faceIndex);
                                });
                            });
                        } else this.reset({
                            width: 0,
                            height: 0,
                            mipmapLevel: this._mipmaps.length
                        });
                    }
                }, {
                    key: "image",
                    get: function get() {
                        return 0 === this._mipmaps.length ? null : this._mipmaps[0];
                    },
                    set: function set(value) {
                        this.mipmaps = value ? [ value ] : [];
                    }
                } ], [ {
                    key: "fromTexture2DArray",
                    value: function fromTexture2DArray(textures, out) {
                        for (var mipmaps = [], nMipmaps = textures.length / 6, i = 0; i < nMipmaps; i++) {
                            var x = 6 * i;
                            mipmaps.push({
                                front: textures[x + FaceIndex.front].image,
                                back: textures[x + FaceIndex.back].image,
                                left: textures[x + FaceIndex.left].image,
                                right: textures[x + FaceIndex.right].image,
                                top: textures[x + FaceIndex.top].image,
                                bottom: textures[x + FaceIndex.bottom].image
                            });
                        }
                        return (out = out || new TextureCube()).mipmaps = mipmaps, out;
                    }
                } ]), _createClass(TextureCube, [ {
                    key: "onLoaded",
                    value: function onLoaded() {
                        this.mipmaps = this._mipmaps, this.loaded = !0, this.emit("load");
                    }
                }, {
                    key: "reset",
                    value: function reset(info) {
                        this._width = info.width, this._height = info.height, this._setGFXFormat(info.format), 
                        this._setMipmapLevel(info.mipmapLevel || 1), this._tryReset();
                    }
                }, {
                    key: "updateMipmaps",
                    value: function updateMipmaps(argument_0, argument_1) {
                        var _this3 = this, firstLevel = 0 < arguments.length && void 0 !== argument_0 ? argument_0 : 0, count = 1 < arguments.length ? argument_1 : void 0;
                        if (!(firstLevel >= this._mipmaps.length)) for (var nUpdate = Math.min(void 0 === count ? this._mipmaps.length : count, this._mipmaps.length - firstLevel), _loop = function _loop(i) {
                            var level = firstLevel + i;
                            _forEachFace(_this3._mipmaps[level], function(face, faceIndex) {
                                _this3._assignImage(face, level, faceIndex);
                            });
                        }, i = 0; i < nUpdate; ++i) _loop(i);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        return this._mipmaps = [], _get(_getPrototypeOf(TextureCube.prototype), "destroy", this).call(this);
                    }
                }, {
                    key: "releaseTexture",
                    value: function releaseTexture() {
                        this.mipmaps = [];
                    }
                }, {
                    key: "_serialize",
                    value: function _serialize(exporting) {
                        return {
                            base: _get(_getPrototypeOf(TextureCube.prototype), "_serialize", this).call(this),
                            mipmaps: this._mipmaps.map(function(mipmap) {
                                return exporting ? {
                                    front: Editor.Utils.UuidUtils.compressUuid(mipmap.front._uuid, !0),
                                    back: Editor.Utils.UuidUtils.compressUuid(mipmap.back._uuid, !0),
                                    left: Editor.Utils.UuidUtils.compressUuid(mipmap.left._uuid, !0),
                                    right: Editor.Utils.UuidUtils.compressUuid(mipmap.right._uuid, !0),
                                    top: Editor.Utils.UuidUtils.compressUuid(mipmap.top._uuid, !0),
                                    bottom: Editor.Utils.UuidUtils.compressUuid(mipmap.bottom._uuid, !0)
                                } : {
                                    front: mipmap.front._uuid,
                                    back: mipmap.back._uuid,
                                    left: mipmap.left._uuid,
                                    right: mipmap.right._uuid,
                                    top: mipmap.top._uuid,
                                    bottom: mipmap.bottom._uuid
                                };
                            })
                        };
                    }
                }, {
                    key: "_deserialize",
                    value: function _deserialize(serializedData, handle) {
                        var data = serializedData;
                        _get(_getPrototypeOf(TextureCube.prototype), "_deserialize", this).call(this, data.base, handle), 
                        this._mipmaps = new Array(data.mipmaps.length);
                        for (var i = 0; i < data.mipmaps.length; ++i) {
                            this._mipmaps[i] = {
                                front: new ImageAsset(),
                                back: new ImageAsset(),
                                left: new ImageAsset(),
                                right: new ImageAsset(),
                                top: new ImageAsset(),
                                bottom: new ImageAsset()
                            };
                            var mipmap = data.mipmaps[i];
                            handle.result.push(this._mipmaps[i], "front", mipmap.front), handle.result.push(this._mipmaps[i], "back", mipmap.back), 
                            handle.result.push(this._mipmaps[i], "left", mipmap.left), handle.result.push(this._mipmaps[i], "right", mipmap.right), 
                            handle.result.push(this._mipmaps[i], "top", mipmap.top), handle.result.push(this._mipmaps[i], "bottom", mipmap.bottom);
                        }
                    }
                }, {
                    key: "_getGfxTextureCreateInfo",
                    value: function _getGfxTextureCreateInfo(presumed) {
                        var result = Object.assign({
                            type: GFXTextureType.TEX2D,
                            width: this._width,
                            height: this._height,
                            arrayLayer: 6
                        }, presumed);
                        return result.flags = (result.flags || 0) | GFXTextureFlagBit.CUBEMAP, result;
                    }
                }, {
                    key: "_getGfxTextureViewCreateInfo",
                    value: function _getGfxTextureViewCreateInfo(presumed) {
                        return Object.assign({
                            type: GFXTextureViewType.CUBE,
                            layerCount: 6
                        }, presumed);
                    }
                } ]), TextureCube;
            }(), _class3$4.FaceIndex = FaceIndex, _descriptor$5 = _applyDecoratedDescriptor((_class2$6 = _temp$9).prototype, "_mipmaps", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _class$9 = _class2$6)) || _class$9);
            function _forEachFace(mipmap, callback) {
                callback(mipmap.front, FaceIndex.front), callback(mipmap.back, FaceIndex.back), 
                callback(mipmap.left, FaceIndex.left), callback(mipmap.right, FaceIndex.right), 
                callback(mipmap.top, FaceIndex.top), callback(mipmap.bottom, FaceIndex.bottom);
            }
            cc.TextureCube = TextureCube;
            var GFXBuffer = exports("GFXBuffer", function() {
                function GFXBuffer(device) {
                    var _this;
                    return _classCallCheck(this, GFXBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXBuffer).call(this, GFXObjectType.BUFFER)))._device = void 0, 
                    _this._usage = GFXBufferUsageBit.NONE, _this._memUsage = GFXMemoryUsageBit.NONE, 
                    _this._size = 0, _this._stride = 1, _this._count = 0, _this._flags = GFXBufferFlagBit.NONE, 
                    _this._bufferView = null, _this._device = device, _this;
                }
                return _inherits(GFXBuffer, GFXObject), _createClass(GFXBuffer, [ {
                    key: "usage",
                    get: function get() {
                        return this._usage;
                    }
                }, {
                    key: "memUsage",
                    get: function get() {
                        return this._memUsage;
                    }
                }, {
                    key: "size",
                    get: function get() {
                        return this._size;
                    }
                }, {
                    key: "stride",
                    get: function get() {
                        return this._stride;
                    }
                }, {
                    key: "count",
                    get: function get() {
                        return this._count;
                    }
                }, {
                    key: "flags",
                    get: function get() {
                        return this._flags;
                    }
                }, {
                    key: "bufferView",
                    get: function get() {
                        return this._bufferView;
                    }
                } ]), GFXBuffer;
            }()), GFXCommandBuffer = exports("GFXCommandBuffer", function() {
                function GFXCommandBuffer(device) {
                    var _this;
                    return _classCallCheck(this, GFXCommandBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXCommandBuffer).call(this, GFXObjectType.COMMAND_BUFFER)))._device = void 0, 
                    _this._allocator = null, _this._type = GFXCommandBufferType.PRIMARY, _this._numDrawCalls = 0, 
                    _this._numTris = 0, _this._device = device, _this;
                }
                return _inherits(GFXCommandBuffer, GFXObject), _createClass(GFXCommandBuffer, [ {
                    key: "type",
                    get: function get() {
                        return this._type;
                    }
                }, {
                    key: "numDrawCalls",
                    get: function get() {
                        return this._numDrawCalls;
                    }
                }, {
                    key: "numTris",
                    get: function get() {
                        return this._numTris;
                    }
                } ]), GFXCommandBuffer;
            }()), GFXFramebuffer = exports("GFXFramebuffer", function() {
                function GFXFramebuffer(device) {
                    var _this;
                    return _classCallCheck(this, GFXFramebuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXFramebuffer).call(this, GFXObjectType.FRAMEBUFFER)))._device = void 0, 
                    _this._renderPass = null, _this._colorViews = [], _this._depthStencilView = null, 
                    _this._isOffscreen = !0, _this._device = device, _this;
                }
                return _inherits(GFXFramebuffer, GFXObject), _createClass(GFXFramebuffer, [ {
                    key: "renderPass",
                    get: function get() {
                        return this._renderPass;
                    }
                }, {
                    key: "colorViews",
                    get: function get() {
                        return this._colorViews;
                    }
                }, {
                    key: "depthStencilView",
                    get: function get() {
                        return this._depthStencilView;
                    }
                }, {
                    key: "isOffscreen",
                    get: function get() {
                        return this._isOffscreen;
                    }
                } ]), GFXFramebuffer;
            }());
            function find(path, referenceNode) {
                if (referenceNode) 0; else {
                    var scene = cc.director.getScene();
                    if (!scene) return null;
                    referenceNode = scene;
                }
                return referenceNode.getChildByPath(path);
            }
            cc.find = find;
            var _class$a, _class2$7, _descriptor$6, _descriptor2$2, BufferBlob = function() {
                function BufferBlob() {
                    _classCallCheck(this, BufferBlob), this._arrayBufferOrPaddings = [], this._length = 0;
                }
                return _createClass(BufferBlob, [ {
                    key: "setNextAlignment",
                    value: function setNextAlignment(align) {
                        if (0 !== align) {
                            var remainder = this._length % align;
                            if (0 != remainder) {
                                var padding = align - remainder;
                                this._arrayBufferOrPaddings.push(padding), this._length += padding;
                            }
                        }
                    }
                }, {
                    key: "addBuffer",
                    value: function addBuffer(arrayBuffer) {
                        var result = this._length;
                        return this._arrayBufferOrPaddings.push(arrayBuffer), this._length += arrayBuffer.byteLength, 
                        result;
                    }
                }, {
                    key: "getLength",
                    value: function getLength() {
                        return this._length;
                    }
                }, {
                    key: "getCombined",
                    value: function getCombined() {
                        var result = new Uint8Array(this._length), counter = 0;
                        return this._arrayBufferOrPaddings.forEach(function(arrayBufferOrPadding) {
                            "number" == typeof arrayBufferOrPadding ? counter += arrayBufferOrPadding : (result.set(new Uint8Array(arrayBufferOrPadding), counter), 
                            counter += arrayBufferOrPadding.byteLength);
                        }), result.buffer;
                    }
                } ]), BufferBlob;
            }();
            var RenderingMesh = function() {
                function RenderingMesh(_subMeshes) {
                    _classCallCheck(this, RenderingMesh), this._subMeshes = _subMeshes;
                }
                return _createClass(RenderingMesh, [ {
                    key: "getSubmesh",
                    value: function getSubmesh(index) {
                        return this._subMeshes[index];
                    }
                }, {
                    key: "destroySubMeshes",
                    value: function destroySubMeshes() {
                        for (var i = 0; i < this._subMeshes.length; ++i) {
                            for (var subMesh = this._subMeshes[i], j = 0; j < subMesh.vertexBuffers.length; ++j) subMesh.vertexBuffers[j].destroy();
                            subMesh.indexBuffer && subMesh.indexBuffer.destroy();
                        }
                        this._subMeshes.splice(0);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.destroySubMeshes(), this._subMeshes.length = 0;
                    }
                }, {
                    key: "subMeshes",
                    get: function get() {
                        return this._subMeshes;
                    }
                }, {
                    key: "subMeshCount",
                    get: function get() {
                        return this._subMeshes.length;
                    }
                } ]), RenderingMesh;
            }(), Mesh = exports("Mesh", ccclass("cc.Mesh")((_descriptor$6 = _applyDecoratedDescriptor((_class2$7 = function() {
                function Mesh() {
                    var _this;
                    return _classCallCheck(this, Mesh), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Mesh).call(this)), "_struct", _descriptor$6, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_dataLength", _descriptor2$2, _assertThisInitialized(_this)), 
                    _this._data = null, _this._initialized = !1, _this._hasFlatBuffers = !1, _this._renderingMesh = null, 
                    _this.loaded = !1, _this;
                }
                return _inherits(Mesh, Asset), _createClass(Mesh, [ {
                    key: "_nativeAsset",
                    get: function get() {
                        return this._data.buffer;
                    },
                    set: function set(value) {
                        this._data && this._data.byteLength === value.byteLength ? (this._data.set(new Uint8Array(value)), 
                        cc.loader._cache[this.nativeUrl] && (cc.loader._cache[this.nativeUrl].content = this._data.buffer)) : this._data = new Uint8Array(value), 
                        this.loaded = !0, this.emit("load");
                    }
                }, {
                    key: "subMeshCount",
                    get: function get() {
                        var renderingMesh = this.renderingMesh;
                        return renderingMesh ? renderingMesh.subMeshCount : 0;
                    }
                }, {
                    key: "minPosition",
                    get: function get() {
                        return this.struct.minPosition;
                    }
                }, {
                    key: "maxPosition",
                    get: function get() {
                        return this.struct.maxPosition;
                    }
                }, {
                    key: "struct",
                    get: function get() {
                        return this._struct;
                    }
                }, {
                    key: "data",
                    get: function get() {
                        return this._data;
                    }
                }, {
                    key: "hasFlatBuffers",
                    get: function get() {
                        return this._hasFlatBuffers;
                    }
                } ]), _createClass(Mesh, [ {
                    key: "initialize",
                    value: function initialize() {
                        var _this2 = this;
                        if (!this._initialized) {
                            this._initialized = !0, this._data || (this._data = new Uint8Array(this._dataLength), 
                            function postLoadMesh(mesh, callback) {
                                mesh.loaded ? callback && callback() : mesh.nativeUrl ? cc.loader.load({
                                    url: mesh.nativeUrl
                                }, function(err, arrayBuffer) {
                                    arrayBuffer && (mesh.loaded || (mesh._nativeAsset = arrayBuffer)), callback && callback(err);
                                }) : callback && callback();
                            }(this));
                            var buffer = this._data.buffer, gfxDevice = cc.director.root.device, vertexBuffers = this._createVertexBuffers(gfxDevice, buffer), submeshes = [], _loop2 = function _loop2() {
                                if (_isArray) {
                                    if (_i >= _iterator.length) return "break";
                                    _ref = _iterator[_i++];
                                } else {
                                    if ((_i = _iterator.next()).done) return "break";
                                    _ref = _i.value;
                                }
                                var prim = _ref;
                                if (0 === prim.vertexBundelIndices.length) return "continue";
                                var indexBuffer = null, ib = null;
                                if (prim.indexView) {
                                    var idxView = prim.indexView;
                                    indexBuffer = gfxDevice.createBuffer({
                                        usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                                        memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                                        size: idxView.length,
                                        stride: idxView.stride
                                    }), ib = new (function getIndexStrideCtor(stride) {
                                        switch (stride) {
                                          case 1:
                                            return Uint8Array;

                                          case 2:
                                            return Uint16Array;

                                          case 4:
                                            return Uint32Array;
                                        }
                                        return Uint8Array;
                                    }(idxView.stride))(buffer, idxView.offset, idxView.count), _this2.loaded ? indexBuffer.update(ib) : _this2.once("load", function() {
                                        indexBuffer.update(ib);
                                    });
                                }
                                var vbReference = prim.vertexBundelIndices.map(function(i) {
                                    return vertexBuffers[i];
                                }), gfxAttributes = [];
                                if (0 < prim.vertexBundelIndices.length) {
                                    var idx = prim.vertexBundelIndices[0];
                                    gfxAttributes = _this2._struct.vertexBundles[idx].attributes;
                                }
                                var subMesh = {
                                    primitiveMode: prim.primitiveMode,
                                    vertexBuffers: vbReference,
                                    flatBuffers: [],
                                    indexBuffer: indexBuffer,
                                    attributes: gfxAttributes
                                };
                                if (prim.geometricInfo) {
                                    var info = prim.geometricInfo, positions = new Float32Array(buffer, info.view.offset, info.view.length / 4);
                                    subMesh.geometricInfo = {
                                        indices: ib,
                                        positions: positions
                                    };
                                }
                                submeshes.push(subMesh);
                            };
                            var _iterator = this._struct.primitives, _isArray = Array.isArray(_iterator), _i = 0;
                            _loop: for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                switch (_loop2()) {
                                  case "break":
                                    break _loop;

                                  case "continue":
                                    continue;
                                }
                            }
                            this._renderingMesh = new RenderingMesh(submeshes);
                        }
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        return this.destroyRenderingMesh(), _get(_getPrototypeOf(Mesh.prototype), "destroy", this).call(this);
                    }
                }, {
                    key: "destroyRenderingMesh",
                    value: function destroyRenderingMesh() {
                        this._renderingMesh && (this._renderingMesh.destroy(), this._renderingMesh = null, 
                        this._data = null, this._initialized = !1);
                    }
                }, {
                    key: "assign",
                    value: function assign(struct, data) {
                        this.reset({
                            struct: struct,
                            data: data
                        });
                    }
                }, {
                    key: "reset",
                    value: function reset(info) {
                        this.destroyRenderingMesh(), this._struct = info.struct, this._data = info.data, 
                        this.loaded = !0, this.emit("load");
                    }
                }, {
                    key: "getSubMesh",
                    value: function getSubMesh(index) {
                        return this.renderingMesh.getSubmesh(index);
                    }
                }, {
                    key: "merge",
                    value: function merge(mesh, validate) {
                        if (void 0 !== validate && validate && (!this.loaded || !mesh.loaded || !this.validateMergingMesh(mesh))) return !1;
                        if (!this._initialized && mesh._data) {
                            var struct = JSON.parse(JSON.stringify(mesh._struct)), data = mesh._data.slice();
                            return this.reset({
                                struct: struct,
                                data: data
                            }), this.initialize(), !0;
                        }
                        for (var vb, vbView, srcVBView, dstVBView, dstAttrView, bufferBlob = new BufferBlob(), vertCount = 0, vertStride = 0, srcOffset = 0, dstOffset = 0, srcAttrOffset = 0, srcVBOffset = 0, dstVBOffset = 0, attrSize = 0, hasAttr = !1, vertexBundles = new Array(this._struct.vertexBundles.length), i = 0; i < this._struct.vertexBundles.length; ++i) {
                            var bundle = this._struct.vertexBundles[i], dstBundle = mesh._struct.vertexBundles[i];
                            srcOffset = bundle.view.offset, dstOffset = dstBundle.view.offset, vertStride = bundle.view.stride, 
                            vertCount = bundle.view.count + dstBundle.view.count, vb = new ArrayBuffer(vertCount * vertStride), 
                            vbView = new Uint8Array(vb), srcOffset += (srcVBView = this._data.subarray(srcOffset, srcOffset + bundle.view.length)).length, 
                            dstOffset += (dstVBView = mesh._data.subarray(dstOffset, dstOffset + dstBundle.view.length)).length, 
                            vbView.set(srcVBView), srcAttrOffset = 0;
                            var _iterator2 = bundle.attributes, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                                var _ref2;
                                if (_isArray2) {
                                    if (_i2 >= _iterator2.length) break;
                                    _ref2 = _iterator2[_i2++];
                                } else {
                                    if ((_i2 = _iterator2.next()).done) break;
                                    _ref2 = _i2.value;
                                }
                                var attr = _ref2;
                                dstVBOffset = 0, hasAttr = !1;
                                var _iterator3 = dstBundle.attributes, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                                    var _ref3;
                                    if (_isArray3) {
                                        if (_i3 >= _iterator3.length) break;
                                        _ref3 = _iterator3[_i3++];
                                    } else {
                                        if ((_i3 = _iterator3.next()).done) break;
                                        _ref3 = _i3.value;
                                    }
                                    var dstAttr = _ref3;
                                    if (attr.name === dstAttr.name && attr.format === dstAttr.format) {
                                        hasAttr = !0;
                                        break;
                                    }
                                    dstVBOffset += GFXFormatInfos[dstAttr.format].size;
                                }
                                if (hasAttr) {
                                    attrSize = GFXFormatInfos[attr.format].size, srcVBOffset = bundle.view.length + srcAttrOffset;
                                    for (var v = 0; v < dstBundle.view.count; ++v) dstAttrView = dstVBView.subarray(dstVBOffset, dstVBOffset + attrSize), 
                                    vbView.set(dstAttrView, srcVBOffset), srcVBOffset += bundle.view.stride, dstVBOffset += dstBundle.view.stride;
                                }
                                srcAttrOffset += GFXFormatInfos[attr.format].size;
                            }
                            vertexBundles[i] = {
                                attributes: bundle.attributes,
                                view: {
                                    offset: bufferBlob.getLength(),
                                    length: vb.byteLength,
                                    count: vertCount,
                                    stride: vertStride
                                }
                            }, bufferBlob.addBuffer(vb);
                        }
                        for (var ibView, srcIBView, dstIBView, idxCount = 0, idxStride = 2, vertBatchCount = 0, primitives = new Array(this._struct.primitives.length), _i4 = 0; _i4 < this._struct.primitives.length; ++_i4) {
                            var prim = this._struct.primitives[_i4], dstPrim = mesh._struct.primitives[_i4];
                            primitives[_i4] = {
                                primitiveMode: prim.primitiveMode,
                                vertexBundelIndices: prim.vertexBundelIndices
                            };
                            var _iterator4 = prim.vertexBundelIndices, _isArray4 = Array.isArray(_iterator4), _i5 = 0;
                            for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                                var _ref4;
                                if (_isArray4) {
                                    if (_i5 >= _iterator4.length) break;
                                    _ref4 = _iterator4[_i5++];
                                } else {
                                    if ((_i5 = _iterator4.next()).done) break;
                                    _ref4 = _i5.value;
                                }
                                var bundleIdx = _ref4;
                                vertBatchCount = Math.max(vertBatchCount, this._struct.vertexBundles[bundleIdx].view.count);
                            }
                            if (prim.indexView && dstPrim.indexView) {
                                idxCount = prim.indexView.count, idxCount += dstPrim.indexView.count, srcOffset = prim.indexView.offset, 
                                dstOffset = dstPrim.indexView.offset, idxStride = idxCount < 256 ? 1 : idxCount < 65536 ? 2 : 4;
                                var ib = new ArrayBuffer(idxCount * idxStride);
                                if (ibView = 2 === idxStride ? new Uint16Array(ib) : 1 === idxStride ? new Uint8Array(ib) : new Uint32Array(ib), 
                                srcIBView = 2 === prim.indexView.stride ? new Uint16Array(this._data.buffer, srcOffset, prim.indexView.count) : 1 === prim.indexView.stride ? new Uint8Array(this._data.buffer, srcOffset, prim.indexView.count) : new Uint32Array(this._data.buffer, srcOffset, prim.indexView.count), 
                                idxStride === prim.indexView.stride) ibView.set(srcIBView); else for (var n = 0; n < prim.indexView.count; ++n) ibView[n] = srcIBView[n];
                                srcOffset += prim.indexView.length, dstIBView = 2 === dstPrim.indexView.stride ? new Uint16Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count) : 1 === dstPrim.indexView.stride ? new Uint8Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count) : new Uint32Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
                                for (var _n = 0; _n < dstPrim.indexView.count; ++_n) ibView[prim.indexView.count + _n] = vertBatchCount + dstIBView[_n];
                                dstOffset += dstPrim.indexView.length, primitives[_i4].indexView = {
                                    offset: bufferBlob.getLength(),
                                    length: ib.byteLength,
                                    count: idxCount,
                                    stride: idxStride
                                }, bufferBlob.setNextAlignment(idxStride), bufferBlob.addBuffer(ib);
                            }
                            if (prim.geometricInfo && dstPrim.geometricInfo) {
                                var geomBuffSize = prim.geometricInfo.view.length + dstPrim.geometricInfo.view.length, geomBuff = new ArrayBuffer(geomBuffSize), geomBuffView = new Uint8Array(geomBuff), srcView = new Uint8Array(this._data.buffer, prim.geometricInfo.view.offset, prim.geometricInfo.view.length), dstView = new Uint8Array(mesh._data.buffer, dstPrim.geometricInfo.view.offset, dstPrim.geometricInfo.view.length);
                                geomBuffView.set(srcView), geomBuffView.set(dstView, srcView.length), bufferBlob.setNextAlignment(4), 
                                primitives[_i4].geometricInfo = {
                                    doubleSided: prim.geometricInfo.doubleSided,
                                    view: {
                                        offset: bufferBlob.getLength(),
                                        length: geomBuffView.length,
                                        count: prim.geometricInfo.view.count + dstPrim.geometricInfo.view.count,
                                        stride: prim.geometricInfo.view.stride
                                    }
                                }, bufferBlob.addBuffer(geomBuff);
                            }
                        }
                        var meshStruct = {
                            vertexBundles: vertexBundles,
                            primitives: primitives,
                            minPosition: this._struct.minPosition,
                            maxPosition: this._struct.maxPosition
                        };
                        return meshStruct.minPosition && mesh._struct.minPosition && Vec3.min(meshStruct.minPosition, meshStruct.minPosition, mesh._struct.minPosition), 
                        meshStruct.maxPosition && mesh._struct.maxPosition && Vec3.max(meshStruct.maxPosition, meshStruct.maxPosition, mesh._struct.maxPosition), 
                        this.reset({
                            struct: meshStruct,
                            data: new Uint8Array(bufferBlob.getCombined())
                        }), this.initialize(), !0;
                    }
                }, {
                    key: "validateMergingMesh",
                    value: function validateMergingMesh(mesh) {
                        if (!this._data && mesh._data) return !0;
                        if (this._struct.vertexBundles.length !== mesh._struct.vertexBundles.length) return !1;
                        for (var i = 0; i < this._struct.vertexBundles.length; ++i) {
                            var bundle = this._struct.vertexBundles[i], dstBundle = mesh._struct.vertexBundles[i];
                            if (bundle.attributes.length !== dstBundle.attributes.length) return !1;
                            for (var j = 0; j < bundle.attributes.length; ++j) if (bundle.attributes[j].format !== dstBundle.attributes[j].format) return !1;
                        }
                        if (this._struct.primitives.length !== mesh._struct.primitives.length) return !1;
                        for (var _i6 = 0; _i6 < this._struct.primitives.length; ++_i6) {
                            var prim = this._struct.primitives[_i6], dstPrim = mesh._struct.primitives[_i6];
                            if (prim.vertexBundelIndices.length !== dstPrim.vertexBundelIndices.length) return !1;
                            for (var _j = 0; _j < prim.vertexBundelIndices.length; ++_j) if (prim.vertexBundelIndices[_j] !== dstPrim.vertexBundelIndices[_j]) return !1;
                            if (prim.primitiveMode !== dstPrim.primitiveMode) return !1;
                            if (prim.indexView) {
                                if (void 0 === dstPrim.indexView) return !1;
                            } else if (dstPrim.indexView) return !1;
                        }
                        return !0;
                    }
                }, {
                    key: "readAttribute",
                    value: function readAttribute(primitiveIndex, attributeName) {
                        var _this3 = this, result = null;
                        return this._accessAttribute(primitiveIndex, attributeName, function(vertexBundle, iAttribute) {
                            var format = vertexBundle.attributes[iAttribute].format, inputView = new DataView(_this3._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute)), formatInfo = GFXFormatInfos[format], storageConstructor = getStorageConstructor(format), reader = getReader(inputView, format);
                            if (storageConstructor && reader) {
                                for (var vertexCount = vertexBundle.view.count, componentCount = formatInfo.count, storage = new storageConstructor(vertexCount * componentCount), inputStride = vertexBundle.view.stride, iVertex = 0; iVertex < vertexCount; ++iVertex) for (var iComponent = 0; iComponent < componentCount; ++iComponent) storage[componentCount * iVertex + iComponent] = reader(inputStride * iVertex + storage.BYTES_PER_ELEMENT * iComponent);
                                result = storage;
                            }
                        }), result;
                    }
                }, {
                    key: "copyAttribute",
                    value: function copyAttribute(primitiveIndex, attributeName, buffer, stride, offset) {
                        var _this4 = this, written = !1;
                        return this._accessAttribute(primitiveIndex, attributeName, function(vertexBundle, iAttribute) {
                            var format = vertexBundle.attributes[iAttribute].format, inputView = new DataView(_this4._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute)), outputView = new DataView(buffer, offset), formatInfo = GFXFormatInfos[format], reader = getReader(inputView, format), writer = function getWriter(dataView, format) {
                                var info = GFXFormatInfos[format], stride = info.size / info.count;
                                switch (info.type) {
                                  case GFXFormatType.UNORM:
                                    switch (stride) {
                                      case 1:
                                        return function(offset, value) {
                                            return dataView.setUint8(offset, value);
                                        };

                                      case 2:
                                        return function(offset, value) {
                                            return dataView.setUint16(offset, value, isLittleEndian);
                                        };

                                      case 4:
                                        return function(offset, value) {
                                            return dataView.setUint32(offset, value, isLittleEndian);
                                        };
                                    }
                                    break;

                                  case GFXFormatType.SNORM:
                                  case GFXFormatType.INT:
                                    switch (stride) {
                                      case 1:
                                        return function(offset, value) {
                                            return dataView.setInt8(offset, value);
                                        };

                                      case 2:
                                        return function(offset, value) {
                                            return dataView.setInt16(offset, value, isLittleEndian);
                                        };

                                      case 4:
                                        return function(offset, value) {
                                            return dataView.setInt32(offset, value, isLittleEndian);
                                        };
                                    }
                                    break;

                                  case GFXFormatType.UINT:
                                    switch (stride) {
                                      case 1:
                                        return function(offset, value) {
                                            return dataView.setUint8(offset, value);
                                        };

                                      case 2:
                                        return function(offset, value) {
                                            return dataView.setUint16(offset, value, isLittleEndian);
                                        };

                                      case 4:
                                        return function(offset, value) {
                                            return dataView.setUint32(offset, value, isLittleEndian);
                                        };
                                    }
                                    break;

                                  case GFXFormatType.FLOAT:
                                    return function(offset, value) {
                                        return dataView.setFloat32(offset, value, isLittleEndian);
                                    };
                                }
                                return null;
                            }(outputView, format);
                            if (reader && writer) {
                                for (var vertexCount = vertexBundle.view.count, componentCount = formatInfo.count, inputStride = vertexBundle.view.stride, inputComponentByteLength = function getComponentByteLength(format) {
                                    var info = GFXFormatInfos[format];
                                    return info.size / info.count;
                                }(format), outputStride = stride, outputComponentByteLength = inputComponentByteLength, iVertex = 0; iVertex < vertexCount; ++iVertex) for (var iComponent = 0; iComponent < componentCount; ++iComponent) {
                                    writer(outputStride * iVertex + outputComponentByteLength * iComponent, reader(inputStride * iVertex + inputComponentByteLength * iComponent));
                                }
                                written = !0;
                            }
                        }), written;
                    }
                }, {
                    key: "readIndices",
                    value: function readIndices(primitiveIndex) {
                        if (!this._data || primitiveIndex >= this._struct.primitives.length) return null;
                        var primitive = this._struct.primitives[primitiveIndex];
                        if (!primitive.indexView) return null;
                        for (var indexCount = primitive.indexView.count, indexFormat = indexCount < 256 ? GFXFormat.R8UI : indexCount < 65536 ? GFXFormat.R16UI : GFXFormat.R32UI, storage = new (getStorageConstructor(indexFormat))(indexCount), reader = getReader(new DataView(this._data.buffer), indexFormat), i = 0; i < indexCount; ++i) storage[i] = reader(primitive.indexView.offset + storage.BYTES_PER_ELEMENT * i);
                        return storage;
                    }
                }, {
                    key: "copyIndices",
                    value: function copyIndices(primitiveIndex, outputArray) {
                        if (!this._data || primitiveIndex >= this._struct.primitives.length) return !1;
                        var primitive = this._struct.primitives[primitiveIndex];
                        if (!primitive.indexView) return !1;
                        for (var indexCount = primitive.indexView.count, indexFormat = 1 === primitive.indexView.stride ? GFXFormat.R8UI : 2 === primitive.indexView.stride ? GFXFormat.R16UI : GFXFormat.R32UI, reader = getReader(new DataView(this._data.buffer), indexFormat), i = 0; i < indexCount; ++i) outputArray[i] = reader(primitive.indexView.offset + GFXFormatInfos[indexFormat].size * i);
                        return !0;
                    }
                }, {
                    key: "createFlatBuffers",
                    value: function createFlatBuffers() {
                        if (!this._renderingMesh || this._hasFlatBuffers) return !1;
                        cc.director.root.device;
                        for (var ibView, idxCount = 0, i = 0; i < this._struct.primitives.length; ++i) {
                            var prim = this._struct.primitives[i], subMesh = this._renderingMesh.subMeshes[i];
                            prim.indexView && (idxCount = prim.indexView.count);
                            var _iterator5 = prim.vertexBundelIndices, _isArray5 = Array.isArray(_iterator5), _i7 = 0;
                            for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                                var _ref5;
                                if (_isArray5) {
                                    if (_i7 >= _iterator5.length) break;
                                    _ref5 = _iterator5[_i7++];
                                } else {
                                    if ((_i7 = _iterator5.next()).done) break;
                                    _ref5 = _i7.value;
                                }
                                var bundleIdx = _ref5, _vertexBundle2 = this._struct.vertexBundles[bundleIdx], vbCount = prim.indexView ? prim.indexView.count : _vertexBundle2.view.count, vbStride = _vertexBundle2.view.stride, vbSize = vbStride * vbCount, view = new Uint8Array(this._data.buffer, _vertexBundle2.view.offset, _vertexBundle2.view.length);
                                if (prim.indexView) {
                                    var vbView = new Uint8Array(vbSize);
                                    ibView = 2 === (idxCount < 65536 ? 2 : 4) ? new Uint16Array(this._data.buffer, prim.indexView.offset, prim.indexView.count) : new Uint32Array(this._data.buffer, prim.indexView.offset, prim.indexView.count);
                                    for (var n = 0; n < idxCount; ++n) for (var offset = n * vbStride, srcOffset = ibView[n] * vbStride, m = 0; m < vbStride; ++m) vbView[offset + m] = view[srcOffset + m];
                                    subMesh.flatBuffers.push({
                                        stride: vbStride,
                                        count: vbCount,
                                        buffer: vbView.buffer
                                    });
                                } else subMesh.flatBuffers.push({
                                    stride: vbStride,
                                    count: vbCount,
                                    buffer: view.buffer
                                });
                            }
                        }
                        return this._hasFlatBuffers = !0;
                    }
                }, {
                    key: "destroyFlatBuffers",
                    value: function destroyFlatBuffers() {
                        if (this._hasFlatBuffers) {
                            if (this._renderingMesh) for (var subMeshes = this._renderingMesh.subMeshes, i = 0; i < subMeshes.length; ++i) subMeshes[i].flatBuffers.splice(0);
                            this._hasFlatBuffers = !1;
                        }
                    }
                }, {
                    key: "_accessAttribute",
                    value: function _accessAttribute(primitiveIndex, attributeName, accessor) {
                        if (this._data && !(primitiveIndex >= this._struct.primitives.length)) {
                            var _iterator6 = this._struct.primitives[primitiveIndex].vertexBundelIndices, _isArray6 = Array.isArray(_iterator6), _i8 = 0;
                            for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                                var _ref6;
                                if (_isArray6) {
                                    if (_i8 >= _iterator6.length) break;
                                    _ref6 = _iterator6[_i8++];
                                } else {
                                    if ((_i8 = _iterator6.next()).done) break;
                                    _ref6 = _i8.value;
                                }
                                var vertexBundleIndex = _ref6, _vertexBundle3 = this._struct.vertexBundles[vertexBundleIndex], _iAttribute = _vertexBundle3.attributes.findIndex(function(a) {
                                    return a.name === attributeName;
                                });
                                if (!(_iAttribute < 0)) {
                                    accessor(_vertexBundle3, _iAttribute);
                                    break;
                                }
                            }
                        }
                    }
                }, {
                    key: "_createVertexBuffers",
                    value: function _createVertexBuffers(gfxDevice, data) {
                        var _this5 = this;
                        return this._struct.vertexBundles.map(function(vertexBundle) {
                            var vertexBuffer = gfxDevice.createBuffer({
                                usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                                size: vertexBundle.view.length,
                                stride: vertexBundle.view.stride
                            }), view = new Uint8Array(data, vertexBundle.view.offset, vertexBundle.view.length);
                            return _this5.loaded ? vertexBuffer.update(view) : _this5.once("load", function() {
                                vertexBuffer.update(view);
                            }), vertexBuffer;
                        });
                    }
                }, {
                    key: "renderingMesh",
                    get: function get() {
                        return this.initialize(), this._renderingMesh;
                    }
                } ]), Mesh;
            }()).prototype, "_struct", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return {
                        vertexBundles: [],
                        primitives: []
                    };
                }
            }), _descriptor2$2 = _applyDecoratedDescriptor(_class2$7.prototype, "_dataLength", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _class$a = _class2$7)) || _class$a);
            function getOffset(attributes, attributeIndex) {
                for (var result = 0, i = 0; i < attributeIndex; ++i) {
                    var attribute = attributes[i];
                    result += GFXFormatInfos[attribute.format].size;
                }
                return result;
            }
            function getStorageConstructor(format) {
                var info = GFXFormatInfos[format], stride = info.size / info.count;
                switch (info.type) {
                  case GFXFormatType.UNORM:
                  case GFXFormatType.UINT:
                    switch (stride) {
                      case 1:
                        return Uint8Array;

                      case 2:
                        return Uint16Array;

                      case 4:
                        return Uint32Array;
                    }
                    break;

                  case GFXFormatType.SNORM:
                  case GFXFormatType.INT:
                    switch (stride) {
                      case 1:
                        return Int8Array;

                      case 2:
                        return Int16Array;

                      case 4:
                        return Int32Array;
                    }
                    break;

                  case GFXFormatType.FLOAT:
                    return Float32Array;
                }
                return null;
            }
            cc.Mesh = Mesh;
            var isLittleEndian = cc.sys.isLittleEndian;
            function getReader(dataView, format) {
                var info = GFXFormatInfos[format], stride = info.size / info.count;
                switch (info.type) {
                  case GFXFormatType.UNORM:
                    switch (stride) {
                      case 1:
                        return function(offset) {
                            return dataView.getUint8(offset);
                        };

                      case 2:
                        return function(offset) {
                            return dataView.getUint16(offset, isLittleEndian);
                        };

                      case 4:
                        return function(offset) {
                            return dataView.getUint32(offset, isLittleEndian);
                        };
                    }
                    break;

                  case GFXFormatType.SNORM:
                  case GFXFormatType.INT:
                    switch (stride) {
                      case 1:
                        return function(offset) {
                            return dataView.getInt8(offset);
                        };

                      case 2:
                        return function(offset) {
                            return dataView.getInt16(offset, isLittleEndian);
                        };

                      case 4:
                        return function(offset) {
                            return dataView.getInt32(offset, isLittleEndian);
                        };
                    }
                    break;

                  case GFXFormatType.UINT:
                    switch (stride) {
                      case 1:
                        return function(offset) {
                            return dataView.getUint8(offset);
                        };

                      case 2:
                        return function(offset) {
                            return dataView.getUint16(offset, isLittleEndian);
                        };

                      case 4:
                        return function(offset) {
                            return dataView.getUint32(offset, isLittleEndian);
                        };
                    }
                    break;

                  case GFXFormatType.FLOAT:
                    return function(offset) {
                        return dataView.getFloat32(offset, isLittleEndian);
                    };
                }
                return null;
            }
            var layerList = {
                NONE: 0,
                IGNORE_RAYCAST: 1 << 20,
                GIZMOS: 1 << 21,
                EDITOR: 1 << 22,
                UI_3D: 1 << 23,
                SCENE_GIZMO: 1 << 24,
                UI_2D: 1 << 25,
                PROFILER: 1 << 28,
                DEFAULT: 1 << 30,
                ALL: 4294967295
            }, Layers = exports("Layers", function() {
                function Layers() {
                    _classCallCheck(this, Layers);
                }
                return _createClass(Layers, null, [ {
                    key: "makeMaskInclude",
                    value: function makeMaskInclude(includes) {
                        var mask = 0, _iterator = includes, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            mask |= _ref;
                        }
                        return mask;
                    }
                }, {
                    key: "makeMaskExclude",
                    value: function makeMaskExclude(excludes) {
                        return ~Layers.makeMaskInclude(excludes);
                    }
                }, {
                    key: "addLayer",
                    value: function addLayer(name, bitNum) {
                        void 0 !== bitNum ? 19 < bitNum || bitNum < 0 ? console.warn("maximum layers reached.") : (Layers.Enum[name] = 1 << bitNum, 
                        Layers.Enum[bitNum] = name, Layers.BitMask[name] = 1 << bitNum, Layers.BitMask[bitNum] = name) : console.warn("bitNum can't be undefined");
                    }
                }, {
                    key: "deleteLayer",
                    value: function deleteLayer(bitNum) {
                        19 < bitNum || bitNum < 0 ? console.warn("do not change buildin layers.") : (delete Layers.Enum[Layers.Enum[bitNum]], 
                        delete Layers.Enum[bitNum], delete Layers.BitMask[Layers.BitMask[bitNum]], delete Layers.BitMask[bitNum]);
                    }
                } ]), Layers;
            }());
            Layers.Enum = Enum(layerList), Layers.BitMask = BitMask(Object.assign({}, layerList)), 
            cc.Layers = Layers;
            var RenderPassStage, RenderPriority;
            !function(RenderPassStage) {
                RenderPassStage[RenderPassStage.DEFAULT = 100] = "DEFAULT";
            }(RenderPassStage = RenderPassStage || exports("RenderPassStage", {})), function(RenderPriority) {
                RenderPriority[RenderPriority.MIN = 0] = "MIN", RenderPriority[RenderPriority.MAX = 255] = "MAX", 
                RenderPriority[RenderPriority.DEFAULT = 128] = "DEFAULT";
            }(RenderPriority = RenderPriority || {});
            var UniformBinding;
            !function(UniformBinding) {
                UniformBinding[UniformBinding.UBO_GLOBAL = 23] = "UBO_GLOBAL", UniformBinding[UniformBinding.UBO_SHADOW = 22] = "UBO_SHADOW", 
                UniformBinding[UniformBinding.UBO_LOCAL = 21] = "UBO_LOCAL", UniformBinding[UniformBinding.UBO_LOCAL_BATCHED = 20] = "UBO_LOCAL_BATCHED", 
                UniformBinding[UniformBinding.UBO_FORWARD_LIGHTS = 19] = "UBO_FORWARD_LIGHTS", UniformBinding[UniformBinding.UBO_SKINNING_ANIMATION = 18] = "UBO_SKINNING_ANIMATION", 
                UniformBinding[UniformBinding.UBO_SKINNING_TEXTURE = 17] = "UBO_SKINNING_TEXTURE", 
                UniformBinding[UniformBinding.UBO_UI = 16] = "UBO_UI", UniformBinding[UniformBinding.SAMPLER_JOINTS = 25] = "SAMPLER_JOINTS", 
                UniformBinding[UniformBinding.SAMPLER_ENVIRONMENT = 26] = "SAMPLER_ENVIRONMENT", 
                UniformBinding[UniformBinding.CUSTUM_UBO_BINDING_END_POINT = 17] = "CUSTUM_UBO_BINDING_END_POINT", 
                UniformBinding[UniformBinding.CUSTOM_SAMPLER_BINDING_START_POINT = 30] = "CUSTOM_SAMPLER_BINDING_START_POINT";
            }(UniformBinding = UniformBinding || {});
            function isBuiltinBinding(binding) {
                return binding >= UniformBinding.CUSTUM_UBO_BINDING_END_POINT && binding < UniformBinding.CUSTOM_SAMPLER_BINDING_START_POINT;
            }
            function UBOGlobal() {
                _classCallCheck(this, UBOGlobal), this.view = new Float32Array(UBOGlobal.COUNT);
            }
            UBOGlobal.SIZE = 4 * (UBOGlobal.COUNT = (UBOGlobal.AMBIENT_GROUND_OFFSET = (UBOGlobal.AMBIENT_SKY_OFFSET = (UBOGlobal.MAIN_LIT_COLOR_OFFSET = (UBOGlobal.MAIN_LIT_DIR_OFFSET = (UBOGlobal.EXPOSURE_OFFSET = (UBOGlobal.CAMERA_POS_OFFSET = (UBOGlobal.MAT_VIEW_PROJ_INV_OFFSET = (UBOGlobal.MAT_VIEW_PROJ_OFFSET = (UBOGlobal.MAT_PROJ_INV_OFFSET = (UBOGlobal.MAT_PROJ_OFFSET = (UBOGlobal.MAT_VIEW_INV_OFFSET = (UBOGlobal.MAT_VIEW_OFFSET = (UBOGlobal.NATIVE_SIZE_OFFSET = (UBOGlobal.SCREEN_SCALE_OFFSET = (UBOGlobal.SCREEN_SIZE_OFFSET = (UBOGlobal.TIME_OFFSET = 0) + 4) + 4) + 4) + 4) + 16) + 16) + 16) + 16) + 16) + 16) + 4) + 4) + 4) + 4) + 4) + 4), 
            UBOGlobal.BLOCK = {
                binding: UniformBinding.UBO_GLOBAL,
                name: "CCGlobal",
                members: [ {
                    name: "cc_time",
                    type: GFXType.FLOAT4,
                    count: 1
                }, {
                    name: "cc_screenSize",
                    type: GFXType.FLOAT4,
                    count: 1
                }, {
                    name: "cc_screenScale",
                    type: GFXType.FLOAT4,
                    count: 1
                }, {
                    name: "cc_nativeSize",
                    type: GFXType.FLOAT4,
                    count: 1
                }, {
                    name: "cc_matView",
                    type: GFXType.MAT4,
                    count: 1
                }, {
                    name: "cc_matViewInv",
                    type: GFXType.MAT4,
                    count: 1
                }, {
                    name: "cc_matProj",
                    type: GFXType.MAT4,
                    count: 1
                }, {
                    name: "cc_matProjInv",
                    type: GFXType.MAT4,
                    count: 1
                }, {
                    name: "cc_matViewProj",
                    type: GFXType.MAT4,
                    count: 1
                }, {
                    name: "cc_matViewProjInv",
                    type: GFXType.MAT4,
                    count: 1
                }, {
                    name: "cc_cameraPos",
                    type: GFXType.FLOAT4,
                    count: 1
                }, {
                    name: "cc_exposure",
                    type: GFXType.FLOAT4,
                    count: 1
                }, {
                    name: "cc_mainLitDir",
                    type: GFXType.FLOAT4,
                    count: 1
                }, {
                    name: "cc_mainLitColor",
                    type: GFXType.FLOAT4,
                    count: 1
                }, {
                    name: "cc_ambientSky",
                    type: GFXType.FLOAT4,
                    count: 1
                }, {
                    name: "cc_ambientGround",
                    type: GFXType.FLOAT4,
                    count: 1
                } ]
            };
            function UBOShadow() {
                _classCallCheck(this, UBOShadow), this.view = new Float32Array(UBOShadow.COUNT);
            }
            UBOShadow.SIZE = 4 * (UBOShadow.COUNT = (UBOShadow.SHADOW_COLOR_OFFSET = (UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET = 0) + 16) + 4), 
            UBOShadow.BLOCK = {
                binding: UniformBinding.UBO_SHADOW,
                name: "CCShadow",
                members: [ {
                    name: "cc_matLightPlaneProj",
                    type: GFXType.MAT4,
                    count: 1
                }, {
                    name: "cc_shadowColor",
                    type: GFXType.FLOAT4,
                    count: 1
                } ]
            };
            function UBOLocal() {
                _classCallCheck(this, UBOLocal), this.view = new Float32Array(UBOLocal.COUNT);
            }
            var UNIFORM_ENVIRONMENT = {
                binding: UniformBinding.SAMPLER_ENVIRONMENT,
                name: "cc_environment",
                type: GFXType.SAMPLER_CUBE,
                count: 1
            }, localBindingsDesc = new Map();
            UBOLocal.BATCHING_COUNT = 10, UBOLocal.SIZE = 4 * (UBOLocal.COUNT = (UBOLocal.MAT_WORLDS_OFFSET = (UBOLocal.MAT_WORLD_IT_OFFSET = (UBOLocal.MAT_WORLD_OFFSET = 0) + 16) + 16) + 16 * UBOLocal.BATCHING_COUNT), 
            UBOLocal.BLOCK = {
                binding: UniformBinding.UBO_LOCAL,
                name: "CCLocal",
                members: [ {
                    name: "cc_matWorld",
                    type: GFXType.MAT4,
                    count: 1
                }, {
                    name: "cc_matWorldIT",
                    type: GFXType.MAT4,
                    count: 1
                }, {
                    name: "cc_matWorlds",
                    type: GFXType.MAT4,
                    count: UBOLocal.BATCHING_COUNT
                } ]
            }, localBindingsDesc.set(UBOLocal.BLOCK.name, {
                type: GFXBindingType.UNIFORM_BUFFER,
                blockInfo: UBOLocal.BLOCK
            });
            function UBOForwardLight() {
                _classCallCheck(this, UBOForwardLight), this.view = new Float32Array(UBOForwardLight.COUNT);
            }
            UBOForwardLight.MAX_SPHERE_LIGHTS = 2, UBOForwardLight.MAX_SPOT_LIGHTS = 2, UBOForwardLight.SIZE = 4 * (UBOForwardLight.COUNT = (UBOForwardLight.SPOT_LIGHT_COLOR_OFFSET = (UBOForwardLight.SPOT_LIGHT_DIR_OFFSET = (UBOForwardLight.SPOT_LIGHT_SIZE_RANGE_ANGLE_OFFSET = (UBOForwardLight.SPOT_LIGHT_POS_OFFSET = (UBOForwardLight.SPHERE_LIGHT_COLOR_OFFSET = (UBOForwardLight.SPHERE_LIGHT_SIZE_RANGE_OFFSET = (UBOForwardLight.SPHERE_LIGHT_POS_OFFSET = 0) + 4 * UBOForwardLight.MAX_SPHERE_LIGHTS) + 4 * UBOForwardLight.MAX_SPHERE_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS), 
            UBOForwardLight.BLOCK = {
                binding: UniformBinding.UBO_FORWARD_LIGHTS,
                name: "CCForwardLight",
                members: [ {
                    name: "cc_sphereLitPos",
                    type: GFXType.FLOAT4,
                    count: UBOForwardLight.MAX_SPHERE_LIGHTS
                }, {
                    name: "cc_sphereLitSizeRange",
                    type: GFXType.FLOAT4,
                    count: UBOForwardLight.MAX_SPHERE_LIGHTS
                }, {
                    name: "cc_sphereLitColor",
                    type: GFXType.FLOAT4,
                    count: UBOForwardLight.MAX_SPHERE_LIGHTS
                }, {
                    name: "cc_spotLitPos",
                    type: GFXType.FLOAT4,
                    count: UBOForwardLight.MAX_SPOT_LIGHTS
                }, {
                    name: "cc_spotLitSizeRangeAngle",
                    type: GFXType.FLOAT4,
                    count: UBOForwardLight.MAX_SPOT_LIGHTS
                }, {
                    name: "cc_spotLitDir",
                    type: GFXType.FLOAT4,
                    count: UBOForwardLight.MAX_SPOT_LIGHTS
                }, {
                    name: "cc_spotLitColor",
                    type: GFXType.FLOAT4,
                    count: UBOForwardLight.MAX_SPOT_LIGHTS
                } ]
            }, localBindingsDesc.set(UBOForwardLight.BLOCK.name, {
                type: GFXBindingType.UNIFORM_BUFFER,
                blockInfo: UBOForwardLight.BLOCK
            });
            function UBOSkinningTexture() {
                _classCallCheck(this, UBOSkinningTexture);
            }
            UBOSkinningTexture.SIZE = 4 * (UBOSkinningTexture.COUNT = (UBOSkinningTexture.JOINTS_TEXTURE_INFO_OFFSET = 0) + 4), 
            UBOSkinningTexture.BLOCK = {
                binding: UniformBinding.UBO_SKINNING_TEXTURE,
                name: "CCSkinningTexture",
                members: [ {
                    name: "cc_jointsTextureInfo",
                    type: GFXType.FLOAT4,
                    count: 1
                } ]
            }, localBindingsDesc.set(UBOSkinningTexture.BLOCK.name, {
                type: GFXBindingType.UNIFORM_BUFFER,
                blockInfo: UBOSkinningTexture.BLOCK
            });
            function UBOSkinningAnimation() {
                _classCallCheck(this, UBOSkinningAnimation);
            }
            UBOSkinningAnimation.SIZE = 4 * (UBOSkinningAnimation.COUNT = (UBOSkinningAnimation.JOINTS_ANIM_INFO_OFFSET = 0) + 4), 
            UBOSkinningAnimation.BLOCK = {
                binding: UniformBinding.UBO_SKINNING_ANIMATION,
                name: "CCSkinningAnimation",
                members: [ {
                    name: "cc_jointsAnimInfo",
                    type: GFXType.FLOAT4,
                    count: 1
                } ]
            }, localBindingsDesc.set(UBOSkinningAnimation.BLOCK.name, {
                type: GFXBindingType.UNIFORM_BUFFER,
                blockInfo: UBOSkinningAnimation.BLOCK
            });
            var UniformJointsTexture = {
                binding: UniformBinding.SAMPLER_JOINTS,
                name: "cc_jointsTexture",
                type: GFXType.SAMPLER2D,
                count: 1
            };
            localBindingsDesc.set(UniformJointsTexture.name, {
                type: GFXBindingType.SAMPLER,
                samplerInfo: UniformJointsTexture
            });
            var CameraDefaultMask = Layers.makeMaskExclude([ Layers.BitMask.UI_2D, Layers.BitMask.GIZMOS, Layers.BitMask.EDITOR, Layers.BitMask.SCENE_GIZMO, Layers.BitMask.PROFILER ]), CameraEditorMask = Layers.makeMaskExclude([ Layers.BitMask.UI_2D, Layers.BitMask.PROFILER ]), Customization = (Layers.Enum.ALL, 
            function() {
                function Customization(info) {
                    _classCallCheck(this, Customization), this._onAttach = void 0, this._onDetach = void 0, 
                    this._models = {}, this._onAttach = info.onAttach, this._onDetach = info.onDetach;
                }
                return _createClass(Customization, [ {
                    key: "attach",
                    value: function attach(model) {
                        var models = this._models, id = model.id;
                        models[id] ? models[id]++ : (this._onAttach && this._onAttach(model), models[id] = 1);
                    }
                }, {
                    key: "detach",
                    value: function detach(model) {
                        var models = this._models, id = model.id;
                        !models[id] || 0 < --models[id] || this._onDetach && this._onDetach(model);
                    }
                } ]), Customization;
            }()), customizationManager = new (function() {
                function CustomizationManager() {
                    _classCallCheck(this, CustomizationManager), this._customs = {};
                }
                return _createClass(CustomizationManager, [ {
                    key: "register",
                    value: function register(name, info) {
                        this._customs[name] = new Customization(info);
                    }
                }, {
                    key: "attach",
                    value: function attach(name, model) {
                        var cus = this._customs[name];
                        cus ? cus.attach(model) : console.warn("no customization named '".concat(name, "'"));
                    }
                }, {
                    key: "detach",
                    value: function detach(name, model) {
                        var cus = this._customs[name];
                        cus ? cus.detach(model) : console.warn("no customization named '".concat(name, "'"));
                    }
                } ]), CustomizationManager;
            }())();
            cc.customizationManager = customizationManager;
            var SubModel = function() {
                function SubModel() {
                    _classCallCheck(this, SubModel), this._subMeshObject = void 0, this._inputAssembler = void 0, 
                    this._material = void 0, this._cmdBuffers = void 0, this._psos = void 0, this._priority = void 0, 
                    this._subMeshObject = null, this._material = null, this._cmdBuffers = new Array(), 
                    this._psos = null, this._inputAssembler = null, this._priority = RenderPriority.DEFAULT;
                }
                return _createClass(SubModel, [ {
                    key: "initialize",
                    value: function initialize(subMesh, mat, psos) {
                        this._psos = psos, this.subMeshData = subMesh, this.material = mat;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._inputAssembler && this._inputAssembler.destroy();
                        for (var i = 0; i < this.passes.length; i++) this.passes[i].destroyPipelineState(this._psos[i]);
                        var _iterator = this._cmdBuffers, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            _ref.destroy();
                        }
                        this._cmdBuffers.splice(0), this._material = null;
                    }
                }, {
                    key: "updateCommandBuffer",
                    value: function updateCommandBuffer() {
                        if (this._material) {
                            for (var i = 0; i < this._material.passes.length; i++) this._subMeshObject && this._material.passes[i].primitive !== this._subMeshObject.primitiveMode && console.warn("mesh primitive type doesn't match with pass settings"), 
                            this.recordCommandBuffer(i);
                            for (var _i2 = this._cmdBuffers.length - 1; _i2 >= this._material.passes.length; _i2--) {
                                var cmdBuff = this._cmdBuffers.pop();
                                cmdBuff && cmdBuff.destroy();
                            }
                        }
                    }
                }, {
                    key: "recordCommandBuffer",
                    value: function recordCommandBuffer(index) {
                        var device = cc.director.root.device, pso = this._psos[index];
                        if (null == this._cmdBuffers[index]) {
                            var cmdBufferInfo = {
                                allocator: device.commandAllocator,
                                type: GFXCommandBufferType.SECONDARY
                            };
                            this._cmdBuffers[index] = device.createCommandBuffer(cmdBufferInfo);
                        } else this._cmdBuffers[index].status === GFXStatus.UNREADY && this._cmdBuffers[index].initialize({
                            allocator: device.commandAllocator,
                            type: GFXCommandBufferType.SECONDARY
                        });
                        var inputAssembler = this._inputAssembler, cmdBuff = this._cmdBuffers[index];
                        cmdBuff.begin(), cmdBuff.bindPipelineState(pso), cmdBuff.bindBindingLayout(pso.pipelineLayout.layouts[0]), 
                        cmdBuff.bindInputAssembler(inputAssembler), cmdBuff.draw(inputAssembler), cmdBuff.end();
                    }
                }, {
                    key: "priority",
                    set: function set(val) {
                        this._priority = val;
                    },
                    get: function get() {
                        return this._priority;
                    }
                }, {
                    key: "subMeshData",
                    set: function set(sm) {
                        this._inputAssembler && this._inputAssembler.destroy(), this._subMeshObject = sm;
                        var iaInfo = {};
                        iaInfo.attributes = this._subMeshObject.attributes, iaInfo.vertexBuffers = this._subMeshObject.vertexBuffers, 
                        this._subMeshObject.indexBuffer && (iaInfo.indexBuffer = this._subMeshObject.indexBuffer), 
                        this._subMeshObject.indirectBuffer && (iaInfo.indirectBuffer = this._subMeshObject.indirectBuffer), 
                        this._inputAssembler ? this._inputAssembler.initialize(iaInfo) : this._inputAssembler = cc.director.root.device.createInputAssembler(iaInfo);
                    },
                    get: function get() {
                        return this._subMeshObject;
                    }
                }, {
                    key: "psos",
                    get: function get() {
                        return this._psos;
                    },
                    set: function set(val) {
                        this._psos = val;
                    }
                }, {
                    key: "material",
                    set: function set(material) {
                        null != (this._material = material) && this.updateCommandBuffer();
                    },
                    get: function get() {
                        return this._material;
                    }
                }, {
                    key: "inputAssembler",
                    get: function get() {
                        return this._inputAssembler;
                    }
                }, {
                    key: "passes",
                    get: function get() {
                        return this._material.passes;
                    }
                }, {
                    key: "commandBuffers",
                    get: function get() {
                        return this._cmdBuffers;
                    }
                } ]), SubModel;
            }(), m4_1 = new Mat4(), _subMeshPool = new Pool$1(function() {
                return new SubModel();
            }, 32);
            function getUniformBlockSize(block) {
                var size = 0, _iterator = block.members, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var mem = _ref;
                    size += GFXGetTypeSize(mem.type) * mem.count;
                }
                return size;
            }
            var Model = function() {
                function Model(scene, node) {
                    _classCallCheck(this, Model), this._type = "default", this._device = void 0, this._scene = void 0, 
                    this._node = void 0, this._transform = void 0, this._id = void 0, this._enabled = !1, 
                    this._visFlags = Layers.Enum.NONE, this._cameraID = -1, this._userKey = -1, this._worldBounds = null, 
                    this._modelBounds = null, this._subModels = [], this._matPSORecord = void 0, this._matRefCount = void 0, 
                    this._uboLocal = void 0, this._localUBO = null, this._localBindings = new Map(), 
                    this._inited = !1, this._uboUpdated = !1, this._castShadow = !1, this._isDynamicBatching = !1, 
                    this._transformUpdated = !0, this._device = cc.director.root.device, this._scene = scene, 
                    this._id = this._scene.generateModelId(), this._transform = this._node = node, this._matPSORecord = new Map(), 
                    this._matRefCount = new Map(), this._uboLocal = new UBOLocal();
                }
                return _createClass(Model, [ {
                    key: "scene",
                    set: function set(scene) {
                        this._scene = scene, this._id = this._scene.generateModelId();
                    },
                    get: function get() {
                        return this._scene;
                    }
                }, {
                    key: "id",
                    get: function get() {
                        return this._id;
                    }
                }, {
                    key: "subModels",
                    get: function get() {
                        return this._subModels;
                    }
                }, {
                    key: "subModelNum",
                    get: function get() {
                        return this._subModels.length;
                    }
                }, {
                    key: "inited",
                    get: function get() {
                        return this._inited;
                    }
                }, {
                    key: "enabled",
                    set: function set(val) {
                        this._enabled = val;
                    },
                    get: function get() {
                        return this._enabled;
                    }
                }, {
                    key: "node",
                    get: function get() {
                        return this._node;
                    },
                    set: function set(node) {
                        this._node = node;
                    }
                }, {
                    key: "transform",
                    get: function get() {
                        return this._transform;
                    },
                    set: function set(transform) {
                        this._transform = transform;
                    }
                }, {
                    key: "worldBounds",
                    get: function get() {
                        return this._worldBounds;
                    }
                }, {
                    key: "modelBounds",
                    get: function get() {
                        return this._modelBounds;
                    }
                }, {
                    key: "visFlags",
                    get: function get() {
                        return this._visFlags;
                    },
                    set: function set(id) {
                        this._visFlags = id;
                    }
                }, {
                    key: "userKey",
                    set: function set(key) {
                        this._userKey = key;
                    }
                }, {
                    key: "uboLocal",
                    get: function get() {
                        return this._uboLocal;
                    }
                }, {
                    key: "localUBO",
                    get: function get() {
                        return this._localUBO;
                    }
                }, {
                    key: "localBindings",
                    get: function get() {
                        return this._localBindings;
                    }
                }, {
                    key: "castShadow",
                    get: function get() {
                        return this._castShadow;
                    },
                    set: function set(val) {
                        this._castShadow = val;
                    }
                }, {
                    key: "isDynamicBatching",
                    get: function get() {
                        return this._isDynamicBatching;
                    },
                    set: function set(val) {
                        this._isDynamicBatching = val;
                    }
                }, {
                    key: "UBOUpdated",
                    get: function get() {
                        return this._uboUpdated;
                    }
                } ]), _createClass(Model, [ {
                    key: "destroy",
                    value: function destroy() {
                        var _iterator2 = this._subModels, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            var subModel = _ref2;
                            subModel.destroy(), _subMeshPool.free(subModel);
                        }
                        for (var lbIter = this._localBindings.values(), lbResult = lbIter.next(); !lbResult.done; ) {
                            var localBinding = lbResult.value;
                            localBinding.buffer && (localBinding.buffer.destroy(), localBinding.buffer = void 0), 
                            lbResult = lbIter.next();
                        }
                        this._localBindings.has(UBOForwardLight.BLOCK.name) && this._localBindings.delete(UBOForwardLight.BLOCK.name), 
                        this._worldBounds = null, this._modelBounds = null, this._subModels.splice(0), this._matPSORecord.clear(), 
                        this._matRefCount.clear(), this._inited = !1;
                    }
                }, {
                    key: "getSubModel",
                    value: function getSubModel(idx) {
                        return this._subModels[idx];
                    }
                }, {
                    key: "updateTransform",
                    value: function updateTransform() {
                        var node = this._transform;
                        (node.hasChangedFlags || node._dirtyFlags) && (node.updateWorldTransform(), this._transformUpdated = !0, 
                        this._modelBounds && this._worldBounds && this._modelBounds.transform(node._mat, node._pos, node._rot, node._scale, this._worldBounds));
                    }
                }, {
                    key: "_resetUBOUpdateFlag",
                    value: function _resetUBOUpdateFlag() {
                        this._uboUpdated = !1;
                    }
                }, {
                    key: "updateUBOs",
                    value: function updateUBOs() {
                        if (this._uboUpdated) return !1;
                        if (this._uboUpdated = !0, this._transformUpdated && !this._isDynamicBatching) {
                            var worldMatrix = this._transform._mat;
                            Mat4.toArray(this._uboLocal.view, worldMatrix, UBOLocal.MAT_WORLD_OFFSET), Mat4.inverseTranspose(m4_1, worldMatrix), 
                            Mat4.toArray(this._uboLocal.view, m4_1, UBOLocal.MAT_WORLD_IT_OFFSET);
                            var commonLocal = this._localBindings.get(UBOLocal.BLOCK.name);
                            commonLocal && commonLocal.buffer && commonLocal.buffer.update(this._uboLocal.view), 
                            this._transformUpdated = !1;
                        }
                        return this._matPSORecord.forEach(this._updatePass, this), !0;
                    }
                }, {
                    key: "createBoundingShape",
                    value: function createBoundingShape(minPos, maxPos) {
                        minPos && maxPos && (this._modelBounds = aabb.fromPoints(aabb.create(), minPos, maxPos), 
                        this._worldBounds = aabb.clone(this._modelBounds), this._transform.updateWorldTransform(), 
                        this._modelBounds.transform(this._transform._mat, this._transform._pos, this._transform._rot, this._transform._scale, this._worldBounds));
                    }
                }, {
                    key: "initSubModel",
                    value: function initSubModel(idx, subMeshData, mat) {
                        if (this.initLocalBindings(mat), null == this._subModels[idx]) this._subModels[idx] = _subMeshPool.alloc(); else {
                            var oldMat = this._subModels[idx].material;
                            this._subModels[idx].destroy(), this.releasePSO(oldMat);
                        }
                        this.allocatePSO(mat), this._subModels[idx].initialize(subMeshData, mat, this._matPSORecord.get(mat)), 
                        this._inited = !0;
                    }
                }, {
                    key: "setSubModelMesh",
                    value: function setSubModelMesh(idx, subMeshData) {
                        null == this._subModels[idx] && (this._subModels[idx] = _subMeshPool.alloc()), this._subModels[idx].subMeshData = subMeshData;
                    }
                }, {
                    key: "setSubModelMaterial",
                    value: function setSubModelMaterial(idx, mat) {
                        null != this._subModels[idx] && (this.initLocalBindings(mat), this._subModels[idx].material === mat ? mat && (this.destroyPipelineState(mat, this._matPSORecord.get(mat)), 
                        this._matPSORecord.set(mat, this.createPipelineState(mat))) : (this._subModels[idx].material && this.releasePSO(this._subModels[idx].material), 
                        mat && this.allocatePSO(mat)), this._subModels[idx].psos = mat && this._matPSORecord.get(mat) || null, 
                        this._subModels[idx].material = mat);
                    }
                }, {
                    key: "onPipelineChange",
                    value: function onPipelineChange() {
                        var _iterator3 = this._subModels, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i3 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i3++];
                            } else {
                                if ((_i3 = _iterator3.next()).done) break;
                                _ref3 = _i3.value;
                            }
                            for (var m = _ref3, mat = m.material, psos = this._matPSORecord.get(mat), i = 0; i < mat.passes.length; i++) {
                                var pass = mat.passes[i];
                                pass.tryCompile(), pass.destroyPipelineState(psos[i]), psos[i] = this._doCreatePSO(pass), 
                                psos[i].pipelineLayout.layouts[0].update();
                            }
                            m.updateCommandBuffer();
                        }
                    }
                }, {
                    key: "createPipelineState",
                    value: function createPipelineState(mat) {
                        for (var ret = new Array(mat.passes.length), i = 0; i < ret.length; i++) {
                            var pass = mat.passes[i], _iterator4 = pass.customizations, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                            for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                                var _ref4;
                                if (_isArray4) {
                                    if (_i4 >= _iterator4.length) break;
                                    _ref4 = _iterator4[_i4++];
                                } else {
                                    if ((_i4 = _iterator4.next()).done) break;
                                    _ref4 = _i4.value;
                                }
                                var cus = _ref4;
                                customizationManager.attach(cus, this);
                            }
                            ret[i] = this._doCreatePSO(pass);
                        }
                        return ret;
                    }
                }, {
                    key: "destroyPipelineState",
                    value: function destroyPipelineState(mat, pso) {
                        for (var i = 0; i < mat.passes.length; i++) {
                            var pass = mat.passes[i];
                            pass.destroyPipelineState(pso[i]);
                            var _iterator5 = pass.customizations, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                            for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                                var _ref5;
                                if (_isArray5) {
                                    if (_i5 >= _iterator5.length) break;
                                    _ref5 = _iterator5[_i5++];
                                } else {
                                    if ((_i5 = _iterator5.next()).done) break;
                                    _ref5 = _i5.value;
                                }
                                var cus = _ref5;
                                customizationManager.detach(cus, this);
                            }
                        }
                    }
                }, {
                    key: "_doCreatePSO",
                    value: function _doCreatePSO(pass) {
                        var pso = pass.createPipelineState();
                        return pso.pipelineLayout.layouts[0].bindBuffer(UBOLocal.BLOCK.binding, this._localBindings.get(UBOLocal.BLOCK.name).buffer), 
                        this._localBindings.has(UBOForwardLight.BLOCK.name) && pso.pipelineLayout.layouts[0].bindBuffer(UBOForwardLight.BLOCK.binding, this._localBindings.get(UBOForwardLight.BLOCK.name).buffer), 
                        pso;
                    }
                }, {
                    key: "onSetLocalBindings",
                    value: function onSetLocalBindings(mat) {
                        this._localBindings.has(UBOLocal.BLOCK.name) || this._localBindings.set(UBOLocal.BLOCK.name, {
                            type: GFXBindingType.UNIFORM_BUFFER,
                            blockInfo: UBOLocal.BLOCK
                        });
                        var hasForwardLight = !1, _iterator6 = mat.passes, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                        for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                            var _ref6;
                            if (_isArray6) {
                                if (_i6 >= _iterator6.length) break;
                                _ref6 = _iterator6[_i6++];
                            } else {
                                if ((_i6 = _iterator6.next()).done) break;
                                _ref6 = _i6.value;
                            }
                            if (_ref6.bindings.find(function(b) {
                                return b.name === UBOForwardLight.BLOCK.name;
                            })) {
                                hasForwardLight = !0;
                                break;
                            }
                        }
                        hasForwardLight && "ForwardPipeline" === cc.director.root.pipeline.name && (this._localBindings.has(UBOForwardLight.BLOCK.name) || this._localBindings.set(UBOForwardLight.BLOCK.name, {
                            type: GFXBindingType.UNIFORM_BUFFER,
                            blockInfo: UBOForwardLight.BLOCK
                        }));
                    }
                }, {
                    key: "initLocalBindings",
                    value: function initLocalBindings(mat) {
                        if (mat) {
                            this.onSetLocalBindings(mat);
                            for (var lbIter = this._localBindings.values(), lbResult = lbIter.next(); !lbResult.done; ) {
                                var localBinding = lbResult.value;
                                localBinding.buffer || (localBinding.buffer = this._device.createBuffer({
                                    usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                                    size: getUniformBlockSize(localBinding.blockInfo)
                                })), lbResult = lbIter.next();
                            }
                        }
                    }
                }, {
                    key: "_updatePass",
                    value: function _updatePass(psos, mat) {
                        for (var i = 0; i < mat.passes.length; i++) mat.passes[i].update();
                        for (var _i7 = 0; _i7 < psos.length; _i7++) psos[_i7].pipelineLayout.layouts[0].update();
                    }
                }, {
                    key: "allocatePSO",
                    value: function allocatePSO(mat) {
                        null == this._matRefCount.get(mat) ? (this._matRefCount.set(mat, 1), this._matPSORecord.set(mat, this.createPipelineState(mat))) : this._matRefCount.set(mat, this._matRefCount.get(mat) + 1);
                    }
                }, {
                    key: "releasePSO",
                    value: function releasePSO(mat) {
                        this._matRefCount.set(mat, this._matRefCount.get(mat) - 1), 0 === this._matRefCount.get(mat) && (this.destroyPipelineState(mat, this._matPSORecord.get(mat)), 
                        this._matPSORecord.delete(mat), this._matRefCount.delete(mat));
                    }
                } ]), Model;
            }(), JointsAnimationInfo = function() {
                function JointsAnimationInfo() {
                    _classCallCheck(this, JointsAnimationInfo);
                }
                return _createClass(JointsAnimationInfo, null, [ {
                    key: "create",
                    value: function create(nodeID) {
                        var res = JointsAnimationInfo.pool.get(nodeID);
                        if (res) return res;
                        var buffer = cc.director.root.device.createBuffer({
                            usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                            size: UBOSkinningAnimation.SIZE,
                            stride: UBOSkinningAnimation.SIZE
                        }), data = new Float32Array([ 1, 0, 0, 0 ]);
                        buffer.update(data);
                        var info = {
                            buffer: buffer,
                            data: data
                        };
                        return JointsAnimationInfo.pool.set(nodeID, info), info;
                    }
                }, {
                    key: "destroy",
                    value: function destroy(nodeID) {
                        var info = JointsAnimationInfo.pool.get(nodeID);
                        info && (info.buffer.destroy(), JointsAnimationInfo.pool.delete(nodeID));
                    }
                }, {
                    key: "switchClip",
                    value: function switchClip(nodeID, clip) {
                        var info = JointsAnimationInfo.pool.get(nodeID);
                        info && (info.data[0] = clip ? clip.keys[0].length : 1, info.data[1] = 0, info.buffer.update(info.data));
                    }
                }, {
                    key: "get",
                    value: function get(nodeID) {
                        return JointsAnimationInfo.pool.get(nodeID) || JointsAnimationInfo.create(-1);
                    }
                } ]), JointsAnimationInfo;
            }();
            JointsAnimationInfo.pool = new Map();
            var _typeMap2, _keyMap, jointsTextureSamplerHash = genSamplerHash([ GFXFilter.POINT, GFXFilter.POINT, GFXFilter.NONE, GFXAddress.CLAMP, GFXAddress.CLAMP, GFXAddress.CLAMP ]), SkinningModel = function() {
                function SkinningModel(scene, node) {
                    var _this;
                    _classCallCheck(this, SkinningModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SkinningModel).call(this, scene, node))).uploadedAnim = null, 
                    _this._jointsMedium = void 0, _this._skeleton = null, _this._type = "skinning";
                    var jointsTextureInfo = new Float32Array(4), texture = _this._scene.texturePool.getDefaultJointsTexture();
                    return _this._jointsMedium = {
                        buffer: null,
                        jointsTextureInfo: jointsTextureInfo,
                        texture: texture
                    }, _this;
                }
                return _inherits(SkinningModel, Model), _createClass(SkinningModel, [ {
                    key: "worldBounds",
                    get: function get() {
                        return this.uploadedAnim ? null : this._worldBounds;
                    }
                } ]), _createClass(SkinningModel, [ {
                    key: "destroy",
                    value: function destroy() {
                        _get(_getPrototypeOf(SkinningModel.prototype), "destroy", this).call(this), this._jointsMedium.buffer && (this._jointsMedium.buffer.destroy(), 
                        this._jointsMedium.buffer = null);
                    }
                }, {
                    key: "bindSkeleton",
                    value: function bindSkeleton(skeleton, skinningRoot) {
                        (this._skeleton = skeleton) && skinningRoot && (this._transform = skinningRoot, 
                        this._jointsMedium.buffer || (this._jointsMedium.buffer = this._device.createBuffer({
                            usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                            size: UBOSkinningTexture.SIZE,
                            stride: UBOSkinningTexture.SIZE
                        })), this.uploadAnimation(this.uploadedAnim));
                    }
                }, {
                    key: "uploadAnimation",
                    value: function uploadAnimation(anim) {
                        if (this._skeleton) {
                            this.uploadedAnim = anim;
                            var texture = this.uploadedAnim ? this._scene.texturePool.getJointsTextureWithAnimation(this._skeleton, this.uploadedAnim) : this._scene.texturePool.getDefaultJointsTexture(this._skeleton);
                            JointsAnimationInfo.switchClip(this._transform.uuid, anim), this._applyJointsTexture(texture);
                        }
                    }
                }, {
                    key: "_applyJointsTexture",
                    value: function _applyJointsTexture(texture) {
                        if (texture) {
                            this._jointsMedium.texture = texture;
                            var _this$_jointsMedium = this._jointsMedium, buffer = _this$_jointsMedium.buffer, jointsTextureInfo = _this$_jointsMedium.jointsTextureInfo;
                            jointsTextureInfo[0] = texture.handle.texture.width, jointsTextureInfo[1] = 1 / jointsTextureInfo[0], 
                            jointsTextureInfo[2] = texture.pixelOffset + .1, buffer && buffer.update(jointsTextureInfo);
                            var sampler = samplerLib.getSampler(this._device, jointsTextureSamplerHash), _iterator = this._subModels, _isArray = Array.isArray(_iterator), _i = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i >= _iterator.length) break;
                                    _ref = _iterator[_i++];
                                } else {
                                    if ((_i = _iterator.next()).done) break;
                                    _ref = _i.value;
                                }
                                var submodel = _ref;
                                if (submodel.psos) {
                                    var _iterator2 = submodel.psos, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                                        var _ref2;
                                        if (_isArray2) {
                                            if (_i2 >= _iterator2.length) break;
                                            _ref2 = _iterator2[_i2++];
                                        } else {
                                            if ((_i2 = _iterator2.next()).done) break;
                                            _ref2 = _i2.value;
                                        }
                                        var pso = _ref2;
                                        pso.pipelineLayout.layouts[0].bindTextureView(UniformJointsTexture.binding, texture.handle.texView), 
                                        pso.pipelineLayout.layouts[0].bindSampler(UniformJointsTexture.binding, sampler);
                                    }
                                }
                            }
                        }
                    }
                }, {
                    key: "_doCreatePSO",
                    value: function _doCreatePSO(pass) {
                        var pso = _get(_getPrototypeOf(SkinningModel.prototype), "_doCreatePSO", this).call(this, pass), _this$_jointsMedium2 = this._jointsMedium, buffer = _this$_jointsMedium2.buffer, texture = _this$_jointsMedium2.texture, animInfo = JointsAnimationInfo.get(this._transform.uuid);
                        pso.pipelineLayout.layouts[0].bindBuffer(UBOSkinningTexture.BLOCK.binding, buffer), 
                        pso.pipelineLayout.layouts[0].bindBuffer(UBOSkinningAnimation.BLOCK.binding, animInfo.buffer);
                        var sampler = samplerLib.getSampler(this._device, jointsTextureSamplerHash);
                        return texture && (pso.pipelineLayout.layouts[0].bindTextureView(UniformJointsTexture.binding, texture.handle.texView), 
                        pso.pipelineLayout.layouts[0].bindSampler(UniformJointsTexture.binding, sampler)), 
                        pso;
                    }
                } ]), SkinningModel;
            }();
            !function(_keyMap) {
                _keyMap[_keyMap.positions = GFXAttributeName.ATTR_POSITION] = "positions", _keyMap[_keyMap.normals = GFXAttributeName.ATTR_NORMAL] = "normals", 
                _keyMap[_keyMap.uvs = GFXAttributeName.ATTR_TEX_COORD] = "uvs", _keyMap[_keyMap.colors = GFXAttributeName.ATTR_COLOR] = "colors";
            }(_keyMap = _keyMap || {});
            var _defAttrs = [ {
                name: GFXAttributeName.ATTR_POSITION,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_NORMAL,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_TEX_COORD,
                format: GFXFormat.RG32F
            }, {
                name: GFXAttributeName.ATTR_COLOR,
                format: GFXFormat.RGBA32F
            } ], v3_1$4 = new Vec3();
            function createMesh(geometry, out, options) {
                options = options || {};
                var attr, attributes = [], stride = 0, channels = [], vertCount = 0;
                if (0 < geometry.positions.length) {
                    if (attr = null, geometry.attributes) {
                        var _iterator = geometry.attributes, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var att = _ref;
                            if (att.name === GFXAttributeName.ATTR_POSITION) {
                                attr = att;
                                break;
                            }
                        }
                    }
                    attr = attr || _defAttrs[0];
                    var info = GFXFormatInfos[attr.format];
                    attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.positions.length / info.count)), 
                    channels.push({
                        offset: stride,
                        data: geometry.positions,
                        attribute: attr
                    }), stride += info.size;
                }
                if (geometry.normals && 0 < geometry.normals.length) {
                    if (attr = null, geometry.attributes) {
                        var _iterator2 = geometry.attributes, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            var _att = _ref2;
                            if (_att.name === GFXAttributeName.ATTR_NORMAL) {
                                attr = _att;
                                break;
                            }
                        }
                    }
                    attr = attr || _defAttrs[1];
                    var _info = GFXFormatInfos[attr.format];
                    attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.normals.length / _info.count)), 
                    channels.push({
                        offset: stride,
                        data: geometry.normals,
                        attribute: attr
                    }), stride += _info.size;
                }
                if (geometry.uvs && 0 < geometry.uvs.length) {
                    if (attr = null, geometry.attributes) {
                        var _iterator3 = geometry.attributes, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i3 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i3++];
                            } else {
                                if ((_i3 = _iterator3.next()).done) break;
                                _ref3 = _i3.value;
                            }
                            var _att2 = _ref3;
                            if (_att2.name === GFXAttributeName.ATTR_TEX_COORD) {
                                attr = _att2;
                                break;
                            }
                        }
                    }
                    attr = attr || _defAttrs[2];
                    var _info2 = GFXFormatInfos[attr.format];
                    attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.uvs.length / _info2.count)), 
                    channels.push({
                        offset: stride,
                        data: geometry.uvs,
                        attribute: attr
                    }), stride += _info2.size;
                }
                if (geometry.colors && 0 < geometry.colors.length) {
                    if (attr = null, geometry.attributes) {
                        var _iterator4 = geometry.attributes, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                        for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                            var _ref4;
                            if (_isArray4) {
                                if (_i4 >= _iterator4.length) break;
                                _ref4 = _iterator4[_i4++];
                            } else {
                                if ((_i4 = _iterator4.next()).done) break;
                                _ref4 = _i4.value;
                            }
                            var _att3 = _ref4;
                            if (_att3.name === GFXAttributeName.ATTR_COLOR) {
                                attr = _att3;
                                break;
                            }
                        }
                    }
                    attr = attr || _defAttrs[3];
                    var _info3 = GFXFormatInfos[attr.format];
                    attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.colors.length / _info3.count)), 
                    channels.push({
                        offset: stride,
                        data: geometry.colors,
                        attribute: attr
                    }), stride += _info3.size;
                }
                if (geometry.customAttributes) {
                    var _iterator5 = geometry.customAttributes, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                    for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                        var _ref5;
                        if (_isArray5) {
                            if (_i5 >= _iterator5.length) break;
                            _ref5 = _iterator5[_i5++];
                        } else {
                            if ((_i5 = _iterator5.next()).done) break;
                            _ref5 = _i5.value;
                        }
                        var ca = _ref5, _info4 = GFXFormatInfos[ca.attr.format];
                        attributes.push(ca.attr), vertCount = Math.max(vertCount, Math.floor(ca.values.length / _info4.count)), 
                        channels.push({
                            offset: stride,
                            data: ca.values,
                            attribute: ca.attr
                        }), stride += _info4.size;
                    }
                }
                for (var bufferBlob = new BufferBlob(), vertexBuffer = new ArrayBuffer(vertCount * stride), vertexBufferView = new DataView(vertexBuffer), _i6 = 0, _channels = channels; _i6 < _channels.length; _i6++) {
                    var channel = _channels[_i6];
                    writeBuffer(vertexBufferView, channel.data, channel.attribute.format, channel.offset, stride);
                }
                bufferBlob.setNextAlignment(0);
                var vertexBundle = {
                    attributes: attributes,
                    view: {
                        offset: bufferBlob.getLength(),
                        length: vertexBuffer.byteLength,
                        count: vertCount,
                        stride: stride
                    }
                };
                bufferBlob.addBuffer(vertexBuffer);
                var indexBuffer = null, idxCount = 0;
                if (geometry.indices) {
                    var indices = geometry.indices;
                    idxCount = indices.length, indexBuffer = new ArrayBuffer(2 * idxCount), writeBuffer(new DataView(indexBuffer), indices, GFXFormat.R16UI);
                }
                var primitive = {
                    primitiveMode: geometry.primitiveMode || GFXPrimitiveMode.TRIANGLE_LIST,
                    vertexBundelIndices: [ 0 ]
                };
                if (primitive.primitiveMode >= GFXPrimitiveMode.TRIANGLE_LIST) {
                    var geomInfo = Float32Array.from(geometry.positions);
                    bufferBlob.setNextAlignment(4), primitive.geometricInfo = {
                        doubleSided: geometry.doubleSided,
                        view: {
                            offset: bufferBlob.getLength(),
                            length: geomInfo.byteLength,
                            count: geometry.positions.length / 4,
                            stride: 4
                        }
                    }, bufferBlob.addBuffer(geomInfo.buffer);
                }
                indexBuffer && (bufferBlob.setNextAlignment(2), primitive.indexView = {
                    offset: bufferBlob.getLength(),
                    length: indexBuffer.byteLength,
                    count: idxCount,
                    stride: 2
                }, bufferBlob.addBuffer(indexBuffer));
                var minPosition = geometry.minPos;
                if (!minPosition && options.calculateBounds) {
                    minPosition = Vec3.set(new Vec3(), 1 / 0, 1 / 0, 1 / 0);
                    for (var iVertex = 0; iVertex < vertCount; ++iVertex) Vec3.set(v3_1$4, geometry.positions[3 * iVertex + 0], geometry.positions[3 * iVertex + 1], geometry.positions[3 * iVertex + 2]), 
                    Vec3.min(minPosition, minPosition, v3_1$4);
                }
                var maxPosition = geometry.maxPos;
                if (!maxPosition && options.calculateBounds) {
                    maxPosition = Vec3.set(new Vec3(), -1 / 0, -1 / 0, -1 / 0);
                    for (var _iVertex = 0; _iVertex < vertCount; ++_iVertex) Vec3.set(v3_1$4, geometry.positions[3 * _iVertex + 0], geometry.positions[3 * _iVertex + 1], geometry.positions[3 * _iVertex + 2]), 
                    Vec3.max(maxPosition, maxPosition, v3_1$4);
                }
                var meshStruct = {
                    vertexBundles: [ vertexBundle ],
                    primitives: [ primitive ]
                };
                return minPosition && (meshStruct.minPosition = new Vec3(minPosition.x, minPosition.y, minPosition.z)), 
                maxPosition && (meshStruct.maxPosition = new Vec3(maxPosition.x, maxPosition.y, maxPosition.z)), 
                (out = out || new Mesh()).reset({
                    struct: meshStruct,
                    data: new Uint8Array(bufferBlob.getCombined())
                }), out;
            }
            var isLittleEndian$1 = cc.sys.isLittleEndian, _typeMap = (_defineProperty(_typeMap2 = {}, GFXFormatType.UNORM, "Uint"), 
            _defineProperty(_typeMap2, GFXFormatType.SNORM, "Int"), _defineProperty(_typeMap2, GFXFormatType.UINT, "Uint"), 
            _defineProperty(_typeMap2, GFXFormatType.INT, "Int"), _defineProperty(_typeMap2, GFXFormatType.UFLOAT, "Float"), 
            _defineProperty(_typeMap2, GFXFormatType.FLOAT, "Float"), _defineProperty(_typeMap2, "default", "Uint"), 
            _typeMap2);
            function _getDataViewType(info) {
                return (_typeMap[info.type] || _typeMap.default) + info.size / info.count * 8;
            }
            function writeBuffer(target, data) {
                var format = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : GFXFormat.R32F, offset = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, stride = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, info = GFXFormatInfos[format];
                stride = stride || info.size;
                for (var writer = "set" + _getDataViewType(info), componentBytesLength = info.size / info.count, nSeg = Math.floor(data.length / info.count), iSeg = 0; iSeg < nSeg; ++iSeg) for (var x = offset + stride * iSeg, iComponent = 0; iComponent < info.count; ++iComponent) {
                    var y = x + componentBytesLength * iComponent;
                    target[writer](y, data[info.count * iSeg + iComponent], isLittleEndian$1);
                }
            }
            function readBuffer(target) {
                var format = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : GFXFormat.R32F, offset = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, length = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : target.byteLength - offset, stride = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, out = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : [], info = GFXFormatInfos[format];
                stride = stride || info.size;
                for (var reader = "get" + _getDataViewType(info), componentBytesLength = info.size / info.count, nSeg = Math.floor(length / stride), iSeg = 0; iSeg < nSeg; ++iSeg) for (var x = offset + stride * iSeg, iComponent = 0; iComponent < info.count; ++iComponent) {
                    var y = x + componentBytesLength * iComponent;
                    out[info.count * iSeg + iComponent] = target[reader](y, isLittleEndian$1);
                }
                return out;
            }
            function mapBuffer(target, callback) {
                var format = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : GFXFormat.R32F, offset = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, length = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : target.byteLength - offset, stride = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0, out = 6 < arguments.length ? arguments[6] : void 0;
                out = out || new DataView(new ArrayBuffer(target.byteLength));
                var info = GFXFormatInfos[format];
                stride = stride || info.size;
                for (var writer = "set" + _getDataViewType(info), reader = "get" + _getDataViewType(info), componentBytesLength = info.size / info.count, nSeg = Math.floor(length / stride), iSeg = 0; iSeg < nSeg; ++iSeg) for (var x = offset + stride * iSeg, iComponent = 0; iComponent < info.count; ++iComponent) {
                    var y = x + componentBytesLength * iComponent, _cur = target[reader](y, isLittleEndian$1);
                    out[writer](y, callback(_cur, iComponent, target), isLittleEndian$1);
                }
                return out;
            }
            var _path = [], v3_2$2 = new Vec3();
            var boneSpaceBoundsManager = new (function() {
                function BoneSpaceBoundsManager() {
                    _classCallCheck(this, BoneSpaceBoundsManager), this._cached = new Map();
                }
                return _createClass(BoneSpaceBoundsManager, [ {
                    key: "use",
                    value: function use(mesh, skeleton) {
                        var bucket = this._cached.get(mesh);
                        bucket || (bucket = new Map(), this._cached.set(mesh, bucket));
                        var cached = bucket.get(skeleton);
                        return cached || (cached = {
                            bounds: function calculateBoneSpaceBounds(mesh, skeleton) {
                                for (var result = new Array(skeleton.joints.length), i = 0; i < result.length; ++i) result[i] = {
                                    hasValue: !1,
                                    min: new Vec3(1 / 0, 1 / 0, 1 / 0),
                                    max: new Vec3(-1 / 0, -1 / 0, -1 / 0)
                                };
                                for (var iPrimitive = 0; iPrimitive < mesh.struct.primitives.length; ++iPrimitive) {
                                    var joints = mesh.readAttribute(iPrimitive, GFXAttributeName.ATTR_JOINTS);
                                    if (joints) {
                                        var weights = mesh.readAttribute(iPrimitive, GFXAttributeName.ATTR_WEIGHTS);
                                        if (weights) {
                                            var positions = mesh.readAttribute(iPrimitive, GFXAttributeName.ATTR_POSITION);
                                            if (positions) for (var vertexCount = Math.min(joints.length / 4, weights.length / 4, positions.length / 3), iVertex = 0; iVertex < vertexCount; ++iVertex) {
                                                Vec3.set(v3_1$4, positions[3 * iVertex + 0], positions[3 * iVertex + 1], positions[3 * iVertex + 2]);
                                                for (var _i9 = 0; _i9 < 4; ++_i9) {
                                                    if (0 !== weights[4 * iVertex + _i9]) {
                                                        var refJointIndex = joints[4 * iVertex + _i9];
                                                        if (!(refJointIndex >= skeleton.joints.length)) {
                                                            skeleton.bindposes ? Vec3.transformMat4(v3_2$2, v3_1$4, skeleton.bindposes[refJointIndex]) : Vec3.copy(v3_2$2, v3_1$4);
                                                            var jointBounds = result[refJointIndex];
                                                            jointBounds.hasValue = !0, Vec3.min(jointBounds.min, jointBounds.min, v3_2$2), Vec3.max(jointBounds.max, jointBounds.max, v3_2$2);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                return result.map(function(bounds) {
                                    return bounds.hasValue ? aabb.fromPoints(new aabb(), bounds.min, bounds.max) : null;
                                });
                            }(mesh, skeleton),
                            referenceCount: 0
                        }, bucket.set(skeleton, cached)), ++cached.referenceCount, cached.bounds;
                    }
                }, {
                    key: "unuse",
                    value: function unuse(mesh, skeleton) {
                        var bucket = this._cached.get(mesh);
                        if (bucket) {
                            var cached = bucket.get(skeleton);
                            cached && (--cached.referenceCount, 0 === cached.referenceCount && bucket.delete(skeleton)), 
                            0 === bucket.size && this._cached.delete(mesh);
                        }
                    }
                } ]), BoneSpaceBoundsManager;
            }())(), m4_1$1 = new Mat4(), m4_2 = new Mat4(), ab_1 = new aabb(), v3_3 = new Vec3(), v3_4 = new Vec3();
            var utils = Object.freeze({
                toPPM: function toPPM(buffer, w, h) {
                    return "P3 ".concat(w, " ").concat(h, " 255\n").concat(buffer.filter(function(e, i) {
                        return i % 4 < 3;
                    }).toString(), "\n");
                },
                createMesh: createMesh,
                readMesh: function readMesh(mesh) {
                    var iPrimitive = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, out = {
                        positions: []
                    }, dataView = new DataView(mesh._nativeAsset), struct = mesh.struct, primitive = struct.primitives[iPrimitive], _iterator6 = primitive.vertexBundelIndices, _isArray6 = Array.isArray(_iterator6), _i7 = 0;
                    for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                        var _ref6;
                        if (_isArray6) {
                            if (_i7 >= _iterator6.length) break;
                            _ref6 = _iterator6[_i7++];
                        } else {
                            if ((_i7 = _iterator6.next()).done) break;
                            _ref6 = _i7.value;
                        }
                        var _idx = _ref6, bundle = struct.vertexBundles[_idx], offset = bundle.view.offset, _bundle$view = bundle.view, length = _bundle$view.length, stride = _bundle$view.stride, _iterator7 = bundle.attributes, _isArray7 = Array.isArray(_iterator7), _i8 = 0;
                        for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                            var _ref7;
                            if (_isArray7) {
                                if (_i8 >= _iterator7.length) break;
                                _ref7 = _iterator7[_i8++];
                            } else {
                                if ((_i8 = _iterator7.next()).done) break;
                                _ref7 = _i8.value;
                            }
                            var attr = _ref7, name = _keyMap[attr.name];
                            name && (out[name] = (out[name] || []).concat(readBuffer(dataView, attr.format, offset, length, stride))), 
                            offset += GFXFormatInfos[attr.format].size;
                        }
                    }
                    var view = primitive.indexView;
                    return out.indices = readBuffer(dataView, GFXFormat["R".concat(8 * view.stride, "UI")], view.offset, view.length), 
                    out;
                },
                writeBuffer: writeBuffer,
                readBuffer: readBuffer,
                mapBuffer: mapBuffer,
                LCA: function LCA(a, b) {
                    if (a === b) return a;
                    var cur = b;
                    for (_path.length = 0; cur; ) _path.push(cur), cur = cur.parent;
                    for (cur = a; cur; ) {
                        if (_path.find(function(n) {
                            return n === cur;
                        })) return cur;
                        cur = cur.parent;
                    }
                    return null;
                },
                calculateSkinnedBounds: function calculateSkinnedBounds(out, comp) {
                    if (comp.model && comp.mesh) {
                        var skeleton = comp.skeleton, root = comp.skinningRoot, clip = comp.model.uploadedAnim, animInfo = root && JointsAnimationInfo.get(root.uuid);
                        if (!(skeleton && root && clip && animInfo)) {
                            if (!comp.model.worldBounds) return;
                            return aabb.copy(out, comp.model.worldBounds), !0;
                        }
                        Vec3.set(v3_3, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), 
                        Vec3.set(v3_4, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY), 
                        root.getWorldMatrix(m4_1$1);
                        for (var boundList = boneSpaceBoundsManager.use(comp.mesh, skeleton), len = skeleton.joints.length, data = clip.convertedData, fid = animInfo.data[1], i = 0; i < len; ++i) {
                            var bounds = boundList[i], nodeData = data[skeleton.joints[i]];
                            if (bounds && nodeData && nodeData.props) {
                                var matrix = nodeData.props.worldMatrix.values[fid];
                                Mat4.multiply(m4_2, m4_1$1, matrix), aabb.transform(ab_1, bounds, m4_2), ab_1.getBoundary(v3_1$4, v3_2$2), 
                                Vec3.min(v3_3, v3_3, v3_1$4), Vec3.max(v3_4, v3_4, v3_2$2);
                            }
                        }
                        return aabb.fromPoints(out, v3_3, v3_4), !0;
                    }
                },
                find: find
            });
            exports("utils", utils);
            function GFXBlendState() {
                _classCallCheck(this, GFXBlendState), this.isA2C = !1, this.isIndepend = !1, this.blendColor = [ 0, 0, 0, 0 ], 
                this.targets = [ new GFXBlendTarget() ];
            }
            function GFXInputState() {
                _classCallCheck(this, GFXInputState), this.attributes = [];
            }
            var GFXInputAssembler = exports("GFXInputAssembler", function() {
                function GFXInputAssembler(device) {
                    var _this;
                    return _classCallCheck(this, GFXInputAssembler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXInputAssembler).call(this, GFXObjectType.INPUT_ASSEMBLER)))._device = void 0, 
                    _this._attributes = [], _this._vertexBuffers = [], _this._indexBuffer = null, _this._vertexCount = 0, 
                    _this._firstVertex = 0, _this._indexCount = 0, _this._firstIndex = 0, _this._vertexOffset = 0, 
                    _this._instanceCount = 0, _this._firstInstance = 0, _this._isIndirect = !1, _this._indirectBuffer = null, 
                    _this._device = device, _this;
                }
                return _inherits(GFXInputAssembler, GFXObject), _createClass(GFXInputAssembler, [ {
                    key: "vertexBuffers",
                    get: function get() {
                        return this._vertexBuffers;
                    }
                }, {
                    key: "indexBuffer",
                    get: function get() {
                        return this._indexBuffer;
                    }
                }, {
                    key: "attributes",
                    get: function get() {
                        return this._attributes;
                    }
                }, {
                    key: "vertexCount",
                    get: function get() {
                        return this._vertexCount;
                    },
                    set: function set(count) {
                        this._vertexCount = count;
                    }
                }, {
                    key: "firstVertex",
                    get: function get() {
                        return this._firstVertex;
                    },
                    set: function set(first) {
                        this._firstVertex = first;
                    }
                }, {
                    key: "indexCount",
                    get: function get() {
                        return this._indexCount;
                    },
                    set: function set(count) {
                        this._indexCount = count;
                    }
                }, {
                    key: "firstIndex",
                    get: function get() {
                        return this._firstIndex;
                    },
                    set: function set(first) {
                        this._firstIndex = first;
                    }
                }, {
                    key: "vertexOffset",
                    get: function get() {
                        return this._vertexOffset;
                    },
                    set: function set(offset) {
                        this._vertexOffset = offset;
                    }
                }, {
                    key: "instanceCount",
                    get: function get() {
                        return this._instanceCount;
                    },
                    set: function set(count) {
                        this._instanceCount = count;
                    }
                }, {
                    key: "firstInstance",
                    get: function get() {
                        return this._firstInstance;
                    },
                    set: function set(first) {
                        this._firstInstance = first;
                    }
                }, {
                    key: "isIndirect",
                    get: function get() {
                        return this._isIndirect;
                    }
                }, {
                    key: "indirectBuffer",
                    get: function get() {
                        return this._indirectBuffer;
                    }
                } ]), _createClass(GFXInputAssembler, [ {
                    key: "getVertexBuffer",
                    value: function getVertexBuffer(argument_0) {
                        var stream = 0 < arguments.length && void 0 !== argument_0 ? argument_0 : 0;
                        return stream < this._vertexBuffers.length ? this._vertexBuffers[stream] : null;
                    }
                }, {
                    key: "extractDrawInfo",
                    value: function extractDrawInfo(drawInfo) {
                        drawInfo.vertexCount = this._vertexCount, drawInfo.firstVertex = this._firstVertex, 
                        drawInfo.indexCount = this._indexCount, drawInfo.firstIndex = this._firstIndex, 
                        drawInfo.vertexOffset = this._vertexOffset, drawInfo.instanceCount = this._instanceCount, 
                        drawInfo.firstInstance = this._firstInstance;
                    }
                }, {
                    key: "updateVertexAttr",
                    value: function updateVertexAttr(vbuffer, attr, data, argument_3, argument_4) {
                        var index = 3 < arguments.length && void 0 !== argument_3 ? argument_3 : 0, _final = !(4 < arguments.length && void 0 !== argument_4) || argument_4, offset = 0, format = GFXFormat.UNKNOWN, _iterator = this._attributes, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var a = _ref;
                            if (a.name === attr) {
                                format = a.format;
                                break;
                            }
                            offset += GFXFormatInfos[a.format].size;
                        }
                        var vb = this._vertexBuffers[index];
                        format && vb && (writeBuffer(new DataView(vbuffer), data, format, offset, vb.stride), 
                        _final && vb.update(vbuffer, 0, vb.stride * vb.count));
                    }
                }, {
                    key: "updateIndexBuffer",
                    value: function updateIndexBuffer(ibuffer, data) {
                        var count = this._indexCount, ib = this._indexBuffer;
                        count && ib && (writeBuffer(new DataView(ibuffer), data, GFXFormat["R".concat(8 * ib.stride, "UI")]), 
                        ib.update(ibuffer, 0, ib.stride * ib.count), this._indexCount = data.length);
                    }
                } ]), GFXInputAssembler;
            }()), GFXPipelineLayout = exports("GFXPipelineLayout", function() {
                function GFXPipelineLayout(device) {
                    var _this;
                    return _classCallCheck(this, GFXPipelineLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXPipelineLayout).call(this, GFXObjectType.PIPELINE_LAYOUT)))._device = void 0, 
                    _this._pushConstantsRanges = [], _this._layouts = [], _this._device = device, _this;
                }
                return _inherits(GFXPipelineLayout, GFXObject), _createClass(GFXPipelineLayout, [ {
                    key: "layouts",
                    get: function get() {
                        return this._layouts;
                    }
                } ]), GFXPipelineLayout;
            }()), GFXRasterizerState = function() {
                function GFXRasterizerState() {
                    _classCallCheck(this, GFXRasterizerState), this.isDiscard = !1, this.polygonMode = GFXPolygonMode.FILL, 
                    this.shadeModel = GFXShadeModel.GOURAND, this.cullMode = GFXCullMode.BACK, this.isFrontFaceCCW = !0, 
                    this.depthBias = 0, this.depthBiasClamp = 0, this.depthBiasSlop = 0, this.isDepthClip = !0, 
                    this.isMultisample = !1, this.lineWidth = 1;
                }
                return _createClass(GFXRasterizerState, [ {
                    key: "compare",
                    value: function compare(state) {
                        return this.isDiscard === state.isDiscard && this.polygonMode === state.polygonMode && this.shadeModel === state.shadeModel && this.cullMode === state.cullMode && this.isFrontFaceCCW === state.isFrontFaceCCW && this.depthBias === state.depthBias && this.depthBiasClamp === state.depthBiasClamp && this.depthBiasSlop === state.depthBiasSlop && this.isDepthClip === state.isDepthClip && this.lineWidth === state.lineWidth && this.isMultisample === state.isMultisample;
                    }
                } ]), GFXRasterizerState;
            }(), GFXDepthStencilState = function() {
                function GFXDepthStencilState() {
                    _classCallCheck(this, GFXDepthStencilState), this.depthTest = !0, this.depthWrite = !0, 
                    this.depthFunc = GFXComparisonFunc.LESS, this.stencilTestFront = !1, this.stencilFuncFront = GFXComparisonFunc.ALWAYS, 
                    this.stencilReadMaskFront = 4294967295, this.stencilWriteMaskFront = 4294967295, 
                    this.stencilFailOpFront = GFXStencilOp.KEEP, this.stencilZFailOpFront = GFXStencilOp.KEEP, 
                    this.stencilPassOpFront = GFXStencilOp.KEEP, this.stencilRefFront = 1, this.stencilTestBack = !1, 
                    this.stencilFuncBack = GFXComparisonFunc.ALWAYS, this.stencilReadMaskBack = 4294967295, 
                    this.stencilWriteMaskBack = 4294967295, this.stencilFailOpBack = GFXStencilOp.KEEP, 
                    this.stencilZFailOpBack = GFXStencilOp.KEEP, this.stencilPassOpBack = GFXStencilOp.KEEP, 
                    this.stencilRefBack = 1;
                }
                return _createClass(GFXDepthStencilState, [ {
                    key: "compare",
                    value: function compare(state) {
                        return this.depthTest === state.depthTest && this.depthWrite === state.depthWrite && this.depthFunc === state.depthFunc && this.stencilTestFront === state.stencilTestFront && this.stencilFuncFront === state.stencilFuncFront && this.stencilReadMaskFront === state.stencilReadMaskFront && this.stencilWriteMaskFront === state.stencilWriteMaskFront && this.stencilFailOpFront === state.stencilFailOpFront && this.stencilZFailOpFront === state.stencilZFailOpFront && this.stencilPassOpFront === state.stencilPassOpFront && this.stencilRefFront === state.stencilRefFront && this.stencilTestBack === state.stencilTestBack && this.stencilFuncBack === state.stencilFuncBack && this.stencilReadMaskBack === state.stencilReadMaskBack && this.stencilWriteMaskBack === state.stencilWriteMaskBack && this.stencilFailOpBack === state.stencilFailOpBack && this.stencilZFailOpBack === state.stencilZFailOpBack && this.stencilPassOpBack === state.stencilPassOpBack && this.stencilRefBack === state.stencilRefBack;
                    }
                } ]), GFXDepthStencilState;
            }(), GFXBlendTarget = function() {
                function GFXBlendTarget() {
                    _classCallCheck(this, GFXBlendTarget), this.blend = !1, this.blendSrc = GFXBlendFactor.ONE, 
                    this.blendDst = GFXBlendFactor.ZERO, this.blendEq = GFXBlendOp.ADD, this.blendSrcAlpha = GFXBlendFactor.ONE, 
                    this.blendDstAlpha = GFXBlendFactor.ZERO, this.blendAlphaEq = GFXBlendOp.ADD, this.blendColorMask = GFXColorMask.ALL;
                }
                return _createClass(GFXBlendTarget, [ {
                    key: "compare",
                    value: function compare(target) {
                        return this.blend === target.blend && this.blendSrc === target.blendSrc && this.blendDst === target.blendDst && this.blendEq === target.blendEq && this.blendSrcAlpha === target.blendSrcAlpha && this.blendDstAlpha === target.blendDstAlpha && this.blendAlphaEq === target.blendAlphaEq && this.blendColorMask === target.blendColorMask;
                    }
                } ]), GFXBlendTarget;
            }(), GFXPipelineState = exports("GFXPipelineState", function() {
                function GFXPipelineState(device) {
                    var _this;
                    return _classCallCheck(this, GFXPipelineState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXPipelineState).call(this, GFXObjectType.PIPELINE_STATE)))._device = void 0, 
                    _this._shader = null, _this._primitive = GFXPrimitiveMode.TRIANGLE_LIST, _this._is = null, 
                    _this._rs = null, _this._dss = null, _this._bs = null, _this._dynamicStates = [], 
                    _this._layout = null, _this._renderPass = null, _this._device = device, _this;
                }
                return _inherits(GFXPipelineState, GFXObject), _createClass(GFXPipelineState, [ {
                    key: "shader",
                    get: function get() {
                        return this._shader;
                    }
                }, {
                    key: "primitive",
                    get: function get() {
                        return this._primitive;
                    }
                }, {
                    key: "rasterizerState",
                    get: function get() {
                        return this._rs;
                    }
                }, {
                    key: "depthStencilState",
                    get: function get() {
                        return this._dss;
                    }
                }, {
                    key: "blendState",
                    get: function get() {
                        return this._bs;
                    }
                }, {
                    key: "dynamicStates",
                    get: function get() {
                        return this._dynamicStates;
                    }
                }, {
                    key: "pipelineLayout",
                    get: function get() {
                        return this._layout;
                    }
                }, {
                    key: "renderPass",
                    get: function get() {
                        return this._renderPass;
                    }
                } ]), GFXPipelineState;
            }()), GFXQueue = exports("GFXQueue", function() {
                function GFXQueue(device) {
                    var _this;
                    return _classCallCheck(this, GFXQueue), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXQueue).call(this, GFXObjectType.QUEUE)))._device = void 0, 
                    _this._type = GFXQueueType.GRAPHICS, _this._device = device, _this;
                }
                return _inherits(GFXQueue, GFXObject), _createClass(GFXQueue, [ {
                    key: "type",
                    get: function get() {
                        return this._type;
                    }
                } ]), GFXQueue;
            }()), GFXRenderPass = exports("GFXRenderPass", function() {
                function GFXRenderPass(device) {
                    var _this;
                    return _classCallCheck(this, GFXRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXRenderPass).call(this, GFXObjectType.RENDER_PASS)))._device = void 0, 
                    _this._colorInfos = [], _this._depthStencilInfo = null, _this._device = device, 
                    _this;
                }
                return _inherits(GFXRenderPass, GFXObject), GFXRenderPass;
            }()), GFXSamplerState = function() {
                function GFXSamplerState() {
                    _classCallCheck(this, GFXSamplerState), this.name = "", this.minFilter = GFXFilter.LINEAR, 
                    this.magFilter = GFXFilter.LINEAR, this.mipFilter = GFXFilter.NONE, this.addressU = GFXAddress.WRAP, 
                    this.addressV = GFXAddress.WRAP, this.addressW = GFXAddress.WRAP, this.maxAnisotropy = 16, 
                    this.cmpFunc = GFXComparisonFunc.NEVER, this.borderColor = {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0
                    }, this.minLOD = 0, this.maxLOD = 0, this.mipLODBias = 0;
                }
                return _createClass(GFXSamplerState, [ {
                    key: "compare",
                    value: function compare(state) {
                        return this.minFilter === state.minFilter && this.magFilter === state.magFilter && this.mipFilter === state.mipFilter && this.addressU === state.addressU && this.addressV === state.addressV && this.addressW === state.addressW && this.maxAnisotropy === state.maxAnisotropy && this.cmpFunc === state.cmpFunc && this.borderColor.r === state.borderColor.r && this.borderColor.g === state.borderColor.g && this.borderColor.b === state.borderColor.b && this.borderColor.a === state.borderColor.a && this.minLOD === state.minLOD && this.maxLOD === state.maxLOD && this.mipLODBias === state.mipLODBias;
                    }
                } ]), GFXSamplerState;
            }(), GFXSampler = exports("GFXSampler", function() {
                function GFXSampler(device) {
                    var _this;
                    return _classCallCheck(this, GFXSampler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXSampler).call(this, GFXObjectType.SAMPLER)))._device = void 0, 
                    _this._state = new GFXSamplerState(), _this._device = device, _this;
                }
                return _inherits(GFXSampler, GFXObject), _createClass(GFXSampler, [ {
                    key: "state",
                    get: function get() {
                        return this._state;
                    }
                } ]), GFXSampler;
            }()), GFXShader = exports("GFXShader", function() {
                function GFXShader(device) {
                    var _this;
                    return _classCallCheck(this, GFXShader), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXShader).call(this, GFXObjectType.SHADER)))._device = void 0, 
                    _this._id = void 0, _this._name = "", _this._stages = [], _this._blocks = [], _this._samplers = [], 
                    _this._device = device, _this._id = device.genShaderId(), _this;
                }
                return _inherits(GFXShader, GFXObject), _createClass(GFXShader, [ {
                    key: "id",
                    get: function get() {
                        return this._id;
                    }
                }, {
                    key: "name",
                    get: function get() {
                        return this._name;
                    }
                } ]), GFXShader;
            }()), GFXTexture = exports("GFXTexture", function() {
                function GFXTexture(device) {
                    var _this;
                    return _classCallCheck(this, GFXTexture), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXTexture).call(this, GFXObjectType.TEXTURE)))._device = void 0, 
                    _this._type = GFXTextureType.TEX2D, _this._usage = GFXTextureUsageBit.NONE, _this._format = GFXFormat.UNKNOWN, 
                    _this._width = 0, _this._height = 0, _this._depth = 1, _this._arrayLayer = 1, _this._mipLevel = 1, 
                    _this._samples = GFXSampleCount.X1, _this._flags = GFXTextureFlagBit.NONE, _this._isPowerOf2 = !1, 
                    _this._size = 0, _this._buffer = null, _this._device = device, _this;
                }
                return _inherits(GFXTexture, GFXObject), _createClass(GFXTexture, [ {
                    key: "type",
                    get: function get() {
                        return this._type;
                    }
                }, {
                    key: "usage",
                    get: function get() {
                        return this._usage;
                    }
                }, {
                    key: "format",
                    get: function get() {
                        return this._format;
                    }
                }, {
                    key: "width",
                    get: function get() {
                        return this._width;
                    }
                }, {
                    key: "height",
                    get: function get() {
                        return this._height;
                    }
                }, {
                    key: "depth",
                    get: function get() {
                        return this._depth;
                    }
                }, {
                    key: "arrayLayer",
                    get: function get() {
                        return this._arrayLayer;
                    }
                }, {
                    key: "mipLevel",
                    get: function get() {
                        return this._mipLevel;
                    }
                }, {
                    key: "samples",
                    get: function get() {
                        return this._samples;
                    }
                }, {
                    key: "flags",
                    get: function get() {
                        return this._flags;
                    }
                }, {
                    key: "size",
                    get: function get() {
                        return this._size;
                    }
                }, {
                    key: "buffer",
                    get: function get() {
                        return this._buffer;
                    }
                } ]), GFXTexture;
            }()), GFXTextureView = exports("GFXTextureView", function() {
                function GFXTextureView(device) {
                    var _this;
                    return _classCallCheck(this, GFXTextureView), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXTextureView).call(this, GFXObjectType.TEXTURE_VIEW)))._device = void 0, 
                    _this._texture = null, _this._type = GFXTextureViewType.TV2D, _this._format = GFXFormat.UNKNOWN, 
                    _this._baseLevel = 0, _this._levelCount = 1, _this._baseLayer = 0, _this._layerCount = 1, 
                    _this._device = device, _this;
                }
                return _inherits(GFXTextureView, GFXObject), _createClass(GFXTextureView, [ {
                    key: "texture",
                    get: function get() {
                        return this._texture;
                    }
                }, {
                    key: "type",
                    get: function get() {
                        return this._type;
                    }
                }, {
                    key: "format",
                    get: function get() {
                        return this._format;
                    }
                }, {
                    key: "baseLevel",
                    get: function get() {
                        return this._baseLevel;
                    }
                }, {
                    key: "levelCount",
                    get: function get() {
                        return this._levelCount;
                    }
                }, {
                    key: "baseLayer",
                    get: function get() {
                        return this._baseLayer;
                    }
                }, {
                    key: "layerCount",
                    get: function get() {
                        return this._layerCount;
                    }
                } ]), GFXTextureView;
            }());
            cc.GFXDevice = GFXDevice, cc.GFXBuffer = GFXBuffer, cc.GFXTexture = GFXTexture, 
            cc.GFXTextureView = GFXTextureView, cc.GFXSampler = GFXSampler, cc.GFXShader = GFXShader, 
            cc.GFXInputAssembler = GFXInputAssembler, cc.GFXRenderPass = GFXRenderPass, cc.GFXFramebuffer = GFXFramebuffer, 
            cc.GFXPipelineLayout = GFXPipelineLayout, cc.GFXPipelineState = GFXPipelineState, 
            cc.GFXCommandBuffer = GFXCommandBuffer, cc.GFXQueue = GFXQueue, Object.assign(cc, GFXDefines);
            var _jointsFormat2, JointsMediumType, TextureBufferPool = function() {
                function TextureBufferPool(device) {
                    _classCallCheck(this, TextureBufferPool), this._device = void 0, this._format = GFXFormat.UNKNOWN, 
                    this._formatSize = 0, this._chunks = [], this._chunkCount = 0, this._handles = [], 
                    this._region0 = new GFXBufferTextureCopy(), this._region1 = new GFXBufferTextureCopy(), 
                    this._region2 = new GFXBufferTextureCopy(), this._roundUpFn = null, this._inOrderFree = !1, 
                    this._device = device;
                }
                return _createClass(TextureBufferPool, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return this._format = info.format, this._formatSize = GFXFormatInfos[this._format].size, 
                        this._chunks = new Array(info.maxChunks), this._roundUpFn = info.roundUpFn || null, 
                        this._inOrderFree = info.inOrderFree || !1, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        for (var i = 0; i < this._chunkCount; ++i) {
                            var chunk = this._chunks[i];
                            chunk.texView.destroy(), chunk.texture.destroy();
                        }
                        this._chunks.splice(0), this._handles.splice(0);
                    }
                }, {
                    key: "alloc",
                    value: function alloc(size) {
                        var _this = this;
                        if (0 === size) return null;
                        for (var _loop = function _loop(i) {
                            var chunk = _this._chunks[i], isFound = !1, start = chunk.start;
                            if (start + size <= chunk.end) isFound = !0; else if (_this._inOrderFree) start > chunk.end ? start + size <= chunk.size ? isFound = !0 : size <= chunk.end && (chunk.start = start = 0, 
                            isFound = !0) : start === chunk.end && (chunk.start = start = 0, chunk.end = chunk.size, 
                            size <= chunk.end && (isFound = !0)); else {
                                start = 0;
                                for (var handles = _this._handles.filter(function(h) {
                                    return h.chunkIdx === i;
                                }).sort(function(a, b) {
                                    return a.start - b.start;
                                }), j = 0; j < handles.length; j++) {
                                    var handle = handles[j];
                                    if (start + size <= handle.start) {
                                        isFound = !0;
                                        break;
                                    }
                                    start = handle.end;
                                }
                                !isFound && start + size <= chunk.size && (isFound = !0);
                            }
                            if (isFound) {
                                chunk.start += size;
                                var _handle = {
                                    chunkIdx: i,
                                    start: start,
                                    end: start + size,
                                    texture: chunk.texture,
                                    texView: chunk.texView
                                };
                                return _this._handles.push(_handle), {
                                    v: _handle
                                };
                            }
                        }, i = 0; i < this._chunkCount; ++i) {
                            var _ret = _loop(i);
                            if ("object" === _typeof(_ret)) return _ret.v;
                        }
                        if (this._chunkCount >= this._chunks.length) return console.error("TextureBufferPool: Reach max chunk count."), 
                        null;
                        var targetSize = Math.sqrt(size / this._formatSize), texWidth = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, function nearestPO2(num) {
                            return --num, num |= num >> 16, num |= num >> 8, num |= num >> 4, num |= num >> 2, 
                            num |= num >> 1, ++num;
                        }(targetSize)), texSize = texWidth * texWidth * this._formatSize;
                        console.info("TextureBufferPool: Allocate chunk " + this._chunkCount + ", size: " + texSize);
                        var texture = this._device.createTexture({
                            type: GFXTextureType.TEX2D,
                            usage: GFXTextureUsageBit.SAMPLED,
                            format: this._format,
                            width: texWidth,
                            height: texWidth,
                            mipLevel: 1
                        }), texView = this._device.createTextureView({
                            texture: texture,
                            type: GFXTextureViewType.TV2D,
                            format: this._format
                        }), texHandle = {
                            chunkIdx: this._chunkCount,
                            start: 0,
                            end: size,
                            texture: texture,
                            texView: texView
                        };
                        return this._handles.push(texHandle), this._chunks[this._chunkCount++] = {
                            texture: texture,
                            texView: texView,
                            size: texSize,
                            start: size,
                            end: texSize
                        }, texHandle;
                    }
                }, {
                    key: "free",
                    value: function free(handle) {
                        for (var i = 0; i < this._handles.length; ++i) if (this._handles[i] === handle) return this._chunks[handle.chunkIdx].end = handle.end, 
                        void this._handles.splice(i, 1);
                    }
                }, {
                    key: "update",
                    value: function update(handle, buffer) {
                        var buffers = [], regions = [], start = handle.start / this._formatSize, remainSize = buffer.byteLength / this._formatSize, offsetX = start % handle.texture.width, offsetY = Math.floor(start / handle.texture.width), copySize = Math.min(handle.texture.width - offsetX, remainSize), begin = 0;
                        0 < offsetX && (this._region0.texOffset.x = offsetX, this._region0.texOffset.y = offsetY, 
                        this._region0.texExtent.width = copySize, this._region0.texExtent.height = 1, buffers.push(buffer.slice(begin * this._formatSize, (begin + copySize) * this._formatSize)), 
                        regions.push(this._region0), offsetX = 0, offsetY += 1, remainSize -= copySize, 
                        begin += copySize), 0 < remainSize && (this._region1.texOffset.x = offsetX, this._region1.texOffset.y = offsetY, 
                        remainSize > handle.texture.width ? (this._region1.texExtent.width = handle.texture.width, 
                        this._region1.texExtent.height = Math.floor(remainSize / handle.texture.width), 
                        copySize = this._region1.texExtent.width * this._region1.texExtent.height) : (copySize = remainSize, 
                        this._region1.texExtent.width = copySize, this._region1.texExtent.height = 1), buffers.push(buffer.slice(begin * this._formatSize, (begin + copySize) * this._formatSize)), 
                        regions.push(this._region1), offsetX = 0, offsetY += this._region1.texExtent.height, 
                        remainSize -= copySize, begin += copySize), 0 < remainSize && (this._region2.texOffset.x = offsetX, 
                        this._region2.texOffset.y = offsetY, this._region2.texExtent.width = remainSize, 
                        this._region2.texExtent.height = 1, buffers.push(buffer.slice(begin * this._formatSize, (begin + remainSize) * this._formatSize)), 
                        regions.push(this._region2)), this._device.copyBuffersToTexture(buffers, handle.texture, regions);
                    }
                } ]), TextureBufferPool;
            }(), uploadJointData = function uploadJointDataDQS(out, base, mat, firstBone) {
                Mat4.toRTS(mat, qt_1$1, v3_1$5, v3_2$3), firstBone ? Quat.copy(dq_0, qt_1$1) : Quat.dot(dq_0, qt_1$1) < 0 && Quat.multiplyScalar(qt_1$1, qt_1$1, -1);
                Quat.set(dq_1, v3_1$5.x, v3_1$5.y, v3_1$5.z, 0), Quat.multiplyScalar(dq_1, Quat.multiply(dq_1, dq_1, qt_1$1), .5), 
                out[base + 0] = qt_1$1.x, out[base + 1] = qt_1$1.y, out[base + 2] = qt_1$1.z, out[base + 3] = qt_1$1.w, 
                out[base + 4] = dq_1.x, out[base + 5] = dq_1.y, out[base + 6] = dq_1.z, out[base + 7] = dq_1.w, 
                out[base + 8] = v3_2$3.x, out[base + 9] = v3_2$3.y, out[base + 10] = v3_2$3.z;
            };
            function selectJointsMediumType(device) {
                return device.hasFeature(GFXFeature.TEXTURE_FLOAT) ? JointsMediumType.RGBA32F : JointsMediumType.RGBA8;
            }
            !function(JointsMediumType) {
                JointsMediumType[JointsMediumType.NONE = 0] = "NONE", JointsMediumType[JointsMediumType.RGBA8 = 1] = "RGBA8", 
                JointsMediumType[JointsMediumType.RGBA32F = 2] = "RGBA32F";
            }(JointsMediumType = JointsMediumType || {});
            var id_m4 = Object.freeze(new Mat4()), m4_1$2 = new Mat4(), dq_0 = new Quat(), dq_1 = new Quat(), v3_1$5 = new Vec3(), qt_1$1 = new Quat(), v3_2$3 = new Vec3();
            function roundUpTextureSize(targetLength, formatSize) {
                var formatScale = 4 / Math.sqrt(formatSize);
                return 12 * Math.ceil(Math.max(204 * formatScale, targetLength) / 12);
            }
            function getBitCount(cnt) {
                return Math.ceil(Math.log2(Math.max(cnt, 2)));
            }
            function mapDefine(info, def) {
                switch (info.type) {
                  case "boolean":
                    return def ? "1" : "0";

                  case "string":
                    return void 0 !== def ? def : info.options[0];

                  case "number":
                    return (void 0 !== def ? def : info.range[0]) + "";
                }
                return console.warn("unknown define type '".concat(info.type, "'")), "-1";
            }
            function insertBuiltinBindings(tmpl, source, type) {
                var target = tmpl.builtins[type], blocks = tmpl.blocks, _iterator2 = target.blocks, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var b = _ref2, info = source.get(b.name);
                    if (info && info.type === GFXBindingType.UNIFORM_BUFFER) {
                        var builtin = Object.assign({
                            defines: b.defines
                        }, info.blockInfo);
                        blocks.push(builtin);
                    } else console.warn("builtin UBO '".concat(b.name, "' not available!"));
                }
                var samplers = tmpl.samplers, _iterator3 = target.samplers, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var s = _ref3, _info = source.get(s.name);
                    if (_info && _info.type === GFXBindingType.SAMPLER) {
                        var _builtin = Object.assign({
                            defines: s.defines
                        }, _info.samplerInfo);
                        samplers.push(_builtin);
                    } else console.warn("builtin sampler '".concat(s.name, "' not available!"));
                }
            }
            var phases, phaseNum, _type2writer2, _type2reader2, _type2default2, _jointsFormat = (_defineProperty(_jointsFormat2 = {}, JointsMediumType.RGBA8, GFXFormat.RGBA8), 
            _defineProperty(_jointsFormat2, JointsMediumType.RGBA32F, GFXFormat.RGBA32F), _jointsFormat2), JointsTexturePool = function() {
                function JointsTexturePool(device) {
                    _classCallCheck(this, JointsTexturePool), this._device = void 0, this._pool = void 0, 
                    this._textureBuffers = new Map(), this._formatSize = 0, this._device = device, this._pool = new TextureBufferPool(device);
                }
                return _createClass(JointsTexturePool, [ {
                    key: "initialize",
                    value: function initialize(argument_0) {
                        var maxChunks = 0 < arguments.length && void 0 !== argument_0 ? argument_0 : 8, format = _jointsFormat[selectJointsMediumType(this._device)];
                        this._formatSize = GFXFormatInfos[format].size;
                        var scale = 16 / this._formatSize;
                        this._pool.initialize({
                            format: format,
                            maxChunks: maxChunks * scale,
                            roundUpFn: roundUpTextureSize
                        });
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._pool.destroy();
                    }
                }, {
                    key: "getDefaultJointsTexture",
                    value: function getDefaultJointsTexture(skeleton) {
                        var len = skeleton && skeleton.joints.length || 1, texture = this._textureBuffers.get(len) || null;
                        if (texture) return texture.refCount++, texture;
                        var handle = this._pool.alloc(12 * len * Float32Array.BYTES_PER_ELEMENT);
                        if (!handle) return null;
                        texture = {
                            pixelOffset: handle.start / this._formatSize,
                            refCount: 1,
                            hash: len,
                            handle: handle
                        };
                        for (var textureBuffer = new Float32Array(12 * len), i = 0; i < len; i++) uploadJointData(textureBuffer, 12 * i, id_m4, 0 === i);
                        return this._pool.update(handle, textureBuffer.buffer), this._textureBuffers.set(len, texture), 
                        texture;
                    }
                }, {
                    key: "getJointsTextureWithAnimation",
                    value: function getJointsTextureWithAnimation(skeleton, clip) {
                        var hash = skeleton.hash ^ clip.hash, texture = this._textureBuffers.get(hash) || null;
                        if (texture) return texture.refCount++, texture;
                        var frames = clip.keys[0].length, bufSize = 12 * skeleton.joints.length * frames, handle = this._pool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT);
                        if (!handle) return null;
                        texture = {
                            pixelOffset: handle.start / this._formatSize,
                            refCount: 1,
                            hash: hash,
                            handle: handle
                        };
                        for (var textureBuffer = new Float32Array(bufSize), data = clip.convertedData, i = 0; i < skeleton.joints.length; i++) {
                            var nodeData = data[skeleton.joints[i]];
                            if (nodeData && nodeData.props) for (var bindpose = skeleton.bindposes[i], matrix = nodeData.props.worldMatrix.values, frame = 0; frame < frames; frame++) {
                                var m = matrix[frame];
                                Mat4.multiply(m4_1$2, m, bindpose), uploadJointData(textureBuffer, 12 * (frames * i + frame), m4_1$2, 0 === i);
                            }
                        }
                        return this._pool.update(handle, textureBuffer.buffer), this._textureBuffers.set(hash, texture), 
                        texture;
                    }
                }, {
                    key: "releaseTexture",
                    value: function releaseTexture(texture) {
                        0 == --texture.refCount && (this._pool.free(texture.handle), this._textureBuffers.delete(texture.hash));
                    }
                } ]), JointsTexturePool;
            }(), effects = exports("effects", [ {
                name: "builtin-billboard",
                techniques: [ {
                    name: "add",
                    passes: [ {
                        rasterizerState: {
                            cullMode: 0
                        },
                        blendState: {
                            targets: [ {
                                blend: !0,
                                blendSrc: 2,
                                blendDst: 1,
                                blendSrcAlpha: 2,
                                blendDstAlpha: 1
                            } ]
                        },
                        program: "builtin-billboard|vert:vs_main|tinted-fs:add",
                        depthStencilState: {
                            depthTest: !0,
                            depthWrite: !1
                        },
                        properties: {
                            mainTexture: {
                                value: "grey",
                                type: 28
                            },
                            mainTiling_Offset: {
                                value: [ 1, 1, 0, 0 ],
                                type: 16
                            },
                            tintColor: {
                                value: [ .5, .5, .5, .5 ],
                                type: 16
                            }
                        }
                    } ]
                } ],
                shaders: [ {
                    name: "builtin-billboard|vert:vs_main|tinted-fs:add",
                    hash: 3876741410,
                    glsl3: {
                        vert: "\nprecision mediump float;\nuniform Constants{\n    vec4 mainTiling_Offset;\n    vec4 frameTile_velLenScale;\n    vec4 scale;\n};\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp mat4 cc_matWorlds[10];\n};\nvec4 quaternionFromAxisAngle(float angle, vec3 axis){\n    angle /= 2.;\n    float s = sin(angle);\n    vec4 res;\n    res.xyz = s * axis;\n    res.w = cos(angle);\n    return res;\n}\nvec4 quaternionFromAxis(vec3 xAxis,vec3 yAxis,vec3 zAxis){\n    mat3 m = mat3(xAxis,yAxis,zAxis);\n    float trace = m[0][0] + m[1][1] + m[2][2];\n    vec4 quat;\n    if (trace > 0.) {\n        float s = 0.5 / sqrt(trace + 1.0);\n        quat.w = 0.25 / s;\n        quat.x = (m[2][1] - m[1][2]) * s;\n        quat.y = (m[0][2] - m[2][0]) * s;\n        quat.z = (m[1][0] - m[0][1]) * s;\n    } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n        float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n        quat.w = (m[2][1] - m[1][2]) / s;\n        quat.x = 0.25 * s;\n        quat.y = (m[0][1] + m[1][0]) / s;\n        quat.z = (m[0][2] + m[2][0]) / s;\n    } else if (m[1][1] > m[2][2]) {\n        float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n        quat.w = (m[0][2] - m[2][0]) / s;\n        quat.x = (m[0][1] + m[1][0]) / s;\n        quat.y = 0.25 * s;\n        quat.z = (m[1][2] + m[2][1]) / s;\n    } else {\n        float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n        quat.w = (m[1][0] - m[0][1]) / s;\n        quat.x = (m[0][2] + m[2][0]) / s;\n        quat.y = (m[1][2] + m[2][1]) / s;\n        quat.z = 0.25 * s;\n    }\n    float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n    if (len > 0.) {\n        len = 1. / sqrt(len);\n        quat.x = quat.x * len;\n        quat.y = quat.y * len;\n        quat.z = quat.z * len;\n        quat.w = quat.w * len;\n    }\n    return quat;\n}\nvec4 quaternionFromEuler(vec3 angle){\n    float x = angle.x / 2.;\n    float y = angle.y / 2.;\n    float z = angle.z / 2.;\n    float sx = sin(x);\n    float cx = cos(x);\n    float sy = sin(y);\n    float cy = cos(y);\n    float sz = sin(z);\n    float cz = cos(z);\n    vec4 quat = vec4(0);\n    quat.x = sx * cy * cz + cx * sy * sz;\n    quat.y = cx * sy * cz + sx * cy * sz;\n    quat.z = cx * cy * sz - sx * sy * cz;\n    quat.w = cx * cy * cz - sx * sy * sz;\n    return quat;\n}\nmat4 matrixFromRT(vec4 q, vec3 p){\n    float x2 = q.x + q.x;\n    float y2 = q.y + q.y;\n    float z2 = q.z + q.z;\n    float xx = q.x * x2;\n    float xy = q.x * y2;\n    float xz = q.x * z2;\n    float yy = q.y * y2;\n    float yz = q.y * z2;\n    float zz = q.z * z2;\n    float wx = q.w * x2;\n    float wy = q.w * y2;\n    float wz = q.w * z2;\n    return mat4(\n        1. - (yy + zz), xy + wz, xz - wy, 0,\n        xy - wz, 1. - (xx + zz), yz + wx, 0,\n        xz + wy, yz - wx, 1. - (xx + yy), 0,\n        p.x, p.y, p.z, 1\n    );\n}\nmat4 matFromRTS(vec4 q, vec3 t, vec3 s){\n    float x = q.x, y = q.y, z = q.z, w = q.w;\n    float x2 = x + x;\n    float y2 = y + y;\n    float z2 = z + z;\n    float xx = x * x2;\n    float xy = x * y2;\n    float xz = x * z2;\n    float yy = y * y2;\n    float yz = y * z2;\n    float zz = z * z2;\n    float wx = w * x2;\n    float wy = w * y2;\n    float wz = w * z2;\n    float sx = s.x;\n    float sy = s.y;\n    float sz = s.z;\n    return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n        (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n        (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n        t.x, t.y, t.z, 1);\n}\nvoid scaleMatrix(inout mat4 m, float s){\n    m[0].xyz *= s;\n    m[1].xyz *= s;\n    m[2].xyz *= s;\n}\nvec4 quatMultiply(vec4 a, vec4 b){\n    vec4 quat;\n    quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n    quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n    quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n    quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n    return quat;\n}\nvoid rotateVecFromQuat(inout vec3 v, vec4 q){\n    float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n    float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n    float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n    float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n    v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n    v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n    v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateVecFromAxis(vec3 v, vec3 axis, float theta){\n    return cos(theta) * v + sin(theta) * cross(v, axis) + (1. - cos(theta)) * dot(v, axis) * axis;\n}\nvec3 rotateInLocalSpace(vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n    vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n    vec4 rotQuat = quatMultiply(viewQuat, q);\n    rotateVecFromQuat(pos, rotQuat);\n    return pos;\n}\nvoid rotateCorner(inout vec2 corner, float angle){\n    float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n    float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n    corner.x = xOS;\n    corner.y = yOS;\n}\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if 1 || CC_USE_VERTICAL_BILLBOARD\n    , mat4 viewInv\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n    , vec3 eye\n    , vec4 velocity\n    , float velocityScale\n    , float lengthScale\n    , float xIndex\n#endif\n) {\n#if 1\n    vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n    vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n    vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n    vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n    pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_USE_STRETCHED_BILLBOARD\n    vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n    vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n    pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n    vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n    vec3 camX = vec3(1, 0, 0);\n    vec3 camY = vec3(0, 0, -1);\n    pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_USE_VERTICAL_BILLBOARD\n    vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n    rotateCorner(viewSpaceVert, q.z);\n    vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n    vec3 camY = vec3(0, 1, 0);\n    vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n    pos.xyz += offset;\n#else\n    pos.x += vertOffset.x;\n    pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile){\n    vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n    aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if !CC_USE_MESH\n    vertIndex.y = 1. - vertIndex.y;\n#endif\n    return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nuniform builtin {\n  vec4 cc_size_rotation;\n};\nvec4 vs_main() {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  vec2 vertOffset = a_texCoord.xy - 0.5;\n  computeVertPos(pos, vertOffset, quaternionFromEuler(0., 0., cc_size_rotation.z), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.xy;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }\n",
                        frag: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }\n"
                    },
                    glsl1: {
                        vert: "\nprecision mediump float;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nvec4 quaternionFromAxisAngle(float angle, vec3 axis){\n    angle /= 2.;\n    float s = sin(angle);\n    vec4 res;\n    res.xyz = s * axis;\n    res.w = cos(angle);\n    return res;\n}\nvec4 quaternionFromAxis(vec3 xAxis,vec3 yAxis,vec3 zAxis){\n    mat3 m = mat3(xAxis,yAxis,zAxis);\n    float trace = m[0][0] + m[1][1] + m[2][2];\n    vec4 quat;\n    if (trace > 0.) {\n        float s = 0.5 / sqrt(trace + 1.0);\n        quat.w = 0.25 / s;\n        quat.x = (m[2][1] - m[1][2]) * s;\n        quat.y = (m[0][2] - m[2][0]) * s;\n        quat.z = (m[1][0] - m[0][1]) * s;\n    } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n        float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n        quat.w = (m[2][1] - m[1][2]) / s;\n        quat.x = 0.25 * s;\n        quat.y = (m[0][1] + m[1][0]) / s;\n        quat.z = (m[0][2] + m[2][0]) / s;\n    } else if (m[1][1] > m[2][2]) {\n        float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n        quat.w = (m[0][2] - m[2][0]) / s;\n        quat.x = (m[0][1] + m[1][0]) / s;\n        quat.y = 0.25 * s;\n        quat.z = (m[1][2] + m[2][1]) / s;\n    } else {\n        float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n        quat.w = (m[1][0] - m[0][1]) / s;\n        quat.x = (m[0][2] + m[2][0]) / s;\n        quat.y = (m[1][2] + m[2][1]) / s;\n        quat.z = 0.25 * s;\n    }\n    float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n    if (len > 0.) {\n        len = 1. / sqrt(len);\n        quat.x = quat.x * len;\n        quat.y = quat.y * len;\n        quat.z = quat.z * len;\n        quat.w = quat.w * len;\n    }\n    return quat;\n}\nvec4 quaternionFromEuler(vec3 angle){\n    float x = angle.x / 2.;\n    float y = angle.y / 2.;\n    float z = angle.z / 2.;\n    float sx = sin(x);\n    float cx = cos(x);\n    float sy = sin(y);\n    float cy = cos(y);\n    float sz = sin(z);\n    float cz = cos(z);\n    vec4 quat = vec4(0);\n    quat.x = sx * cy * cz + cx * sy * sz;\n    quat.y = cx * sy * cz + sx * cy * sz;\n    quat.z = cx * cy * sz - sx * sy * cz;\n    quat.w = cx * cy * cz - sx * sy * sz;\n    return quat;\n}\nmat4 matrixFromRT(vec4 q, vec3 p){\n    float x2 = q.x + q.x;\n    float y2 = q.y + q.y;\n    float z2 = q.z + q.z;\n    float xx = q.x * x2;\n    float xy = q.x * y2;\n    float xz = q.x * z2;\n    float yy = q.y * y2;\n    float yz = q.y * z2;\n    float zz = q.z * z2;\n    float wx = q.w * x2;\n    float wy = q.w * y2;\n    float wz = q.w * z2;\n    return mat4(\n        1. - (yy + zz), xy + wz, xz - wy, 0,\n        xy - wz, 1. - (xx + zz), yz + wx, 0,\n        xz + wy, yz - wx, 1. - (xx + yy), 0,\n        p.x, p.y, p.z, 1\n    );\n}\nmat4 matFromRTS(vec4 q, vec3 t, vec3 s){\n    float x = q.x, y = q.y, z = q.z, w = q.w;\n    float x2 = x + x;\n    float y2 = y + y;\n    float z2 = z + z;\n    float xx = x * x2;\n    float xy = x * y2;\n    float xz = x * z2;\n    float yy = y * y2;\n    float yz = y * z2;\n    float zz = z * z2;\n    float wx = w * x2;\n    float wy = w * y2;\n    float wz = w * z2;\n    float sx = s.x;\n    float sy = s.y;\n    float sz = s.z;\n    return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n        (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n        (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n        t.x, t.y, t.z, 1);\n}\nvoid scaleMatrix(inout mat4 m, float s){\n    m[0].xyz *= s;\n    m[1].xyz *= s;\n    m[2].xyz *= s;\n}\nvec4 quatMultiply(vec4 a, vec4 b){\n    vec4 quat;\n    quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n    quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n    quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n    quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n    return quat;\n}\nvoid rotateVecFromQuat(inout vec3 v, vec4 q){\n    float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n    float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n    float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n    float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n    v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n    v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n    v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateVecFromAxis(vec3 v, vec3 axis, float theta){\n    return cos(theta) * v + sin(theta) * cross(v, axis) + (1. - cos(theta)) * dot(v, axis) * axis;\n}\nvec3 rotateInLocalSpace(vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n    vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n    vec4 rotQuat = quatMultiply(viewQuat, q);\n    rotateVecFromQuat(pos, rotQuat);\n    return pos;\n}\nvoid rotateCorner(inout vec2 corner, float angle){\n    float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n    float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n    corner.x = xOS;\n    corner.y = yOS;\n}\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if 1 || CC_USE_VERTICAL_BILLBOARD\n    , mat4 viewInv\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n    , vec3 eye\n    , vec4 velocity\n    , float velocityScale\n    , float lengthScale\n    , float xIndex\n#endif\n) {\n#if 1\n    vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n    vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n    vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n    vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n    pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_USE_STRETCHED_BILLBOARD\n    vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n    vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n    pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n    vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n    vec3 camX = vec3(1, 0, 0);\n    vec3 camY = vec3(0, 0, -1);\n    pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_USE_VERTICAL_BILLBOARD\n    vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n    rotateCorner(viewSpaceVert, q.z);\n    vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n    vec3 camY = vec3(0, 1, 0);\n    vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n    pos.xyz += offset;\n#else\n    pos.x += vertOffset.x;\n    pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile){\n    vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n    aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if !CC_USE_MESH\n    vertIndex.y = 1. - vertIndex.y;\n#endif\n    return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nuniform vec4 cc_size_rotation;\nvec4 vs_main() {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  vec2 vertOffset = a_texCoord.xy - 0.5;\n  computeVertPos(pos, vertOffset, quaternionFromEuler(0., 0., cc_size_rotation.z), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.xy;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }\n",
                        frag: "\nprecision mediump float;\nuniform vec4 cc_exposure;\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }\n"
                    },
                    builtins: {
                        globals: {
                            blocks: [ {
                                name: "CCGlobal",
                                defines: []
                            } ],
                            samplers: []
                        },
                        locals: {
                            blocks: [ {
                                name: "CCLocal",
                                defines: []
                            } ],
                            samplers: []
                        }
                    },
                    defines: [ {
                        name: "CC_USE_STRETCHED_BILLBOARD",
                        type: "boolean"
                    }, {
                        name: "CC_USE_HORIZONTAL_BILLBOARD",
                        type: "boolean"
                    }, {
                        name: "CC_USE_VERTICAL_BILLBOARD",
                        type: "boolean"
                    }, {
                        name: "CC_USE_MESH",
                        type: "boolean"
                    }, {
                        name: "CC_USE_HDR",
                        type: "boolean"
                    } ],
                    blocks: [ {
                        name: "Constants",
                        defines: [],
                        binding: 0,
                        members: [ {
                            name: "mainTiling_Offset",
                            type: 16,
                            count: 1
                        }, {
                            name: "frameTile_velLenScale",
                            type: 16,
                            count: 1
                        }, {
                            name: "scale",
                            type: 16,
                            count: 1
                        } ]
                    }, {
                        name: "builtin",
                        defines: [],
                        binding: 1,
                        members: [ {
                            name: "cc_size_rotation",
                            type: 16,
                            count: 1
                        } ]
                    }, {
                        name: "FragConstants",
                        defines: [],
                        binding: 2,
                        members: [ {
                            name: "tintColor",
                            type: 16,
                            count: 1
                        } ]
                    } ],
                    samplers: [ {
                        name: "mainTexture",
                        type: 28,
                        count: 1,
                        defines: [],
                        binding: 30
                    } ]
                } ]
            }, {
                name: "builtin-particle-trail",
                techniques: [ {
                    name: "add",
                    passes: [ {
                        rasterizerState: {
                            cullMode: 0
                        },
                        blendState: {
                            targets: [ {
                                blend: !0,
                                blendSrc: 2,
                                blendDst: 1,
                                blendSrcAlpha: 2,
                                blendDstAlpha: 1
                            } ]
                        },
                        program: "builtin-particle-trail|particle-trail:vs_main|tinted-fs:add",
                        depthStencilState: {
                            depthTest: !0,
                            depthWrite: !1
                        },
                        properties: {
                            mainTexture: {
                                value: "grey",
                                type: 28
                            },
                            mainTiling_Offset: {
                                value: [ 1, 1, 0, 0 ],
                                type: 16
                            },
                            frameTile_velLenScale: {
                                value: [ 1, 1, 0, 0 ],
                                type: 16
                            },
                            tintColor: {
                                value: [ .5, .5, .5, .5 ],
                                type: 16
                            }
                        }
                    } ]
                } ],
                shaders: [ {
                    name: "builtin-particle-trail|particle-trail:vs_main|tinted-fs:add",
                    hash: 207867717,
                    glsl3: {
                        vert: "\nprecision mediump float;\nuniform Constants{\n    vec4 mainTiling_Offset;\n    vec4 frameTile_velLenScale;\n    vec4 scale;\n};\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp mat4 cc_matWorlds[10];\n};\nvec4 quaternionFromAxisAngle(float angle, vec3 axis){\n    angle /= 2.;\n    float s = sin(angle);\n    vec4 res;\n    res.xyz = s * axis;\n    res.w = cos(angle);\n    return res;\n}\nvec4 quaternionFromAxis(vec3 xAxis,vec3 yAxis,vec3 zAxis){\n    mat3 m = mat3(xAxis,yAxis,zAxis);\n    float trace = m[0][0] + m[1][1] + m[2][2];\n    vec4 quat;\n    if (trace > 0.) {\n        float s = 0.5 / sqrt(trace + 1.0);\n        quat.w = 0.25 / s;\n        quat.x = (m[2][1] - m[1][2]) * s;\n        quat.y = (m[0][2] - m[2][0]) * s;\n        quat.z = (m[1][0] - m[0][1]) * s;\n    } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n        float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n        quat.w = (m[2][1] - m[1][2]) / s;\n        quat.x = 0.25 * s;\n        quat.y = (m[0][1] + m[1][0]) / s;\n        quat.z = (m[0][2] + m[2][0]) / s;\n    } else if (m[1][1] > m[2][2]) {\n        float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n        quat.w = (m[0][2] - m[2][0]) / s;\n        quat.x = (m[0][1] + m[1][0]) / s;\n        quat.y = 0.25 * s;\n        quat.z = (m[1][2] + m[2][1]) / s;\n    } else {\n        float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n        quat.w = (m[1][0] - m[0][1]) / s;\n        quat.x = (m[0][2] + m[2][0]) / s;\n        quat.y = (m[1][2] + m[2][1]) / s;\n        quat.z = 0.25 * s;\n    }\n    float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n    if (len > 0.) {\n        len = 1. / sqrt(len);\n        quat.x = quat.x * len;\n        quat.y = quat.y * len;\n        quat.z = quat.z * len;\n        quat.w = quat.w * len;\n    }\n    return quat;\n}\nvec4 quaternionFromEuler(vec3 angle){\n    float x = angle.x / 2.;\n    float y = angle.y / 2.;\n    float z = angle.z / 2.;\n    float sx = sin(x);\n    float cx = cos(x);\n    float sy = sin(y);\n    float cy = cos(y);\n    float sz = sin(z);\n    float cz = cos(z);\n    vec4 quat = vec4(0);\n    quat.x = sx * cy * cz + cx * sy * sz;\n    quat.y = cx * sy * cz + sx * cy * sz;\n    quat.z = cx * cy * sz - sx * sy * cz;\n    quat.w = cx * cy * cz - sx * sy * sz;\n    return quat;\n}\nmat4 matrixFromRT(vec4 q, vec3 p){\n    float x2 = q.x + q.x;\n    float y2 = q.y + q.y;\n    float z2 = q.z + q.z;\n    float xx = q.x * x2;\n    float xy = q.x * y2;\n    float xz = q.x * z2;\n    float yy = q.y * y2;\n    float yz = q.y * z2;\n    float zz = q.z * z2;\n    float wx = q.w * x2;\n    float wy = q.w * y2;\n    float wz = q.w * z2;\n    return mat4(\n        1. - (yy + zz), xy + wz, xz - wy, 0,\n        xy - wz, 1. - (xx + zz), yz + wx, 0,\n        xz + wy, yz - wx, 1. - (xx + yy), 0,\n        p.x, p.y, p.z, 1\n    );\n}\nmat4 matFromRTS(vec4 q, vec3 t, vec3 s){\n    float x = q.x, y = q.y, z = q.z, w = q.w;\n    float x2 = x + x;\n    float y2 = y + y;\n    float z2 = z + z;\n    float xx = x * x2;\n    float xy = x * y2;\n    float xz = x * z2;\n    float yy = y * y2;\n    float yz = y * z2;\n    float zz = z * z2;\n    float wx = w * x2;\n    float wy = w * y2;\n    float wz = w * z2;\n    float sx = s.x;\n    float sy = s.y;\n    float sz = s.z;\n    return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n        (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n        (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n        t.x, t.y, t.z, 1);\n}\nvoid scaleMatrix(inout mat4 m, float s){\n    m[0].xyz *= s;\n    m[1].xyz *= s;\n    m[2].xyz *= s;\n}\nvec4 quatMultiply(vec4 a, vec4 b){\n    vec4 quat;\n    quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n    quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n    quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n    quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n    return quat;\n}\nvoid rotateVecFromQuat(inout vec3 v, vec4 q){\n    float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n    float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n    float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n    float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n    v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n    v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n    v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateVecFromAxis(vec3 v, vec3 axis, float theta){\n    return cos(theta) * v + sin(theta) * cross(v, axis) + (1. - cos(theta)) * dot(v, axis) * axis;\n}\nvec3 rotateInLocalSpace(vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n    vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n    vec4 rotQuat = quatMultiply(viewQuat, q);\n    rotateVecFromQuat(pos, rotQuat);\n    return pos;\n}\nvoid rotateCorner(inout vec2 corner, float angle){\n    float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n    float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n    corner.x = xOS;\n    corner.y = yOS;\n}\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n    , mat4 viewInv\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n    , vec3 eye\n    , vec4 velocity\n    , float velocityScale\n    , float lengthScale\n    , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n    vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n    vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n    vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n    vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n    pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_USE_STRETCHED_BILLBOARD\n    vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n    vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n    pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n    vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n    vec3 camX = vec3(1, 0, 0);\n    vec3 camY = vec3(0, 0, -1);\n    pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_USE_VERTICAL_BILLBOARD\n    vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n    rotateCorner(viewSpaceVert, q.z);\n    vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n    vec3 camY = vec3(0, 1, 0);\n    vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n    pos.xyz += offset;\n#else\n    pos.x += vertOffset.x;\n    pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile){\n    vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n    aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if !CC_USE_MESH\n    vertIndex.y = 1. - vertIndex.y;\n#endif\n    return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec4 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n    out vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n    highp vec4 pos = vec4(a_position, 1);\n    vec4 velocity = vec4(a_texCoord1.xyz, 0);\n#if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n#endif\n    float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n    vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n    pos.xyz += camUp * vertOffset;\n    pos = cc_matViewProj * pos;\n    uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n    color = a_color;\n#if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n#endif\n    return pos;\n}\nvoid main() { gl_Position = vs_main(); }\n",
                        frag: "\n  precision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n  in vec2 uv;\n  in vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    in vec3 vBarycentric;\n  #endif\n  uniform sampler2D mainTexture;\n  uniform FragConstants {\n    vec4 tintColor;\n  };\n  vec4 add () {\n    vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., 1.);\n    }\n#endif\n    return CCFragOutput(col);\n  }\n  vec4 multiply () {\n    vec4 col;\n    vec4 texColor = texture(mainTexture, uv);\n    col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n    col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., col.a);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }\n"
                    },
                    glsl1: {
                        vert: "\nprecision mediump float;\nuniform vec4 mainTiling_Offset;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewProj;\nuniform vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvec4 quaternionFromAxisAngle(float angle, vec3 axis){\n    angle /= 2.;\n    float s = sin(angle);\n    vec4 res;\n    res.xyz = s * axis;\n    res.w = cos(angle);\n    return res;\n}\nvec4 quaternionFromAxis(vec3 xAxis,vec3 yAxis,vec3 zAxis){\n    mat3 m = mat3(xAxis,yAxis,zAxis);\n    float trace = m[0][0] + m[1][1] + m[2][2];\n    vec4 quat;\n    if (trace > 0.) {\n        float s = 0.5 / sqrt(trace + 1.0);\n        quat.w = 0.25 / s;\n        quat.x = (m[2][1] - m[1][2]) * s;\n        quat.y = (m[0][2] - m[2][0]) * s;\n        quat.z = (m[1][0] - m[0][1]) * s;\n    } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n        float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n        quat.w = (m[2][1] - m[1][2]) / s;\n        quat.x = 0.25 * s;\n        quat.y = (m[0][1] + m[1][0]) / s;\n        quat.z = (m[0][2] + m[2][0]) / s;\n    } else if (m[1][1] > m[2][2]) {\n        float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n        quat.w = (m[0][2] - m[2][0]) / s;\n        quat.x = (m[0][1] + m[1][0]) / s;\n        quat.y = 0.25 * s;\n        quat.z = (m[1][2] + m[2][1]) / s;\n    } else {\n        float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n        quat.w = (m[1][0] - m[0][1]) / s;\n        quat.x = (m[0][2] + m[2][0]) / s;\n        quat.y = (m[1][2] + m[2][1]) / s;\n        quat.z = 0.25 * s;\n    }\n    float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n    if (len > 0.) {\n        len = 1. / sqrt(len);\n        quat.x = quat.x * len;\n        quat.y = quat.y * len;\n        quat.z = quat.z * len;\n        quat.w = quat.w * len;\n    }\n    return quat;\n}\nvec4 quaternionFromEuler(vec3 angle){\n    float x = angle.x / 2.;\n    float y = angle.y / 2.;\n    float z = angle.z / 2.;\n    float sx = sin(x);\n    float cx = cos(x);\n    float sy = sin(y);\n    float cy = cos(y);\n    float sz = sin(z);\n    float cz = cos(z);\n    vec4 quat = vec4(0);\n    quat.x = sx * cy * cz + cx * sy * sz;\n    quat.y = cx * sy * cz + sx * cy * sz;\n    quat.z = cx * cy * sz - sx * sy * cz;\n    quat.w = cx * cy * cz - sx * sy * sz;\n    return quat;\n}\nmat4 matrixFromRT(vec4 q, vec3 p){\n    float x2 = q.x + q.x;\n    float y2 = q.y + q.y;\n    float z2 = q.z + q.z;\n    float xx = q.x * x2;\n    float xy = q.x * y2;\n    float xz = q.x * z2;\n    float yy = q.y * y2;\n    float yz = q.y * z2;\n    float zz = q.z * z2;\n    float wx = q.w * x2;\n    float wy = q.w * y2;\n    float wz = q.w * z2;\n    return mat4(\n        1. - (yy + zz), xy + wz, xz - wy, 0,\n        xy - wz, 1. - (xx + zz), yz + wx, 0,\n        xz + wy, yz - wx, 1. - (xx + yy), 0,\n        p.x, p.y, p.z, 1\n    );\n}\nmat4 matFromRTS(vec4 q, vec3 t, vec3 s){\n    float x = q.x, y = q.y, z = q.z, w = q.w;\n    float x2 = x + x;\n    float y2 = y + y;\n    float z2 = z + z;\n    float xx = x * x2;\n    float xy = x * y2;\n    float xz = x * z2;\n    float yy = y * y2;\n    float yz = y * z2;\n    float zz = z * z2;\n    float wx = w * x2;\n    float wy = w * y2;\n    float wz = w * z2;\n    float sx = s.x;\n    float sy = s.y;\n    float sz = s.z;\n    return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n        (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n        (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n        t.x, t.y, t.z, 1);\n}\nvoid scaleMatrix(inout mat4 m, float s){\n    m[0].xyz *= s;\n    m[1].xyz *= s;\n    m[2].xyz *= s;\n}\nvec4 quatMultiply(vec4 a, vec4 b){\n    vec4 quat;\n    quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n    quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n    quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n    quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n    return quat;\n}\nvoid rotateVecFromQuat(inout vec3 v, vec4 q){\n    float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n    float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n    float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n    float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n    v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n    v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n    v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateVecFromAxis(vec3 v, vec3 axis, float theta){\n    return cos(theta) * v + sin(theta) * cross(v, axis) + (1. - cos(theta)) * dot(v, axis) * axis;\n}\nvec3 rotateInLocalSpace(vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n    vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n    vec4 rotQuat = quatMultiply(viewQuat, q);\n    rotateVecFromQuat(pos, rotQuat);\n    return pos;\n}\nvoid rotateCorner(inout vec2 corner, float angle){\n    float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n    float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n    corner.x = xOS;\n    corner.y = yOS;\n}\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n    , mat4 viewInv\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n    , vec3 eye\n    , vec4 velocity\n    , float velocityScale\n    , float lengthScale\n    , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n    vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n    vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n    vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n    vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n    pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_USE_STRETCHED_BILLBOARD\n    vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n    vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n    pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n    vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n    vec3 camX = vec3(1, 0, 0);\n    vec3 camY = vec3(0, 0, -1);\n    pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_USE_VERTICAL_BILLBOARD\n    vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n    rotateCorner(viewSpaceVert, q.z);\n    vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n    vec3 camY = vec3(0, 1, 0);\n    vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n    pos.xyz += offset;\n#else\n    pos.x += vertOffset.x;\n    pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile){\n    vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n    aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if !CC_USE_MESH\n    vertIndex.y = 1. - vertIndex.y;\n#endif\n    return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec4 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n    varying vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n    highp vec4 pos = vec4(a_position, 1);\n    vec4 velocity = vec4(a_texCoord1.xyz, 0);\n#if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n#endif\n    float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n    vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n    pos.xyz += camUp * vertOffset;\n    pos = cc_matViewProj * pos;\n    uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n    color = a_color;\n#if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n#endif\n    return pos;\n}\nvoid main() { gl_Position = vs_main(); }\n",
                        frag: "\n  precision mediump float;\nuniform vec4 cc_exposure;\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n  varying vec2 uv;\n  varying vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    varying vec3 vBarycentric;\n  #endif\n  uniform sampler2D mainTexture;\n  uniform vec4 tintColor;\n  vec4 add () {\n    vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., 1.);\n    }\n#endif\n    return CCFragOutput(col);\n  }\n  vec4 multiply () {\n    vec4 col;\n    vec4 texColor = texture2D(mainTexture, uv);\n    col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n    col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., col.a);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nvoid main() { gl_FragColor = add(); }\n"
                    },
                    builtins: {
                        globals: {
                            blocks: [ {
                                name: "CCGlobal",
                                defines: []
                            } ],
                            samplers: []
                        },
                        locals: {
                            blocks: [ {
                                name: "CCLocal",
                                defines: []
                            } ],
                            samplers: []
                        }
                    },
                    defines: [ {
                        name: "CC_USE_BILLBOARD",
                        type: "boolean"
                    }, {
                        name: "CC_USE_STRETCHED_BILLBOARD",
                        type: "boolean"
                    }, {
                        name: "CC_USE_HORIZONTAL_BILLBOARD",
                        type: "boolean"
                    }, {
                        name: "CC_USE_VERTICAL_BILLBOARD",
                        type: "boolean"
                    }, {
                        name: "CC_USE_MESH",
                        type: "boolean"
                    }, {
                        name: "CC_DRAW_WIRE_FRAME",
                        type: "boolean"
                    }, {
                        name: "CC_USE_WORLD_SPACE",
                        type: "boolean"
                    }, {
                        name: "CC_USE_HDR",
                        type: "boolean"
                    } ],
                    blocks: [ {
                        name: "Constants",
                        defines: [],
                        binding: 0,
                        members: [ {
                            name: "mainTiling_Offset",
                            type: 16,
                            count: 1
                        }, {
                            name: "frameTile_velLenScale",
                            type: 16,
                            count: 1
                        }, {
                            name: "scale",
                            type: 16,
                            count: 1
                        } ]
                    }, {
                        name: "FragConstants",
                        defines: [],
                        binding: 1,
                        members: [ {
                            name: "tintColor",
                            type: 16,
                            count: 1
                        } ]
                    } ],
                    samplers: [ {
                        name: "mainTexture",
                        type: 28,
                        count: 1,
                        defines: [],
                        binding: 30
                    } ]
                } ]
            }, {
                name: "builtin-particle",
                techniques: [ {
                    name: "add",
                    passes: [ {
                        rasterizerState: {
                            cullMode: 0
                        },
                        blendState: {
                            targets: [ {
                                blend: !0,
                                blendSrc: 2,
                                blendDst: 1,
                                blendSrcAlpha: 2,
                                blendDstAlpha: 1
                            } ]
                        },
                        program: "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
                        depthStencilState: {
                            depthTest: !0,
                            depthWrite: !1
                        },
                        properties: {
                            mainTexture: {
                                value: "grey",
                                type: 28
                            },
                            mainTiling_Offset: {
                                value: [ 1, 1, 0, 0 ],
                                type: 16
                            },
                            tintColor: {
                                value: [ .5, .5, .5, .5 ],
                                type: 16
                            }
                        }
                    } ]
                } ],
                shaders: [ {
                    name: "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
                    hash: 1044134572,
                    glsl3: {
                        vert: "\nprecision highp float;\nvec4 quaternionFromAxisAngle(float angle, vec3 axis){\n    angle /= 2.;\n    float s = sin(angle);\n    vec4 res;\n    res.xyz = s * axis;\n    res.w = cos(angle);\n    return res;\n}\nvec4 quaternionFromAxis(vec3 xAxis,vec3 yAxis,vec3 zAxis){\n    mat3 m = mat3(xAxis,yAxis,zAxis);\n    float trace = m[0][0] + m[1][1] + m[2][2];\n    vec4 quat;\n    if (trace > 0.) {\n        float s = 0.5 / sqrt(trace + 1.0);\n        quat.w = 0.25 / s;\n        quat.x = (m[2][1] - m[1][2]) * s;\n        quat.y = (m[0][2] - m[2][0]) * s;\n        quat.z = (m[1][0] - m[0][1]) * s;\n    } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n        float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n        quat.w = (m[2][1] - m[1][2]) / s;\n        quat.x = 0.25 * s;\n        quat.y = (m[0][1] + m[1][0]) / s;\n        quat.z = (m[0][2] + m[2][0]) / s;\n    } else if (m[1][1] > m[2][2]) {\n        float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n        quat.w = (m[0][2] - m[2][0]) / s;\n        quat.x = (m[0][1] + m[1][0]) / s;\n        quat.y = 0.25 * s;\n        quat.z = (m[1][2] + m[2][1]) / s;\n    } else {\n        float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n        quat.w = (m[1][0] - m[0][1]) / s;\n        quat.x = (m[0][2] + m[2][0]) / s;\n        quat.y = (m[1][2] + m[2][1]) / s;\n        quat.z = 0.25 * s;\n    }\n    float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n    if (len > 0.) {\n        len = 1. / sqrt(len);\n        quat.x = quat.x * len;\n        quat.y = quat.y * len;\n        quat.z = quat.z * len;\n        quat.w = quat.w * len;\n    }\n    return quat;\n}\nvec4 quaternionFromEuler(vec3 angle){\n    float x = angle.x / 2.;\n    float y = angle.y / 2.;\n    float z = angle.z / 2.;\n    float sx = sin(x);\n    float cx = cos(x);\n    float sy = sin(y);\n    float cy = cos(y);\n    float sz = sin(z);\n    float cz = cos(z);\n    vec4 quat = vec4(0);\n    quat.x = sx * cy * cz + cx * sy * sz;\n    quat.y = cx * sy * cz + sx * cy * sz;\n    quat.z = cx * cy * sz - sx * sy * cz;\n    quat.w = cx * cy * cz - sx * sy * sz;\n    return quat;\n}\nmat4 matrixFromRT(vec4 q, vec3 p){\n    float x2 = q.x + q.x;\n    float y2 = q.y + q.y;\n    float z2 = q.z + q.z;\n    float xx = q.x * x2;\n    float xy = q.x * y2;\n    float xz = q.x * z2;\n    float yy = q.y * y2;\n    float yz = q.y * z2;\n    float zz = q.z * z2;\n    float wx = q.w * x2;\n    float wy = q.w * y2;\n    float wz = q.w * z2;\n    return mat4(\n        1. - (yy + zz), xy + wz, xz - wy, 0,\n        xy - wz, 1. - (xx + zz), yz + wx, 0,\n        xz + wy, yz - wx, 1. - (xx + yy), 0,\n        p.x, p.y, p.z, 1\n    );\n}\nmat4 matFromRTS(vec4 q, vec3 t, vec3 s){\n    float x = q.x, y = q.y, z = q.z, w = q.w;\n    float x2 = x + x;\n    float y2 = y + y;\n    float z2 = z + z;\n    float xx = x * x2;\n    float xy = x * y2;\n    float xz = x * z2;\n    float yy = y * y2;\n    float yz = y * z2;\n    float zz = z * z2;\n    float wx = w * x2;\n    float wy = w * y2;\n    float wz = w * z2;\n    float sx = s.x;\n    float sy = s.y;\n    float sz = s.z;\n    return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n        (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n        (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n        t.x, t.y, t.z, 1);\n}\nvoid scaleMatrix(inout mat4 m, float s){\n    m[0].xyz *= s;\n    m[1].xyz *= s;\n    m[2].xyz *= s;\n}\nvec4 quatMultiply(vec4 a, vec4 b){\n    vec4 quat;\n    quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n    quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n    quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n    quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n    return quat;\n}\nvoid rotateVecFromQuat(inout vec3 v, vec4 q){\n    float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n    float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n    float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n    float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n    v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n    v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n    v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateVecFromAxis(vec3 v, vec3 axis, float theta){\n    return cos(theta) * v + sin(theta) * cross(v, axis) + (1. - cos(theta)) * dot(v, axis) * axis;\n}\nvec3 rotateInLocalSpace(vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n    vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n    vec4 rotQuat = quatMultiply(viewQuat, q);\n    rotateVecFromQuat(pos, rotQuat);\n    return pos;\n}\nvoid rotateCorner(inout vec2 corner, float angle){\n    float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n    float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n    corner.x = xOS;\n    corner.y = yOS;\n}\nuniform Constants{\n    vec4 mainTiling_Offset;\n    vec4 frameTile_velLenScale;\n    vec4 scale;\n};\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp mat4 cc_matWorlds[10];\n};\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n    , mat4 viewInv\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n    , vec3 eye\n    , vec4 velocity\n    , float velocityScale\n    , float lengthScale\n    , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n    vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n    vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n    vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n    vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n    pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_USE_STRETCHED_BILLBOARD\n    vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n    vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n    pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n    vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n    vec3 camX = vec3(1, 0, 0);\n    vec3 camY = vec3(0, 0, -1);\n    pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_USE_VERTICAL_BILLBOARD\n    vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n    rotateCorner(viewSpaceVert, q.z);\n    vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n    vec3 camY = vec3(0, 1, 0);\n    vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n    pos.xyz += offset;\n#else\n    pos.x += vertOffset.x;\n    pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile){\n    vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n    aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if !CC_USE_MESH\n    vertIndex.y = 1. - vertIndex.y;\n#endif\n    return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_USE_STRETCHED_BILLBOARD\n    in vec3 a_color1;\n#endif\n#if CC_USE_MESH\n    in vec3 a_texCoord3;\n    in vec3 a_normal;\n    in vec4 a_color1;\n#endif\nvec4 lpvs_main() {\n    vec3 compScale = scale.xyz * a_texCoord1;\n    vec4 pos = vec4(a_position, 1);\n#if CC_USE_STRETCHED_BILLBOARD\n    vec4 velocity = vec4(a_color1.xyz, 0);\n#endif\n#if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_USE_STRETCHED_BILLBOARD\n        velocity = cc_matWorld * velocity;\n    #endif\n#endif\n#if !CC_USE_MESH\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_USE_BILLBOARD\n        vec3 rotEuler = a_texCoord2;\n    #elif CC_USE_STRETCHED_BILLBOARD\n        vec3 rotEuler = vec3(0.);\n    #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n        , cc_matViewInv\n    #endif\n    #if CC_USE_STRETCHED_BILLBOARD\n        , cc_cameraPos.xyz\n        , velocity\n        , frameTile_velLenScale.z\n        , frameTile_velLenScale.w\n        , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n#else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n#endif\n    uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n    pos = cc_matViewProj * pos;\n    return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }\n",
                        frag: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }\n"
                    },
                    glsl1: {
                        vert: "\nprecision highp float;\nvec4 quaternionFromAxisAngle(float angle, vec3 axis){\n    angle /= 2.;\n    float s = sin(angle);\n    vec4 res;\n    res.xyz = s * axis;\n    res.w = cos(angle);\n    return res;\n}\nvec4 quaternionFromAxis(vec3 xAxis,vec3 yAxis,vec3 zAxis){\n    mat3 m = mat3(xAxis,yAxis,zAxis);\n    float trace = m[0][0] + m[1][1] + m[2][2];\n    vec4 quat;\n    if (trace > 0.) {\n        float s = 0.5 / sqrt(trace + 1.0);\n        quat.w = 0.25 / s;\n        quat.x = (m[2][1] - m[1][2]) * s;\n        quat.y = (m[0][2] - m[2][0]) * s;\n        quat.z = (m[1][0] - m[0][1]) * s;\n    } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n        float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n        quat.w = (m[2][1] - m[1][2]) / s;\n        quat.x = 0.25 * s;\n        quat.y = (m[0][1] + m[1][0]) / s;\n        quat.z = (m[0][2] + m[2][0]) / s;\n    } else if (m[1][1] > m[2][2]) {\n        float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n        quat.w = (m[0][2] - m[2][0]) / s;\n        quat.x = (m[0][1] + m[1][0]) / s;\n        quat.y = 0.25 * s;\n        quat.z = (m[1][2] + m[2][1]) / s;\n    } else {\n        float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n        quat.w = (m[1][0] - m[0][1]) / s;\n        quat.x = (m[0][2] + m[2][0]) / s;\n        quat.y = (m[1][2] + m[2][1]) / s;\n        quat.z = 0.25 * s;\n    }\n    float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n    if (len > 0.) {\n        len = 1. / sqrt(len);\n        quat.x = quat.x * len;\n        quat.y = quat.y * len;\n        quat.z = quat.z * len;\n        quat.w = quat.w * len;\n    }\n    return quat;\n}\nvec4 quaternionFromEuler(vec3 angle){\n    float x = angle.x / 2.;\n    float y = angle.y / 2.;\n    float z = angle.z / 2.;\n    float sx = sin(x);\n    float cx = cos(x);\n    float sy = sin(y);\n    float cy = cos(y);\n    float sz = sin(z);\n    float cz = cos(z);\n    vec4 quat = vec4(0);\n    quat.x = sx * cy * cz + cx * sy * sz;\n    quat.y = cx * sy * cz + sx * cy * sz;\n    quat.z = cx * cy * sz - sx * sy * cz;\n    quat.w = cx * cy * cz - sx * sy * sz;\n    return quat;\n}\nmat4 matrixFromRT(vec4 q, vec3 p){\n    float x2 = q.x + q.x;\n    float y2 = q.y + q.y;\n    float z2 = q.z + q.z;\n    float xx = q.x * x2;\n    float xy = q.x * y2;\n    float xz = q.x * z2;\n    float yy = q.y * y2;\n    float yz = q.y * z2;\n    float zz = q.z * z2;\n    float wx = q.w * x2;\n    float wy = q.w * y2;\n    float wz = q.w * z2;\n    return mat4(\n        1. - (yy + zz), xy + wz, xz - wy, 0,\n        xy - wz, 1. - (xx + zz), yz + wx, 0,\n        xz + wy, yz - wx, 1. - (xx + yy), 0,\n        p.x, p.y, p.z, 1\n    );\n}\nmat4 matFromRTS(vec4 q, vec3 t, vec3 s){\n    float x = q.x, y = q.y, z = q.z, w = q.w;\n    float x2 = x + x;\n    float y2 = y + y;\n    float z2 = z + z;\n    float xx = x * x2;\n    float xy = x * y2;\n    float xz = x * z2;\n    float yy = y * y2;\n    float yz = y * z2;\n    float zz = z * z2;\n    float wx = w * x2;\n    float wy = w * y2;\n    float wz = w * z2;\n    float sx = s.x;\n    float sy = s.y;\n    float sz = s.z;\n    return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n        (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n        (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n        t.x, t.y, t.z, 1);\n}\nvoid scaleMatrix(inout mat4 m, float s){\n    m[0].xyz *= s;\n    m[1].xyz *= s;\n    m[2].xyz *= s;\n}\nvec4 quatMultiply(vec4 a, vec4 b){\n    vec4 quat;\n    quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n    quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n    quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n    quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n    return quat;\n}\nvoid rotateVecFromQuat(inout vec3 v, vec4 q){\n    float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n    float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n    float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n    float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n    v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n    v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n    v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateVecFromAxis(vec3 v, vec3 axis, float theta){\n    return cos(theta) * v + sin(theta) * cross(v, axis) + (1. - cos(theta)) * dot(v, axis) * axis;\n}\nvec3 rotateInLocalSpace(vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n    vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n    vec4 rotQuat = quatMultiply(viewQuat, q);\n    rotateVecFromQuat(pos, rotQuat);\n    return pos;\n}\nvoid rotateCorner(inout vec2 corner, float angle){\n    float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n    float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n    corner.x = xOS;\n    corner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matViewProj;\nuniform vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n    , mat4 viewInv\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n    , vec3 eye\n    , vec4 velocity\n    , float velocityScale\n    , float lengthScale\n    , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n    vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n    vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n    vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n    vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n    pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_USE_STRETCHED_BILLBOARD\n    vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n    vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n    pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n    vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n    vec3 camX = vec3(1, 0, 0);\n    vec3 camY = vec3(0, 0, -1);\n    pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_USE_VERTICAL_BILLBOARD\n    vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n    rotateCorner(viewSpaceVert, q.z);\n    vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n    vec3 camY = vec3(0, 1, 0);\n    vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n    pos.xyz += offset;\n#else\n    pos.x += vertOffset.x;\n    pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile){\n    vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n    aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if !CC_USE_MESH\n    vertIndex.y = 1. - vertIndex.y;\n#endif\n    return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_USE_STRETCHED_BILLBOARD\n    attribute vec3 a_color1;\n#endif\n#if CC_USE_MESH\n    attribute vec3 a_texCoord3;\n    attribute vec3 a_normal;\n    attribute vec4 a_color1;\n#endif\nvec4 lpvs_main() {\n    vec3 compScale = scale.xyz * a_texCoord1;\n    vec4 pos = vec4(a_position, 1);\n#if CC_USE_STRETCHED_BILLBOARD\n    vec4 velocity = vec4(a_color1.xyz, 0);\n#endif\n#if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_USE_STRETCHED_BILLBOARD\n        velocity = cc_matWorld * velocity;\n    #endif\n#endif\n#if !CC_USE_MESH\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_USE_BILLBOARD\n        vec3 rotEuler = a_texCoord2;\n    #elif CC_USE_STRETCHED_BILLBOARD\n        vec3 rotEuler = vec3(0.);\n    #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n        , cc_matViewInv\n    #endif\n    #if CC_USE_STRETCHED_BILLBOARD\n        , cc_cameraPos.xyz\n        , velocity\n        , frameTile_velLenScale.z\n        , frameTile_velLenScale.w\n        , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n#else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n#endif\n    uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n    pos = cc_matViewProj * pos;\n    return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }\n",
                        frag: "\nprecision highp float;\nuniform vec4 cc_exposure;\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }\n"
                    },
                    builtins: {
                        globals: {
                            blocks: [ {
                                name: "CCGlobal",
                                defines: []
                            } ],
                            samplers: []
                        },
                        locals: {
                            blocks: [ {
                                name: "CCLocal",
                                defines: []
                            } ],
                            samplers: []
                        }
                    },
                    defines: [ {
                        name: "CC_USE_BILLBOARD",
                        type: "boolean"
                    }, {
                        name: "CC_USE_STRETCHED_BILLBOARD",
                        type: "boolean"
                    }, {
                        name: "CC_USE_HORIZONTAL_BILLBOARD",
                        type: "boolean"
                    }, {
                        name: "CC_USE_VERTICAL_BILLBOARD",
                        type: "boolean"
                    }, {
                        name: "CC_USE_MESH",
                        type: "boolean"
                    }, {
                        name: "CC_USE_WORLD_SPACE",
                        type: "boolean"
                    }, {
                        name: "CC_USE_HDR",
                        type: "boolean"
                    } ],
                    blocks: [ {
                        name: "Constants",
                        defines: [],
                        binding: 0,
                        members: [ {
                            name: "mainTiling_Offset",
                            type: 16,
                            count: 1
                        }, {
                            name: "frameTile_velLenScale",
                            type: 16,
                            count: 1
                        }, {
                            name: "scale",
                            type: 16,
                            count: 1
                        } ]
                    }, {
                        name: "FragConstants",
                        defines: [],
                        binding: 1,
                        members: [ {
                            name: "tintColor",
                            type: 16,
                            count: 1
                        } ]
                    } ],
                    samplers: [ {
                        name: "mainTexture",
                        type: 28,
                        count: 1,
                        defines: [],
                        binding: 30
                    } ]
                } ]
            }, {
                name: "builtin-sprite",
                techniques: [ {
                    passes: [ {
                        blendState: {
                            targets: [ {
                                blend: !0,
                                blendSrc: 2,
                                blendDst: 4,
                                blendDstAlpha: 4
                            } ]
                        },
                        rasterizerState: {
                            cullMode: 0
                        },
                        program: "builtin-sprite|sprite-vs:vert|sprite-fs:frag",
                        priority: 244,
                        depthStencilState: {
                            depthTest: !1,
                            depthWrite: !1
                        },
                        properties: {
                            mainTexture: {
                                value: "white",
                                type: 28
                            }
                        }
                    } ]
                } ],
                shaders: [ {
                    name: "builtin-sprite|sprite-vs:vert|sprite-fs:frag",
                    hash: 1678704147,
                    glsl3: {
                        vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n#if USE_LOCAL\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp mat4 cc_matWorlds[10];\n};\n#endif\nin vec3 a_position;\nin vec4 a_color;\nout vec4 color;\nin vec2 a_texCoord;\nout vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision mediump float;\nin vec4 color;\n#if USE_TEXTURE\n  in vec2 uv0;\n  uniform sampler2D mainTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture(mainTexture, uv0);\n  #endif\n  o *= color;\n  return o;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
                    },
                    glsl1: {
                        vert: "\nprecision mediump float;\nuniform mat4 cc_matViewProj;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 color;\nattribute vec2 a_texCoord;\nvarying vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision mediump float;\nvarying vec4 color;\n#if USE_TEXTURE\n  varying vec2 uv0;\n  uniform sampler2D mainTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, uv0);\n  #endif\n  o *= color;\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }\n"
                    },
                    builtins: {
                        globals: {
                            blocks: [ {
                                name: "CCGlobal",
                                defines: []
                            } ],
                            samplers: []
                        },
                        locals: {
                            blocks: [ {
                                name: "CCLocal",
                                defines: [ "USE_LOCAL" ]
                            } ],
                            samplers: []
                        }
                    },
                    defines: [ {
                        name: "USE_LOCAL",
                        type: "boolean"
                    }, {
                        name: "USE_TEXTURE",
                        type: "boolean"
                    } ],
                    blocks: [],
                    samplers: [ {
                        name: "mainTexture",
                        type: 28,
                        count: 1,
                        defines: [ "USE_TEXTURE" ],
                        binding: 30
                    } ]
                } ]
            }, {
                name: "builtin-standard",
                techniques: [ {
                    name: "opaque",
                    passes: [ {
                        program: "builtin-standard|standard-vs:vert|standard-fs:frag",
                        properties: {
                            tilingOffset: {
                                value: [ 1, 1, 0, 0 ],
                                type: 16
                            },
                            albedo: {
                                value: [ 1, 1, 1, 1 ],
                                type: 16
                            },
                            albedoScale: {
                                value: [ 1, 1, 1, 0 ],
                                type: 16
                            },
                            pbrParams: {
                                value: [ .8, .6, 1, 1 ],
                                type: 16
                            },
                            pbrScale: {
                                value: [ 1, 1, 1, 1 ],
                                type: 16
                            },
                            emissive: {
                                value: [ 0, 0, 0, 1 ],
                                type: 16
                            },
                            emissiveScale: {
                                value: [ 1, 1, 1, 1 ],
                                type: 16
                            },
                            albedoMap: {
                                value: "grey",
                                type: 28
                            },
                            normalMap: {
                                value: "normal",
                                type: 28
                            },
                            pbrMap: {
                                value: "grey",
                                type: 28
                            },
                            metallicRoughnessMap: {
                                value: "grey",
                                type: 28
                            },
                            occlusionMap: {
                                value: "white",
                                type: 28
                            },
                            emissiveMap: {
                                value: "grey",
                                type: 28
                            }
                        }
                    } ]
                } ],
                shaders: [ {
                    name: "builtin-standard|standard-vs:vert|standard-fs:frag",
                    hash: 1071940485,
                    glsl3: {
                        vert: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp mat4 cc_matWorlds[10];\n};\nstruct StandardAttributes {\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  int index;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec4 a_tangent;\n#if USE_BATCHING\nin float a_index;\n#endif\nvoid CCDecode (out StandardAttributes attr) {\n  attr.position = vec4(a_position, 1.0);\n  attr.normal = a_normal;\n  attr.tangent = a_tangent;\n#if USE_BATCHING\n  attr.index = int(a_index + 0.5);\n#endif\n}\n#if CC_USE_SKINNING\nin vec4 a_weights;\nin vec4 a_joints;\nuniform CCSkinningTexture {\n  highp vec4 cc_jointsTextureInfo;\n};\nuniform CCSkinningAnimation {\n  highp vec4 cc_jointsAnimInfo;\n};\nuniform sampler2D cc_jointsTexture;\n#if CC_USE_SKINNING == 1\n  highp float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 12.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    Qt = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    S = vec3(\n      decode32(texture(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 10.5) * invSize, y)))\n    );\n  }\n#elif CC_USE_SKINNING == 2\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 3.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    Qt = texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    S = texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0); vec3 s;\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    getJointDQ(a_joints[i], r, t, s);\n    S += s * w; R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n  return v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout vec4 position) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  position.xyz = VectorTransformQuat(position.xyz * S, R) + T;\n}\nvoid CCSkin(inout StandardAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position.xyz = VectorTransformQuat(attr.position.xyz * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent.xyz = VectorTransformQuat(attr.tangent.xyz, R);\n}\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  int index;\n};\nvoid CCAttrToInput (in StandardAttributes attr, out StandardVertInput In) {\n  In.position = attr.position;\n  In.normal = attr.normal;\n  In.tangent = attr.tangent;\n  In.index = attr.index;\n}\nvoid CCVertInput (out StandardVertInput In) {\n  StandardAttributes attr;\n  CCDecode(attr);\n  #if CC_USE_SKINNING\n    CCSkin(attr);\n  #endif\n  CCAttrToInput(attr, In);\n}\nuniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScale;\n  vec4 pbrParams;\n  vec4 pbrScale;\n  vec4 emissive;\n  vec4 emissiveScale;\n};\n#define saturate(a) clamp( a, 0.0, 1.0 )\nhighp mat4 transposeMat4(in highp mat4 mat) {\n    highp vec4 i0 = mat[0];\n    highp vec4 i1 = mat[1];\n    highp vec4 i2 = mat[2];\n    highp vec4 i3 = mat[3];\n    return mat4(vec4(i0.x, i1.x, i2.x, i3.x),\n                vec4(i0.y, i1.y, i2.y, i3.y),\n                vec4(i0.z, i1.z, i2.z, i3.z),\n                vec4(i0.w, i1.w, i2.w, i3.w));\n}\nout vec3 v_position;\nout vec3 v_normal;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP || USE_METALLIC_ROUGHNESS_MAP || USE_OCCLUSION_MAP\n  in vec2 a_texCoord;\n  out vec2 v_uv;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  #if USE_BATCHING\n    mat4 matWorld = cc_matWorlds[In.index];\n    mat4 matWorldIT = transposeMat4(matWorld);\n  #else\n    mat4 matWorld = cc_matWorld;\n    mat4 matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorldIT * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  #if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP || USE_METALLIC_ROUGHNESS_MAP || USE_OCCLUSION_MAP\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  return cc_matViewProj * pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackNormal(vec4 nmap) {\n  return nmap.xyz * 2.0 - 1.0;\n}\nvec3 unpackRGBE(vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\n#endif\n#define saturate(a) clamp( a, 0.0, 1.0 )\nhighp mat4 transposeMat4(in highp mat4 mat) {\n    highp vec4 i0 = mat[0];\n    highp vec4 i1 = mat[1];\n    highp vec4 i2 = mat[2];\n    highp vec4 i3 = mat[3];\n    return mat4(vec4(i0.x, i1.x, i2.x, i3.x),\n                vec4(i0.y, i1.y, i2.y, i3.y),\n                vec4(i0.z, i1.z, i2.z, i3.z),\n                vec4(i0.w, i1.w, i2.w, i3.w));\n}\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nuniform CCForwardLight {\n  highp vec4 cc_sphereLitPos[2];\n  vec4 cc_sphereLitSizeRange[2];\n  vec4 cc_sphereLitColor[2];\n  highp vec4 cc_spotLitPos[2];\n  vec4 cc_spotLitSizeRangeAngle[2];\n  vec4 cc_spotLitDir[2];\n  vec4 cc_spotLitColor[2];\n};\nfloat SmoothDistAtt2(float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float factor2 = factor * factor;\n  float factor3 = factor2 * factor2;\n  float smoothFactor = clamp(1.0 - factor3 * factor3, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat SmoothDistAtt(float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt(float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt(vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GGXMobile(float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular(float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox(vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nvec3 CalcDynamicLighting(vec3 worldPos, vec3 N, vec3 V, vec3 diffuse, vec3 specular, float roughness) {\n  vec3 lighting = vec3(0.0);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  for (int i = 0; i < 2; i++) {\n    vec3 PLU = cc_sphereLitPos[i].xyz - worldPos;\n    vec3 PL = normalize(PLU);\n    vec3 PH = normalize(PL + V);\n    float PNL = max(dot(N, PL), 0.001);\n    float PNH = max(dot(N, PH), 0.0);\n    float distSqr = dot(PLU, PLU);\n    float litRadius = cc_sphereLitSizeRange[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);\n    lighting += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  for (int i = 0; i < 2; i++) {\n    vec3 SLU = cc_spotLitPos[i].xyz - worldPos;\n    vec3 SL = normalize(SLU);\n    vec3 SH = normalize(SL + V);\n    float SNL = max(dot(N, SL), 0.001);\n    float SNH = max(dot(N, SH), 0.0);\n    float distSqr = dot(SLU, SLU);\n    float litRadius = cc_spotLitSizeRangeAngle[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);\n    float cosOuter = cc_spotLitSizeRangeAngle[i].z;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    float litAngleOffset = -cosOuter * litAngleScale;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);\n    vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);\n    lighting += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  return lighting;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShading (StandardSurface s) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L+V);\n  float NV = max(abs(dot(N, V)), 0.001);\n  float NL = max(dot(N, L), 0.001);\n  float NH = max(dot(N, H), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);\n  finalColor += CalcDynamicLighting(s.position, N, V, diffuse, specular, s.roughness);\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = textureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb) * cc_ambientSky.w;\n    #endif\n    finalColor += env * specular;\n  #endif\n  finalColor = finalColor * s.occlusion;\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = LinearToSRGB(color.rgb);\n  #endif\n  return color;\n}\nuniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScale;\n  vec4 pbrParams;\n  vec4 pbrScale;\n  vec4 emissive;\n  vec4 emissiveScale;\n};\nin vec3 v_position;\n#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP || USE_METALLIC_ROUGHNESS_MAP || USE_OCCLUSION_MAP\n  in vec2 v_uv;\n#endif\nin vec3 v_normal;\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScale.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScale.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, v_uv).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrScale.w) * normalize(v_tangent) +\n      (nmmp.y * pbrScale.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    pbr = texture(pbrMap, v_uv);\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, v_uv);\n    pbr.METALLIC_CHANNEL = metallicRoughness.METALLIC_CHANNEL;\n    pbr.ROUGHNESS_CHANNEL = metallicRoughness.ROUGHNESS_CHANNEL;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.OCCLUSION_CHANNEL = texture(occlusionMap, v_uv).OCCLUSION_CHANNEL;\n  #endif\n  pbr *= pbrScale;\n  s.roughness = clamp(pbr.ROUGHNESS_CHANNEL, 0.04, 1.0);\n  s.metallic = clamp(pbr.METALLIC_CHANNEL, 0.0, 0.96);\n  s.occlusion = pbr.OCCLUSION_CHANNEL;\n  s.emissive = emissive.rgb * emissiveScale.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, v_uv).rgb);\n  #endif\n}\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  return CCFragOutput(color);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
                    },
                    glsl1: {
                        vert: "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\nuniform highp mat4 cc_matWorlds[10];\nstruct StandardAttributes {\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  int index;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec4 a_tangent;\n#if USE_BATCHING\nattribute float a_index;\n#endif\nvoid CCDecode (out StandardAttributes attr) {\n  attr.position = vec4(a_position, 1.0);\n  attr.normal = a_normal;\n  attr.tangent = a_tangent;\n#if USE_BATCHING\n  attr.index = int(a_index + 0.5);\n#endif\n}\n#if CC_USE_SKINNING\nattribute vec4 a_weights;\nattribute vec4 a_joints;\nuniform highp vec4 cc_jointsTextureInfo;\nuniform highp vec4 cc_jointsAnimInfo;\nuniform sampler2D cc_jointsTexture;\n#if CC_USE_SKINNING == 1\n  highp float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 12.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    Qt = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    S = vec3(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 10.5) * invSize, y)))\n    );\n  }\n#elif CC_USE_SKINNING == 2\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 3.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    Qt = texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    S = texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0); vec3 s;\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    getJointDQ(a_joints[i], r, t, s);\n    S += s * w; R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n  return v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout vec4 position) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  position.xyz = VectorTransformQuat(position.xyz * S, R) + T;\n}\nvoid CCSkin(inout StandardAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position.xyz = VectorTransformQuat(attr.position.xyz * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent.xyz = VectorTransformQuat(attr.tangent.xyz, R);\n}\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  int index;\n};\nvoid CCAttrToInput (in StandardAttributes attr, out StandardVertInput In) {\n  In.position = attr.position;\n  In.normal = attr.normal;\n  In.tangent = attr.tangent;\n  In.index = attr.index;\n}\nvoid CCVertInput (out StandardVertInput In) {\n  StandardAttributes attr;\n  CCDecode(attr);\n  #if CC_USE_SKINNING\n    CCSkin(attr);\n  #endif\n  CCAttrToInput(attr, In);\n}\nuniform vec4 tilingOffset;\n#define saturate(a) clamp( a, 0.0, 1.0 )\nhighp mat4 transposeMat4(in highp mat4 mat) {\n    highp vec4 i0 = mat[0];\n    highp vec4 i1 = mat[1];\n    highp vec4 i2 = mat[2];\n    highp vec4 i3 = mat[3];\n    return mat4(vec4(i0.x, i1.x, i2.x, i3.x),\n                vec4(i0.y, i1.y, i2.y, i3.y),\n                vec4(i0.z, i1.z, i2.z, i3.z),\n                vec4(i0.w, i1.w, i2.w, i3.w));\n}\nvarying vec3 v_position;\nvarying vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP || USE_METALLIC_ROUGHNESS_MAP || USE_OCCLUSION_MAP\n  attribute vec2 a_texCoord;\n  varying vec2 v_uv;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  #if USE_BATCHING\n    mat4 matWorld = cc_matWorlds[In.index];\n    mat4 matWorldIT = transposeMat4(matWorld);\n  #else\n    mat4 matWorld = cc_matWorld;\n    mat4 matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorldIT * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  #if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP || USE_METALLIC_ROUGHNESS_MAP || USE_OCCLUSION_MAP\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  return cc_matViewProj * pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\n#if CC_USE_IBL\n  #ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n  #endif\n#endif\nprecision highp float;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackNormal(vec4 nmap) {\n  return nmap.xyz * 2.0 - 1.0;\n}\nvec3 unpackRGBE(vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\n#endif\n#define saturate(a) clamp( a, 0.0, 1.0 )\nhighp mat4 transposeMat4(in highp mat4 mat) {\n    highp vec4 i0 = mat[0];\n    highp vec4 i1 = mat[1];\n    highp vec4 i2 = mat[2];\n    highp vec4 i3 = mat[3];\n    return mat4(vec4(i0.x, i1.x, i2.x, i3.x),\n                vec4(i0.y, i1.y, i2.y, i3.y),\n                vec4(i0.z, i1.z, i2.z, i3.z),\n                vec4(i0.w, i1.w, i2.w, i3.w));\n}\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nuniform highp vec4 cc_sphereLitPos[2];\nuniform vec4 cc_sphereLitSizeRange[2];\nuniform vec4 cc_sphereLitColor[2];\nuniform highp vec4 cc_spotLitPos[2];\nuniform vec4 cc_spotLitSizeRangeAngle[2];\nuniform vec4 cc_spotLitDir[2];\nuniform vec4 cc_spotLitColor[2];\nfloat SmoothDistAtt2(float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float factor2 = factor * factor;\n  float factor3 = factor2 * factor2;\n  float smoothFactor = clamp(1.0 - factor3 * factor3, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat SmoothDistAtt(float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt(float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt(vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GGXMobile(float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular(float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox(vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nvec3 CalcDynamicLighting(vec3 worldPos, vec3 N, vec3 V, vec3 diffuse, vec3 specular, float roughness) {\n  vec3 lighting = vec3(0.0);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  for (int i = 0; i < 2; i++) {\n    vec3 PLU = cc_sphereLitPos[i].xyz - worldPos;\n    vec3 PL = normalize(PLU);\n    vec3 PH = normalize(PL + V);\n    float PNL = max(dot(N, PL), 0.001);\n    float PNH = max(dot(N, PH), 0.0);\n    float distSqr = dot(PLU, PLU);\n    float litRadius = cc_sphereLitSizeRange[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);\n    lighting += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  for (int i = 0; i < 2; i++) {\n    vec3 SLU = cc_spotLitPos[i].xyz - worldPos;\n    vec3 SL = normalize(SLU);\n    vec3 SH = normalize(SL + V);\n    float SNL = max(dot(N, SL), 0.001);\n    float SNH = max(dot(N, SH), 0.0);\n    float distSqr = dot(SLU, SLU);\n    float litRadius = cc_spotLitSizeRangeAngle[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);\n    float cosOuter = cc_spotLitSizeRangeAngle[i].z;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    float litAngleOffset = -cosOuter * litAngleScale;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);\n    vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);\n    lighting += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  return lighting;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShading (StandardSurface s) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L+V);\n  float NV = max(abs(dot(N, V)), 0.001);\n  float NL = max(dot(N, L), 0.001);\n  float NH = max(dot(N, H), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);\n  finalColor += CalcDynamicLighting(s.position, N, V, diffuse, specular, s.roughness);\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    #ifdef GL_EXT_shader_texture_lod\n      vec4 envmap = textureCubeLodEXT(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #else\n      vec4 envmap = textureCube(cc_environment, R);\n    #endif\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb) * cc_ambientSky.w;\n    #endif\n    finalColor += env * specular;\n  #endif\n  finalColor = finalColor * s.occlusion;\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = LinearToSRGB(color.rgb);\n  #endif\n  return color;\n}\nuniform vec4 albedo;\nuniform vec4 albedoScale;\nuniform vec4 pbrParams;\nuniform vec4 pbrScale;\nuniform vec4 emissive;\nuniform vec4 emissiveScale;\nvarying vec3 v_position;\n#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP || USE_METALLIC_ROUGHNESS_MAP || USE_OCCLUSION_MAP\n  varying vec2 v_uv;\n#endif\nvarying vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScale.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScale.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, v_uv).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrScale.w) * normalize(v_tangent) +\n      (nmmp.y * pbrScale.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    pbr = texture2D(pbrMap, v_uv);\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, v_uv);\n    pbr.METALLIC_CHANNEL = metallicRoughness.METALLIC_CHANNEL;\n    pbr.ROUGHNESS_CHANNEL = metallicRoughness.ROUGHNESS_CHANNEL;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.OCCLUSION_CHANNEL = texture2D(occlusionMap, v_uv).OCCLUSION_CHANNEL;\n  #endif\n  pbr *= pbrScale;\n  s.roughness = clamp(pbr.ROUGHNESS_CHANNEL, 0.04, 1.0);\n  s.metallic = clamp(pbr.METALLIC_CHANNEL, 0.0, 0.96);\n  s.occlusion = pbr.OCCLUSION_CHANNEL;\n  s.emissive = emissive.rgb * emissiveScale.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, v_uv).rgb);\n  #endif\n}\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }\n"
                    },
                    builtins: {
                        globals: {
                            blocks: [ {
                                name: "CCGlobal",
                                defines: []
                            } ],
                            samplers: [ {
                                name: "cc_environment",
                                defines: [ "CC_USE_IBL" ]
                            } ]
                        },
                        locals: {
                            blocks: [ {
                                name: "CCLocal",
                                defines: []
                            }, {
                                name: "CCSkinningTexture",
                                defines: [ "CC_USE_SKINNING" ]
                            }, {
                                name: "CCSkinningAnimation",
                                defines: [ "CC_USE_SKINNING" ]
                            }, {
                                name: "CCForwardLight",
                                defines: []
                            } ],
                            samplers: [ {
                                name: "cc_jointsTexture",
                                defines: [ "CC_USE_SKINNING" ]
                            } ]
                        }
                    },
                    defines: [ {
                        name: "USE_BATCHING",
                        type: "boolean"
                    }, {
                        name: "CC_USE_SKINNING",
                        type: "number",
                        range: [ 0, 2 ]
                    }, {
                        name: "USE_NORMAL_MAP",
                        type: "boolean"
                    }, {
                        name: "USE_ALBEDO_MAP",
                        type: "boolean"
                    }, {
                        name: "CC_USE_IBL",
                        type: "number",
                        range: [ 0, 2 ]
                    }, {
                        name: "CC_USE_HDR",
                        type: "boolean"
                    }, {
                        name: "USE_PBR_MAP",
                        type: "boolean"
                    }, {
                        name: "USE_METALLIC_ROUGHNESS_MAP",
                        type: "boolean"
                    }, {
                        name: "USE_OCCLUSION_MAP",
                        type: "boolean"
                    }, {
                        name: "USE_EMISSIVE_MAP",
                        type: "boolean"
                    }, {
                        name: "ROUGHNESS_CHANNEL",
                        type: "string",
                        options: [ "r", "g", "b" ]
                    }, {
                        name: "METALLIC_CHANNEL",
                        type: "string",
                        options: [ "g", "r", "b" ]
                    }, {
                        name: "OCCLUSION_CHANNEL",
                        type: "string",
                        options: [ "b", "r", "g" ]
                    }, {
                        name: "USE_ALPHA_TEST",
                        type: "boolean"
                    }, {
                        name: "ALPHA_TEST_CHANNEL",
                        type: "string",
                        options: [ "a", "r", "g", "b" ]
                    } ],
                    blocks: [ {
                        name: "Constants",
                        defines: [],
                        binding: 0,
                        members: [ {
                            name: "tilingOffset",
                            type: 16,
                            count: 1
                        }, {
                            name: "albedo",
                            type: 16,
                            count: 1
                        }, {
                            name: "albedoScale",
                            type: 16,
                            count: 1
                        }, {
                            name: "pbrParams",
                            type: 16,
                            count: 1
                        }, {
                            name: "pbrScale",
                            type: 16,
                            count: 1
                        }, {
                            name: "emissive",
                            type: 16,
                            count: 1
                        }, {
                            name: "emissiveScale",
                            type: 16,
                            count: 1
                        } ]
                    } ],
                    samplers: [ {
                        name: "albedoMap",
                        type: 28,
                        count: 1,
                        defines: [ "USE_ALBEDO_MAP" ],
                        binding: 30
                    }, {
                        name: "normalMap",
                        type: 28,
                        count: 1,
                        defines: [ "USE_NORMAL_MAP" ],
                        binding: 31
                    }, {
                        name: "pbrMap",
                        type: 28,
                        count: 1,
                        defines: [ "USE_PBR_MAP" ],
                        binding: 32
                    }, {
                        name: "metallicRoughnessMap",
                        type: 28,
                        count: 1,
                        defines: [ "USE_METALLIC_ROUGHNESS_MAP" ],
                        binding: 33
                    }, {
                        name: "occlusionMap",
                        type: 28,
                        count: 1,
                        defines: [ "USE_OCCLUSION_MAP" ],
                        binding: 34
                    }, {
                        name: "emissiveMap",
                        type: 28,
                        count: 1,
                        defines: [ "USE_EMISSIVE_MAP" ],
                        binding: 35
                    } ]
                } ]
            }, {
                name: "builtin-terrain",
                techniques: [ {
                    name: "opaque",
                    passes: [ {
                        program: "builtin-terrain|terrain-vs:vert|terrain-fs:frag",
                        properties: {
                            UVScale: {
                                value: [ 1, 1, 1, 1 ],
                                type: 16
                            },
                            weightMap: {
                                value: "black",
                                type: 28
                            },
                            detailMap0: {
                                value: "grey",
                                type: 28
                            },
                            detailMap1: {
                                value: "grey",
                                type: 28
                            },
                            detailMap2: {
                                value: "grey",
                                type: 28
                            },
                            detailMap3: {
                                value: "grey",
                                type: 28
                            }
                        }
                    } ]
                } ],
                shaders: [ {
                    name: "builtin-terrain|terrain-vs:vert|terrain-fs:frag",
                    hash: 2907199317,
                    glsl3: {
                        vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp mat4 cc_matWorlds[10];\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nout vec2 uvw;\nout vec2 uv0;\nout vec2 uv1;\nout vec2 uv2;\nout vec2 uv3;\nout vec3 diffuse;\nuniform TexCoords {\n  vec4 UVScale;\n};\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  pos = cc_matViewProj * pos;\n  uvw = a_texCoord;\n  uv0 = a_position.xz * UVScale.x;\n  uv1 = a_position.xz * UVScale.y;\n  uv2 = a_position.xz * UVScale.z;\n  uv3 = a_position.xz * UVScale.w;\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 N = a_normal;\n  float fAmb = dot(N, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  diffuse = ambDiff + vec3(dot(N, L));\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n  in vec2 uvw;\n  in vec2 uv0;\n  in vec2 uv1;\n  in vec2 uv2;\n  in vec2 uv3;\n  in vec3 diffuse;\n  uniform sampler2D weightMap;\n  uniform sampler2D detailMap0;\n  uniform sampler2D detailMap1;\n  uniform sampler2D detailMap2;\n  uniform sampler2D detailMap3;\nvec4 frag () {\n  vec4 color = vec4(0, 0, 0, 0);\n  #if LAYERS == 1\n    color = texture(detailMap0, uv0);\n  #elif LAYERS == 2\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n  #elif LAYERS == 3\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n    color += texture(detailMap2, uv2) * w.b;\n  #elif LAYERS == 4\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n    color += texture(detailMap2, uv2) * w.b;\n    color += texture(detailMap3, uv3) * w.a;\n  #else\n    color = texture(detailMap0, uv0);\n  #endif\n  color.rgb *= diffuse;\n  return CCFragOutput(color);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
                    },
                    glsl1: {
                        vert: "\nprecision mediump float;\nuniform mat4 cc_matViewProj;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\nuniform highp mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nvarying vec2 uvw;\nvarying vec2 uv0;\nvarying vec2 uv1;\nvarying vec2 uv2;\nvarying vec2 uv3;\nvarying vec3 diffuse;\nuniform vec4 UVScale;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  pos = cc_matViewProj * pos;\n  uvw = a_texCoord;\n  uv0 = a_position.xz * UVScale.x;\n  uv1 = a_position.xz * UVScale.y;\n  uv2 = a_position.xz * UVScale.z;\n  uv3 = a_position.xz * UVScale.w;\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 N = a_normal;\n  float fAmb = dot(N, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  diffuse = ambDiff + vec3(dot(N, L));\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision mediump float;\nuniform vec4 cc_exposure;\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n  varying vec2 uvw;\n  varying vec2 uv0;\n  varying vec2 uv1;\n  varying vec2 uv2;\n  varying vec2 uv3;\n  varying vec3 diffuse;\n  uniform sampler2D weightMap;\n  uniform sampler2D detailMap0;\n  uniform sampler2D detailMap1;\n  uniform sampler2D detailMap2;\n  uniform sampler2D detailMap3;\nvec4 frag () {\n  vec4 color = vec4(0, 0, 0, 0);\n  #if LAYERS == 1\n    color = texture2D(detailMap0, uv0);\n  #elif LAYERS == 2\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n  #elif LAYERS == 3\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n    color += texture2D(detailMap2, uv2) * w.b;\n  #elif LAYERS == 4\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n    color += texture2D(detailMap2, uv2) * w.b;\n    color += texture2D(detailMap3, uv3) * w.a;\n  #else\n    color = texture2D(detailMap0, uv0);\n  #endif\n  color.rgb *= diffuse;\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }\n"
                    },
                    builtins: {
                        globals: {
                            blocks: [ {
                                name: "CCGlobal",
                                defines: []
                            } ],
                            samplers: []
                        },
                        locals: {
                            blocks: [ {
                                name: "CCLocal",
                                defines: []
                            } ],
                            samplers: []
                        }
                    },
                    defines: [ {
                        name: "CC_USE_HDR",
                        type: "boolean"
                    }, {
                        name: "LAYERS",
                        type: "number",
                        range: [ 0, 3 ]
                    } ],
                    blocks: [ {
                        name: "TexCoords",
                        defines: [],
                        binding: 0,
                        members: [ {
                            name: "UVScale",
                            type: 16,
                            count: 1
                        } ]
                    } ],
                    samplers: [ {
                        name: "weightMap",
                        type: 28,
                        count: 1,
                        defines: [],
                        binding: 30
                    }, {
                        name: "detailMap0",
                        type: 28,
                        count: 1,
                        defines: [],
                        binding: 31
                    }, {
                        name: "detailMap1",
                        type: 28,
                        count: 1,
                        defines: [],
                        binding: 32
                    }, {
                        name: "detailMap2",
                        type: 28,
                        count: 1,
                        defines: [],
                        binding: 33
                    }, {
                        name: "detailMap3",
                        type: 28,
                        count: 1,
                        defines: [],
                        binding: 34
                    } ]
                } ]
            }, {
                name: "builtin-unlit",
                techniques: [ {
                    name: "opaque",
                    passes: [ {
                        program: "builtin-unlit|unlit-vs:vert|unlit-fs:frag",
                        properties: {
                            color: {
                                value: [ 1, 1, 1, 1 ],
                                type: 16
                            },
                            tilingOffset: {
                                value: [ 1, 1, 0, 0 ],
                                type: 16
                            },
                            mainTexture: {
                                value: "grey",
                                type: 28
                            }
                        }
                    } ]
                } ],
                shaders: [ {
                    name: "builtin-unlit|unlit-vs:vert|unlit-fs:frag",
                    hash: 2096712480,
                    glsl3: {
                        vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp mat4 cc_matWorlds[10];\n};\nin vec3 a_position;\nvoid CCDecode (out vec4 position) {\n  position = vec4(a_position, 1.0);\n}\n#if CC_USE_SKINNING\nstruct StandardAttributes {\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  int index;\n};\nin vec4 a_weights;\nin vec4 a_joints;\nuniform CCSkinningTexture {\n  highp vec4 cc_jointsTextureInfo;\n};\nuniform CCSkinningAnimation {\n  highp vec4 cc_jointsAnimInfo;\n};\nuniform sampler2D cc_jointsTexture;\n#if CC_USE_SKINNING == 1\n  highp float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 12.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    Qt = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    S = vec3(\n      decode32(texture(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 10.5) * invSize, y)))\n    );\n  }\n#elif CC_USE_SKINNING == 2\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 3.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    Qt = texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    S = texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0); vec3 s;\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    getJointDQ(a_joints[i], r, t, s);\n    S += s * w; R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n  return v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout vec4 position) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  position.xyz = VectorTransformQuat(position.xyz * S, R) + T;\n}\nvoid CCSkin(inout StandardAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position.xyz = VectorTransformQuat(attr.position.xyz * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent.xyz = VectorTransformQuat(attr.tangent.xyz, R);\n}\n#endif\nvoid CCVertInput (out highp vec4 position) {\n  CCDecode(position);\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n}\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\n#if USE_TEXTURE\n  in vec2 a_texCoord;\n  out vec2 v_uv;\n  uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nhighp vec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  highp vec4 pos = cc_matViewProj * cc_matWorld * position;\n  #if USE_TEXTURE\n    v_uv = a_texCoord;\n  #if FLIP_UV\n    v_uv.y = 1.0 - v_uv.y;\n  #endif\n    v_uv = v_uv * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n#if USE_TEXTURE\n  in vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\n#if USE_COLOR\n  uniform Constant {\n    vec4 color;\n  };\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture(mainTexture, v_uv);\n  #endif\n  #if USE_COLOR\n    o *= color;\n  #endif\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  return CCFragOutput(o);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
                    },
                    glsl1: {
                        vert: "\nprecision mediump float;\nuniform mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nattribute vec3 a_position;\nvoid CCDecode (out vec4 position) {\n  position = vec4(a_position, 1.0);\n}\n#if CC_USE_SKINNING\nstruct StandardAttributes {\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  int index;\n};\nattribute vec4 a_weights;\nattribute vec4 a_joints;\nuniform highp vec4 cc_jointsTextureInfo;\nuniform highp vec4 cc_jointsAnimInfo;\nuniform sampler2D cc_jointsTexture;\n#if CC_USE_SKINNING == 1\n  highp float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 12.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    Qt = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    S = vec3(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 10.5) * invSize, y)))\n    );\n  }\n#elif CC_USE_SKINNING == 2\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 3.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    Qt = texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    S = texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0); vec3 s;\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    getJointDQ(a_joints[i], r, t, s);\n    S += s * w; R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n  return v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout vec4 position) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  position.xyz = VectorTransformQuat(position.xyz * S, R) + T;\n}\nvoid CCSkin(inout StandardAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position.xyz = VectorTransformQuat(attr.position.xyz * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent.xyz = VectorTransformQuat(attr.tangent.xyz, R);\n}\n#endif\nvoid CCVertInput (out highp vec4 position) {\n  CCDecode(position);\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n}\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\n#if USE_TEXTURE\n  attribute vec2 a_texCoord;\n  varying vec2 v_uv;\n  uniform vec4 tilingOffset;\n#endif\nhighp vec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  highp vec4 pos = cc_matViewProj * cc_matWorld * position;\n  #if USE_TEXTURE\n    v_uv = a_texCoord;\n  #if FLIP_UV\n    v_uv.y = 1.0 - v_uv.y;\n  #endif\n    v_uv = v_uv * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision mediump float;\nuniform vec4 cc_exposure;\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\n#if USE_COLOR\n  uniform vec4 color;\n#endif\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, v_uv);\n  #endif\n  #if USE_COLOR\n    o *= color;\n  #endif\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  return CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }\n"
                    },
                    builtins: {
                        globals: {
                            blocks: [ {
                                name: "CCGlobal",
                                defines: []
                            } ],
                            samplers: []
                        },
                        locals: {
                            blocks: [ {
                                name: "CCLocal",
                                defines: []
                            }, {
                                name: "CCSkinningTexture",
                                defines: [ "CC_USE_SKINNING" ]
                            }, {
                                name: "CCSkinningAnimation",
                                defines: [ "CC_USE_SKINNING" ]
                            } ],
                            samplers: [ {
                                name: "cc_jointsTexture",
                                defines: [ "CC_USE_SKINNING" ]
                            } ]
                        }
                    },
                    defines: [ {
                        name: "CC_USE_SKINNING",
                        type: "number",
                        range: [ 0, 2 ]
                    }, {
                        name: "USE_VERTEX_COLOR",
                        type: "boolean"
                    }, {
                        name: "USE_TEXTURE",
                        type: "boolean"
                    }, {
                        name: "FLIP_UV",
                        type: "boolean"
                    }, {
                        name: "CC_USE_HDR",
                        type: "boolean"
                    }, {
                        name: "USE_COLOR",
                        type: "boolean"
                    } ],
                    blocks: [ {
                        name: "TexCoords",
                        defines: [ "USE_TEXTURE" ],
                        binding: 0,
                        members: [ {
                            name: "tilingOffset",
                            type: 16,
                            count: 1
                        } ]
                    }, {
                        name: "Constant",
                        defines: [ "USE_COLOR" ],
                        binding: 1,
                        members: [ {
                            name: "color",
                            type: 16,
                            count: 1
                        } ]
                    } ],
                    samplers: [ {
                        name: "mainTexture",
                        type: 28,
                        count: 1,
                        defines: [ "USE_TEXTURE" ],
                        binding: 30
                    } ]
                } ]
            }, {
                name: "editor/terrain-circle-brush",
                techniques: [ {
                    name: "transparent",
                    passes: [ {
                        blendState: {
                            targets: [ {
                                blend: !0,
                                blendSrc: 2,
                                blendDst: 4,
                                blendDstAlpha: 4
                            } ]
                        },
                        program: "editor/terrain-circle-brush|terrain-brush-vs:vert|terrain-brush-fs:frag",
                        depthStencilState: {
                            depthTest: !0,
                            depthWrite: !1
                        },
                        properties: {
                            BrushPos: {
                                value: [ 0, 0, 0, 1 ],
                                type: 16
                            },
                            BrushParams: {
                                value: [ 2.5, 2.5, 0, 0 ],
                                type: 16
                            }
                        }
                    } ]
                } ],
                shaders: [ {
                    name: "editor/terrain-circle-brush|terrain-brush-vs:vert|terrain-brush-fs:frag",
                    hash: 394086792,
                    glsl3: {
                        vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp mat4 cc_matWorlds[10];\n};\nin vec3 a_position;\nout vec4 wposition;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  wposition = cc_matWorld * pos;\n  wposition.y += 0.01;\n  pos = cc_matViewProj * wposition;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nin vec4 wposition;\nuniform TexCoords {\n  vec4 BrushPos;\n  vec4 BrushParams;\n};\nvec4 frag () {\n  float Radius = BrushParams.x;\n  float Falloff = BrushParams.y;\n  float Distance = length(wposition.xz - BrushPos.xz);\n  float k = 0.0;\n  #if LINEAR\n    if (Distance <= Radius) {\n      k = 1.0;\n    }\n    else if (Distance > Radius + Falloff) {\n      k = 0.0;\n    }\n    else {\n      k = max(0.0, 1.0 - (Distance - Radius) / Falloff);\n    }\n  #elif SMOOTH\n    if (Distance <= Radius) {\n      k = 1.0;\n    }\n    else if (Distance > Radius + Falloff) {\n      k = 0.0;\n    }\n    else {\n      float y = (Distance - Radius) / Falloff;\n      k = sqrt(1.0 - y * y);\n    }\n  #elif SPHERICAL\n    if (Distance <= Radius) {\n      k = 1.0;\n    }\n    else if (Distance > Radius + Falloff) {\n      k = 0.0;\n    }\n    else {\n      k = max(0.0, 1.0 - (Distance - Radius) / Falloff);\n    }\n    k = k*k*(3 - 2 * k);\n  #elif TIP\n    if (Distance <= Radius) {\n      k = 1.0;\n    }\n    else if (Distance > Radius + Falloff) {\n      k = 0.0;\n    }\n    else {\n      float y = (Falloff + Radius - Distance) / Falloff;\n      k = 1.0 - sqrt(1.0 - y * y);\n    }\n  #endif\n  vec4 color = vec4(0, 0, 0, 0);\n  color.rgb = vec3(100, 100, 135) / 255.0;\n  color.a = 0.85 * k;\n  return CCFragOutput(color);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
                    },
                    glsl1: {
                        vert: "\nprecision mediump float;\nuniform mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nattribute vec3 a_position;\nvarying vec4 wposition;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  wposition = cc_matWorld * pos;\n  wposition.y += 0.01;\n  pos = cc_matViewProj * wposition;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision mediump float;\nuniform vec4 cc_exposure;\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvarying vec4 wposition;\nuniform vec4 BrushPos;\nuniform vec4 BrushParams;\nvec4 frag () {\n  float Radius = BrushParams.x;\n  float Falloff = BrushParams.y;\n  float Distance = length(wposition.xz - BrushPos.xz);\n  float k = 0.0;\n  #if LINEAR\n    if (Distance <= Radius) {\n      k = 1.0;\n    }\n    else if (Distance > Radius + Falloff) {\n      k = 0.0;\n    }\n    else {\n      k = max(0.0, 1.0 - (Distance - Radius) / Falloff);\n    }\n  #elif SMOOTH\n    if (Distance <= Radius) {\n      k = 1.0;\n    }\n    else if (Distance > Radius + Falloff) {\n      k = 0.0;\n    }\n    else {\n      float y = (Distance - Radius) / Falloff;\n      k = sqrt(1.0 - y * y);\n    }\n  #elif SPHERICAL\n    if (Distance <= Radius) {\n      k = 1.0;\n    }\n    else if (Distance > Radius + Falloff) {\n      k = 0.0;\n    }\n    else {\n      k = max(0.0, 1.0 - (Distance - Radius) / Falloff);\n    }\n    k = k*k*(3 - 2 * k);\n  #elif TIP\n    if (Distance <= Radius) {\n      k = 1.0;\n    }\n    else if (Distance > Radius + Falloff) {\n      k = 0.0;\n    }\n    else {\n      float y = (Falloff + Radius - Distance) / Falloff;\n      k = 1.0 - sqrt(1.0 - y * y);\n    }\n  #endif\n  vec4 color = vec4(0, 0, 0, 0);\n  color.rgb = vec3(100, 100, 135) / 255.0;\n  color.a = 0.85 * k;\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }\n"
                    },
                    builtins: {
                        globals: {
                            blocks: [ {
                                name: "CCGlobal",
                                defines: []
                            } ],
                            samplers: []
                        },
                        locals: {
                            blocks: [ {
                                name: "CCLocal",
                                defines: []
                            } ],
                            samplers: []
                        }
                    },
                    defines: [ {
                        name: "CC_USE_HDR",
                        type: "boolean"
                    }, {
                        name: "LINEAR",
                        type: "boolean"
                    }, {
                        name: "SMOOTH",
                        type: "boolean"
                    }, {
                        name: "SPHERICAL",
                        type: "boolean"
                    }, {
                        name: "TIP",
                        type: "boolean"
                    } ],
                    blocks: [ {
                        name: "TexCoords",
                        defines: [],
                        binding: 0,
                        members: [ {
                            name: "BrushPos",
                            type: 16,
                            count: 1
                        }, {
                            name: "BrushParams",
                            type: 16,
                            count: 1
                        } ]
                    } ],
                    samplers: []
                } ]
            }, {
                name: "pipeline/planar-shadow",
                techniques: [ {
                    passes: [ {
                        phase: "planarShadow",
                        blendState: {
                            targets: [ {
                                blend: !0,
                                blendSrc: 2,
                                blendDst: 4,
                                blendDstAlpha: 4
                            } ]
                        },
                        program: "pipeline/planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
                        depthStencilState: {
                            depthTest: !0,
                            depthWrite: !1,
                            stencilTestFront: !0,
                            stencilFuncFront: 5,
                            stencilPassOpFront: 2,
                            stencilRefBack: 128,
                            stencilRefFront: 128,
                            stencilReadMaskBack: 128,
                            stencilReadMaskFront: 128,
                            stencilWriteMaskBack: 128,
                            stencilWriteMaskFront: 128
                        }
                    } ]
                } ],
                shaders: [ {
                    name: "pipeline/planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
                    hash: 2934695859,
                    glsl3: {
                        vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp mat4 cc_matWorlds[10];\n};\nuniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  vec4 cc_shadowColor;\n};\nin vec3 a_position;\nvoid CCDecode (out vec4 position) {\n  position = vec4(a_position, 1.0);\n}\n#if CC_USE_SKINNING\nstruct StandardAttributes {\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  int index;\n};\nin vec4 a_weights;\nin vec4 a_joints;\nuniform CCSkinningTexture {\n  highp vec4 cc_jointsTextureInfo;\n};\nuniform CCSkinningAnimation {\n  highp vec4 cc_jointsAnimInfo;\n};\nuniform sampler2D cc_jointsTexture;\n#if CC_USE_SKINNING == 1\n  highp float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 12.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    Qt = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    S = vec3(\n      decode32(texture(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 10.5) * invSize, y)))\n    );\n  }\n#elif CC_USE_SKINNING == 2\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 3.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    Qt = texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    S = texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0); vec3 s;\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    getJointDQ(a_joints[i], r, t, s);\n    S += s * w; R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n  return v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout vec4 position) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  position.xyz = VectorTransformQuat(position.xyz * S, R) + T;\n}\nvoid CCSkin(inout StandardAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position.xyz = VectorTransformQuat(attr.position.xyz * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent.xyz = VectorTransformQuat(attr.tangent.xyz, R);\n}\n#endif\nvoid CCVertInput (out highp vec4 position) {\n  CCDecode(position);\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n}\nhighp vec4 vert () {\n  highp vec4 position;\n  CCVertInput(position);\n  position = cc_matViewProj * cc_matLightPlaneProj * cc_matWorld * position;\n  position.z -= 0.0001;\n  return position;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision mediump float;\nuniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  vec4 cc_shadowColor;\n};\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvec4 frag () {\n  return CCFragOutput(cc_shadowColor);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
                    },
                    glsl1: {
                        vert: "\nprecision mediump float;\nuniform mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matLightPlaneProj;\nattribute vec3 a_position;\nvoid CCDecode (out vec4 position) {\n  position = vec4(a_position, 1.0);\n}\n#if CC_USE_SKINNING\nstruct StandardAttributes {\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  int index;\n};\nattribute vec4 a_weights;\nattribute vec4 a_joints;\nuniform highp vec4 cc_jointsTextureInfo;\nuniform highp vec4 cc_jointsAnimInfo;\nuniform sampler2D cc_jointsTexture;\n#if CC_USE_SKINNING == 1\n  highp float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 12.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    Qt = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    S = vec3(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 10.5) * invSize, y)))\n    );\n  }\n#elif CC_USE_SKINNING == 2\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 3.0 * (cc_jointsAnimInfo.x * i + cc_jointsAnimInfo.y) + cc_jointsTextureInfo.z;\n    highp float invSize = cc_jointsTextureInfo.y;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    Qt = texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    S = texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0); vec3 s;\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    getJointDQ(a_joints[i], r, t, s);\n    S += s * w; R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n  return v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout vec4 position) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  position.xyz = VectorTransformQuat(position.xyz * S, R) + T;\n}\nvoid CCSkin(inout StandardAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position.xyz = VectorTransformQuat(attr.position.xyz * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent.xyz = VectorTransformQuat(attr.tangent.xyz, R);\n}\n#endif\nvoid CCVertInput (out highp vec4 position) {\n  CCDecode(position);\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n}\nhighp vec4 vert () {\n  highp vec4 position;\n  CCVertInput(position);\n  position = cc_matViewProj * cc_matLightPlaneProj * cc_matWorld * position;\n  position.z -= 0.0001;\n  return position;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision mediump float;\nuniform vec4 cc_shadowColor;\nuniform vec4 cc_exposure;\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvec4 frag () {\n  return CCFragOutput(cc_shadowColor);\n}\nvoid main() { gl_FragColor = frag(); }\n"
                    },
                    builtins: {
                        globals: {
                            blocks: [ {
                                name: "CCGlobal",
                                defines: []
                            }, {
                                name: "CCShadow",
                                defines: []
                            } ],
                            samplers: []
                        },
                        locals: {
                            blocks: [ {
                                name: "CCLocal",
                                defines: []
                            }, {
                                name: "CCSkinningTexture",
                                defines: [ "CC_USE_SKINNING" ]
                            }, {
                                name: "CCSkinningAnimation",
                                defines: [ "CC_USE_SKINNING" ]
                            } ],
                            samplers: [ {
                                name: "cc_jointsTexture",
                                defines: [ "CC_USE_SKINNING" ]
                            } ]
                        }
                    },
                    defines: [ {
                        name: "CC_USE_SKINNING",
                        type: "number",
                        range: [ 0, 2 ]
                    }, {
                        name: "CC_USE_HDR",
                        type: "boolean"
                    } ],
                    blocks: [],
                    samplers: []
                } ]
            }, {
                name: "pipeline/skybox",
                techniques: [ {
                    passes: [ {
                        rasterizerState: {
                            cullMode: 0
                        },
                        program: "pipeline/skybox|sky-vs:vert|sky-fs:frag",
                        priority: 245,
                        depthStencilState: {
                            depthTest: !0,
                            depthWrite: !1
                        }
                    } ]
                } ],
                shaders: [ {
                    name: "pipeline/skybox|sky-vs:vert|sky-fs:frag",
                    hash: 234120969,
                    glsl3: {
                        vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec3 a_position;\nvoid CCDecode (out vec4 position) {\n  position = vec4(a_position, 1.0);\n}\nout vec4 viewDir;\nhighp vec4 vert () {\n  CCDecode(viewDir);\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  highp vec4 pos = matViewRotOnly * viewDir;\n  highp vec2 f = cc_matProj[3][3] > 0.0 ? vec2(4.8, 2.4) : vec2(cc_matProj[1][1]);\n  pos.xy *= vec2(cc_screenSize.y * cc_screenSize.z, 1.0) * f;\n  pos.zw = vec2(-0.99999 * pos.z, -pos.z);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform samplerCube cc_environment;\nvec3 unpackNormal(vec4 nmap) {\n  return nmap.xyz * 2.0 - 1.0;\n}\nvec3 unpackRGBE(vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = LinearToSRGB(color.rgb);\n  #endif\n  return color;\n}\nin vec4 viewDir;\nvec4 frag () {\n  #if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(texture(cc_environment, viewDir.xyz));\n  #else\n    vec3 c = SRGBToLinear(texture(cc_environment, viewDir.xyz).rgb) * cc_ambientSky.w;\n  #endif\n  return CCFragOutput(vec4(c, 1.0));\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
                    },
                    glsl1: {
                        vert: "\nprecision mediump float;\nuniform vec4 cc_screenSize;\nuniform mat4 cc_matView;\nuniform mat4 cc_matProj;\nattribute vec3 a_position;\nvoid CCDecode (out vec4 position) {\n  position = vec4(a_position, 1.0);\n}\nvarying vec4 viewDir;\nhighp vec4 vert () {\n  CCDecode(viewDir);\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  highp vec4 pos = matViewRotOnly * viewDir;\n  highp vec2 f = cc_matProj[3][3] > 0.0 ? vec2(4.8, 2.4) : vec2(cc_matProj[1][1]);\n  pos.xy *= vec2(cc_screenSize.y * cc_screenSize.z, 1.0) * f;\n  pos.zw = vec2(-0.99999 * pos.z, -pos.z);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision mediump float;\nuniform vec4 cc_ambientSky;\nuniform samplerCube cc_environment;\nvec3 unpackNormal(vec4 nmap) {\n  return nmap.xyz * 2.0 - 1.0;\n}\nvec3 unpackRGBE(vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = LinearToSRGB(color.rgb);\n  #endif\n  return color;\n}\nvarying vec4 viewDir;\nvec4 frag () {\n  #if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(textureCube(cc_environment, viewDir.xyz));\n  #else\n    vec3 c = SRGBToLinear(textureCube(cc_environment, viewDir.xyz).rgb) * cc_ambientSky.w;\n  #endif\n  return CCFragOutput(vec4(c, 1.0));\n}\nvoid main() { gl_FragColor = frag(); }\n"
                    },
                    builtins: {
                        globals: {
                            blocks: [ {
                                name: "CCGlobal",
                                defines: []
                            } ],
                            samplers: [ {
                                name: "cc_environment",
                                defines: []
                            } ]
                        },
                        locals: {
                            blocks: [],
                            samplers: []
                        }
                    },
                    defines: [ {
                        name: "CC_USE_IBL",
                        type: "number",
                        range: [ 0, 2 ]
                    }, {
                        name: "CC_USE_HDR",
                        type: "boolean"
                    }, {
                        name: "USE_RGBE_CUBEMAP",
                        type: "boolean"
                    } ],
                    blocks: [],
                    samplers: []
                } ]
            }, {
                name: "pipeline/smaa",
                techniques: [ {
                    name: "smaa",
                    passes: [ {
                        program: "pipeline/smaa|smaa-edge-vs:vert|smaa-edge-fs:frag",
                        depthStencilState: {
                            depthTest: !1,
                            depthWrite: !1
                        },
                        properties: {
                            u_texSampler: {
                                type: 28,
                                samplerHash: 66186
                            }
                        }
                    }, {
                        program: "pipeline/smaa|smaa-blend-vs:vert|smaa-blend-fs:frag",
                        depthStencilState: {
                            depthTest: !1,
                            depthWrite: !1
                        },
                        properties: {
                            u_edgeTexSampler: {
                                type: 28,
                                samplerHash: 66186
                            },
                            u_areaTexSampler: {
                                type: 28,
                                samplerHash: 66186
                            },
                            u_searchTexSampler: {
                                type: 28,
                                samplerHash: 66181
                            }
                        }
                    } ]
                } ],
                shaders: [ {
                    name: "pipeline/smaa|smaa-edge-vs:vert|smaa-edge-fs:frag",
                    hash: 2142686600,
                    glsl3: {
                        vert: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nout vec4 v_offsets[3];\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0.0, 1.0);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_offsets[0] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-1.0, 0.0, 0.0, 1.0);\n  v_offsets[1] = v_uv.xyxy + cc_nativeSize.zwzw * vec4( 1.0, 0.0, 0.0, -1.0);\n  v_offsets[2] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-2.0, 0.0, 0.0, 2.0);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n#define saturate(a) clamp( a, 0.0, 1.0 )\nhighp mat4 transposeMat4(in highp mat4 mat) {\n    highp vec4 i0 = mat[0];\n    highp vec4 i1 = mat[1];\n    highp vec4 i2 = mat[2];\n    highp vec4 i3 = mat[3];\n    return mat4(vec4(i0.x, i1.x, i2.x, i3.x),\n                vec4(i0.y, i1.y, i2.y, i3.y),\n                vec4(i0.z, i1.z, i2.z, i3.z),\n                vec4(i0.w, i1.w, i2.w, i3.w));\n}\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec3 ACESToneMap(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nin vec2 v_uv;\nin vec4 v_offsets[3];\nuniform sampler2D u_texSampler;\nvec3 ToLDR(vec3 color) {\n#if CC_USE_HDR\n  color *= cc_exposure.x * 1024.0;\n  color = ACESToneMap(color);\n  color = LinearToSRGB(color);\n#endif\n  return color;\n}\nvec4 frag () {\n  vec2 threshold = vec2(0.1, 0.1);\n  vec4 delta;\n  vec3 C = ToLDR(texture(u_texSampler, v_uv).rgb);\n  vec3 Cleft = ToLDR(texture(u_texSampler, v_offsets[0].xy).rgb);\n  vec3 t = abs(C - Cleft);\n  delta.x = max(max(t.r, t.g), t.b);\n  vec3 Ctop = ToLDR(texture(u_texSampler, v_offsets[0].zw).rgb);\n  t = abs(C - Ctop);\n  delta.y = max(max(t.r, t.g), t.b);\n  vec2 edges = step(threshold, delta.xy);\n  if (dot(edges, vec2(1.0, 1.0)) == 0.0)\n    discard;\n  vec3 Cright = ToLDR(texture(u_texSampler, v_offsets[1].xy).rgb);\n  t = abs(C - Cright);\n  delta.z = max(max(t.r, t.g), t.b);\n  vec3 Cbottom = ToLDR(texture(u_texSampler, v_offsets[1].zw).rgb);\n  t = abs(C - Cbottom);\n  delta.w = max(max(t.r, t.g), t.b);\n  float maxDelta = max(max(max(delta.x, delta.y), delta.z), delta.w);\n  vec3 Cleftleft = ToLDR(texture(u_texSampler, v_offsets[2].xy).rgb);\n  t = abs(C - Cleftleft);\n  delta.z = max(max(t.r, t.g), t.b);\n  vec3 Ctoptop = ToLDR(texture(u_texSampler, v_offsets[2].zw).rgb);\n  t = abs(C - Ctoptop);\n  delta.w = max(max(t.r, t.g), t.b);\n  maxDelta = max(max(maxDelta, delta.z), delta.w);\n  edges.xy *= step(0.5 * maxDelta, delta.xy);\n  vec4 o = vec4(edges, 0.0, 0.0);\n  return o;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
                    },
                    glsl1: {
                        vert: "\nprecision highp float;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nvarying vec4 v_offsets[3];\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0.0, 1.0);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_offsets[0] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-1.0, 0.0, 0.0, 1.0);\n  v_offsets[1] = v_uv.xyxy + cc_nativeSize.zwzw * vec4( 1.0, 0.0, 0.0, -1.0);\n  v_offsets[2] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-2.0, 0.0, 0.0, 2.0);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision highp float;\nuniform vec4 cc_exposure;\n#define saturate(a) clamp( a, 0.0, 1.0 )\nhighp mat4 transposeMat4(in highp mat4 mat) {\n    highp vec4 i0 = mat[0];\n    highp vec4 i1 = mat[1];\n    highp vec4 i2 = mat[2];\n    highp vec4 i3 = mat[3];\n    return mat4(vec4(i0.x, i1.x, i2.x, i3.x),\n                vec4(i0.y, i1.y, i2.y, i3.y),\n                vec4(i0.z, i1.z, i2.z, i3.z),\n                vec4(i0.w, i1.w, i2.w, i3.w));\n}\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec3 ACESToneMap(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvarying vec2 v_uv;\nvarying vec4 v_offsets[3];\nuniform sampler2D u_texSampler;\nvec3 ToLDR(vec3 color) {\n#if CC_USE_HDR\n  color *= cc_exposure.x * 1024.0;\n  color = ACESToneMap(color);\n  color = LinearToSRGB(color);\n#endif\n  return color;\n}\nvec4 frag () {\n  vec2 threshold = vec2(0.1, 0.1);\n  vec4 delta;\n  vec3 C = ToLDR(texture2D(u_texSampler, v_uv).rgb);\n  vec3 Cleft = ToLDR(texture2D(u_texSampler, v_offsets[0].xy).rgb);\n  vec3 t = abs(C - Cleft);\n  delta.x = max(max(t.r, t.g), t.b);\n  vec3 Ctop = ToLDR(texture2D(u_texSampler, v_offsets[0].zw).rgb);\n  t = abs(C - Ctop);\n  delta.y = max(max(t.r, t.g), t.b);\n  vec2 edges = step(threshold, delta.xy);\n  if (dot(edges, vec2(1.0, 1.0)) == 0.0)\n    discard;\n  vec3 Cright = ToLDR(texture2D(u_texSampler, v_offsets[1].xy).rgb);\n  t = abs(C - Cright);\n  delta.z = max(max(t.r, t.g), t.b);\n  vec3 Cbottom = ToLDR(texture2D(u_texSampler, v_offsets[1].zw).rgb);\n  t = abs(C - Cbottom);\n  delta.w = max(max(t.r, t.g), t.b);\n  float maxDelta = max(max(max(delta.x, delta.y), delta.z), delta.w);\n  vec3 Cleftleft = ToLDR(texture2D(u_texSampler, v_offsets[2].xy).rgb);\n  t = abs(C - Cleftleft);\n  delta.z = max(max(t.r, t.g), t.b);\n  vec3 Ctoptop = ToLDR(texture2D(u_texSampler, v_offsets[2].zw).rgb);\n  t = abs(C - Ctoptop);\n  delta.w = max(max(t.r, t.g), t.b);\n  maxDelta = max(max(maxDelta, delta.z), delta.w);\n  edges.xy *= step(0.5 * maxDelta, delta.xy);\n  vec4 o = vec4(edges, 0.0, 0.0);\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }\n"
                    },
                    builtins: {
                        globals: {
                            blocks: [ {
                                name: "CCGlobal",
                                defines: []
                            } ],
                            samplers: []
                        },
                        locals: {
                            blocks: [],
                            samplers: []
                        }
                    },
                    defines: [ {
                        name: "CC_USE_HDR",
                        type: "boolean"
                    } ],
                    blocks: [],
                    samplers: [ {
                        name: "u_texSampler",
                        type: 28,
                        count: 1,
                        defines: [],
                        binding: 30
                    } ]
                }, {
                    name: "pipeline/smaa|smaa-blend-vs:vert|smaa-blend-fs:frag",
                    hash: 1697076750,
                    glsl3: {
                        vert: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nout vec4 v_offsets[3];\nout vec2 v_pixCoord;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0.0, 1.0);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_pixCoord = v_uv * cc_nativeSize.xy;\n  v_offsets[0] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-0.25, 0.125, 1.25, 0.125);\n  v_offsets[1] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-0.125, 0.25, -0.125, -1.25);\n  v_offsets[2] = vec4(v_offsets[0].xz, v_offsets[1].yw) + vec4(-2.0, 2.0, -2.0, 2.0) * cc_nativeSize.zzww * float(8);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec2 v_uv;\nin vec4 v_offsets[3];\nin vec2 v_pixCoord;\nuniform sampler2D u_edgeTexSampler;\nuniform sampler2D u_areaTexSampler;\nuniform sampler2D u_searchTexSampler;\nfloat SMAASearchLength(vec2 e, float bias, float scale) {\n  e.r = bias + e.r * scale;\n  return 255.0 * texture(u_searchTexSampler, e).r;\n}\nfloat SMAASearchXLeft(vec2 texcoord, float end) {\n  vec2 e = vec2(0.0, 1.0);\n  for (int i = 0; i < 8; ++i) {\n      e = texture(u_edgeTexSampler, texcoord).rg;\n      texcoord -= vec2( 2.0, 0.0 ) * cc_nativeSize.zw;\n      if (!(texcoord.x > end && e.g > 0.8281 && e.r == 0.0))\n        break;\n  }\n  texcoord.x += 0.25 * cc_nativeSize.z;\n  texcoord.x += cc_nativeSize.z;\n  texcoord.x += 2.0 * cc_nativeSize.z;\n  texcoord.x -= cc_nativeSize.z * SMAASearchLength(e, 0.0, 0.5);\n  return texcoord.x;\n}\nfloat SMAASearchXRight(vec2 texcoord, float end) {\n  vec2 e = vec2(0.0, 1.0);\n  for (int i = 0; i < 8; ++i) {\n      e = texture(u_edgeTexSampler, texcoord).rg;\n      texcoord += vec2( 2.0, 0.0 ) * cc_nativeSize.zw;\n      if (!(texcoord.x < end && e.g > 0.8281 && e.r == 0.0))\n        break;\n  }\n  texcoord.x -= 0.25 * cc_nativeSize.z;\n  texcoord.x -= cc_nativeSize.z;\n  texcoord.x -= 2.0 * cc_nativeSize.z;\n  texcoord.x += cc_nativeSize.z * SMAASearchLength(e, 0.5, 0.5);\n  return texcoord.x;\n}\nfloat SMAASearchYUp(vec2 texcoord, float end) {\n    vec2 e = vec2(1.0, 0.0);\n    for (int i = 0; i < 8; ++i) {\n        e = texture(u_edgeTexSampler, texcoord).rg;\n        texcoord += vec2( 0.0, 2.0 ) * cc_nativeSize.zw;\n        if (!(texcoord.y > end && e.r > 0.8281 && e.g == 0.0))\n          break;\n    }\n    texcoord.y -= 0.25 * cc_nativeSize.w;\n    texcoord.y -= cc_nativeSize.w;\n    texcoord.y -= 2.0 * cc_nativeSize.w;\n    texcoord.y += cc_nativeSize.w * SMAASearchLength(e.gr, 0.0, 0.5);\n    return texcoord.y;\n}\nfloat SMAASearchYDown(vec2 texcoord, float end) {\n    vec2 e = vec2(1.0, 0.0);\n    for (int i = 0; i < 8; ++i) {\n        e = texture(u_edgeTexSampler, texcoord).rg;\n        texcoord -= vec2( 0.0, 2.0 ) * cc_nativeSize.zw;\n        if (!(texcoord.y < end && e.r > 0.8281 && e.g == 0.0))\n          break;\n    }\n    texcoord.y += 0.25 * cc_nativeSize.w;\n    texcoord.y += cc_nativeSize.w;\n    texcoord.y += 2.0 * cc_nativeSize.w;\n    texcoord.y -= cc_nativeSize.w * SMAASearchLength(e.gr, 0.5, 0.5);\n    return texcoord.y;\n}\nvec2 Round(vec2 x) {\n  return sign(x) * floor(abs(x) + 0.5);\n}\nvec2 SMAAArea(vec2 dist, float e1, float e2) {\n    vec2 texcoord = float(16) * Round(4.0 * vec2(e1, e2)) + dist;\n    texcoord = (1.0 / vec2(160.0, 560.0)) * texcoord + 0.5 * (1.0 / vec2(160.0, 560.0));\n    return texture(u_areaTexSampler, texcoord).rg;\n}\nvec4 frag () {\n  vec4 weights = vec4(0.0);\n  vec2 e = texture(u_edgeTexSampler, v_uv).rg;\n  vec2 d;\n  vec2 coords;\n  if ( e.g > 0.0 ) {\n      coords.x = SMAASearchXLeft(v_offsets[0].xy, v_offsets[2].x);\n      coords.y = v_offsets[1].y;\n      d.x = coords.x;\n      float e1 = texture(u_edgeTexSampler, coords).r;\n      coords.x = SMAASearchXRight(v_offsets[0].zw, v_offsets[2].y);\n      d.y = coords.x;\n      d = d / cc_nativeSize.z - v_pixCoord.x;\n      vec2 sqrt_d = sqrt(abs(d));\n      coords.y -= 1.0 * cc_nativeSize.w;\n      float e2 = texture(u_edgeTexSampler, coords + vec2(cc_nativeSize.z, 0.0)).r;\n      weights.rg = SMAAArea(sqrt_d, e1, e2);\n  }\n  if ( e.r > 0.0 ) {\n      coords.y = SMAASearchYUp(v_offsets[1].xy, v_offsets[2].z);\n      coords.x = v_offsets[0].x;\n      d.x = coords.y;\n      float e1 = texture(u_edgeTexSampler, coords).g;\n      coords.y = SMAASearchYDown(v_offsets[1].zw, v_offsets[2].w);\n      d.y = coords.y;\n      d = d / cc_nativeSize.w - v_pixCoord.y;\n      vec2 sqrt_d = sqrt(abs(d));\n      coords.y -= 1.0 * cc_nativeSize.w;\n      float e2 = texture(u_edgeTexSampler, coords + vec2(0.0, cc_nativeSize.w)).g;\n      weights.ba = SMAAArea(sqrt_d, e1, e2);\n  }\n  return weights;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
                    },
                    glsl1: {
                        vert: "\nprecision highp float;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nvarying vec4 v_offsets[3];\nvarying vec2 v_pixCoord;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0.0, 1.0);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_pixCoord = v_uv * cc_nativeSize.xy;\n  v_offsets[0] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-0.25, 0.125, 1.25, 0.125);\n  v_offsets[1] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-0.125, 0.25, -0.125, -1.25);\n  v_offsets[2] = vec4(v_offsets[0].xz, v_offsets[1].yw) + vec4(-2.0, 2.0, -2.0, 2.0) * cc_nativeSize.zzww * float(8);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision highp float;\nuniform vec4 cc_nativeSize;\nvarying vec2 v_uv;\nvarying vec4 v_offsets[3];\nvarying vec2 v_pixCoord;\nuniform sampler2D u_edgeTexSampler;\nuniform sampler2D u_areaTexSampler;\nuniform sampler2D u_searchTexSampler;\nfloat SMAASearchLength(vec2 e, float bias, float scale) {\n  e.r = bias + e.r * scale;\n  return 255.0 * texture2D(u_searchTexSampler, e).r;\n}\nfloat SMAASearchXLeft(vec2 texcoord, float end) {\n  vec2 e = vec2(0.0, 1.0);\n  for (int i = 0; i < 8; ++i) {\n      e = texture2D(u_edgeTexSampler, texcoord).rg;\n      texcoord -= vec2( 2.0, 0.0 ) * cc_nativeSize.zw;\n      if (!(texcoord.x > end && e.g > 0.8281 && e.r == 0.0))\n        break;\n  }\n  texcoord.x += 0.25 * cc_nativeSize.z;\n  texcoord.x += cc_nativeSize.z;\n  texcoord.x += 2.0 * cc_nativeSize.z;\n  texcoord.x -= cc_nativeSize.z * SMAASearchLength(e, 0.0, 0.5);\n  return texcoord.x;\n}\nfloat SMAASearchXRight(vec2 texcoord, float end) {\n  vec2 e = vec2(0.0, 1.0);\n  for (int i = 0; i < 8; ++i) {\n      e = texture2D(u_edgeTexSampler, texcoord).rg;\n      texcoord += vec2( 2.0, 0.0 ) * cc_nativeSize.zw;\n      if (!(texcoord.x < end && e.g > 0.8281 && e.r == 0.0))\n        break;\n  }\n  texcoord.x -= 0.25 * cc_nativeSize.z;\n  texcoord.x -= cc_nativeSize.z;\n  texcoord.x -= 2.0 * cc_nativeSize.z;\n  texcoord.x += cc_nativeSize.z * SMAASearchLength(e, 0.5, 0.5);\n  return texcoord.x;\n}\nfloat SMAASearchYUp(vec2 texcoord, float end) {\n    vec2 e = vec2(1.0, 0.0);\n    for (int i = 0; i < 8; ++i) {\n        e = texture2D(u_edgeTexSampler, texcoord).rg;\n        texcoord += vec2( 0.0, 2.0 ) * cc_nativeSize.zw;\n        if (!(texcoord.y > end && e.r > 0.8281 && e.g == 0.0))\n          break;\n    }\n    texcoord.y -= 0.25 * cc_nativeSize.w;\n    texcoord.y -= cc_nativeSize.w;\n    texcoord.y -= 2.0 * cc_nativeSize.w;\n    texcoord.y += cc_nativeSize.w * SMAASearchLength(e.gr, 0.0, 0.5);\n    return texcoord.y;\n}\nfloat SMAASearchYDown(vec2 texcoord, float end) {\n    vec2 e = vec2(1.0, 0.0);\n    for (int i = 0; i < 8; ++i) {\n        e = texture2D(u_edgeTexSampler, texcoord).rg;\n        texcoord -= vec2( 0.0, 2.0 ) * cc_nativeSize.zw;\n        if (!(texcoord.y < end && e.r > 0.8281 && e.g == 0.0))\n          break;\n    }\n    texcoord.y += 0.25 * cc_nativeSize.w;\n    texcoord.y += cc_nativeSize.w;\n    texcoord.y += 2.0 * cc_nativeSize.w;\n    texcoord.y -= cc_nativeSize.w * SMAASearchLength(e.gr, 0.5, 0.5);\n    return texcoord.y;\n}\nvec2 Round(vec2 x) {\n  return sign(x) * floor(abs(x) + 0.5);\n}\nvec2 SMAAArea(vec2 dist, float e1, float e2) {\n    vec2 texcoord = float(16) * Round(4.0 * vec2(e1, e2)) + dist;\n    texcoord = (1.0 / vec2(160.0, 560.0)) * texcoord + 0.5 * (1.0 / vec2(160.0, 560.0));\n    return texture2D(u_areaTexSampler, texcoord).rg;\n}\nvec4 frag () {\n  vec4 weights = vec4(0.0);\n  vec2 e = texture2D(u_edgeTexSampler, v_uv).rg;\n  vec2 d;\n  vec2 coords;\n  if ( e.g > 0.0 ) {\n      coords.x = SMAASearchXLeft(v_offsets[0].xy, v_offsets[2].x);\n      coords.y = v_offsets[1].y;\n      d.x = coords.x;\n      float e1 = texture2D(u_edgeTexSampler, coords).r;\n      coords.x = SMAASearchXRight(v_offsets[0].zw, v_offsets[2].y);\n      d.y = coords.x;\n      d = d / cc_nativeSize.z - v_pixCoord.x;\n      vec2 sqrt_d = sqrt(abs(d));\n      coords.y -= 1.0 * cc_nativeSize.w;\n      float e2 = texture2D(u_edgeTexSampler, coords + vec2(cc_nativeSize.z, 0.0)).r;\n      weights.rg = SMAAArea(sqrt_d, e1, e2);\n  }\n  if ( e.r > 0.0 ) {\n      coords.y = SMAASearchYUp(v_offsets[1].xy, v_offsets[2].z);\n      coords.x = v_offsets[0].x;\n      d.x = coords.y;\n      float e1 = texture2D(u_edgeTexSampler, coords).g;\n      coords.y = SMAASearchYDown(v_offsets[1].zw, v_offsets[2].w);\n      d.y = coords.y;\n      d = d / cc_nativeSize.w - v_pixCoord.y;\n      vec2 sqrt_d = sqrt(abs(d));\n      coords.y -= 1.0 * cc_nativeSize.w;\n      float e2 = texture2D(u_edgeTexSampler, coords + vec2(0.0, cc_nativeSize.w)).g;\n      weights.ba = SMAAArea(sqrt_d, e1, e2);\n  }\n  return weights;\n}\nvoid main() { gl_FragColor = frag(); }\n"
                    },
                    builtins: {
                        globals: {
                            blocks: [ {
                                name: "CCGlobal",
                                defines: []
                            } ],
                            samplers: []
                        },
                        locals: {
                            blocks: [],
                            samplers: []
                        }
                    },
                    defines: [],
                    blocks: [],
                    samplers: [ {
                        name: "u_edgeTexSampler",
                        type: 28,
                        count: 1,
                        defines: [],
                        binding: 30
                    }, {
                        name: "u_areaTexSampler",
                        type: 28,
                        count: 1,
                        defines: [],
                        binding: 31
                    }, {
                        name: "u_searchTexSampler",
                        type: 28,
                        count: 1,
                        defines: [],
                        binding: 32
                    } ]
                } ]
            }, {
                name: "pipeline/tonemap",
                techniques: [ {
                    name: "tonemap",
                    passes: [ {
                        program: "pipeline/tonemap|tonemap-vs:vert|tonemap-fs:frag",
                        depthStencilState: {
                            depthTest: !1,
                            depthWrite: !1
                        },
                        properties: {
                            u_texSampler: {
                                type: 28,
                                samplerHash: 66186
                            },
                            u_blendTexSampler: {
                                type: 28,
                                samplerHash: 66186
                            }
                        }
                    } ]
                } ],
                shaders: [ {
                    name: "pipeline/tonemap|tonemap-vs:vert|tonemap-fs:frag",
                    hash: 1769238053,
                    glsl3: {
                        vert: "\nprecision highp float;\n#define saturate(a) clamp( a, 0.0, 1.0 )\nhighp mat4 transposeMat4(in highp mat4 mat) {\n    highp vec4 i0 = mat[0];\n    highp vec4 i1 = mat[1];\n    highp vec4 i2 = mat[2];\n    highp vec4 i3 = mat[3];\n    return mat4(vec4(i0.x, i1.x, i2.x, i3.x),\n                vec4(i0.y, i1.y, i2.y, i3.y),\n                vec4(i0.z, i1.z, i2.z, i3.z),\n                vec4(i0.w, i1.w, i2.w, i3.w));\n}\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nout vec4 v_offset;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0, 1);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_offset = v_uv.xyxy + cc_nativeSize.zwzw * vec4(1.0, 0.0, 0.0, -1.0);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n#define saturate(a) clamp( a, 0.0, 1.0 )\nhighp mat4 transposeMat4(in highp mat4 mat) {\n    highp vec4 i0 = mat[0];\n    highp vec4 i1 = mat[1];\n    highp vec4 i2 = mat[2];\n    highp vec4 i3 = mat[3];\n    return mat4(vec4(i0.x, i1.x, i2.x, i3.x),\n                vec4(i0.y, i1.y, i2.y, i3.y),\n                vec4(i0.z, i1.z, i2.z, i3.z),\n                vec4(i0.w, i1.w, i2.w, i3.w));\n}\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec3 ACESToneMap(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nin vec2 v_uv;\nin vec4 v_offset;\nuniform sampler2D u_texSampler;\nuniform sampler2D u_blendTexSampler;\nvec3 ToLDR(vec3 color) {\n  #if CC_USE_HDR\n    color *= cc_exposure.x * 1024.0;\n    color = ACESToneMap(color);\n    color = LinearToSRGB(color);\n  #endif\n  return color;\n}\nvec4 frag () {\n  #if CC_USE_SMAA\n    vec4 a;\n    a.rb = texture(u_blendTexSampler, v_uv).rb;\n    a.g = texture(u_blendTexSampler, v_offset.zw).g;\n    a.a = texture(u_blendTexSampler, v_offset.xy).a;\n    if (dot(a, vec4(1.0)) < 1e-5) {\n      vec4 o = texture(u_texSampler, v_uv);\n      o.rgb = ToLDR(o.rgb);\n      return o;\n    } else {\n      vec2 offset;\n      offset.x = a.a > a.b ? a.a : -a.b;\n      offset.y = a.g > a.r ? -a.g : a.r;\n      if (abs(offset.x) > abs(offset.y)) {\n        offset.y = 0.0;\n      } else {\n        offset.x = 0.0;\n      }\n      vec4 C = texture(u_texSampler, v_uv);\n      C.rgb = ToLDR(C.rgb);\n      vec2 uv = v_uv + sign(offset) * cc_nativeSize.zw;\n      vec4 Cop = texture(u_texSampler, uv);\n      Cop.rgb = ToLDR(Cop.rgb);\n      float s = abs(offset.x) > abs(offset.y) ? abs(offset.x) : abs(offset.y);\n      C.rgb = pow(C.rgb, vec3(2.2));\n      Cop.rgb = pow(Cop.rgb, vec3(2.2));\n      vec4 mixed = mix(C, Cop, s);\n      mixed.rgb = pow(mixed.rgb, vec3(1.0 / 2.2));\n      return mixed;\n    }\n  #else\n    vec4 o = texture(u_texSampler, v_uv);\n    o.rgb = ToLDR(o.rgb);\n    return o;\n  #endif\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
                    },
                    glsl1: {
                        vert: "\nprecision highp float;\n#define saturate(a) clamp( a, 0.0, 1.0 )\nhighp mat4 transposeMat4(in highp mat4 mat) {\n    highp vec4 i0 = mat[0];\n    highp vec4 i1 = mat[1];\n    highp vec4 i2 = mat[2];\n    highp vec4 i3 = mat[3];\n    return mat4(vec4(i0.x, i1.x, i2.x, i3.x),\n                vec4(i0.y, i1.y, i2.y, i3.y),\n                vec4(i0.z, i1.z, i2.z, i3.z),\n                vec4(i0.w, i1.w, i2.w, i3.w));\n}\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nvarying vec4 v_offset;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0, 1);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_offset = v_uv.xyxy + cc_nativeSize.zwzw * vec4(1.0, 0.0, 0.0, -1.0);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision highp float;\nuniform vec4 cc_nativeSize;\nuniform vec4 cc_exposure;\n#define saturate(a) clamp( a, 0.0, 1.0 )\nhighp mat4 transposeMat4(in highp mat4 mat) {\n    highp vec4 i0 = mat[0];\n    highp vec4 i1 = mat[1];\n    highp vec4 i2 = mat[2];\n    highp vec4 i3 = mat[3];\n    return mat4(vec4(i0.x, i1.x, i2.x, i3.x),\n                vec4(i0.y, i1.y, i2.y, i3.y),\n                vec4(i0.z, i1.z, i2.z, i3.z),\n                vec4(i0.w, i1.w, i2.w, i3.w));\n}\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec3 ACESToneMap(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvarying vec2 v_uv;\nvarying vec4 v_offset;\nuniform sampler2D u_texSampler;\nuniform sampler2D u_blendTexSampler;\nvec3 ToLDR(vec3 color) {\n  #if CC_USE_HDR\n    color *= cc_exposure.x * 1024.0;\n    color = ACESToneMap(color);\n    color = LinearToSRGB(color);\n  #endif\n  return color;\n}\nvec4 frag () {\n  #if CC_USE_SMAA\n    vec4 a;\n    a.rb = texture2D(u_blendTexSampler, v_uv).rb;\n    a.g = texture2D(u_blendTexSampler, v_offset.zw).g;\n    a.a = texture2D(u_blendTexSampler, v_offset.xy).a;\n    if (dot(a, vec4(1.0)) < 1e-5) {\n      vec4 o = texture2D(u_texSampler, v_uv);\n      o.rgb = ToLDR(o.rgb);\n      return o;\n    } else {\n      vec2 offset;\n      offset.x = a.a > a.b ? a.a : -a.b;\n      offset.y = a.g > a.r ? -a.g : a.r;\n      if (abs(offset.x) > abs(offset.y)) {\n        offset.y = 0.0;\n      } else {\n        offset.x = 0.0;\n      }\n      vec4 C = texture2D(u_texSampler, v_uv);\n      C.rgb = ToLDR(C.rgb);\n      vec2 uv = v_uv + sign(offset) * cc_nativeSize.zw;\n      vec4 Cop = texture2D(u_texSampler, uv);\n      Cop.rgb = ToLDR(Cop.rgb);\n      float s = abs(offset.x) > abs(offset.y) ? abs(offset.x) : abs(offset.y);\n      C.rgb = pow(C.rgb, vec3(2.2));\n      Cop.rgb = pow(Cop.rgb, vec3(2.2));\n      vec4 mixed = mix(C, Cop, s);\n      mixed.rgb = pow(mixed.rgb, vec3(1.0 / 2.2));\n      return mixed;\n    }\n  #else\n    vec4 o = texture2D(u_texSampler, v_uv);\n    o.rgb = ToLDR(o.rgb);\n    return o;\n  #endif\n}\nvoid main() { gl_FragColor = frag(); }\n"
                    },
                    builtins: {
                        globals: {
                            blocks: [ {
                                name: "CCGlobal",
                                defines: []
                            } ],
                            samplers: []
                        },
                        locals: {
                            blocks: [],
                            samplers: []
                        }
                    },
                    defines: [ {
                        name: "CC_USE_HDR",
                        type: "boolean"
                    }, {
                        name: "CC_USE_SMAA",
                        type: "boolean"
                    } ],
                    blocks: [],
                    samplers: [ {
                        name: "u_texSampler",
                        type: 28,
                        count: 1,
                        defines: [],
                        binding: 30
                    }, {
                        name: "u_blendTexSampler",
                        type: 28,
                        count: 1,
                        defines: [],
                        binding: 31
                    } ]
                } ]
            }, {
                name: "util/profiler",
                techniques: [ {
                    passes: [ {
                        blendState: {
                            targets: [ {
                                blend: !0,
                                blendSrc: 2,
                                blendDst: 4,
                                blendDstAlpha: 4
                            } ]
                        },
                        program: "util/profiler|profiler-vs:vert|profiler-fs:frag",
                        depthStencilState: {
                            depthTest: !0,
                            depthWrite: !1
                        },
                        properties: {
                            mainTexture: {
                                value: "grey",
                                type: 28
                            },
                            offset: {
                                type: 16
                            }
                        }
                    } ]
                } ],
                shaders: [ {
                    name: "util/profiler|profiler-vs:vert|profiler-fs:frag",
                    hash: 3710757766,
                    glsl3: {
                        vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec3 a_position;\nvoid CCDecode (out vec4 position) {\n  position = vec4(a_position, 1.0);\n}\nin vec2 a_texCoord;\nout vec2 v_uv;\nuniform Constants {\n  vec4 offset;\n};\nvec4 vert () {\n  vec4 position;\n  CCDecode(position);\n  position.x *= cc_screenSize.y * cc_screenSize.z;\n  position.xy += offset.xy + abs(position.xy);\n  v_uv = a_texCoord;\n  return position;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nin vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\n  return CCFragOutput(texture(mainTexture, v_uv));\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
                    },
                    glsl1: {
                        vert: "\nprecision mediump float;\nuniform vec4 cc_screenSize;\nattribute vec3 a_position;\nvoid CCDecode (out vec4 position) {\n  position = vec4(a_position, 1.0);\n}\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nuniform vec4 offset;\nvec4 vert () {\n  vec4 position;\n  CCDecode(position);\n  position.x *= cc_screenSize.y * cc_screenSize.z;\n  position.xy += offset.xy + abs(position.xy);\n  v_uv = a_texCoord;\n  return position;\n}\nvoid main() { gl_Position = vert(); }\n",
                        frag: "\nprecision mediump float;\nuniform vec4 cc_exposure;\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\n  return CCFragOutput(texture2D(mainTexture, v_uv));\n}\nvoid main() { gl_FragColor = frag(); }\n"
                    },
                    builtins: {
                        globals: {
                            blocks: [ {
                                name: "CCGlobal",
                                defines: []
                            } ],
                            samplers: []
                        },
                        locals: {
                            blocks: [],
                            samplers: []
                        }
                    },
                    defines: [ {
                        name: "CC_USE_HDR",
                        type: "boolean"
                    } ],
                    blocks: [ {
                        name: "Constants",
                        defines: [],
                        binding: 0,
                        members: [ {
                            name: "offset",
                            type: 16,
                            count: 1
                        } ]
                    } ],
                    samplers: [ {
                        name: "mainTexture",
                        type: 28,
                        count: 1,
                        defines: [],
                        binding: 30
                    } ]
                } ]
            } ]), BuiltinResMgr = function() {
                function BuiltinResMgr() {
                    _classCallCheck(this, BuiltinResMgr), this._device = null, this._resources = {};
                }
                return _createClass(BuiltinResMgr, [ {
                    key: "initBuiltinRes",
                    value: function initBuiltinRes(device) {
                        this._device = device;
                        var resources = this._resources, canvas = document.createElement("canvas"), context = canvas.getContext("2d"), imgAsset = new ImageAsset(canvas), l = canvas.width = canvas.height = 2;
                        context.fillStyle = "#000", context.fillRect(0, 0, l, l);
                        var blackTexture = new Texture2D();
                        blackTexture._uuid = "black-texture", blackTexture.image = imgAsset, resources[blackTexture._uuid] = blackTexture;
                        var blackCubeTexture = new TextureCube();
                        blackCubeTexture._uuid = "black-cube-texture", blackCubeTexture.setMipFilter(TextureCube.Filter.LINEAR), 
                        blackCubeTexture.image = {
                            front: new ImageAsset(canvas),
                            back: new ImageAsset(canvas),
                            left: new ImageAsset(canvas),
                            right: new ImageAsset(canvas),
                            top: new ImageAsset(canvas),
                            bottom: new ImageAsset(canvas)
                        }, resources[blackCubeTexture._uuid] = blackCubeTexture, context.fillStyle = "#777", 
                        context.fillRect(0, 0, l, l);
                        var greyTexture = new Texture2D();
                        greyTexture._uuid = "grey-texture", greyTexture.image = imgAsset, resources[greyTexture._uuid] = greyTexture, 
                        context.fillStyle = "#fff", context.fillRect(0, 0, l, l);
                        var whiteTexture = new Texture2D();
                        whiteTexture._uuid = "white-texture", whiteTexture.image = imgAsset, resources[whiteTexture._uuid] = whiteTexture;
                        var whiteCubeTexture = new TextureCube();
                        whiteCubeTexture._uuid = "white-cube-texture", whiteCubeTexture.setMipFilter(TextureCube.Filter.LINEAR), 
                        whiteCubeTexture.image = {
                            front: new ImageAsset(canvas),
                            back: new ImageAsset(canvas),
                            left: new ImageAsset(canvas),
                            right: new ImageAsset(canvas),
                            top: new ImageAsset(canvas),
                            bottom: new ImageAsset(canvas)
                        }, resources[whiteCubeTexture._uuid] = whiteCubeTexture, context.fillStyle = "#7f7fff", 
                        context.fillRect(0, 0, l, l);
                        var normalTexture = new Texture2D();
                        normalTexture._uuid = "normal-texture", normalTexture.image = imgAsset, resources[normalTexture._uuid] = normalTexture, 
                        canvas.width = canvas.height = 16, context.fillStyle = "#ddd", context.fillRect(0, 0, 16, 16), 
                        context.fillStyle = "#555", context.fillRect(0, 0, 8, 8), context.fillStyle = "#555", 
                        context.fillRect(8, 8, 8, 8);
                        var defaultTexture = new Texture2D();
                        defaultTexture._uuid = "default-texture", defaultTexture.image = imgAsset, resources[defaultTexture._uuid] = defaultTexture;
                        var defaultCubeTexture = new TextureCube();
                        defaultCubeTexture.setMipFilter(TextureCube.Filter.LINEAR), defaultCubeTexture._uuid = "default-cube-texture", 
                        defaultCubeTexture.image = {
                            front: new ImageAsset(canvas),
                            back: new ImageAsset(canvas),
                            left: new ImageAsset(canvas),
                            right: new ImageAsset(canvas),
                            top: new ImageAsset(canvas),
                            bottom: new ImageAsset(canvas)
                        }, resources[defaultCubeTexture._uuid] = defaultCubeTexture;
                        var spriteFrame = new SpriteFrame(), texture = imgAsset._texture;
                        spriteFrame.texture = texture, spriteFrame._uuid = "default-spriteframe", resources[spriteFrame._uuid] = spriteFrame, 
                        effects.forEach(function(e) {
                            Object.assign(new cc.EffectAsset(), e).onLoaded();
                        });
                        var standardMtl = new cc.Material();
                        standardMtl._uuid = "standard-material", standardMtl.initialize({
                            effectName: "builtin-standard"
                        }), resources[standardMtl._uuid] = standardMtl;
                        var missingMtl = new cc.Material();
                        missingMtl._uuid = "missing-material", missingMtl.initialize({
                            effectName: "builtin-unlit",
                            defines: {
                                USE_COLOR: !0
                            }
                        }), missingMtl.setProperty("color", cc.color("#ff00ff")), resources[missingMtl._uuid] = missingMtl;
                        var missingSkinningMtl = new cc.Material();
                        missingSkinningMtl._uuid = "missing-skinning-material";
                        var type = selectJointsMediumType(device);
                        missingSkinningMtl.initialize({
                            effectName: "builtin-unlit",
                            defines: {
                                USE_COLOR: !0,
                                CC_USE_SKINNING: type
                            }
                        }), missingSkinningMtl.setProperty("color", cc.color("#ff00ff")), resources[missingSkinningMtl._uuid] = missingSkinningMtl;
                        var missingEfxMtl = new cc.Material();
                        missingEfxMtl._uuid = "missing-effect-material", missingEfxMtl.initialize({
                            effectName: "builtin-unlit",
                            defines: {
                                USE_COLOR: !0
                            }
                        }), missingEfxMtl.setProperty("color", cc.color("#ffff00")), resources[missingEfxMtl._uuid] = missingEfxMtl;
                        var spriteMtl = new cc.Material();
                        spriteMtl._uuid = "ui-base-material", spriteMtl.initialize({
                            defines: {
                                USE_TEXTURE: !1
                            },
                            effectName: "builtin-sprite"
                        }), resources[spriteMtl._uuid] = spriteMtl;
                        var spriteColorMtl = new cc.Material();
                        spriteColorMtl._uuid = "ui-sprite-material", spriteColorMtl.initialize({
                            defines: {
                                USE_TEXTURE: !0
                            },
                            effectName: "builtin-sprite"
                        }), resources[spriteColorMtl._uuid] = spriteColorMtl;
                        var defaultParticleMtl = new cc.Material();
                        defaultParticleMtl._uuid = "default-particle-material", defaultParticleMtl.initialize({
                            effectName: "builtin-particle"
                        }), resources[defaultParticleMtl._uuid] = defaultParticleMtl;
                        var defaultTrailMtl = new cc.Material();
                        defaultTrailMtl._uuid = "default-trail-material", defaultTrailMtl.initialize({
                            effectName: "builtin-particle-trail"
                        }), resources[defaultTrailMtl._uuid] = defaultTrailMtl;
                        var defaultBillboardMtl = new cc.Material();
                        defaultBillboardMtl._uuid = "default-billboard-material", defaultBillboardMtl.initialize({
                            effectName: "builtin-billboard"
                        }), resources[defaultBillboardMtl._uuid] = defaultBillboardMtl;
                    }
                }, {
                    key: "get",
                    value: function get(uuid) {
                        return this._resources[uuid];
                    }
                } ]), BuiltinResMgr;
            }(), builtinResMgr = exports("builtinResMgr", cc.builtinResMgr = new BuiltinResMgr()), BatchedBuffer = function() {
                function BatchedBuffer(pass) {
                    _classCallCheck(this, BatchedBuffer), this.batches = [], this.pso = null, this.ubo = void 0, 
                    this.pass = void 0, this._limitCount = 10, this.pass = pass, this.ubo = pass.device.createBuffer({
                        usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                        size: UBOLocal.SIZE
                    });
                }
                return _createClass(BatchedBuffer, [ {
                    key: "destroy",
                    value: function destroy() {
                        for (var i = 0; i < this.batches.length; ++i) {
                            for (var batch = this.batches[i], j = 0; j < batch.vbs.length; ++j) batch.vbs[j].destroy();
                            batch.vbIdx.destroy(), batch.ia.destroy();
                        }
                        this.batches.splice(0), this.pso = null, this.ubo.destroy();
                    }
                }, {
                    key: "merge",
                    value: function merge(subModel, ro) {
                        var flatBuffers = subModel.subMeshData.flatBuffers;
                        if (0 !== flatBuffers.length) {
                            for (var vbSize = 0, vbIdxSize = 0, vbCount = flatBuffers[0].count, isBatchExist = !1, i = 0; i < this.batches.length; ++i) {
                                var batch = this.batches[i];
                                if (batch.vbs.length === flatBuffers.length && batch.mergeCount <= this._limitCount) {
                                    isBatchExist = !0;
                                    for (var j = 0; j < batch.vbs.length; ++j) {
                                        if (batch.vbs[j].stride !== flatBuffers[j].stride) {
                                            isBatchExist = !1;
                                            break;
                                        }
                                    }
                                    if (isBatchExist) {
                                        for (var _j = 0; _j < batch.vbs.length; ++_j) {
                                            var flatBuff = flatBuffers[_j], batchVB = batch.vbs[_j];
                                            (vbSize = (vbCount + batch.vbCount) * flatBuff.stride) > batchVB.size && batchVB.resize(vbSize), 
                                            batchVB.update(flatBuff.buffer, batch.vbCount * flatBuff.stride);
                                        }
                                        (vbIdxSize = 4 * (vbCount + batch.vbCount)) > batch.vbIdx.size && batch.vbIdx.resize(vbIdxSize);
                                        var vbIdxView = new Float32Array(flatBuffers[0].count);
                                        return vbIdxView.fill(batch.mergeCount), batch.vbIdx.update(vbIdxView.buffer, 4 * batch.vbCount), 
                                        Mat4.toArray(batch.uboLocal.view, ro.model.transform.worldMatrix, UBOLocal.MAT_WORLDS_OFFSET + 16 * batch.mergeCount), 
                                        ++batch.mergeCount, batch.vbCount += vbCount, void (batch.ia.vertexCount += vbCount);
                                    }
                                }
                            }
                            for (var device = this.pass.device, newVBs = [], totalVBS = [], _i = 0; _i < flatBuffers.length; ++_i) {
                                var _flatBuff = flatBuffers[_i], newVB = device.createBuffer({
                                    usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                                    size: _flatBuff.count * _flatBuff.stride,
                                    stride: _flatBuff.stride,
                                    flags: GFXBufferFlagBit.BAKUP_BUFFER
                                });
                                newVB.update(_flatBuff.buffer), newVBs.push(newVB), totalVBS.push(newVB);
                            }
                            var vbIdx = device.createBuffer({
                                usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                                size: 4 * vbCount,
                                stride: 4,
                                flags: GFXBufferFlagBit.BAKUP_BUFFER
                            }), vbIndices = new Float32Array(vbCount);
                            vbIndices.fill(0), vbIdx.update(vbIndices), totalVBS.push(vbIdx);
                            for (var attributes = subModel.inputAssembler.attributes, attrs = new Array(attributes.length + 1), a = 0; a < attributes.length; ++a) attrs[a] = attributes[a];
                            attrs[attributes.length] = {
                                name: "a_index",
                                format: GFXFormat.R32F,
                                stream: flatBuffers.length
                            };
                            var newBatch = {
                                vbs: newVBs,
                                vbIdx: vbIdx,
                                vbCount: vbCount,
                                mergeCount: 1,
                                ia: device.createInputAssembler({
                                    attributes: attrs,
                                    vertexBuffers: totalVBS
                                }),
                                uboLocal: new UBOLocal()
                            };
                            if (Mat4.toArray(newBatch.uboLocal.view, ro.model.transform.worldMatrix, UBOLocal.MAT_WORLDS_OFFSET), 
                            this.batches.push(newBatch), this.pass.bindBuffer(UniformBinding.UBO_LOCAL, this.ubo), 
                            this.pass.update(), !this.pso) this.pso = subModel.psos[this.pass.idxInTech], this.pso.pipelineLayout.layouts[0].update();
                        }
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        for (var i = 0; i < this.batches.length; ++i) {
                            var batch = this.batches[i];
                            batch.vbCount = 0, batch.mergeCount = 0, batch.ia.vertexCount = 0;
                        }
                    }
                } ]), BatchedBuffer;
            }(), getPhaseID = (phases = new Map(), phaseNum = 0, function(phaseName) {
                return phases.has(phaseName) || (phases.set(phaseName, 1 << phaseNum), phaseNum++), 
                phases.get(phaseName);
            }), _shdID = 0, programLib = new (function() {
                function ProgramLib() {
                    _classCallCheck(this, ProgramLib), this._templates = void 0, this._cache = void 0, 
                    this._templates = {}, this._cache = {};
                }
                return _createClass(ProgramLib, [ {
                    key: "define",
                    value: function define(prog) {
                        var cur = this._templates[prog.name];
                        if (!cur || cur.hash !== prog.hash) {
                            var tmpl = Object.assign({
                                id: ++_shdID
                            }, prog);
                            tmpl.localsInited || (insertBuiltinBindings(tmpl, localBindingsDesc, "locals"), 
                            tmpl.localsInited = !0);
                            var offset = 0, _loop = function _loop() {
                                if (_isArray4) {
                                    if (_i4 >= _iterator4.length) return "break";
                                    _ref4 = _iterator4[_i4++];
                                } else {
                                    if ((_i4 = _iterator4.next()).done) return "break";
                                    _ref4 = _i4.value;
                                }
                                var def = _ref4, cnt = 1;
                                if ("number" === def.type) {
                                    var range = def.range;
                                    cnt = getBitCount(range[1] - range[0] + 1), def._map = function(value) {
                                        return value - range[0] << def._offset;
                                    };
                                } else "string" === def.type ? (cnt = getBitCount(def.options.length), def._map = function(value) {
                                    return Math.max(0, def.options.findIndex(function(s) {
                                        return s === value;
                                    })) << def._offset;
                                }) : "boolean" === def.type && (def._map = function(value) {
                                    return value ? 1 << def._offset : 0;
                                });
                                def._offset = offset, offset += cnt;
                            }, _iterator4 = tmpl.defines, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                            for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                                var _ref4;
                                if ("break" === _loop()) break;
                            }
                            this._templates[prog.name] = tmpl;
                        }
                    }
                }, {
                    key: "getTemplate",
                    value: function getTemplate(name) {
                        return this._templates[name];
                    }
                }, {
                    key: "hasProgram",
                    value: function hasProgram(name) {
                        return void 0 !== this._templates[name];
                    }
                }, {
                    key: "getKey",
                    value: function getKey(name, defines) {
                        var tmpl = this._templates[name], key = 0, _iterator5 = tmpl.defines, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                            var _ref5;
                            if (_isArray5) {
                                if (_i5 >= _iterator5.length) break;
                                _ref5 = _iterator5[_i5++];
                            } else {
                                if ((_i5 = _iterator5.next()).done) break;
                                _ref5 = _i5.value;
                            }
                            var tmplDef = _ref5, _value = defines[tmplDef.name];
                            void 0 !== _value && tmplDef._map && (key |= tmplDef._map(_value));
                        }
                        return key << 8 | 255 & tmpl.id;
                    }
                }, {
                    key: "destroyShaderByDefines",
                    value: function destroyShaderByDefines(defines) {
                        var _this = this, defs = Object.keys(defines);
                        if (defs.length) {
                            var regexes = defs.map(function(cur) {
                                var val = defs[cur];
                                return "boolean" == typeof val && (val = val ? "1" : "0"), new RegExp(cur + val);
                            }), _iterator6 = Object.keys(this._cache).filter(function(k) {
                                return regexes.every(function(re) {
                                    return re.test(_this._cache[k].name);
                                });
                            }), _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                            for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                                var _ref6;
                                if (_isArray6) {
                                    if (_i6 >= _iterator6.length) break;
                                    _ref6 = _iterator6[_i6++];
                                } else {
                                    if ((_i6 = _iterator6.next()).done) break;
                                    _ref6 = _i6.value;
                                }
                                var k = _ref6;
                                console.log("destroyed shader ".concat(this._cache[k].name)), this._cache[k].destroy(), 
                                delete this._cache[k];
                            }
                        }
                    }
                }, {
                    key: "getGFXShader",
                    value: function getGFXShader(device, name, defines, pipeline) {
                        Object.assign(defines, pipeline.macros);
                        var key = this.getKey(name, defines), program = this._cache[key];
                        if (void 0 !== program) return program;
                        var tmpl = this._templates[name];
                        tmpl.globalsInited || (insertBuiltinBindings(tmpl, pipeline.globalBindings, "globals"), 
                        tmpl.globalsInited = !0);
                        var defs = function prepareDefines(defs, tDefs) {
                            var defines = [], _iterator = tDefs, _isArray = Array.isArray(_iterator), _i = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i >= _iterator.length) break;
                                    _ref = _iterator[_i++];
                                } else {
                                    if ((_i = _iterator.next()).done) break;
                                    _ref = _i.value;
                                }
                                var tmpl = _ref, name = tmpl.name, result = mapDefine(tmpl, defs[name]);
                                defines.push({
                                    name: name,
                                    result: result
                                });
                            }
                            return defines;
                        }(defines, tmpl.defines), customDef = defs.reduce(function(acc, cur) {
                            return "".concat(acc, "#define ").concat(cur.name, " ").concat(cur.result, "\n");
                        }, ""), vert = "", frag = "";
                        return frag = device.gfxAPI === GFXAPI.WEBGL2 ? (vert = "#version 300 es\n".concat(customDef, "\n").concat(tmpl.glsl3.vert), 
                        "#version 300 es\n".concat(customDef, "\n").concat(tmpl.glsl3.frag)) : (vert = "#version 100\n".concat(customDef, "\n").concat(tmpl.glsl1.vert), 
                        "#version 100\n".concat(customDef, "\n").concat(tmpl.glsl1.frag)), program = device.createShader({
                            name: function getShaderInstanceName(name, defs) {
                                return name + defs.reduce(function(acc, cur) {
                                    return "0" !== cur.result ? "".concat(acc, "|").concat(cur.name).concat(cur.result) : acc;
                                }, "");
                            }(name, defs),
                            blocks: tmpl.blocks,
                            samplers: tmpl.samplers,
                            stages: [ {
                                type: GFXShaderType.VERTEX,
                                source: vert
                            }, {
                                type: GFXShaderType.FRAGMENT,
                                source: frag
                            } ]
                        }), this._cache[key] = program;
                    }
                } ]), ProgramLib;
            }())();
            cc.programLib = programLib;
            function genHandle(bt, binding, type, argument_3) {
                return bt << 28 & 4026531840 | type << 22 & 264241152 | binding << 14 & 4177920 | 16383 & (3 < arguments.length && void 0 !== argument_3 ? argument_3 : 0);
            }
            function getTypeFromHandle(handle) {
                return (264241152 & handle) >>> 22;
            }
            function customizeType(handle, type) {
                return -264241153 & handle | type << 22 & 264241152;
            }
            var _type2writer = (_defineProperty(_type2writer2 = {}, GFXType.UNKNOWN, function(a, v) {
                return console.warn("illegal uniform handle");
            }), _defineProperty(_type2writer2, GFXType.INT, function(a, v) {
                return a[2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0] = v;
            }), _defineProperty(_type2writer2, GFXType.INT2, function(a, v) {
                var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return Vec2.toArray(a, v, idx);
            }), _defineProperty(_type2writer2, GFXType.INT3, function(a, v) {
                var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return Vec3.toArray(a, v, idx);
            }), _defineProperty(_type2writer2, GFXType.INT4, function(a, v) {
                var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return Vec4.toArray(a, v, idx);
            }), _defineProperty(_type2writer2, GFXType.FLOAT, function(a, v) {
                return a[2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0] = v;
            }), _defineProperty(_type2writer2, GFXType.FLOAT2, function(a, v) {
                var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return Vec2.toArray(a, v, idx);
            }), _defineProperty(_type2writer2, GFXType.FLOAT3, function(a, v) {
                var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return Vec3.toArray(a, v, idx);
            }), _defineProperty(_type2writer2, GFXType.FLOAT4, function(a, v) {
                var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return Vec4.toArray(a, v, idx);
            }), _defineProperty(_type2writer2, GFXType.MAT3, function(a, v) {
                var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return Mat3.toArray(a, v, idx);
            }), _defineProperty(_type2writer2, GFXType.MAT4, function(a, v) {
                var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return Mat4.toArray(a, v, idx);
            }), _type2writer2), _type2reader = (_defineProperty(_type2reader2 = {}, GFXType.UNKNOWN, function(a, v) {
                return console.warn("illegal uniform handle");
            }), _defineProperty(_type2reader2, GFXType.INT, function(a, v) {
                return a[2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0];
            }), _defineProperty(_type2reader2, GFXType.INT2, function(a, v) {
                var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return Vec2.fromArray(v, a, idx);
            }), _defineProperty(_type2reader2, GFXType.INT3, function(a, v) {
                var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return Vec3.fromArray(v, a, idx);
            }), _defineProperty(_type2reader2, GFXType.INT4, function(a, v) {
                var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return Vec4.fromArray(v, a, idx);
            }), _defineProperty(_type2reader2, GFXType.FLOAT, function(a, v) {
                return a[2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0];
            }), _defineProperty(_type2reader2, GFXType.FLOAT2, function(a, v) {
                var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return Vec2.fromArray(v, a, idx);
            }), _defineProperty(_type2reader2, GFXType.FLOAT3, function(a, v) {
                var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return Vec3.fromArray(v, a, idx);
            }), _defineProperty(_type2reader2, GFXType.FLOAT4, function(a, v) {
                var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return Vec4.fromArray(v, a, idx);
            }), _defineProperty(_type2reader2, GFXType.MAT3, function(a, v) {
                var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return Mat3.fromArray(v, a, idx);
            }), _defineProperty(_type2reader2, GFXType.MAT4, function(a, v) {
                var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return Mat4.fromArray(v, a, idx);
            }), _type2reader2), _type2default = (_defineProperty(_type2default2 = {}, GFXType.INT, [ 0 ]), 
            _defineProperty(_type2default2, GFXType.INT2, [ 0, 0 ]), _defineProperty(_type2default2, GFXType.INT3, [ 0, 0, 0 ]), 
            _defineProperty(_type2default2, GFXType.INT4, [ 0, 0, 0, 0 ]), _defineProperty(_type2default2, GFXType.FLOAT, [ 0 ]), 
            _defineProperty(_type2default2, GFXType.FLOAT2, [ 0, 0 ]), _defineProperty(_type2default2, GFXType.FLOAT3, [ 0, 0, 0 ]), 
            _defineProperty(_type2default2, GFXType.FLOAT4, [ 0, 0, 0, 0 ]), _defineProperty(_type2default2, GFXType.MAT3, [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]), 
            _defineProperty(_type2default2, GFXType.MAT4, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]), 
            _defineProperty(_type2default2, GFXType.SAMPLER2D, "default-texture"), _defineProperty(_type2default2, GFXType.SAMPLER_CUBE, "default-cube-texture"), 
            _type2default2), Pass = function() {
                function Pass(device) {
                    _classCallCheck(this, Pass), this._buffers = {}, this._samplers = {}, this._textureViews = {}, 
                    this._resources = [], this._phase = 0, this._idxInTech = 0, this._programName = "", 
                    this._priority = RenderPriority.DEFAULT, this._primitive = GFXPrimitiveMode.TRIANGLE_LIST, 
                    this._stage = RenderPassStage.DEFAULT, this._bindings = [], this._bs = new GFXBlendState(), 
                    this._dss = new GFXDepthStencilState(), this._rs = new GFXRasterizerState(), this._dynamicStates = [], 
                    this._dynamics = {}, this._customizations = [], this._handleMap = {}, this._blocks = [], 
                    this._shaderInfo = null, this._defines = {}, this._properties = {}, this._device = void 0, 
                    this._renderPass = null, this._shader = null, this._batchedBuffer = null, this._device = device;
                }
                return _createClass(Pass, null, [ {
                    key: "createPasses",
                    value: function createPasses(effect, info) {
                        var techIdx = info.techIdx, defines = info.defines, states = info.states, tech = effect.techniques[techIdx || 0];
                        if (!tech) return [];
                        for (var passNum = tech.passes.length, passes = [], k = 0; k < passNum; ++k) {
                            var passInfo = tech.passes[k], defs = passInfo.curDefs = defines.length > k ? defines[k] : {};
                            if (!passInfo.switch || defs[passInfo.switch]) {
                                passInfo.states = states.length > k ? states[k] : {}, passInfo.idxInTech = k;
                                var pass = new Pass(cc.game._gfxDevice);
                                pass.initialize(passInfo), passes.push(pass);
                            }
                        }
                        return passes;
                    }
                } ]), _createClass(Pass, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        var _this = this;
                        this._idxInTech = info.idxInTech, this._programName = info.program, this._defines = info.curDefs, 
                        this._shaderInfo = programLib.getTemplate(info.program), this._properties = info.properties || this._properties;
                        var device = this._device;
                        this._fillinPipelineInfo(info), this._fillinPipelineInfo(info.states);
                        function _loop2() {
                            if (_isArray) {
                                if (_i >= _iterator.length) return "break";
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) return "break";
                                _ref = _i.value;
                            }
                            var u = _ref;
                            if (isBuiltinBinding(u.binding)) return "continue";
                            var blockSize = u.members.reduce(function(s, m) {
                                return s + GFXGetTypeSize(m.type) * m.count;
                            }, 0);
                            _this._buffers[u.binding] = device.createBuffer({
                                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                                size: 16 * Math.ceil(blockSize / 16),
                                usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST
                            });
                            var buffer = new ArrayBuffer(blockSize);
                            _this._blocks[u.binding] = {
                                buffer: buffer,
                                dirty: !1,
                                view: new Float32Array(buffer)
                            }, u.members.reduce(function(acc, cur) {
                                return _this._handleMap[cur.name] = genHandle(GFXBindingType.UNIFORM_BUFFER, u.binding, cur.type, acc), 
                                acc + (GFXGetTypeSize(cur.type) >> 2) * cur.count;
                            }, 0);
                        }
                        var _iterator = this._shaderInfo.blocks, _isArray = Array.isArray(_iterator), _i = 0;
                        _loop: for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            switch (_loop2()) {
                              case "break":
                                break _loop;

                              case "continue":
                                continue;
                            }
                        }
                        for (var _i2 = 0, _Object$keys = Object.keys(this._properties); _i2 < _Object$keys.length; _i2++) {
                            var _name = _Object$keys[_i2], prop = this._properties[_name];
                            prop.handleInfo && (this._handleMap[_name] = this.getHandle.apply(this, prop.handleInfo));
                        }
                        var _iterator2 = this._shaderInfo.samplers, _isArray2 = Array.isArray(_iterator2), _i3 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i3 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i3++];
                            } else {
                                if ((_i3 = _iterator2.next()).done) break;
                                _ref2 = _i3.value;
                            }
                            var u = _ref2;
                            this._handleMap[u.name] = genHandle(GFXBindingType.SAMPLER, u.binding, u.type);
                        }
                        this.resetUBOs(), this.resetTextures(), this.tryCompile();
                    }
                }, {
                    key: "getHandle",
                    value: function getHandle(name, argument_1, argument_2) {
                        var offset = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : 0, targetType = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : GFXType.UNKNOWN, handle = this._handleMap[name];
                        if (handle) return targetType ? handle = customizeType(handle, targetType) : offset && (handle = customizeType(handle, getTypeFromHandle(handle) - offset)), 
                        handle + offset;
                    }
                }, {
                    key: "getBinding",
                    value: function getBinding(name) {
                        var handle = this.getHandle(name);
                        if (void 0 !== handle) return Pass.getBindingFromHandle(handle);
                    }
                }, {
                    key: "setUniform",
                    value: function setUniform(handle, value) {
                        var binding = Pass.getBindingFromHandle(handle), type = Pass.getTypeFromHandle(handle), ofs = Pass.getOffsetFromHandle(handle), block = this._blocks[binding];
                        _type2writer[type](block.view, value, ofs), block.dirty = !0;
                    }
                }, {
                    key: "getUniform",
                    value: function getUniform(handle, out) {
                        var binding = Pass.getBindingFromHandle(handle), type = Pass.getTypeFromHandle(handle), ofs = Pass.getOffsetFromHandle(handle), block = this._blocks[binding];
                        return _type2reader[type](block.view, out, ofs);
                    }
                }, {
                    key: "setUniformArray",
                    value: function setUniformArray(handle, value) {
                        for (var binding = Pass.getBindingFromHandle(handle), type = Pass.getTypeFromHandle(handle), stride = GFXGetTypeSize(type) >> 2, block = this._blocks[binding], ofs = Pass.getOffsetFromHandle(handle), i = 0; i < value.length; i++, 
                        ofs += stride) null !== value[i] && _type2writer[type](block.view, value[i], ofs);
                        block.dirty = !0;
                    }
                }, {
                    key: "bindBuffer",
                    value: function bindBuffer(binding, value) {
                        if (this._buffers[binding] !== value) {
                            this._buffers[binding] = value;
                            for (var len = this._resources.length, i = 0; i < len; i++) {
                                this._resources[i].bindingLayout.bindBuffer(binding, value);
                            }
                        }
                    }
                }, {
                    key: "bindTextureView",
                    value: function bindTextureView(binding, value) {
                        if (this._textureViews[binding] !== value) {
                            this._textureViews[binding] = value;
                            for (var len = this._resources.length, i = 0; i < len; i++) {
                                this._resources[i].bindingLayout.bindTextureView(binding, value);
                            }
                        }
                    }
                }, {
                    key: "bindSampler",
                    value: function bindSampler(binding, value) {
                        if (this._samplers[binding] !== value) {
                            this._samplers[binding] = value;
                            for (var len = this._resources.length, i = 0; i < len; i++) {
                                this._resources[i].bindingLayout.bindSampler(binding, value);
                            }
                        }
                    }
                }, {
                    key: "setDynamicState",
                    value: function setDynamicState(state, value) {
                        var ds = this._dynamics[state];
                        ds && ds.value === value || (ds.value = value, ds.dirty = !0);
                    }
                }, {
                    key: "overridePipelineStates",
                    value: function overridePipelineStates(original, overrides) {
                        this._bs = new GFXBlendState(), this._dss = new GFXDepthStencilState(), this._rs = new GFXRasterizerState(), 
                        this._fillinPipelineInfo(original), this._fillinPipelineInfo(overrides);
                    }
                }, {
                    key: "update",
                    value: function update() {
                        for (var len = this._blocks.length, i = 0; i < len; i++) {
                            var block = this._blocks[i];
                            block.dirty && (this._buffers[i].update(block.buffer), block.dirty = !1);
                        }
                        for (var source = cc.director.root.pipeline.globalBindings, target = this._shaderInfo.builtins.globals, samplerLen = target.samplers.length, _i4 = 0; _i4 < samplerLen; _i4++) {
                            var s = target.samplers[_i4], info = source.get(s.name);
                            info.sampler && this.bindSampler(info.samplerInfo.binding, info.sampler), this.bindTextureView(info.samplerInfo.binding, info.textureView);
                        }
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        var _iterator3 = this._shaderInfo.blocks, _isArray3 = Array.isArray(_iterator3), _i5 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i5 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i5++];
                            } else {
                                if ((_i5 = _iterator3.next()).done) break;
                                _ref3 = _i5.value;
                            }
                            var u = _ref3;
                            isBuiltinBinding(u.binding) || this._buffers[u.binding].destroy();
                        }
                        this._buffers = {}, this._samplers = {}, this._textureViews = {}, this._batchedBuffer && (this._batchedBuffer.destroy(), 
                        this._batchedBuffer = null);
                    }
                }, {
                    key: "resetUBOs",
                    value: function resetUBOs() {
                        var _iterator4 = this._shaderInfo.blocks, _isArray4 = Array.isArray(_iterator4), _i6 = 0;
                        for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                            var _ref4;
                            if (_isArray4) {
                                if (_i6 >= _iterator4.length) break;
                                _ref4 = _iterator4[_i6++];
                            } else {
                                if ((_i6 = _iterator4.next()).done) break;
                                _ref4 = _i6.value;
                            }
                            var u = _ref4;
                            if (!isBuiltinBinding(u.binding)) {
                                for (var block = this._blocks[u.binding], ofs = 0, i = 0; i < u.members.length; i++) {
                                    for (var cur = u.members[i], inf = this._properties[cur.name], givenDefault = inf && inf.value, value = givenDefault || _type2default[cur.type], stride = GFXGetTypeSize(cur.type) >> 2, j = 0; j < cur.count; j++) block.view.set(value, ofs + j * stride);
                                    ofs += stride * cur.count;
                                }
                                block.dirty = !0;
                            }
                        }
                    }
                }, {
                    key: "resetTextures",
                    value: function resetTextures() {
                        var _iterator5 = this._shaderInfo.samplers, _isArray5 = Array.isArray(_iterator5), _i7 = 0;
                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                            var _ref5;
                            if (_isArray5) {
                                if (_i7 >= _iterator5.length) break;
                                _ref5 = _iterator5[_i7++];
                            } else {
                                if ((_i7 = _iterator5.next()).done) break;
                                _ref5 = _i7.value;
                            }
                            var u = _ref5;
                            if (!isBuiltinBinding(u.binding)) {
                                var inf = this._properties[u.name], texName = inf && inf.value ? inf.value + "-texture" : _type2default[u.type], texture = builtinResMgr.get(texName), textureView = texture && texture.getGFXTextureView();
                                if (textureView) {
                                    this._textureViews[u.binding] = textureView;
                                    for (var samplerHash = inf && void 0 !== inf.samplerHash ? inf.samplerHash : texture.getSamplerHash(), sampler = this._samplers[u.binding] = samplerLib.getSampler(this._device, samplerHash), i = 0; i < this._resources.length; i++) {
                                        var res = this._resources[i];
                                        res.bindingLayout.bindSampler(u.binding, sampler), res.bindingLayout.bindTextureView(u.binding, textureView);
                                    }
                                } else console.warn("illegal texture default value: " + texName);
                            }
                        }
                    }
                }, {
                    key: "tryCompile",
                    value: function tryCompile(defineOverrides) {
                        var _this2 = this;
                        defineOverrides && Object.assign(this._defines, defineOverrides);
                        var pipeline = cc.director.root.pipeline;
                        return !!pipeline && (this._renderPass = pipeline.getRenderPass(this._stage), this._renderPass ? (this._shader = programLib.getGFXShader(this._device, this._programName, this._defines, pipeline), 
                        this._shader ? (this._bindings = this._shaderInfo.blocks.reduce(function(acc, cur) {
                            return cur.defines.every(function(d) {
                                return _this2._defines[d];
                            }) && acc.push({
                                name: cur.name,
                                binding: cur.binding,
                                type: GFXBindingType.UNIFORM_BUFFER
                            }), acc;
                        }, []).concat(this._shaderInfo.samplers.reduce(function(acc, cur) {
                            return cur.defines.every(function(d) {
                                return _this2._defines[d];
                            }) && acc.push({
                                name: cur.name,
                                binding: cur.binding,
                                type: GFXBindingType.SAMPLER
                            }), acc;
                        }, [])), !0) : (console.warn("create shader ".concat(this._programName, " failed")), 
                        !1)) : (console.warn("illegal pass stage."), !1));
                    }
                }, {
                    key: "createPipelineState",
                    value: function createPipelineState() {
                        if (!(this._renderPass && this._shader && this._bindings.length || this.tryCompile())) return console.warn("pass resources not complete, create PSO failed"), 
                        null;
                        for (var bindingLayout = this._device.createBindingLayout({
                            bindings: this._bindings
                        }), _i8 = 0, _Object$keys2 = Object.keys(this._buffers); _i8 < _Object$keys2.length; _i8++) {
                            var b = _Object$keys2[_i8];
                            bindingLayout.bindBuffer(parseInt(b), this._buffers[b]);
                        }
                        for (var _i9 = 0, _Object$keys3 = Object.keys(this._samplers); _i9 < _Object$keys3.length; _i9++) {
                            var s = _Object$keys3[_i9];
                            bindingLayout.bindSampler(parseInt(s), this._samplers[s]);
                        }
                        for (var _i10 = 0, _Object$keys4 = Object.keys(this._textureViews); _i10 < _Object$keys4.length; _i10++) {
                            var t = _Object$keys4[_i10];
                            bindingLayout.bindTextureView(parseInt(t), this._textureViews[t]);
                        }
                        var source = cc.director.root.pipeline.globalBindings, target = this._shaderInfo.builtins.globals, _iterator6 = target.blocks, _isArray6 = Array.isArray(_iterator6), _i11 = 0;
                        for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                            var _ref6;
                            if (_isArray6) {
                                if (_i11 >= _iterator6.length) break;
                                _ref6 = _iterator6[_i11++];
                            } else {
                                if ((_i11 = _iterator6.next()).done) break;
                                _ref6 = _i11.value;
                            }
                            var _b = _ref6, info = source.get(_b.name);
                            info && info.type === GFXBindingType.UNIFORM_BUFFER ? bindingLayout.bindBuffer(info.blockInfo.binding, info.buffer) : console.warn("builtin UBO '".concat(_b.name, "' not available!"));
                        }
                        var _iterator7 = target.samplers, _isArray7 = Array.isArray(_iterator7), _i12 = 0;
                        for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                            var _ref7;
                            if (_isArray7) {
                                if (_i12 >= _iterator7.length) break;
                                _ref7 = _iterator7[_i12++];
                            } else {
                                if ((_i12 = _iterator7.next()).done) break;
                                _ref7 = _i12.value;
                            }
                            var _s = _ref7, _info = source.get(_s.name);
                            _info && _info.type === GFXBindingType.SAMPLER ? (_info.sampler && bindingLayout.bindSampler(_info.samplerInfo.binding, _info.sampler), 
                            bindingLayout.bindTextureView(_info.samplerInfo.binding, _info.textureView)) : console.warn("builtin texture '".concat(_s.name, "' not available!"));
                        }
                        var pipelineLayout = this._device.createPipelineLayout({
                            layouts: [ bindingLayout ]
                        }), pipelineState = this._device.createPipelineState({
                            bs: this._bs,
                            dss: this._dss,
                            dynamicStates: this._dynamicStates,
                            is: new GFXInputState(),
                            layout: pipelineLayout,
                            primitive: this._primitive,
                            renderPass: this._renderPass,
                            rs: this._rs,
                            shader: this._shader
                        });
                        return this._resources.push({
                            bindingLayout: bindingLayout,
                            pipelineLayout: pipelineLayout,
                            pipelineState: pipelineState
                        }), pipelineState;
                    }
                }, {
                    key: "destroyPipelineState",
                    value: function destroyPipelineState(pipelineStates) {
                        var idx = this._resources.findIndex(function(res) {
                            return res.pipelineState === pipelineStates;
                        });
                        if (0 <= idx) {
                            var _this$_resources$idx = this._resources[idx], bl = _this$_resources$idx.bindingLayout, pl = _this$_resources$idx.pipelineLayout, ps = _this$_resources$idx.pipelineState;
                            bl.destroy(), pl.destroy(), ps.destroy(), this._resources.splice(idx, 1);
                        }
                    }
                }, {
                    key: "serializePipelineStates",
                    value: function serializePipelineStates() {
                        var shaderKey = programLib.getKey(this._programName, this._defines), res = "".concat(shaderKey, ",").concat(this._stage, ",").concat(this._primitive);
                        return res += serializeBlendState(this._bs), res += serializeDepthStencilState(this._dss), 
                        res += serializeRasterizerState(this._rs);
                    }
                }, {
                    key: "createBatchedBuffer",
                    value: function createBatchedBuffer() {
                        this._batchedBuffer || (this._batchedBuffer = new BatchedBuffer(this));
                    }
                }, {
                    key: "destroyBatchedBuffer",
                    value: function destroyBatchedBuffer() {
                        this._batchedBuffer && (this._batchedBuffer.destroy(), this._batchedBuffer = null);
                    }
                }, {
                    key: "clearBatchedBuffer",
                    value: function clearBatchedBuffer() {
                        if (this._batchedBuffer) {
                            var uboLocal = new UBOLocal();
                            this._batchedBuffer.ubo.update(uboLocal.view.buffer);
                        }
                    }
                }, {
                    key: "_fillinPipelineInfo",
                    value: function _fillinPipelineInfo(info) {
                        if (void 0 !== info.priority && (this._priority = info.priority), void 0 !== info.primitive && (this._primitive = info.primitive), 
                        void 0 !== info.stage && (this._stage = info.stage), void 0 !== info.dynamics && (this._dynamicStates = info.dynamics), 
                        info.customizations && (this._customizations = info.customizations), 0 === this._phase) {
                            var phaseName = info.phase || "default";
                            this._phase = getPhaseID(phaseName);
                        }
                        var bs = this._bs;
                        if (info.blendState) {
                            var bsInfo = Object.assign({}, info.blendState);
                            bsInfo.targets && bsInfo.targets.forEach(function(t, i) {
                                return Object.assign(bs.targets[i] || (bs.targets[i] = new GFXBlendTarget()), t);
                            }), delete bsInfo.targets, Object.assign(bs, bsInfo);
                        }
                        Object.assign(this._rs, info.rasterizerState), Object.assign(this._dss, info.depthStencilState);
                    }
                }, {
                    key: "device",
                    get: function get() {
                        return this._device;
                    }
                }, {
                    key: "idxInTech",
                    get: function get() {
                        return this._idxInTech;
                    }
                }, {
                    key: "programName",
                    get: function get() {
                        return this._programName;
                    }
                }, {
                    key: "priority",
                    get: function get() {
                        return this._priority;
                    }
                }, {
                    key: "primitive",
                    get: function get() {
                        return this._primitive;
                    }
                }, {
                    key: "stage",
                    get: function get() {
                        return this._stage;
                    }
                }, {
                    key: "phase",
                    get: function get() {
                        return this._phase;
                    }
                }, {
                    key: "bindings",
                    get: function get() {
                        return this._bindings;
                    }
                }, {
                    key: "blendState",
                    get: function get() {
                        return this._bs;
                    }
                }, {
                    key: "depthStencilState",
                    get: function get() {
                        return this._dss;
                    }
                }, {
                    key: "rasterizerState",
                    get: function get() {
                        return this._rs;
                    }
                }, {
                    key: "dynamics",
                    get: function get() {
                        return this._dynamics;
                    }
                }, {
                    key: "customizations",
                    get: function get() {
                        return this._customizations;
                    }
                }, {
                    key: "shader",
                    get: function get() {
                        return this._shader;
                    }
                }, {
                    key: "batchedBuffer",
                    get: function get() {
                        return this._batchedBuffer;
                    }
                }, {
                    key: "shaderInfo",
                    get: function get() {
                        return this._shaderInfo;
                    }
                }, {
                    key: "properties",
                    get: function get() {
                        return this._properties;
                    }
                } ]), Pass;
            }();
            Pass.getBindingTypeFromHandle = function getBindingTypeFromHandle(handle) {
                return (4026531840 & handle) >>> 28;
            }, Pass.getTypeFromHandle = getTypeFromHandle, Pass.getBindingFromHandle = function getBindingFromHandle(handle) {
                return (4177920 & handle) >>> 14;
            }, Pass.getOffsetFromHandle = function getOffsetFromHandle(handle) {
                return 16383 & handle;
            };
            var _class$b, _class2$8, _descriptor$7, _descriptor2$3, _descriptor3$2, _class3$5, _temp$b, _dec$c, _dec2$3, _class$c, _class2$9, _descriptor$8, _descriptor2$4, _descriptor3$3, _descriptor4$2, _descriptor5$2, serializeBlendState = function serializeBlendState(bs) {
                var res = ",bs,".concat(bs.isA2C, ",").concat(bs.blendColor), _iterator8 = bs.targets, _isArray8 = Array.isArray(_iterator8), _i13 = 0;
                for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                    var _ref8;
                    if (_isArray8) {
                        if (_i13 >= _iterator8.length) break;
                        _ref8 = _iterator8[_i13++];
                    } else {
                        if ((_i13 = _iterator8.next()).done) break;
                        _ref8 = _i13.value;
                    }
                    var t = _ref8;
                    res += ",bt,".concat(t.blend, ",").concat(t.blendEq, ",").concat(t.blendAlphaEq, ",").concat(t.blendColorMask), 
                    res += ",".concat(t.blendSrc, ",").concat(t.blendDst, ",").concat(t.blendSrcAlpha, ",").concat(t.blendDstAlpha);
                }
                return res;
            }, serializeRasterizerState = function serializeRasterizerState(rs) {
                return ",rs,".concat(rs.cullMode, ",").concat(rs.depthBias, ",").concat(rs.isFrontFaceCCW);
            }, serializeDepthStencilState = function serializeDepthStencilState(dss) {
                var res = ",dss,".concat(dss.depthTest, ",").concat(dss.depthWrite, ",").concat(dss.depthFunc);
                return res += ",".concat(dss.stencilTestFront, ",").concat(dss.stencilFuncFront, ",").concat(dss.stencilRefFront, ",").concat(dss.stencilReadMaskFront), 
                res += ",".concat(dss.stencilFailOpFront, ",").concat(dss.stencilZFailOpFront, ",").concat(dss.stencilPassOpFront, ",").concat(dss.stencilWriteMaskFront), 
                res += ",".concat(dss.stencilTestBack, ",").concat(dss.stencilFuncBack, ",").concat(dss.stencilRefBack, ",").concat(dss.stencilReadMaskBack), 
                res += ",".concat(dss.stencilFailOpBack, ",").concat(dss.stencilZFailOpBack, ",").concat(dss.stencilPassOpBack, ",").concat(dss.stencilWriteMaskBack);
            }, effects$1 = {}, EffectAsset = exports("EffectAsset", ccclass("cc.EffectAsset")((_temp$b = _class3$5 = function() {
                function EffectAsset() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, EffectAsset);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EffectAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "techniques", _descriptor$7, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "shaders", _descriptor2$3, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "combinations", _descriptor3$2, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(EffectAsset, Asset), _createClass(EffectAsset, [ {
                    key: "onLoaded",
                    value: function onLoaded() {
                        this.shaders.forEach(function(s) {
                            return programLib.define(s);
                        }), cc.game.once(cc.Game.EVENT_ENGINE_INITED, this._precompile, this), EffectAsset.register(this);
                    }
                }, {
                    key: "_precompile",
                    value: function _precompile() {
                        for (var _this2 = this, root = cc.director.root, _loop = function _loop(i) {
                            var shader = _this2.shaders[i], combination = _this2.combinations[i];
                            if (!combination) return "continue";
                            Object.keys(combination).reduce(function(out, name) {
                                return out.reduce(function(acc, cur) {
                                    var choices = combination[name], next = [ cur ].concat(_toConsumableArray(Array(choices.length - 1)).map(function() {
                                        return Object.assign({}, cur);
                                    }));
                                    return next.forEach(function(defines, idx) {
                                        return defines[name] = choices[idx];
                                    }), acc.concat(next);
                                }, []);
                            }, [ {} ]).forEach(function(defines) {
                                return programLib.getGFXShader(root.device, shader.name, defines, root.pipeline);
                            });
                        }, i = 0; i < this.shaders.length; i++) _loop(i);
                    }
                } ], [ {
                    key: "register",
                    value: function register(asset) {
                        effects$1[asset.name] = asset;
                    }
                }, {
                    key: "remove",
                    value: function remove(name) {
                        if (effects$1[name]) delete effects$1[name]; else for (var n in effects$1) if (effects$1[n]._uuid === name) return void delete effects$1[n];
                    }
                }, {
                    key: "get",
                    value: function get(name) {
                        if (effects$1[name]) return effects$1[name];
                        for (var n in effects$1) if (effects$1[n]._uuid === name) return effects$1[n];
                        return null;
                    }
                }, {
                    key: "getAll",
                    value: function getAll() {
                        return effects$1;
                    }
                } ]), EffectAsset;
            }(), _class3$5._effects = {}, _descriptor$7 = _applyDecoratedDescriptor((_class2$8 = _temp$b).prototype, "techniques", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor2$3 = _applyDecoratedDescriptor(_class2$8.prototype, "shaders", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor3$2 = _applyDecoratedDescriptor(_class2$8.prototype, "combinations", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _class$b = _class2$8)) || _class$b);
            cc.EffectAsset = EffectAsset;
            var Material = exports("Material", (_dec$c = ccclass("cc.Material"), _dec2$3 = property(EffectAsset), 
            _dec$c((_descriptor$8 = _applyDecoratedDescriptor((_class2$9 = function() {
                function Material() {
                    var _this;
                    return _classCallCheck(this, Material), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Material).call(this)), "_effectAsset", _descriptor$8, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_techIdx", _descriptor2$4, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_defines", _descriptor3$3, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_states", _descriptor4$2, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_props", _descriptor5$2, _assertThisInitialized(_this)), 
                    _this._passes = [], _this._owner = null, _this._hash = 0, _this.loaded = !1, _this;
                }
                return _inherits(Material, Asset), _createClass(Material, [ {
                    key: "effectAsset",
                    get: function get() {
                        return this._effectAsset;
                    }
                }, {
                    key: "effectName",
                    get: function get() {
                        return this._effectAsset ? this._effectAsset.name : "";
                    }
                }, {
                    key: "technique",
                    get: function get() {
                        return this._techIdx;
                    }
                }, {
                    key: "passes",
                    get: function get() {
                        return this._passes;
                    }
                }, {
                    key: "hash",
                    get: function get() {
                        return this._hash;
                    }
                } ], [ {
                    key: "getInstantiatedMaterial",
                    value: function getInstantiatedMaterial(mat, rndCom, inEditor) {
                        if (mat._owner === rndCom) return mat;
                        var instance = new Material();
                        return instance.copy(mat), instance._native = mat._native + " (Instance)", instance._owner = rndCom, 
                        inEditor && (instance._uuid = mat._uuid), instance;
                    }
                } ]), _createClass(Material, [ {
                    key: "reset",
                    value: function reset(info) {
                        this._defines || (this._defines = []), this._states || (this._states = []), this._props || (this._props = []), 
                        void 0 !== info.technique && (this._techIdx = info.technique), info.effectAsset ? this._effectAsset = info.effectAsset : info.effectName && (this._effectAsset = EffectAsset.get(info.effectName)), 
                        info.defines && this._prepareInfo(info.defines, this._defines), info.states && this._prepareInfo(info.states, this._states), 
                        this._update();
                    }
                }, {
                    key: "initialize",
                    value: function initialize(info) {
                        this.reset(info);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        if (this._passes && this._passes.length) {
                            var _iterator = this._passes, _isArray = Array.isArray(_iterator), _i = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i >= _iterator.length) break;
                                    _ref = _iterator[_i++];
                                } else {
                                    if ((_i = _iterator.next()).done) break;
                                    _ref = _i.value;
                                }
                                _ref.destroy();
                            }
                        }
                        return this._passes = [], this._effectAsset = null, this._props = [], this._defines = [], 
                        this._states = [], _get(_getPrototypeOf(Material.prototype), "destroy", this).call(this);
                    }
                }, {
                    key: "resetUniforms",
                    value: function resetUniforms(argument_0) {
                        var clearPasses = !(0 < arguments.length && void 0 !== argument_0) || argument_0;
                        this._props.length = this._passes.length;
                        for (var i = 0; i < this._props.length; i++) this._props[i] = {};
                        if (clearPasses) {
                            var _iterator2 = this._passes, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                                var _ref2;
                                if (_isArray2) {
                                    if (_i2 >= _iterator2.length) break;
                                    _ref2 = _iterator2[_i2++];
                                } else {
                                    if ((_i2 = _iterator2.next()).done) break;
                                    _ref2 = _i2.value;
                                }
                                var pass = _ref2;
                                pass.resetUBOs(), pass.resetTextures();
                            }
                        }
                    }
                }, {
                    key: "recompileShaders",
                    value: function recompileShaders(overrides, passIdx) {
                        if (this._passes && this._effectAsset) {
                            if (void 0 === passIdx) {
                                var _iterator3 = this._passes, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                                    var _ref3;
                                    if (_isArray3) {
                                        if (_i3 >= _iterator3.length) break;
                                        _ref3 = _iterator3[_i3++];
                                    } else {
                                        if ((_i3 = _iterator3.next()).done) break;
                                        _ref3 = _i3.value;
                                    }
                                    _ref3.tryCompile(overrides);
                                }
                            } else this._passes[passIdx].tryCompile(overrides);
                            this._onPassesChange();
                        }
                    }
                }, {
                    key: "overridePipelineStates",
                    value: function overridePipelineStates(overrides, passIdx) {
                        if (this._passes && this._effectAsset) {
                            var passInfos = this._effectAsset.techniques[this._techIdx].passes;
                            if (void 0 === passIdx) for (var i = 0; i < this._passes.length; i++) {
                                var pass = this._passes[i];
                                this._states[i] = overrides, pass.overridePipelineStates(passInfos[pass.idxInTech], overrides);
                            } else this._states[passIdx] = overrides, this._passes[passIdx].overridePipelineStates(passInfos[passIdx], overrides);
                            this._onPassesChange();
                        }
                    }
                }, {
                    key: "onLoaded",
                    value: function onLoaded() {
                        this._update(), this.loaded = !0, this.emit("load");
                    }
                }, {
                    key: "setProperty",
                    value: function setProperty(name, val, passIdx) {
                        var success = !1;
                        if (void 0 === passIdx) for (var passes = this._passes, len = passes.length, i = 0; i < len; i++) {
                            var pass = passes[i];
                            this._uploadProperty(pass, name, val) && (this._props[i][name] = val, success = !0);
                        } else {
                            if (passIdx >= this._passes.length) return void console.warn("illegal pass index: ".concat(passIdx, "."));
                            var _pass = this._passes[passIdx];
                            this._uploadProperty(_pass, name, val) && (this._props[passIdx][name] = val, success = !0);
                        }
                        success || console.warn("illegal property name: ".concat(name, "."));
                    }
                }, {
                    key: "getProperty",
                    value: function getProperty(name, passIdx) {
                        if (void 0 === passIdx) for (var propsArray = this._props, len = propsArray.length, i = 0; i < len; i++) for (var props = propsArray[i], _i4 = 0, _Object$keys = Object.keys(props); _i4 < _Object$keys.length; _i4++) {
                            var p = _Object$keys[_i4];
                            if (p === name) return props[p];
                        } else {
                            if (passIdx >= this._props.length) return console.warn("illegal pass index: ".concat(passIdx, ".")), 
                            null;
                            for (var _props = this._props[passIdx], _i5 = 0, _Object$keys2 = Object.keys(_props); _i5 < _Object$keys2.length; _i5++) {
                                var _p = _Object$keys2[_i5];
                                if (_p === name) return _props[_p];
                            }
                        }
                        return null;
                    }
                }, {
                    key: "copy",
                    value: function copy(mat) {
                        this._techIdx = mat._techIdx, this._props.length = mat._props.length;
                        for (var i = 0; i < mat._props.length; i++) this._props[i] = Object.assign({}, mat._props[i]);
                        this._defines.length = mat._defines.length;
                        for (var _i6 = 0; _i6 < mat._defines.length; _i6++) this._defines[_i6] = Object.assign({}, mat._defines[_i6]);
                        this._states.length = mat._states.length;
                        for (var _i7 = 0; _i7 < mat._states.length; _i7++) this._states[_i7] = Object.assign({}, mat._states[_i7]);
                        this._effectAsset = mat._effectAsset, this._update();
                    }
                }, {
                    key: "_prepareInfo",
                    value: function _prepareInfo(patch, cur) {
                        if (!Array.isArray(patch)) {
                            var len = this._effectAsset ? this._effectAsset.techniques[this._techIdx].passes.length : 1;
                            patch = Array(len).fill(patch);
                        }
                        for (var i = 0; i < patch.length; ++i) Object.assign(cur[i] || (cur[i] = {}), patch[i]);
                    }
                }, {
                    key: "_update",
                    value: function _update(argument_0) {
                        var _this2 = this, keepProps = !(0 < arguments.length && void 0 !== argument_0) || argument_0;
                        if (this._effectAsset) {
                            if (this._passes && this._passes.length) {
                                var _iterator4 = this._passes, _isArray4 = Array.isArray(_iterator4), _i8 = 0;
                                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                                    var _ref4;
                                    if (_isArray4) {
                                        if (_i8 >= _iterator4.length) break;
                                        _ref4 = _iterator4[_i8++];
                                    } else {
                                        if ((_i8 = _iterator4.next()).done) break;
                                        _ref4 = _i8.value;
                                    }
                                    _ref4.destroy();
                                }
                            }
                            this._passes = Pass.createPasses(this._effectAsset, {
                                techIdx: this._techIdx,
                                defines: this._defines,
                                states: this._states
                            });
                            var totalPasses = this._effectAsset.techniques[this._techIdx].passes.length;
                            if (this._props.length = totalPasses, keepProps) this._passes.forEach(function(pass, i) {
                                var props = _this2._props[pass.idxInTech];
                                props = props || (_this2._props[i] = {});
                                for (var _i9 = 0, _Object$keys3 = Object.keys(props); _i9 < _Object$keys3.length; _i9++) {
                                    var p = _Object$keys3[_i9];
                                    props[p] && _this2._uploadProperty(pass, p, props[p]);
                                }
                            }); else for (var i = 0; i < this._props.length; i++) this._props[i] = {};
                        } else {
                            var missing = builtinResMgr.get("missing-effect-material");
                            missing && (this._passes = missing._passes.slice());
                        }
                        this._onPassesChange();
                    }
                }, {
                    key: "_uploadProperty",
                    value: function _uploadProperty(pass, name, val) {
                        var handle = pass.getHandle(name);
                        if (void 0 === handle) return !1;
                        var bindingType = Pass.getBindingTypeFromHandle(handle);
                        if (bindingType === GFXBindingType.UNIFORM_BUFFER) Array.isArray(val) ? pass.setUniformArray(handle, val) : pass.setUniform(handle, val); else if (bindingType === GFXBindingType.SAMPLER) {
                            var binding = Pass.getBindingFromHandle(handle);
                            if (val instanceof GFXTextureView) pass.bindTextureView(binding, val); else if (val instanceof TextureBase || val instanceof SpriteFrame) {
                                var textureView = val.getGFXTextureView();
                                if (!textureView || !textureView.texture.width || !textureView.texture.height) return !1;
                                pass.bindTextureView(binding, textureView), val instanceof TextureBase && pass.bindSampler(binding, samplerLib.getSampler(cc.game._gfxDevice, val.getSamplerHash()));
                            }
                        }
                        return !0;
                    }
                }, {
                    key: "_onPassesChange",
                    value: function _onPassesChange() {
                        var _this3 = this, str = "", _iterator5 = this._passes, _isArray5 = Array.isArray(_iterator5), _i10 = 0;
                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                            var _ref5;
                            if (_isArray5) {
                                if (_i10 >= _iterator5.length) break;
                                _ref5 = _iterator5[_i10++];
                            } else {
                                if ((_i10 = _iterator5.next()).done) break;
                                _ref5 = _i10.value;
                            }
                            str += _ref5.serializePipelineStates();
                        }
                        if (this._hash = murmurhash2_32_gc(str, 666), this._owner) {
                            var comp = this._owner, index = comp.sharedMaterials.findIndex(function(m) {
                                return m === _this3;
                            });
                            0 <= index && comp._onRebuildPSO(index, this);
                        }
                    }
                } ]), Material;
            }()).prototype, "_effectAsset", [ _dec2$3 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor2$4 = _applyDecoratedDescriptor(_class2$9.prototype, "_techIdx", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor3$3 = _applyDecoratedDescriptor(_class2$9.prototype, "_defines", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor4$2 = _applyDecoratedDescriptor(_class2$9.prototype, "_states", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor5$2 = _applyDecoratedDescriptor(_class2$9.prototype, "_props", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _class$c = _class2$9)) || _class$c));
            function quadIn(k) {
                return k * k;
            }
            function quadOut(k) {
                return k * (2 - k);
            }
            function cubicIn(k) {
                return k * k * k;
            }
            function cubicOut(k) {
                return --k * k * k + 1;
            }
            function quartIn(k) {
                return k * k * k * k;
            }
            function quartOut(k) {
                return 1 - --k * k * k * k;
            }
            function quintIn(k) {
                return k * k * k * k * k;
            }
            function quintOut(k) {
                return --k * k * k * k * k + 1;
            }
            function sineIn(k) {
                return 1 - Math.cos(k * Math.PI / 2);
            }
            function sineOut(k) {
                return Math.sin(k * Math.PI / 2);
            }
            function expoIn(k) {
                return 0 === k ? 0 : Math.pow(1024, k - 1);
            }
            function expoOut(k) {
                return 1 === k ? 1 : 1 - Math.pow(2, -10 * k);
            }
            function circIn(k) {
                return 1 - Math.sqrt(1 - k * k);
            }
            function circOut(k) {
                return Math.sqrt(1 - --k * k);
            }
            function backIn(k) {
                var s = 1.70158;
                return k * k * ((1 + s) * k - s);
            }
            function backOut(k) {
                var s = 1.70158;
                return --k * k * ((1 + s) * k + s) + 1;
            }
            function bounceIn(k) {
                return 1 - bounceOut(1 - k);
            }
            function bounceOut(k) {
                return k < 1 / 2.75 ? 7.5625 * k * k : k < 2 / 2.75 ? 7.5625 * (k -= 1.5 / 2.75) * k + .75 : k < 2.5 / 2.75 ? 7.5625 * (k -= 2.25 / 2.75) * k + .9375 : 7.5625 * (k -= 2.625 / 2.75) * k + .984375;
            }
            cc.Material = Material;
            var quadOutIn = _makeOutIn(quadIn, quadOut), cubicOutIn = _makeOutIn(cubicIn, cubicOut), quartOutIn = _makeOutIn(quartIn, quartOut), quintOutIn = _makeOutIn(quintIn, quintOut), sineOutIn = _makeOutIn(sineIn, sineOut), expoOutIn = _makeOutIn(expoIn, expoOut), circOutIn = _makeOutIn(circIn, circOut), backOutIn = _makeOutIn(backIn, backOut), bounceOutIn = _makeOutIn(bounceIn, bounceOut);
            function _makeOutIn(fnIn, fnOut) {
                return function(k) {
                    return k < .5 ? fnOut(2 * k) / 2 : fnIn(2 * k - 1) / 2 + .5;
                };
            }
            var easing = Object.freeze({
                constant: function constant() {
                    return 0;
                },
                linear: function linear(k) {
                    return k;
                },
                quadIn: quadIn,
                quadOut: quadOut,
                quadInOut: function quadInOut(k) {
                    return (k *= 2) < 1 ? .5 * k * k : -.5 * (--k * (k - 2) - 1);
                },
                cubicIn: cubicIn,
                cubicOut: cubicOut,
                cubicInOut: function cubicInOut(k) {
                    return (k *= 2) < 1 ? .5 * k * k * k : .5 * ((k -= 2) * k * k + 2);
                },
                quartIn: quartIn,
                quartOut: quartOut,
                quartInOut: function quartInOut(k) {
                    return (k *= 2) < 1 ? .5 * k * k * k * k : -.5 * ((k -= 2) * k * k * k - 2);
                },
                quintIn: quintIn,
                quintOut: quintOut,
                quintInOut: function quintInOut(k) {
                    return (k *= 2) < 1 ? .5 * k * k * k * k * k : .5 * ((k -= 2) * k * k * k * k + 2);
                },
                sineIn: sineIn,
                sineOut: sineOut,
                sineInOut: function sineInOut(k) {
                    return .5 * (1 - Math.cos(Math.PI * k));
                },
                expoIn: expoIn,
                expoOut: expoOut,
                expoInOut: function expoInOut(k) {
                    return 0 === k ? 0 : 1 === k ? 1 : (k *= 2) < 1 ? .5 * Math.pow(1024, k - 1) : .5 * (2 - Math.pow(2, -10 * (k - 1)));
                },
                circIn: circIn,
                circOut: circOut,
                circInOut: function circInOut(k) {
                    return (k *= 2) < 1 ? -.5 * (Math.sqrt(1 - k * k) - 1) : .5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
                },
                elasticIn: function elasticIn(k) {
                    var s, a = .1;
                    return 0 === k ? 0 : 1 === k ? 1 : (s = !a || a < 1 ? (a = 1, .1) : .4 * Math.asin(1 / a) / (2 * Math.PI), 
                    -a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4));
                },
                elasticOut: function elasticOut(k) {
                    var s, a = .1;
                    return 0 === k ? 0 : 1 === k ? 1 : (s = !a || a < 1 ? (a = 1, .1) : .4 * Math.asin(1 / a) / (2 * Math.PI), 
                    a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / .4) + 1);
                },
                elasticInOut: function elasticInOut(k) {
                    var s, a = .1;
                    return 0 === k ? 0 : 1 === k ? 1 : (s = !a || a < 1 ? (a = 1, .1) : .4 * Math.asin(1 / a) / (2 * Math.PI), 
                    (k *= 2) < 1 ? a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4) * -.5 : a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4) * .5 + 1);
                },
                backIn: backIn,
                backOut: backOut,
                backInOut: function backInOut(k) {
                    var s = 2.5949095;
                    return (k *= 2) < 1 ? k * k * ((1 + s) * k - s) * .5 : .5 * ((k -= 2) * k * ((1 + s) * k + s) + 2);
                },
                bounceIn: bounceIn,
                bounceOut: bounceOut,
                bounceInOut: function bounceInOut(k) {
                    return k < .5 ? .5 * bounceIn(2 * k) : .5 * bounceOut(2 * k - 1) + .5;
                },
                smooth: function smooth(k) {
                    return k <= 0 ? 0 : 1 <= k ? 1 : k * k * (3 - 2 * k);
                },
                fade: function fade(k) {
                    return k <= 0 ? 0 : 1 <= k ? 1 : k * k * k * (k * (6 * k - 15) + 10);
                },
                quadOutIn: quadOutIn,
                cubicOutIn: cubicOutIn,
                quartOutIn: quartOutIn,
                quintOutIn: quintOutIn,
                sineOutIn: sineOutIn,
                expoOutIn: expoOutIn,
                circOutIn: circOutIn,
                backOutIn: backOutIn,
                bounceOutIn: bounceOutIn
            });
            exports("easing", easing);
            var defaultSrcBase64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADqCAYAAADnPAqjAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAFbVSURBVHhe7X0HgBRF9vfrns2wu4Ql55xzBhMiiAqCqICoKGI6vVP/oud5gLiC9x2nnOE805kAAQkCAookEYkqKjnnvGR2F9g03d97r6pnemZ6ZmeX3ZnZ2fnNvKmqV9U9Fd6r1NVVCkRQ5NB13XblypWqiqLUtdlstdFdU1H0aroOVZCXgu4Kiq4ng6KWxdAJeEkcUjT6qfJ6DY1cpCykK8jI1BXlkgLKeR30s4oOabqin1QUOGa3w5G4uLiDeG0akp2uj6DoEFGQawAKsoqKUB2VoC1KdmtN11sitzl6NUFhJaEPGDAuWaAou0CHnaDo2wC0LTExCX9gPFCRFFK4CAqBiIIUANqePbF5NWt21FS4TtGVbph73ZBdWfiGJrDVOq2Avh7N9agla+Lj439FhcmR3hHkg4iC+AC1EJcvX24VFaX2AU3vjTV0D2RTl6jEAtN0BQt9LRb9MsVmWxITE7Mt0sJ4R0RB3KBpWmx2dvaN2McfiH39O5FVQ/hcO1A4IS8vD7KysgG7ZnA1OxtykHJz8yBPs4Ou6RxOURWIUm0QHR0FMbGxEI+UkJAAcXGxEBUVhXpapMV2HKO1ANM9v0yZMj9GWhdXRBQEgYJry8zM7IljiaHovBuFpJzwKThyc3Mh7cwZOJV2Gs2zcPbcOTh3/gKcu3ARLly8BDk5OWDXCldh21QVsMaHCuWSoUL58lCxQjmoVLEiVK6UAlWrVIYqlSqhUkXL0IXCBcyLuZj+GTjwJ2Up9YP+Uq0gWVlZTVAgHkZ6EJ0FbimwpYEjR4/BgSNH4TDSkWPHWSkKqwDXCptNhSopKVC7Zk2oW7sm1KtdG2rXqgGx2AIVAtiy6FOxxfsiOTl5t+SVOpQ6BcFCj7l69epAXdeewuTfgL0Vv/OAFGLv/oOwc89e2L3vABxC5cCuifQNTVCrU6dWTWjSsAE0a9wQGjWoVyCFwe4X9ftWYWvyPg7wvyltXbBSoyCXLl2qGB1tewJAfRqLvbpk54szZ8/Bpq3bYcu2HbB7/34cQ5TsXgeNYZo0qA9tWjaHtq1aQEpKRenjD/QTmH/vYTfyY2xVzklmWCPsFQQHw7Wxlh+lqspITG4ZyfaJ0ziG+PX3TUxHjqNMhCmo8GvVqA6d2rdlqoxjGH+ArfBlbEk+QeukhISEo4IbnghbBcFuVF27rr+MpTlCVZR8R640q/QLKsTaDb/A/kOHJbd0oWG9OtCjS2dUlnaQkBAvud6BipKDivI5dj3/Wb58+UOSHVYIOwXJzMysiqOCMZiwx7HwfCsG9q4PHTkCK1evZeWgGagIAGKio6Fzh3Zw03XdcbBfO18pIUXRNfgYhzuvly1b9pRkhwXCRkHS0tLKlilTZhQOKl9ExfDZlbLb7fD7ps2wbOUqOHD4iOQWA+h5BUaoJKN+3TrQu+eN0L5Na7DZbJLrFZmY4DcyMjImVatW7bLklWiUeAXB2kvFVuM+tE7E1Picqs3JycUu1M+wZMWPcPb8BcktPnTBfv0vf2ymOEpOyUVKhfJwa6+e0KNrZ4iJyadh1vXjGigvJZctOwMrqxL9lL5EKwjWVK0wCe+j9TrBsQZ1nVatXQeLl/0AlzIyJLf40a1TB55e/WLGLMkp+UhOSoTbb+kFN/Tolu9DSU3T1+TlwVMVKyZulawShxKpIJqmxaNyjMMuzCisoaIk2wP0jGIdDroXLF4KFy5dktzAIS42Bj586w34dskymP3NIskND5Qvlwx33nYrdO/SCVQcfHiFDrm6ApMSy5R5DcNdldwSgxKnIOnp6TegQVOMjZjhBdt27ITZ8xfBibQ0yQkOnhr5MFzfvStMxVbku+U/SG74oHrVKnDvgP7QsnlTyfGKvUgjk5KSVgtnyUCJUZAjR47EJ5Ur9zp2cJ/DVsNrvM+cOQszvp4PW1FBQgH0QO7l55/FaGvw4WeTsau3QfqEF1q3aAZDBw2ESpVSJMcCmAm6orydfvHimNq1a5eI1qREKAh2p1rb7dp07FK1kCwP0CrZ77GG/m7ZCshFe6iAlnp8+O+JkJiYiF0+O7z9wf94SjkcER0VBbf3uQX64mCenth7h75Ns9vvr1ChwhbJCFmEtILouq5cunTpKTQmYaPhdQHR/oMHYfJXs+Bk2mnJCS2MGDYEbu11E9tpafsb7/4XtuzYxe5wRPUqVWD40MHQoF5dyfEElm0Wlumo5OTED9AM2Wm+kFWQs2e1pKiojE8xivdIlgdoduqb7xbD0h9XUYZLbuihUf16MH70S9IlFj1OePNt2HvgoOSEH6gX3OemG2HA7bflM9ulz87Ly300JSUlXTJCCiGpIGfPnm1us8XMxcxrIlkeOHbiBHwydRqcOBX6D25pwfA7/3zNZa1TZuZleO1fk8J6rRehetWq8OiD90PN6t7Xh2LltlvT1LtSUpJCY+BoQsgpyPnz5wfoijoVa6BEyXIBtRQ/rl4Lc75ZGFJjjfwwZGB/GHTnHWw3WruLly7Bq/+cBKdOn2F3uILGJvdg+nte14OaFsn1QDpK44MVkpMXSHdIwMcEdmCBQqOgcvwNM3CuCnqiomvgTllXrsBHn02GGV/PK1HKQVj786/S5kS55GQY/fwzUKFcoV9gLBGgspoxZx589PlkyLp6xaNcJSWB3T7v3LlzfyVZkJcGHSGhIBs3boy+cOHC/7B6+X+gg0oVrDudOJkGr//7Hfh9S8l8KHvs5Cl+69Ad9D7G3//vL5BY1q+V+CUav23eCq9PeofL0qqMsfxVRVEnXrhw6WNUEl/TYAFD0DUVM6LsuQsXZmM/va9keWDz1m3w2bSvIAsHtyUZ/W69BR4YfLd0CRgbNRw4dBgmoPBczaK94sIbcbGx8MgD90Gbll5n7bGe1Bfbc3MHV6lSJVOygoKgKkh6enpKdp79W4xEZ8nywNIVK2HuosWkSJJTclGhfDn47xuvO5dmcM0p0kW/O3btgonvfAA5pWDZPc1yDep/O/S5WUx/WwHz5OcYm3pHMN9eDFoX6/TpzGqoHD96Uw5aR/XlzDnw9cLvwkI5COcvXISdu2nFhYBLutDevEljePaJR3jzhXAHpf3rBd/CtFlzuKytgLLRJceurTp9+nQ1yQo4glISOBCrpdhyVmEV0YJkxJ2ys3Pgg0+/gNXrf5ZXhA/WbPhFWDCdrhCMdq1bwpMPP8A1bGnAT+t+hg8/nczbIVnJAsuIGrXq7NmzNcUVgUXAS4GUQwPlR7TWFxxXXL16Fd7/32dh+xCtbEICfPTOG2BTnS8f8cYhLA1kCHPZyp/gi+kzPfUoTEEPU596bCTEx3vZ0ljX9yug35SSknJMcgKCgLYgZ86cqW7X4QcUgvokCO6UefkyvPXfj2APKoeoPMKP7DotwXeb8sW0u+OWm26Aewf2t7xHOBKV+VvvfwiXUQasZAPDNNBB+SHQ3a2AKQgNyDVQl6G1oeC4gpTjbVSOw8cCWkEEFDQ4b49dqCnY76Yn6QQuegkSBCd0GHD7rXBH717SHf44fPQYKslHqCRXJMcVmDuNdEVdRls4SVaxIyAKgi1H4tWc3O/Q2pxkwJ0uX7kC777/MRw7fgJo2Vq40l0o8AcPH4WM9EyYNvtrkTnId4fBIvO+e+6Cntd1t7xfONKxYyfgnQ8+4l1mrGQFQ7XIys77jvYgIFdxo9gVBGvFaLuuzsHEd6IBjzvRwr33PvwEjob5miTapK16tar8kIzw45r1sHvvPrRxqVM+scmQdoMz4v6h0KVDW+kKfxxFJXnvo095Y28rmVEU6Kwotjn0gBmdxYp8t6m4FmChK2lnzv4PE2W5Ipfe4fjg089g30EckHvkQvgQbS794jNPwSdTpsGljHTmUddq/8FDcPMN17m8smooBZvSQRNa7du2hoOHjsCps2dc7h2uRK9IHzpyFDq0bePtld6GyUnJNd58841iXbtVrC3ImTPnXlZAGSGdLtA1Db6Y8RXsxFqU5CBciZZ6P/Pko7Bn/344fPy4i99hbDW/XbrCrfVwMRygF5Ce/dOj0LhBfZd7hDPt3LuXZYRkxRKK8sipU6f/Ll3FgmJTkBNpaYPsmjaBCt+K5i78Fn79Y5OlX7gQlfLD9w3mzaPnydUA7jQH8+HcufOcZyQUxq9hmCx89MHzTz8JdWrUsLxXOBLJyNxF31r6MQGMP3XqzECZRUWOYlGQkydPtlR0dbLi5WnXmvUb+CUnLvswppuu6wY34gB76/ad2J06bBmGDtP5bPpMdEie0/AA8RPi47i7Vq1SZcc9wp2WrlzF+5lZAUVMxdH9lJMnz3lf2HUNKHIFOXjwYDlQouhlp7JWGr93335erh7uqF+nNjw8bAjb53+7mE1v2LhpC2z8YzPaSCLwVxgIh4VB+UdISkqEl557GiqWL8/u0gCSmb37D7jIkpMgUYe8efv3n0+WwYsMRaog48aNU2NjEz7Xda2RVULOX7gAH0+ZGrQDZgKFsmUScLzwGI8/du7eA7v27pc+3kGby9GMnqtKuAHzUJgAFStUgL9iS5JUNiCznUFHnt0OH0+eyjJkJVuIRnEJOZ+h3bLXUlgUqYI8/qen/6IrykAdFCxDV8rNs8P/pnwJGfIBWbhCxV7l048+DJXkuRvzFtLjn/xxBschcxZgX1u6PVsPaQqDhaJalcrwwl+ehIS4gJ44HTRkZGbCJyhDeXbNIVdmwtwfdOLUmb+I0EWDIlOQ48dPtwdN/xeXpAXNW7gIDtFG0RZ+4UR33dEX2rRqyXmyD7sE23butgxnRbQ1Kj0os4KsJdEiDApP1tq1asFzf3qcd2Q33ytc6SDK0LwFCy39JP3r2LHT7UQmXTuKREGOHz+eoCvaNLTGCI4rtmzbBj+uWStd4QvaJG7QgH7Sha3HIt9jD3dQN+LTqdOxjLGgTRBOoRDC5mo2alAf/vzoCH92Xw8L/Lh2HWzZvl26PBCLg/ZptD2tdF8TikRBdMU2EUuxKe0e6E4XL12EqbPmcGGGM6VUrABPP/YIzaqgC7i1/H3LNsuwvmjXvv2wyq0ycaiGNDBjpcVpbdWiGTz+0P38/8QKZ9Iw0V/Oms2bXljJHIZodvzEqX+h5ZpxzQpy6NixXrqmPS2dLqCa8MuvZvMKTXSELcVERcFzTz0OZU3vlc9biK2HRVh/aPrseZCRId40RY7gSxhuB8fkRydDDR9yD69pMu4VrkSLPafNnIVWdFvjqaNHT/aU9kLjmhRk27a0sjZQ/0fVFkXTnWjuesfuPZ4eYUYPDRvMB80YoEWXdL6hVVh/iCYyps2aiw50SgEQvwiT2ykbhkXnYwnuoe2FOEB40/Zde1jGLLzoAQk9H/lk06aT17QbxjUpSFK5vNfQqMcl5UYXzl/wewanJIMeBt584/XSJTAfWw8fNZtf+GndBti1Z5/IT4JxO3Q77mz6D4ciodG3dy+4vU/pWCY/f9F3cPHCRZFwdwKoX7GiRjJaaBRaQQ4dP94e4/AMRcOKvpo3H67kZIOGXfJwpTq1a8KIB+lwKydOnkqDtRt/swxfELJjLn6CA3Y6Lo7yk+DSmhhMp680yabDXf1vhxtRea3uHU50OTsbZsydx6m3JEV55uCxY4We1SrUtAcWlC3zUvo8BZRaGEeegTbTpi1bYfEPK9EWvqBXZ8e++BwkJcoNIOXgfNrMr+Ggxf5XhUF6RibERkdDk4byHTNUECp0tkqTYG49DFBs6EgCOtKa9uQKZ5w+exZqVq0C1SpX9pBFJFXRlTZJSYmfr1q1ypxtfqFQLcjRo8cf0kHpTP/mTlk5OTBnwSJRWmFKlPFPjXwIKqXQWRjkQiCfziahrpF7+Gsh2vLo7LlzaEU3/Q3/IqTbDL7EGQKjpsAj9w+F1s2aSs/wpTkLFkI2bfyAyXYnLKKuIx977CGyFhQFVpCzZ88m4T/+wzImSLSPVTCOOwskBtx2K7Rt3RKTq/OUo1ASBRYsXlLky2io0L+YPgvzlv5HwGk1LBgTp7czAJqqaoMnHxnOy+TDGecvXoIlKHucJVakwT/ozVa0FQgFVpDMK1l/00CvgoT/6Upnz5+H5T+tRpt1HMOBWjZrAncP6McySLU6ESkJrRH6YfU6y2uulWi71d82bWY7g/5cwqp7RTCF4DVhf37sYahTs4bjnuFIK1avgXNYDlayidVW1ctXs1/GYAVCgRRkz9GjNbEgnpNODyz8fkmJ21S6IKDVs0+NFO9/CeVgG5oaHxRaXGmnv5n81RzeetWpCIbF2XqgTVgIjvgJe1xsHDzz+EioWtl5BEO4gXakXPD999LlCSym544cOeLzqHB3FEhBojQYh38Tb9ScZjp27DhsxFqOCiMcKdpmg788NgLKlE0QLA1rJexOaWhevJQOy1f95HFNURK1zrQTIbslKN+FyYaAq0OqDJURQJkyZeC5J0ZCRdpNnhhhSPTaAD2HcpdPzitFj7frJMP+w28F2Xf0aCPsS4zgHLeghUuWikiEKYbdc5d4GEiZzY02ZTo5dfhu6XLIySn+/XSX/LASjmJFJDKd4Mxvio8Bl1Kg+JoYdOTCs6gkSYnhuUyeymMR9mQ4EywIvR/ec/hwA3T5Bb8VRLHDaFAUm8V/8sv123ftRlt4onvnjnDTDT2oHyuEDVsNrpWQQ0+9aRfEQMBu1+Dz6V+J/+aIyPgYMBzsL6xUQmQX8RVMWor/zGOP8NuJ4YhtKIuHjh7l1LoTSnK0TVfHstUP+KUgh1HjFF1/QDpdgf+6ePlyHqiGI9WsXg0eum8wp1MshpNihibRkhU/wJWsLMtri4N27z8AP65Zx1lPQBbGh2PEMNv442Swp+GuUa0aPPXIQziAj7L8n5JO36NMeoOiw7BDh07Wk06f8EtB8jTlRWo9pNMFx0+cwNaDTmylnA8vohr26UdHOA+hRDYpCBcCOq9cycJuD20z7HltcRKtUsjIyHATfulA08E32xniemHT+bXgx4ffD1FRVLSGX3gQtSInTp5EuwUUiLbruc5TVX0gXwXZv39/FVS5h2gi2YqW/0SbtIcfaNn4yAfug8opKShkJGiYSiOh7NZg2Y+reFfIQCPz8hWY/vU8Fn4SdANmG38kw9y9YpAViYxmjRvBiPvu5TchC4OqpoNJQwmU5mU/UuVlLbcY4KGTJ09WRodP5N+CqFFPga7E0au+7nThwiX4fXPInwVfKNx2c08+AclQDJ61IkGTUpedlQ3fY/cqWFjz86+wa6/zrBEGx8+wS9OA2U9qiEiLDm1btYRhdw/kSqGg6N+3Dx/SGYqg50cXL6ZjOj1lFxMbdyUrx/I1DTN8KsiRI0fiMQ//xDWQBa1evwHsfISYeJIcLtSsUUMYcMdtmEasa7ClIMIUSyETRCftZmRS62F9j+Imitvkr2bxYkZ2OMAxFSZHmdyGv+Fj2CTQ0bVTR7jr9r54Z+v/80atWzSH5k3otG5r/2ASTWr8tG69yAMLQtF9Ak3Lt2AN+FSQ7Oy8e/FOlZAop10oLzcX1v/6K0bD/Np8yacKyUl8rjdXpphOTi61HpoYoGMQyMnOge+W/2B5fSDpxMlTsHiZGIxitJyQ8XbA7OY0oFs6ndB56X7fm2+0/C8riouJhtq1amIL1NzSPxRow8ZfwU4PcGW6zaToepWDBw+LvZm8wHcXS1X/RBlpRZu3b+cjC8IJUTYbPIaD1rJlyrBSOGob9KM8NVoTajkvpaeLi4KMhd8v48WMFEGKo4Cwi7gbTGHSL9s4sMmXLwDo26snXN/V65GRLqBBPm2J2qal2KQiFEHT8Ju2eX/1OQ97SGh4hVcF2bV/f2vMta7S6YH1v3ie+13ScXf/O6BeHXozUGSfEBoyeVBHX8jNzYPFy1dw+FAALWacOnMOx43jzPFmLwEZb2EXZPY23OZr7sLuZcc2raXLOxo1FM/bGtSrG9JbD23Ano5XoIzv2LfPq4Z7VRCbJjedppxzo/NYY+09eNDI77Cgjm3bwPXdu2HypEAR4Q+7Ta3J+l82wtkLF12uDTZt2r4Dftu0CW3EkPFnGBZhoo+wcwDhIhgVAdv5F2DIXQOgZdMmxhWW1LiBUBBqRVrhWMQqTCgQHed34cIFdKDLjbAnrUTr6kgMZglLBaFzF7DOvF86PUBrrnQcANEoJxyoeuXKvJQEcwydRPKBIHoTj4jc1JflPr/FPYJN0+fMg6zsLBlnKnunAjDIgeTOY7a8yKwoqqrAA/cOgka0vMbi/4iaNnYeFsZnnluECQXSUFY3/v6HjKknUE2GYdotp+IsFSQxsVwfNCoZTyXdyVFbhQHi4mLh0eHDIBoHnFJcWFAonSxkgsU/v2Imnz4btCO7fYKOmKY9ADi+Boz4M5xpY5N5BLTJQE6eALUMD983BGrXqC45TtBaripYsRigA4JCGb9t3uwhxwbhp/KePftvlUFdYN3FUlXXF61NOHnqFJw6fUa6SjZo3v/+ewZBSsWKLDhOMeFMkxkoWhOaMqSdD0MZK1atgWN0BokodMk1p8oEdDAPw0onOcS10o8QGxsDjz54n8cy+Yb167k8N6lVsyaUTy7yvaOLDCfTTkMakjfoXmTeQ0Gwe5WAg9IBYt2RJ23Ztp0zMhyIzv6jeXwWFmyKxViDnQj6FQJDivLHlq2YyWnIEteGItEzkSlfzUarcJPBIJPcwuUwyeZQEEdgAtr5enFNfEI8K0mFcqgAFA7JGH8YIGXhVkT6hyJt2roVDWu5xkLut2fPnliZHAc8FKRMmeRb0PC6Fpq2fMS/K/FEMy/9bu2NmSObWWSyXT7voDBGaMrAxctWOK4NZdp/6DD8tNZYzEgc+pXpoUQ6eOTEX/Elh6vbAcFILFsWlWQYdr/Lsn/jhp6v8NKexOQXqrR1xw789QJFT7aDjYYWLvBQEF2BgVY3J7pw8RI/nCrpSE5MhOFD72W7EAqhBFSRUELdW5OtO3bC0RNeFr6FIOYu+o53RGFQAih9wiXADpE+thkWBIfk/DDxpL1i+XIw8oGhkBAfjwrSkPnmcDxQD2EcxzLk7UrRbkWKrnucVOWiIJhYGwbrZ3k10q49e9hakkEbPA8feg8/DKREGYUsiB4Ekok+NPtBrQmaoT72cMflK1dh9nxxtiWmhk1OlNMlndLNaUab4SnBvvTlwMK7SqVK/H57OepuSRj5V6lSClSvku/6v6CB4k/ntbDFgjAVt2M6XHTCxbF794H22IJUoorUininvxKO/rf2grp1alFmkFxIE4lbDGKQKbpZ6MUZeujoMXl1ycHPG38Xx0yLZDgh3Zw+djt9HXnhxhMWvor96tauLXgWoN1eQhkkw1ayLUipumv/fpdN5lwURAN7X9pk14p0HADu3bfPkYElkdq2bAbXde1C5cwFzx/pZxS+mag1+R5bD3d+SSCK+7RZX0NeXi67RYoF2M084lqDQ3MwZzi+DM147GIJmydo2YkRh1Ck/QcPoKDTOixrOdfscJtMCsNNQZRb8DaWn1NpafzmXElFFWz+77mzv0gNZhT+CJLpY6f0M1oTOgBnHw56SypOnj4DS35YJV0ITqO00K/MA06zw88J5Eom/ZCL3DrPaolrxAyQo8VF/5YtmrlM/4Ya6F2aU2mnZGo8P5gQmqRywKEgNL2L/l0ojBUdoFNagwR6qnstoLn84YPv5lOYnF0p+jpN/nChI0PaxduCJRuLl/8gdmaUbiNtwmYGZYTMA4dThhNeTLQ2gwbpnhDXJiclQr3atSQvNLH/wCGKriWhrnel1zzQxXAoSFxc2a4K6LEeV0g6eCR4CtLuGlaLUm12T/87ICVFPAyk5JApBuNSWAxCT/6glTai2L0v/8M3Qx20V9RXX88X6Ua3Iw/IE+0ubgdEPggm/RhuHSubWM5TI+/4cg7nRLsQH4cIWRbpcidF0WPT0690QwfD2cWKUntYXyLo8JHgnS/YqGF9qFurpqVfftSjcwdo2awpWkUhGwVL/VBfrcnSldh6sF/JJ3o/+4/NW7kkiUXgdEuItJOfk0cswyQ2EzrF+MMM4oprDWpN072Oi0KPjnjZ8cQg0gUyCA4F0ex6d3MizZSZmQnnLl6kZyRBIaqx+vS6ydLPF9HxBLf26omJpnSQTrimi3KDTPfW5NiJE7Bjz17Le5ZIwvKd+c0CuHoVx5CUTipwR3rJ4QT70pf82C3Bbhx/xOH4w6hcTBWMMyBA86aNwRZts45LCNB5lOUrV65w3C1J011bkFmzZtF+V13QDwN4UvAfDurQ8/oeBXr3ObFsGbhv0EAcv6iYBmfiHcpAH2l3b02Wr/xJ2MMItPvjwu+XCocpbS75IOGwk+nm5zH+4CDyHjIf4+LioInbUpRQAskAVYKULCvSNL0jpgdVSSpI49ata6OrPNmtQAsUFbwyWERILJsIXTu0t/R3J5uiwtCBd/KZgejEVNOXf9gknrfWhA7A2bJjp+V9Szr9tHa92JaTcxThsAhQ3oiv8KBfM1FLThMe7rNXnH/yGgZaaSMIqziECp30UeljOitt376dZxpEFytX83kCT9rp0645FQSiQujd80YPvhX1uel6qFOrlig4KkT6kJVNJ1m1Jj+sWsMtCrLCjui9CBqw66b1ZkxoN8Bcdgpf9mN/2gBbrOUzhzeHMytOfXozU3iFJLFM+0CernYkkxVEUW0+369MO33G6j8CRzLzW7dsDhUrlLcOI4n6v906d0K7LDTkoYV9pcF+hkk8Q1FoOvSPrQU/urkkEZ1+RQdfCiCHM4VsZCendEsvcjHhj3mALsrElcyoXLmi89oQpNP5vLJh6IRQEE1vQTWtJWFtc/bcWQoWVFAB0Hiil9uBmWakoPIMuL0vZgB+ZCsgCk+YlB7KHLbSh/0EkZL88NNaNsMdCxYvg3TamVG6DVCeCCb9cA6hIexE8Ti2MOcZkRlmfqWKFSU3NCE2urCQd0msEwhWEKydm+MPWTwoOzuLnz4GE+Z5dzpRltzuiImJhsED+0NMNA7kKer0kdc47RiQMoDdbLAffS9cvAi/81Ro+ONqVhbMXyTOcad8cUBaieUg6SZLbFy8Z+8TPa0oISEBypZJwBChiYzLl1G2sykBloQ60YzCqRs36tGgQCMcumCCPYmOtsLgwf9gvKlwKleuDC2aNTb78Kdfn1u41uICkqtwHQVmtCb04fTTj2tr8uPadZCn0YmypeND+wrskQ9Cyc1fygwJwSO3IFoFTZUQ+0kvIspazl4iGZpA96pSuRK6Q/dDrylbybwgqLdy5cooVVF20AvHmHIjea7E6+fRGnTC2IhfHKzfdKOLX+d2baEFjj0cCiE9aNxCl3B2GH6GnW8nWpNL6Rnw6++b6ZJSQyTUs79ZBHl2cSoW55mwSOIvW8lCU7cCkuFC0oY/RIbS0CGnjtuFIJFso82aFEhISkqqrCrRSl0SE290CfuqwYboUlHEBbp07ghlsAkn1KpeDW7BbpdINAm/YUry1pqwW5ir121AQbHz/UoT0s6chRU/rnbkB4F+DTLDqSBWMF/lpMqV6BTg0AXJtpXME1EKlOj4Rqqq6LWlpFgSbbMfKqAo0SCaHhje0L0LK8mgfrehAsmHgfQxm5LwB7+YbLKa/fBDu0P+/Hv47NJSUCxDBTlDA1YC5ZXMH8MuSCiIOHJOHDvnyEPhbYlQV5BMkm0jrRZEuqFqdp0O5rTyZ7qMAuTMjOCReFeciNwAvW68AQbd3oefmJPOcxjkY6zZ3whnXM9kak2o3Mm+Zv0vkEPna5vDlSKixYxzsKslco7yS5rSzhYELVJkPyYqD+MeTqVx8sQ15qMjQpGockTDK5FuUNVbTSTHGleuXnVmWJCIYESaGJS4enVqQ5NGjdw9sJCEP3/MpiT8wa9QKErb+o2/05Wlmnbu3Q+btmxjF30oj5y+ADZssW20ZIcrKXM+iqCCBF8oiVAaOuqN7hCqROXvE6gbqgZKZcoUb5+rNBUWbJimeY1Con5iBZ61EollC9ucrQmngEz8cZqS8D7rf93Ie9tGADBv8RLIyhLHTFMukikyFrtX2Ho4+uYy//jhKpWFQXyhIMNaoUIFyyn5UAHJNsbW64d0QwVF99lRzMFMs1rLEkgiaXcUDMYJOVwA5cqXc9iJTBY2edhBpuGmD5lIWVlZsO6X3yz/rzRS+qV0+G7ZCmf+MdGvDjHUvaIyQOKKR5KhNIbikNKYFYc2tE6Ii7X8v1Agkm2fQN1QMVx5I/FWlIt91KADKyEqLoyOI174w8cVJCcnOQoHv6JYySKukH7kkv4y3C84MCclicCJdb9shGMnTjqzj4AmjT8EA0l2T5lkWRBxHhNhKIfSIFWrUgV/QxMk2+Y0eBDqhopJoe3yMLg12bVQmP7ELhZGGH/QbsQNfzEFFbEZN5p4h5JwEIeFTQyCBvrjhwbl67B7FYEraPwwl/f3pXymnMO8w8opNsa8gpfyWNg5bw0y/EwCRkVGA/VQhZBtUxrcSdeSceSllsUGB51eiMIGHUak8ZcLSBYSfsqUTRQbT3PhGAVIJK8gC9uEHxXab5u28N5REXji6PETsAG7ngzMq6goenqucAUjyMhfqnSEojjz3FNpaKAeqsAoYywtZF4SgFoWu1haggjpg0IARgHgL7cU3CIQ4adc+fKi9aCPVBJvrQkdHUddiQi8gzaryMjM5PwUrYfMW/kx562hNIbiOJVGlEMoKwgnwAeRbtBiRY8Nez1gcXFAiaNgUgq0Gx8Cd7OIZ/DJlIoiCK8RN4HNW7dx4QtmhKyIXs1duFi8fcgDdOQRmcM48tb0MRRHKI1QHNo537gm5Ch/xNLkNu2FgxdYUyhM09GqS06T/DggExqNtVzZsmXZybUZWviDpUR2o+Dy8uyw9udI6+EPNm/bAXv3HxRbJaEciEGrG9GHMtZEDr780G4yoQqWbTd5d6NolUJh0jAp1kSrODFoUCkrOwfjQrFBmAtCErlpzl24ySn96BoyZWuyZccuuOBj/U2EXOnbpSv4EB2Rn+LhnyNv0e0YkDt4zryXDn5HR0dBtLp/sIlkG2PplUg3+H0QX4jGGiTYoOUQlNmc+eg2CkAYgk/TvTYbJcfgYyZQa0Ju/NDxaWvD8ODR4gStdXPko4OcS0vEOMOsOMJtVpqYmFgoY7nRXPDhj2zTcxA7ZYI34o3CMGAwyW7sL4vkUmMZHywUClguuZyINKkFh0GnDE/b+NDxDe73jpB3ql+3jhR+Iz9JQQzZMCuNU3FEOKcdQ/J7IVb3Dza5ri+zJDutxfL5JDAuNkbagods6mJxhPHHoRSiIEgB8IsmQHmjm0UMDMNh0aACjMxcFRy03k0Iu8xrJrubMhh5TOVj3dqE6kxWfrKNactVMXm0mxg5LSmBNioO8ifLWDPDhWEoBdodtRmRDrFxsRAbH4ch0Y1h2ANbE3pz7sz58+IekY/fnwaoICJzRZ4zodtQFqEkRHY3twhnKE0KVVwh+CHZxhj6oizqtF/mPPBCCfEJaHG/LrAklgRgAWCEjEwXhMlkwkKhgGgvX05s78WXopsKbS21HsyIkL9E44aKKSlg55YAqxkjr42Khwnz3UNpnHajtalYsYLjvqFEJNuOpFgQ4jKOQZQMsnsjmj61vDqAxApiOCleaDGUgk0qFFlQxslHHAZN2pX+9Jmz8uII+Uu0FzL108ku8lhWUEhCacguFYcsaApyLQ+6lmaynP6hQ/xogJLojVA3VEzgJZEQa6IdDYONHB6DUHyoVhKEP7IQKIRMEjrovYWkJBFnumbdr3LZRAQFQl3sXrHwmz/mvCdCpTEUh5TGW2tDXaxQBMm2kCtrIt2gQTp1zlm+rIhXy1p7BYyuyjf+8MehFOw2Qhh+5MKfcuXKsT8dYXAi7bTjPhHyn2hnSuoe0fnwZIquk8h7K8VhD/Y3lMapOOXL+97sL1iUTOe6W3k4SD+v6gqcMe987U5JScmg0NtkVtcHiPLy8jCulPkmrqNAiMgq7Fg8kFCmDM9xR94WLByBovAMlhh0y+4UK4swzeTIdzLNH+YLxaGn8cbx0aFCJNOkIO7y7kZnVAycZnkHSfS0kY5NpoQGi3L5rT+nmzOfONJOSkEFxIWERGHpuDhamUrhI1QwKo9dVDoFmARcKIFBzileoTTYQmALYyiOZ2sjywQ/3M2S9w8FKodppJ06hSBZEyY5jbpYJyz8XIgXnAURjk0V0C7SZ8p8g9CPFimLGAPUqF4tJNaRlURw94rylAUdFYOUhOyGm/KeeG6KI/hmZRF2Ih6ohxAqVsj/fXlQ9BOqatePKZgAXxTsl16ycsSTdC4Ao4DIzb7OJAm3cFVEpW7auKFgRFAg0MFDJPiUx9xKkKCzG/NeKglanIrDZSMUwak0Tjfdg9bKhRJIpq1k3UxRunJURdE77BQxa6LtPq34gSI7RpZrIqkUxq9hox92kUlhOKwG13XzeiZphHxQ7Zo1RD5KQaeHrcItFUUqjUNxSEmIKDzmvVNxhB+VXUVj/4AQIX9kOk+BQ9iCRB1CwaPke/1UrVKZuy/BItCoCTe/HikMdrGJH3NhCSa0a90KysTHWd4zQtZkUxWoXaMGZjnlpSHgQsgNJTGUxqk4GE7mvVAaURYOpUEiBbH6v2BRtapV8Nf7B9OgxUfp+9Trr293Ft0ZLFNeKCWlkhjQBAnUgvDWoBQfdAvCDxeGq1IQyEoFSku1u3RsL5gR+IXKKRV5BpAFm/KVlASVxTAdisMDc0HuimO4jbIhoqneUAFt9kEyTXLijVCWLnTo0CFdpddBMDk7xKXWoAyrik1SsEAFkkeFhHZHocmCcSqFwRcFRKkks3uXTiJABH6hFrUemG+iC4X5SUJuCDopDRHZKZ+ZsHX3o7Wh89NDZdKEuldUefoCxnwv6YZoFnRlhzNB1lSjRk3MIExqkIjeJRcFRPHhWAs7F4y5QAwS/lTgNapV87hfhKypFo4/DKUg4TaE3i7t3IWiPDf5+dPaxMTEQDx2dzFY0KlGdWOM5Z1IJ0jGWEE0sNO+kz5Ru5DnlBcVicNOMCJopwR4Uwr64cIiBzMAenTtLOwRypdq16juyD/HWII+hp0UQyqHaGH8b20qVQiN99NZlvOBoROsIDgu28yZ4ONTp1ZtCho0XL16VdRGmECnQlDMEGTKQiVChsunU4e2+TapEWBXGvOID71hwRYk8tZwG0ojiD6GUri0NlRObJJb+JO7Ag7Ugw3q5tWtU0dKhvcP6QSFZwXJiVI2o2BhmtHLCyViHzKYCbyanSMKSxLbMdMNxXBRCvJjk4KJ48DatuIj5yLwgWo0W6moDkEXJIRb5LtTadDCdqMMhNKgW34cSkOE/qQ05f2QnxrVqvKMV3GhYvnycoMPSo9XssfagN+wYwXp3aXLOV1XDpsXoVhRg/oNMOloDQLl8XostFMCZIGRj/hIPn0oDJvSjX7E7N6lI9sj5J1qVq/GQq/Z5ZNxspPwO0yDnG5WGiLkUT4LpSFCf3SbW5vytIjU4n+JaCJo+NB7YdSf/wTn+Gg063DXSvXq1UOLtXwbhLpwoGvXrukYXCgIQdG1deiLNu/UsH59NNAeBMqVS97ZjXExfs0f8pM2Ec5BAE0aNoQK9K6ICz9CZqLlOUL4ScDluitSFjMxT4QRJBTFrDhcOZmUBi1s95b/ndq2gU/fexuGDxsKn385A1meYYqKWIZZQrwT6sIvaGE4FAS9UEF8o17detiXt0lXYJGVY7FVPaeHTHKRFX8dJNwGAVYO3Tp14HtFYI1aOEDnLhERtwDCTvlHwi+E3kJxWDHkNQ7TIKdfOVpebkKlihVg3EujYOL4caycG375Fbbs2Cl9ix40Dq1PLUg+QGlx6IJDQVRNX405YBIwT4qNiYZ6derKKwIL2vqH1EBERQo+u01xRDj8zIQf+tJDw8gCRmvQUQXlkpMcgm0MtJnMSiPdRt6S8JPSUAvhojSG4nBrI8IlJSbi4FfhB3X3DugPX3z4Htx4/XX8/+T/v8lfsr24UB8H57T0HiPuk1gXJBwKsnLlku3Yb8SxiOU1DmrWpAnJWsApz3gnhD7mCBHYKvgOYiZ+sXCMMUvFCuWhccP6xI6QG9HSC7KIbpEgFnxWDCHkxrSu0y6JFIDCy7xnpZHXCyURCkNve3Zs1xY+fPsN+NNjj0C8ab+sJct/gINHjnrEqyipaZOmGC+0+yBM39kbb+zmeOzhUJDU1FQNq9cfpNMrmjZuwrWA5d2LkWjJu8NNYKsoEDOJ3EC7VApiGB9kiW4Wh4uQmaqjgthRiEnw+R0PEnpJopIxKY2V4hgm8dlPXk/X4P1t2DWvW68u/PO1Vzy6OXSy1WdfTveIU1ESKSdV7vlBAWUlPUGXTqeCEHAAv0xavaJMmTJQv27gu1m0NxbKOKYVC8udhIcoSOZRUPFBFvO4oNFs1aI5JMT7OtK4dIKmeIWgCyURpqj5yTQUxxB8Z8vsvbUxlIz2523dqhWfm26FuQsWwtlz56WreFAPu1c03Z8fMAkuOuCiIGDTlmITg+kmwfJOrVq0lBcEDmJnEyHkTPhBi6mgKJTg8wcZhlKQn3EdDdQ6tmvD94zACWpBhIBTvpEyiPxzKoYgVhrmSUXy0dqUSYiDllgh1a9f3+uD2kvp6TB99lzpKj6QzFrJshtpKiiL5SUMFwXp1aPHYZSl7dLpFU2xqfJnX9OiBI9B8MNfoyDclAJZzoKicPhjRZEVvq5IKlsWW9V4mXfUGlC3SCiCsAu+UBajdSCFsW5taCKkDvYyWrduDYn0urYPTJs5Gy5fuSJdxQM646R5s6bS5R2Yzm09e3Y9Jp0M1xYEgRky3yxMVkQLz1o0a+aufcVKdBqtUArSCjQtlcKVOD0OO2sMU83q1fmJrdX/lEaqWqWSsKOwU14Ju8g3B98g2kWRTVIM4cdKIxUnpWIKdOzYAWpgHuc3Y3gqLQ3mLVrsiEdxUbOmTbEFoyX8rvJhQQtk1BzwVBDQ50urT3Ro207aAgPen1d+SCkoQfkpBbsdxF5sEEVaESd4BkvCnHck/A4iN/NMJvINpYmPj4U2rVtB8+bNuAL1B59M/lLs3F/M8FdWFVXx6Ot5KMi6Vdf9gQk/ZM4oK6pRo0ZA3xHJldO8TqVwFibBsAs3ewoSLiYsSixcKmwN2rVtxfPxEeD4w4+TaM35aygN5zW2ErR8o0vnzgV673zvvv2wfJXjcUOxgU7ZJVk1x9+KUCb233Jj903yMgc8FCQ1VcGUK19Jp0907hi4l5HEcxDXgjITqwCZTPx1KAX5G9ONBujsi9Ytm0tX6QV1g8wtSEFAe+5279aVp20L+sbpR59PdimP4kLnDh2lLR9o+mzz9K4By1QpWt50Q/B8UasWLaBMXBwfyl7cZGz9QzD+X2iCQfy1VAr6OEDhiIctUZf27Sz/qzRRxXLJPIgtCOLisDvVpjW0b9fO5WGfv9j4+x9ImyzjU5REG3C3RBk15MUX5WnadBk9F1gqSJ8+N23FyzyaG3fQ1F2njoFZJUsH3NPUIiUGfyShh/RnQp6lUiCYJ7tnhlfDBvV5s2vH9aWQaHrXX/DsVJ3a3GpUKWT3OiMjA/7z0SeWcSlq6tShg9fpZTNQJjbdgTIvnS7w2i7quvYFC1U+1LF9h4BM+dKDpPc+/pQ3/OKpQ3qYj3xqLUgpWDGY4wTHkZQCyc2LoaoKdOlQugfr1atWlTbfoP2Ou3bpBI0bNZRn+1lkaD64fPkyvDjmVd4zubhBEwWdsHvlLq+WBNoX8jIPeFWQOJs+Tdc06teQpHklmj/vGKAZLTp19R9vvsV7qtaqVZv3e/UARcuHUrijcwfsZuUzHRnOqF7NdwtCi/toZqpTx/biKAwDVP4FwNWsLHjplddg5569klO86NCmLcRj999dXj1Ju6rkZU2Vl3nAq4L07NnzLBqz8RYsZ76oa5cu/LpmILBt5y6Y8K9J/MeVUirxNpnJSUm0hkYoBiW6AKC33BpjV6s0gsqsMuahFajSqFGjOnTr1gWVyLqV8TevaYp+9KsTYGsxLmU3g3o03bp29ZBTS9Jhbt++fb2uc/GqIATFprxvfVdXKlumLHa12qM1MJ+NmzbDG++8C/QEl/qY9HCqNrYo9L5BYfbvomci5vuXlk+llAryZGBXUMvcEVvWZk2dKyaslYHu4hu0RGjshH/Axs2b5b8W/6dju3ZQJqGMi4x6JTv8F3+9wqc03XrzDeuxb/+H9Z1dqTtqLJ0aGiis2fALvPP+R/K5iNiFvkLFitj1qsX95YIoSsvmTUvlAkb38QdVNjTG6NSxAyRhq0wla4a7m4FjP2+gzf5S//kv2LAxcIcYxaEM9ujaDW1O2fRGqPQbb7vtpvXo8ArfLYii6Ng7/zcJYH4UH5cAPbp0lVcGBvSg6ePPJrOdag4CK0r58gVSFKolO7YtfQsYzTNYtJlaly6doQYdvWaMyahgzXB3Sxh5bwY9SPzHG/+Gn9ZtkJzAoDvKYFxcvItseiP8fYcv8oF8padyxcSZuqIfpVmj/IgeHAb6LJGF3y+BqTPkc02Dj6B3VmiTgJo1avBUbn6KwktPTPctDVQDWxDe8aVta2jRorlYIkJeMk8IFNQMy66WG4+U419vvQPLf1wl/AJE5bDV69Kps6VsehDAkaOHEmeyzQfyVZCOHTvmYnqxFeEmySdRE92r582cwYGkmfO+ga+RDJjjRLUhDeJp8Vy55HJgU62Xl5A/vRdtdf9wJDogpwOOMzp36ij3zSWugNNGcHV5A+W1Yb79/ofw7bIVjv8KFPW6qaeYgjaVvzey6/pbTzzRMd+FYPn3PxBX0+ETjMAZ9whZUbOmzaBu7TpoCywmfzULvlu6zJEBBGHqWKORS+FpyqpYa9I0MWWkO0rLpg5dUDE+ePtNqFu3Di3Qk1wTMNtEDgoY+WnA3S2A+Y6f9z/5DOYt+k7yAgfaDK4pyp4ocd+Ew9bTek7Gx2jNF34pyODBPTN1TX/T8t8sqG/vPpYCWJygQvsQxyMrfxIL4Gg5NkVGKIfwlzauPStXqsQtizme7du0Cdh0dTBAO7e/+rcX4PVxY6Ca5dStkUeUX9Ii4eb0cBM++WIKfPX1POkKHGjR6W29bxWR8ov0SXfeeadfL6H4pSCEsnE85XtaOn2Cpl15wE65HECipdfvfvgxbx9DLFfloJZFMMhN9SYtWKSThgxFSUiIh9YtmjnuFy4UZVN5F5FP//suXNedZniIjX4OmFsRJ19mn4BLeISbe+qMmTBlxizBDzDRwJxWWPgDlIJTem7me9KZL/yu5idPnpwz9IGH6DTN2wTHN2hwvGvPHrh8tXjfFnMHvauw4dff+OGfsV7IqSBkMsNhJ5PGTqQcND6hGa0NG39nv3BAq2ZN4bXRL8MtN98k1iWhLjjVQcExmrS6wMTMJzyN8Wbj+O+DT78wqVbgQBXcgP53Omfe8gHGcfSd/fqukc58UaB+0IP3D9mk67b7MVvyPQ1FVVSoXrUabN621SmYAQLNoqxHJWnZrAlv9UOwUg5SJs4y+kWDWhEaqNMGBifT0iA9I4P9SiJoj6unHxvJ2+vQbB7BIUQmofcuWJ5hCe7hF3y7GN76wK/ufJGDZiaHDLoXkhKTJMc3sIgPZGWeHTF79mw6rswveMsdr1jw7Q9DsGPm1/sihJ/W/ASr162VrsCCWoXUl//KO1qwBiBIOVgt3JSD+W5Ey7K/+e57OHTU5TXlkAYtwOzb62Z4ZPiDjrVqVMhc0ChQRoE7dAUrMqfMk0XkibyCQf5OF7mF6/tlK+D/vfUu51UwcH33HnDDdTdIV/7Q7fqQAf16YT/Qf5jT7RcwM5QFi1eswca2u2T5BL3EP2XaVDhx8qTkBBa0m9/40X8TU7gk+MgTBUpKwEEE34LYD1ujzdu2wzdYU+4/dJh5oYoG9erCX558DJo0aQz8iBcF2RB+HmyyWzLIW9j4UH3D7gon12WyC++xctVqeG3im9xaBwM1qlWH4fc/6NeDYIIG+toBt/W6HtNfIG22zpd8MP/bpR3x0p/xz/yK3YULF+CzyZ/zxgvBAD1ZHz/6Jd6XSYo9KgBbWBGMQnZXDgokumFk1WD7jl2wYPES2LP/APNCBfSwj3ZG73/7bdxNZN2gH4QxjUu/bLNoRcjCmwEKB5JZhiQfDaOw16z/GV55/Z/8fk4wQEuaRj40gldK+AVdz8N86HLnbbcUeHBp5EqB8c2iZR/g5U9KZ77YuXsnzF3gfJgXaFSplIKD1Zd49S7JvKEEpByG3aEcZJrdUmCM9+H37N3HirJrzz4XUQo0qDW4oXtXePyRh/h9cD7BVdZZDiXBMIbsGwJOLYaw8FdYXbpaZjiZ5P8rju1eTn2d9wgIFgbdORCaNcl/Gx8DWEYfDOx3y1PSWSBYZok/WLRodflcyNqFheT3q2XLli+DX38P3MI1d9SqUQ3G4ZiEnoMYwi8UwKQMZJrd6BJsk7+k/QcPwaIly2D7zt0BV5Sa1aviAHwktG3TSigCthQqx8LUjZLF69GKsNLIMGgYvjR+ESDTnCLB37RlC7w0NhV7AsW/E4k30FuCvXv1lq78geWUBmWimt7Vs+dFySoQjBwpFOYvXD4US2eGl6rHA7Sx2PSZM+DoseJ/o8wbaIfvv7/4PB8oaQg6EcNws5V/iSV4wsImdbuEP4eAw4ePwOKlK3jrfoNfXKD3x+8dNADuHjAAomPkm5yY/aQkpAjUihCDFMCqFSGDrQUcsG/HtL04+hV+8SlYqF2zFtw35D5QTQ93fYLKSYGhd93RO981V97gyI7CYu6iZQvwJv2lM19cuXIZvpg6GdLT+QCfoKBJo4bw0v89w888HAKNpjHtK1jC5PEJWoxwhnLwh3iST/bjx0/C4uUreFBP3bGiBu2M/sTIEVC1ahVRcCapdyoCPQQVCkKwUhLuYLFbMshb2CwH7Lv37IVRL48t9h0QfSE5KRkeevAhHm8VAAvu6td7gLQXCu55UWDMX7q0up6tbMM7+X1S/OnTp2HqdNo0LDiDdkLrFs3h/55+kpcpkCiz0LOwC8E2xhukAOxnCsMf6UcQfKc/7Ri4ZMVK+H3L1iJRFDpo5rGHh0O3Lp3RJQWdBJw8zUJOiuDW1XIoCHHcu1p+DNgPHDwAz/11NKRnZkpe4EGrjB8c9gBUruT/RhFYDuf1HHvLu+++7ZqmT42cuCbMXbT0Pqy4LLdN8Yb9B/bDnPlzRQ0dJHTCGvnpxx7hWpMFngXfKejkMOyO2SyTcgg/EZ79yC0H/URnzp6DZT/+BL9t3lKoGR968t2/bx8Ycs8g8UIXdYHYx4eSSD/BcVMSCi88/BqwHzl6DJ7968tw4eIl6RN40DTuPQMH8fmYBYGuwbBBA/rMkM5Cw8iTa8bchUun4c2GSadf2LRlM3y3xGUz7YDjuq5d4NGHHmCBMISdBV6a7uMNs5+wGnZJrCAc3BH+3Pnz8MOqNfDrps28AZ4/aNG0CXenateqxYVE8SNhF90iKejkpsDsIBO/pAhurYiAMP0dsJ88dQqeefFvxX4sgS9QvG7v0xfatC7gy2w6TLvrzj4PSNc1ociW3N79yPAVah4MQYnwu6tVtUoViFJtcOhI8B7AHTl2HDKx+0DnhpAwk3SzifA13hBO6U/kaDk4CF9jTCHHx8VC8yaN+K1FaklOpZ322nImJyXCEw8/BI8MfwCSk5NchFeQVAr8ZdNwm4Wc4sB8ERm6BzcgHBJ/ZVACW417CCuknT6D3aq/cwsYTNx0/Q3Qsb2fOyNKYL4fjIuy9582bVq2ZF0TTFl17Zi/aEkXu11fjQVSoI2yVq5aCet/dRwsGhT0u7U33N3/DiHk6HYIPn1I6okcfJM/kUk58NfFj5iGnRUOxyS0xmv1+g3wyx+bHQ9PqSvR+6Yb4IEhg6Fs2TLIQaHlWSksIkOA8YfHB+wWRSfCkEW4yeHsThV8wE6tHSnHsSCtfDDQrVMX6HnjTdLlHzB7sxVVv2FQ/75FJkxF1oIQvpr+5fEhwx6kDqtfK34N1K1TF7KysuDEqeAVCj0dj8YBe8P69Qo13mA/Gd7ROmBHmPhCMWhzO7pO472mGtarhy1KaxZ42r7zhb88BX169YLYWGMbUBJtNqQphZrcBg9/HX7SZJA/RZP5Ir6sAPwVYQyFILAN3ZcuXYLnXx4LR48fZ36w0Kl9B7j5pp4cpwJBh1F3D+hbpKfxFDAG+QMFRPl6wffT8cZDJcsvkCAt/2E5bPwjiEvNsUDuxwHxTdf3cAg7RcyhAA67JFYQcSm6mOddOYQ/MY3raYBcqVIlKE9PwfG/SVlYgB2lgi4SEvoaA3T84WGE3wN2+qVICru3ViQjIxOe//sYfvgZTJBy9Lq5F0W/QECxm3HPwL4FGgP7A2Myo8iAhaAnxqmPogBsliy/QIV1y823QJcA7hjvARTa6XPmwnp64YoE3SHMZHUKNiuGm3KQYgjloMCitTB4RteKyFCUxKQkqN+gPiqHc8jG9xYWdhMkh3nCT3qbwngFhZVWA9yyEEzXZ16+DC+98mrQlaNrp84oAwVXDsSmGDXnUWkvUhQiLv5h3rzFdfNA+wVrOuut+3xg3fp1sHrdGr9koDhAJ6I+/vAD0KYVncVIAk3yJARbKIbksZ+TiGnYDaUgkxSGDfyhp9+Vq1SBMjjOcGa+sInaXtT0Ru1OfmxnnqjPyC3Ij1YEWwtfT9izs7Pgb2NTA7broRUoTjf06AHduvq1QNwVup6m2LUu99zTr1hmemROFg9mz/u+O4rICrQWeFe2TZs3wdIVy1mogoGoKBs8NXIENGvSiOPgVAwip3J471JR2RmtEPpjTlNXinYQYYElYSYSVyOEm0Avm7FASzf7FcOAPSc7F8akToA/tlhubB4Q0OREn163FHwql6FnYT71uveufusko8ghc7L4MHPet0OwWOghYoG7c/v274MFixbx9pXBQAzW9n95/BGoV7eOVBDBd1UO1gT2I+UgnqFIgq/z8oiUypUd23gauW68yyCc8lcKvFAgZiGkXfqxKQwkyXMJI0wGhSFtQOUxPxvJycuFV8f/E3757Q8RLgig/LizXz9o2KCh5BQE2D7bYdiQe+4o9DorfyBzsXgxc+63z2OZTJLOAiEtLQ2+njcPMoK01IF2CH/miUd43ywCKYehBIZycGvBrQb60liDPmjSk/CUSinYnbLYhZ4Elz5Grc9wCndxDtjpWOcJEyfxex3BAh1hcffAgVDFj+Pf3EHZDKo+asjAfm9JVrFB5mDxY+bXiyZiCf1VOguEy5czYd433wTtrcQyZRLg2SdGQuXKlVgxzK0Dkft4g7I1uVwy7xXMQu0N6EXdKTKdoQxBRptLV4v4zCSbNIUXhxee7Db8hINM/MpWhA78nzjpXVj5k9/7FhQ5qmNlc9edAzBf6XlPwYG5PXHooH5/k85iRZE+B/GF2TOnrdi+a29VTF7BHo0i+Njp5s3hypUrcOp0Ghd4IIlOYt26Yxe0at5UnjnhfbxB+8JWrV6Na0ifykFgb3rJSQo0Q9ocwi2FnmEIPrENf4OMeziVwzAZZGBE//3eB7D8x5+EOwjUtk1rGIDdqsJudI5Z/OHQu/s9L53FjiKf5vUGLFB9x+ZfnsIETibhKiipqg363NIb7rj1VojGATTX1AGki5cuwvuffs4P00ghePrW6FahP818VcLuQvWaNcQet/6A0kYG3UNwEGabtFMGCIvJavhJq+kejjAm0H/896OPYcnyFeiwTmNxUgyW2R239sUBeW8uS4pjQQmze/LOLb8+TckRqSp+kF4HFLNmzbLZ1fgvUGEKvZjs/PlzsODbRXD6jF/72BUp6NXdp0Y+zE+/xVJ2nY8KoO6UvxsIuECWQHEO2CmWn3w+GeZ8sxBtgQctU7/zjv4FOibaHdhDnLJr8x0j+BTmAILyL+AQSpLwP7SOEJyCgxb9rV7zE2z84zesXQJWoTBqYhfqseEPoGIk4iC80rWfi2IItxRoAWlH3rUO2KdMmwHTZ3/N3ECC4kiLDa/vcf21bkX72a6tdzwWaOUgiLwMAlColRlzvn0X8/DPklUo0Ou73y/9Hi5gFyiQoM3l6tct6k26DdE2weEgFaGKwOTLVqfbzcm4cuUqn8gVaNBmdX1794VaNWtJTmGh/wfHHM+isgW2FpRwy86AQ5k+e+GrmAljRZVYONBzkjVr18Dvm/7gcUEEwQN1FTu0awfXdb8OooznPoUAVqA6SkTqsHvuTJWsoCDYCsKYPnvBk1g9vIeRuaZ2mJ6ZLFuxHE6mnZKcCAKJalWrQu9et0CVygV/tuGGPOw1//n+wXd+JN1BQ0goCOHL2d/0Q2MGdiQsnqr5DxqPbN22FdasW8vTwhEUP2ilAG0D2qplK5SoaxQpHTIUXbtv2JCB30pOUBEyCkL46uuFbex52gLM5NqSVWjk5GTD+p9/ht83/+H3a64RFAx0lkr7tu2ga+cuEBNTBAe46vphu64OGD60f+AHTV4QUgpCmPL115VtedFzMGbXS9Y1ISMjA9auXws7du6IjE+KCDTOaNGsOXTv1oMfiBYFsOVfrUXl3TP87rsDP3fvAyGnIIRZs2bF5OhxbwJof772Nlvg4sULsOHnDbBz966IohQS9DC0adOm2GJ0hXLl/N56wCf40aei/OfKhVMvPPHEE8HbstELQlJBDHw5c94QTYePcVzi3wEQfiA9/RJs/G0jbMcWJVirhEsaaNVti2YtoGOHjvxQtKiAypGu6vD4A/fdVawrcq8FIa0ghCkzv2moaPpXGNMiPWGT3oHfsmUzbN66BdIzS+5BOcWJpLKJ/J5G61atIY7WoBUp9I26ot43fMiAfZIRkgh5BSFQl+uqPWq8oqujsMNVpAssNV2D/QcOwJZtW+DwkcOlvvtF4ws6pZiUon69+mK1cRECO1R2FLo3mzWuOZaOGJfskEWJUBADk2ctuA40++fY5SrMGzb5gvbHosH8zl074ey5s5JbOkBnpzRr0gya4eCbjssuDuBAfB/WSCMeun9Q8NbaFxAlSkEICxYsSLiQaf8HRv3PRd2amHEOFWT33j2wd9/esFUWUoqGDRpBk0ZNoGJF/06JLQy41VDgP1fT1dFPPOHf8cuhghKnIAamTJ/fRVe0DzEJbSWr2EBL3A8eOgCHDh2CY8ePB3XT7WsBLcOn04dpH7J6detDcnKy9Ck+YKuxCauxJx4eMii4OwMWEiVWQQjjxo2Lqt+k7Z+xGMZhUvw8j+vaQGOWUydPwtHjx+A40qm0U+LMDKwmQwpYZdPLXVWrVoMa1WtArRo1oWq1akU+pvAO/aKuwKsJtrz3Bg8eHJyz2ooAJVpBDEyZ8nVlzQbU7XoYC6bYul1WoKUtdNYJKcqZM6e5O3bu3HnIyEjnl6kCAVoOn5iYhN2kCpBSsRJvRkfrohITk4voKZL/oO4U/n5u05TRw4eH1kO/wiAsFMTAF9NntwZdmYjJ6itZQQMtbyHFoe5ZOioLTQBcvnwZrly9gi3OVcjGVode5bXn2UHTkFCySNkItLCZhJ7evLNF2Xir0ti4eG4REuIT+F1uGkjT+eDUTaJnE7RBRDCBMcfo60tUVX/p4WH3bpHsEo+wUhADn0+dfZOuqhMwcT0kK+Th3tgEuua/JuiwRlOUMSPvH7RKcsIGYakgEspnU2beAortFRS26yQvgqLFak2B10bef89y6Q47hLOCOPDZ1NnXY1Jpy6HbMcUB26giLCG2b/lOV6MmYotRYp5nFBalQkEMfDJ1fhMVcp/FLgEdKVU0y1BLCXB8kYHiMlVX7O8++uCQ3ZId9ihVCmLgk/nzE/WLeQ8pKjyGztaCG4EldNisKPr/9JzoKY8+OrDULVorlQpixv+mzesAefYRmBODMTMKvBN9WELXaXp2FrYaXzz28ODfBLN0otQriIGVK1dGHTh+trdmh8G6ovdXQCm+tRehibPYWizSdJh14mDKstTUnpHXMBERBbHAuHEro2o0OH+DAtqdWJ3eruvQULmGXVdCEfTQAo19aPsOpWDB8f07fkpNTY0ohRsiCuIHPp4ys56uKX0U0Htiht2A2VZNepUooEacwN/Vimr7QQf7sseHDzkovSLwgoiCFAIffjGjQZSudgcVOuu60lEHvQV2yUJqVgzjlIFx2o4NxUZUjF90RVv35MP37ZfeEfiJiIIUAWgr1XOZufVVxdZaUdRm2NI0pm4Z5m49lNQU7J0VyzoQFP48/A8aOxxEk7pLe/B/d6o2ZXNynHKwJC8SDBVEFKSY8fnnK+Ny1DOVVU2rBbqtCqh6Cgp0BV3Rk9Esi8qTALoSpSmajU9JQ+ioYaqu2jFMHmrBFeRmKrpyCc3zoClnQbGnaap6NEa7fHrEiBFZ/EcRRBBBBBFEEEEEEUQQQQQRRBBBBBFEEEEEEUQQQQQRRBBBBBFEEEEEEUQQQQQRRBBBBBFEEEEEEUQQQWlBkb8PMm7Cv9pqoE7EG9eSLAd0XcnNTICuSenpdj06aTxybkO2y8tEug65igJzldyM8ampqdqY195qpqj2N/F+9WQQBzCsvUx04nVXr564rEUlvYKsAYqiRwtfB/J0BRapORmv0DvXo8f/q4ENbJNA0RtLfw/oduXp8eNGrZROrxib+kYnxab+A6+oIVkmKFlKbnpHLTrxE4x7V8l0Rw6Gm5k6+vl/jpkwqaYKyvcYf59loihRQ1NHP7fllfFvPq0DPIJ5FS+9DGigK2uvxuS98MZLL2WMnTBplQK6z91aFFD+mTpm1JSxr7/ZG699BcNbbFih7FVUGJX691H78L/fwYt6Sw8XUBljGha0bFz7VX9e2MJ7zcV7NZVOV+jKVfz54rWxL/zn5dffaBmtK7Okjyd05YgWBS9NeHlUkR4hXaQKMmnSpPiLV/SDiqJUkSwPKLlqeT3a/izaXpUsa2j6cy2b1n5v256je9HloRwG8kCpbtO1+/A/J0mWJXRdG6vmZf4DFWkrClVzybaGrg/DQpkhXZZ4ceLExPicKHqTz+vuJzs3b4hq1rrrWgzTRbKsocPjiqqt13V1q+R4haJrvTTFlohCPF+yrKEDCtaoEWMnvHkJFcDnyZtY0YxVo21TtNy8PZiPXg88x3A7XhvzfMtxE/69GNN0q2R7w19fGzPqDWn3ilcmTKIzChsIlzUURbsb1f6srqg+9/6ld+7V3Fr1UlMHF9kBLkWqIGNem9RKVUHs7K3rX2qKfoTtElhD5mDL8DrWqkuw0G7GDN+jK9oc6c17gmIN9AAWUm20fG0H/UWboh4QvjBLA83lwEe8X17FxOh/nEvPnYm5OEDX9UO6ok+X3gwV1HvRaIS0NE6NGZal5RjHRc3H++2QdgcUepfPBl9QTSlZlhg3YVJnLJCfya6D/jnSSfaQUDUl67VXXpjwyvhJ66WC/Ir/t0z4crxI4B5GZa2O8f5SVfWJhoIg/xPMF4+jAyhudkX5L175AubV8/jHF/B/P8Q0Y1QEsAG6BfOvM97zwPixLzQYO/7NF9Cfz2zGPG+P1Bf/IRubGa5QFAXTq8MCDVt8FAZRFrr+Npad4yQoVVeaYcC7yM4VXJRGh6qiguhb8T4LOZAE/v9Q/P/6GKNF48eO6i/ZXjF2wr+fxI6AR28D74NRhSfwpwIm7h1V1+Y6FETX38X4ZbIdgfGrjfF7gOyoTK1SR7+4jT2KAEX6rrRNVW06qjpBUaMmThj9nGVEsdkX++Mq+uoJY14czXYJbHKboFEbCcPEIImdaHS7/e0J4/66nh1uwPvZpKb/4nm/SdUxoxuhMNkydE01+l8oNO9PGP2iQ2ALCs1utyk2cRRJjK6njh374mF2eIOur58w1iNubdCojiTyQwKz8T+po0d5PUIA8wjrBkyxAgfGj3nh75LNGDv+DeyWKJ1J8smNSvImeyBIGDEifVHgsj3yacKkOmSin6bmZYyagN1b9kCMfX1ST0UHVpDs2Ku2GLtsZHT4wz1NqJB10ahP2iw4vjF+zPMfSqsHME43o9EF9d/lzBclxj5xwksvnZBOGPf62y113c4KYrdj9VaE8CsREURQWhFRkAgi8IFSqyCqphbp+KtwEN0QBdSL7AwH4ACEDYBrThOOo/heuqpcYEYQUKoUJCZHy8VM5wEtjkE+xD7uOjONHT9p4djUfxXLqVT4p4Pd/w/HoT1xkH1RUe3/lcEYup43xS2s5fQmpqSpW7h1OPR4XHoHAre5/z/y+mO8LuPg+h0RxD/guOp+831wLLMela09JjJN07RPZbCAo1QpSGrq/13ECu4b6aSp425mwrqvH6i2JePGTaSBc5EC/7cqGi7/h1pjx8HvU6mjX3SbTVNo8O4IhwJ3I3HdgfEtg4brPS2ePxUbFIWer7j9vx6FA/TnU8eMKtCxzzooNDnjuA/mV1fk0n5gj7ye3wRIMaLUdbGU3PT76BkL1uj/xdrpfYOwJp/M/ih0enRUkbciKORbzP+HTdj7yL2C8Zg6bvwbNFvjAPJmuoSluFpB18+4hBNheeo5MNB3e/y/zjs9fjju9TcHykB+QQXtR/N9MA8+ILam6vPGvvZmBxEq8Aju0ahBQGpqKu1E6NH8/+Uv78SWq5L3IHZ66QFFkeeLAvqPr4194VnpZLwyflId9LgDu9r3K6C9JdmgKrZ/pI55Lv+TYhXlyGtjRj0tXYyx498Yg90s3w8miwo6/Ixpcvv/N8th7T8MK4QH0en7YaYJqWNf/AENIgewq9UejS5YIkOxTFyetwQKpXaQHkrA1itOWsMGRZomPXj5E1GQCCLwgYiCRBCBD0QUJIIIfCCiIBFE4ANFOltj1zRdlSqnafbBY16f1Fa4BFRNz1XyMmbzwzp64KpDKwzDi8wItMoMvcS7AYqiR9nsum68URCl3oVhXZZF4/3sfD96B4KhNB2H93N5CUGDlmTQilc66Gb73qP3or9HulUtN5EneREaBmamD9htNsdUV66iPIBxc5mrV3XIfm3MqNnSWSBoWl4/vJ/H8dSqpujZ0TmLIFcyihAal51KT8BVPSbpMfz/y9KLyqmjtEFsdmyRzvGNG//vPnZVryydDmBasRB0WmGMMkFre51FoufY7sb4OZ6uo6w1FiWHMoQyI2xFgyJtQXJjcg9hongZMkZ4LArJVDMh8yuAckmYWp7CVBSls9kf1WYqcluQH9q3nk+wHUfLOQ6rKy+awxLhDabnRidXwtDyftCa7uEaRhQuauSWP/aerID+M8z+znD0XAL/BvPbZtPynWKNztX3YVrl4TXKBI/7Acy69957C7WyFPPldff78T0V/cu4XFsxPROI2u6oaHT40Py/KHtielrXj+/YseES24sIuqK9b/4vgzCtU/B/+YEtlqvrS1CK8q45LMkasbE80svGKEV6zFyRKsjEv/0NM08fhhl9TLLcoGPdF52n5qqvYmq+xdbC4o0zCgOzyyXAxP88+2y2AupQvN8h4ecKuj46F6v+WP2fKPhzMZzHKa2St8CWG5Wqq1fyrMIYwPtdwIbmGc8n255ITX3hLJbUA3iRy3sgBvBe2c2bN6fVRFfJjRWixUlQUsEwjN2uZeM1GD3f0GxRVzEQ39MwzcA2gN/jUED38EPtZ55hmjHhlf/biWn/MwrZeclyg74fm5j7Zs+ebTfSZJgukDyr//ACx3sn7sD0ZeHPhy2b1PoCFNXnSVqYdcdUDe5/8cUXnS3fNQPg/wNUUJtMEKHeLQAAAABJRU5ErkJggg==", SplashImage = function() {
                function SplashImage() {
                    _classCallCheck(this, SplashImage), this.handle = 0, this.callBack = null, this.cancelAnimate = !1, 
                    this.startTime = -1, this.setting = void 0, this.image = void 0, this.device = void 0, 
                    this.cmdBuff = void 0, this.assmebler = void 0, this.vertexBuffers = void 0, this.indicesBuffers = void 0, 
                    this.pso = void 0, this.framebuffer = void 0, this.renderArea = void 0, this.region = void 0, 
                    this.material = void 0, this.texture = void 0, this.textureView = void 0, this._splashFinish = !1, 
                    this._loadFinish = !1;
                }
                return _createClass(SplashImage, [ {
                    key: "_tryToStart",
                    value: function _tryToStart() {
                        this._splashFinish && this._loadFinish && this.callBack && (this.callBack(), this.hide());
                    }
                }, {
                    key: "main",
                    value: function main(device) {
                        if (window._CCSettings && window._CCSettings.PreviewSetting ? (this.setting = window._CCSettings.PreviewSetting, 
                        this.setting.totalTime = null != this.setting.totalTime ? this.setting.totalTime : 3e3, 
                        this.setting.base64src = null != this.setting.base64src ? this.setting.base64src : defaultSrcBase64, 
                        this.setting.effect = null != this.setting.effect ? this.setting.effect : "none") : this.setting = {
                            totalTime: 3e3,
                            base64src: defaultSrcBase64,
                            effect: "none"
                        }, this.setting.totalTime <= 0) return this.callBack && this.callBack(), this.callBack = null, 
                        this.setting = null, void delete SplashImage._ins;
                        this.callBack = null, this.cancelAnimate = !1, this.startTime = -1, this.device = device, 
                        this.image = new Image(), this.image.onload = this.init.bind(this), this.image.src = this.setting.base64src;
                    }
                }, {
                    key: "setOnFinish",
                    value: function setOnFinish(cb) {
                        this.callBack = cb;
                    }
                }, {
                    key: "init",
                    value: function init() {
                        var _this = this;
                        this.initCMD(), this.initIA(), this.initPSO();
                        this.handle = requestAnimationFrame(function animate(time) {
                            if (!_this.cancelAnimate) {
                                _this.startTime < 0 && (_this.startTime = time);
                                var elapsedTime = time - _this.startTime, precent = clamp01(elapsedTime / _this.setting.totalTime);
                                _this.material.setProperty("u_precent", cubicOut(precent)), _this.material.passes[0].update(), 
                                _this.frame(time), elapsedTime > _this.setting.totalTime && (_this.splashFinish = !0), 
                                requestAnimationFrame(animate);
                            }
                        });
                    }
                }, {
                    key: "hide",
                    value: function hide() {
                        cancelAnimationFrame(this.handle), this.cancelAnimate = !0, this.destoy(), delete SplashImage._ins;
                    }
                }, {
                    key: "frame",
                    value: function frame() {
                        var device = this.device, pso = this.pso, cmdBuff = this.cmdBuff, framebuffer = this.framebuffer, renderArea = this.renderArea, assmebler = this.assmebler;
                        cmdBuff.begin(), cmdBuff.beginRenderPass(framebuffer, renderArea, GFXClearFlag.ALL, [ {
                            r: .88,
                            g: .88,
                            b: .88,
                            a: 1
                        } ], 1, 0), cmdBuff.bindPipelineState(pso), cmdBuff.bindBindingLayout(pso.pipelineLayout.layouts[0]), 
                        cmdBuff.bindInputAssembler(assmebler), cmdBuff.draw(assmebler), cmdBuff.endRenderPass(), 
                        cmdBuff.end(), device.queue.submit([ cmdBuff ]), device.present();
                    }
                }, {
                    key: "initCMD",
                    value: function initCMD() {
                        var device = this.device;
                        this.renderArea = {
                            x: 0,
                            y: 0,
                            width: device.width,
                            height: device.height
                        }, this.framebuffer = device.mainWindow.framebuffer, this.cmdBuff = device.createCommandBuffer({
                            allocator: device.commandAllocator,
                            type: GFXCommandBufferType.PRIMARY
                        });
                    }
                }, {
                    key: "initIA",
                    value: function initIA() {
                        var device = this.device, vbStride = 4 * Float32Array.BYTES_PER_ELEMENT, vbSize = 4 * vbStride;
                        this.vertexBuffers = device.createBuffer({
                            usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                            size: vbSize,
                            stride: vbStride
                        });
                        var verts = new Float32Array(16), w = -this.image.width / 2, h = -this.image.height / 2, n = 0;
                        verts[n++] = w, verts[n++] = h, verts[n++] = 0, verts[n++] = 1, verts[n++] = -w, 
                        verts[n++] = h, verts[n++] = 1, verts[n++] = 1, verts[n++] = w, verts[n++] = -h, 
                        verts[n++] = 0, verts[n++] = 0, verts[n++] = -w, verts[n++] = -h, verts[n++] = 1;
                        for (var i = verts[n++] = 0; i < verts.length; i += 4) verts[i] = verts[i] + device.width / 2, 
                        verts[i + 1] = verts[i + 1] + device.height / 2;
                        for (var _i = 0; _i < verts.length; _i += 4) verts[_i] = verts[_i] / device.width * 2 - 1, 
                        verts[_i + 1] = verts[_i + 1] / device.height * 2 - 1;
                        this.vertexBuffers.update(verts);
                        var ibStride = Uint8Array.BYTES_PER_ELEMENT, ibSize = 6 * ibStride;
                        this.indicesBuffers = device.createBuffer({
                            usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                            size: ibSize,
                            stride: ibStride
                        });
                        var indices = new Uint8Array(6);
                        indices[0] = 0, indices[1] = 1, indices[2] = 2, indices[3] = 1, indices[4] = 3, 
                        indices[5] = 2, this.indicesBuffers.update(indices);
                        var attributes = [ {
                            name: "a_position",
                            format: GFXFormat.RG32F
                        }, {
                            name: "a_texCoord",
                            format: GFXFormat.RG32F
                        } ];
                        this.assmebler = device.createInputAssembler({
                            attributes: attributes,
                            vertexBuffers: [ this.vertexBuffers ],
                            indexBuffer: this.indicesBuffers
                        });
                    }
                }, {
                    key: "initPSO",
                    value: function initPSO() {
                        var device = this.device, program_name = "util/splash-image", program_techniques = [ {
                            passes: [ {
                                blendState: {
                                    targets: [ {
                                        blend: !0,
                                        blendSrc: 2,
                                        blendDst: 4,
                                        blendDstAlpha: 4
                                    } ]
                                },
                                program: "util/splash-image|splash-vs:vert|splash-fs:frag",
                                depthStencilState: {
                                    depthTest: !0,
                                    depthWrite: !1
                                },
                                properties: {
                                    mainTexture: {
                                        value: "grey",
                                        type: 28
                                    },
                                    u_precent: {
                                        type: 13
                                    }
                                }
                            } ]
                        } ], program_shaders = [ {
                            name: "util/splash-image|splash-vs:vert|splash-fs:frag",
                            hash: 2381344969,
                            glsl3: {
                                vert: "\nprecision mediump float;\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0, 1);\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                                frag: "\nprecision mediump float;\nin vec2 v_uv;\nuniform sampler2D mainTexture;\nuniform splashFrag {\n  float u_precent;\n};\nvec4 frag () {\n  vec4 color = texture(mainTexture, v_uv);\n  float precent = clamp(u_precent, 0.0, 1.0);\n  color.xyz *= precent;\n  return color;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
                            },
                            glsl1: {
                                vert: "\nprecision mediump float;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0, 1);\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                                frag: "\nprecision mediump float;\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\nuniform float u_precent;\nvec4 frag () {\n  vec4 color = texture2D(mainTexture, v_uv);\n  float precent = clamp(u_precent, 0.0, 1.0);\n  color.xyz *= precent;\n  return color;\n}\nvoid main() { gl_FragColor = frag(); }\n"
                            },
                            builtins: {
                                globals: {
                                    blocks: [],
                                    samplers: []
                                },
                                locals: {
                                    blocks: [],
                                    samplers: []
                                }
                            },
                            defines: [],
                            blocks: [ {
                                name: "splashFrag",
                                defines: [],
                                binding: 0,
                                members: [ {
                                    name: "u_precent",
                                    type: 13,
                                    count: 1
                                } ]
                            } ],
                            samplers: [ {
                                name: "mainTexture",
                                type: 28,
                                count: 1,
                                defines: [],
                                binding: 30
                            } ],
                            dependencies: {}
                        } ], effect = new EffectAsset();
                        effect.name = program_name, effect.techniques = program_techniques, effect.shaders = program_shaders, 
                        effect.onLoaded(), this.material = new Material(), this.material.initialize({
                            effectAsset: effect
                        }), this.texture = device.createTexture({
                            type: GFXTextureType.TEX2D,
                            usage: GFXTextureUsageBit.SAMPLED,
                            format: GFXFormat.RGBA8,
                            width: this.image.width,
                            height: this.image.height,
                            mipLevel: 1
                        }), this.textureView = device.createTextureView({
                            texture: this.texture,
                            type: GFXTextureViewType.TV2D,
                            format: GFXFormat.RGBA8
                        });
                        var pass = this.material.passes[0], binding = pass.getBinding("mainTexture");
                        pass.bindTextureView(binding, this.textureView), this.pso = pass.createPipelineState(), 
                        this.pso.pipelineLayout.layouts[0].update(), this.region = new GFXBufferTextureCopy(), 
                        this.region.texExtent.width = this.image.width, this.region.texExtent.height = this.image.height, 
                        this.region.texExtent.depth = 1, device.copyTexImagesToTexture([ this.image ], this.texture, [ this.region ]);
                    }
                }, {
                    key: "destoy",
                    value: function destoy() {
                        this.callBack = null, this.setting = null, this.device = null, this.image = null, 
                        this.framebuffer = null, this.renderArea = null, this.region = null, this.cmdBuff.destroy(), 
                        this.cmdBuff = null, this.pso.destroy(), this.pso = null, this.material.destroy(), 
                        this.material = null, this.textureView.destroy(), this.textureView = null, this.texture.destroy(), 
                        this.texture = null, this.assmebler.destroy(), this.assmebler = null, this.vertexBuffers.destroy(), 
                        this.vertexBuffers = null, this.indicesBuffers.destroy(), this.indicesBuffers = null;
                    }
                }, {
                    key: "splashFinish",
                    set: function set(v) {
                        this._splashFinish = v, this._tryToStart();
                    }
                }, {
                    key: "loadFinish",
                    set: function set(v) {
                        this._loadFinish = v, this._tryToStart();
                    }
                } ], [ {
                    key: "instance",
                    get: function get() {
                        return null == SplashImage._ins && (SplashImage._ins = new SplashImage()), SplashImage._ins;
                    }
                } ]), SplashImage;
            }();
            SplashImage._ins = void 0;
            var Game = exports("Game", function() {
                function Game() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, Game);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Game)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).frame = null, 
                    _this.container = null, _this.canvas = null, _this.renderType = -1, _this.eventTargetOn = _get(_getPrototypeOf(Game.prototype), "on", _assertThisInitialized(_this)), 
                    _this.eventTargetOnce = _get(_getPrototypeOf(Game.prototype), "once", _assertThisInitialized(_this)), 
                    _this.config = {}, _this.onStart = null, _this._persistRootNodes = {}, _this._paused = !0, 
                    _this._configLoaded = !1, _this._isCloning = !1, _this._prepared = !1, _this._rendererInitialized = !1, 
                    _this._gfxDevice = null, _this._intervalId = null, _this._lastTime = null, _this._frameTime = null, 
                    _this._sceneInfos = [], _this.collisionMatrix = [], _this.groupList = [], _this;
                }
                return _inherits(Game, EventTarget), _createClass(Game, [ {
                    key: "setFrameRate",
                    value: function setFrameRate(frameRate) {
                        var config = this.config;
                        "number" != typeof frameRate && (frameRate = parseInt(frameRate), isNaN(frameRate) && (frameRate = 60)), 
                        config.frameRate = frameRate, this._intervalId && window.cancelAnimationFrame(this._intervalId), 
                        this._intervalId = 0, this._paused = !0, this._setAnimFrame(), this._runMainLoop();
                    }
                }, {
                    key: "getFrameRate",
                    value: function getFrameRate() {
                        return this.config.frameRate || 0;
                    }
                }, {
                    key: "step",
                    value: function step() {
                        cc.director.mainLoop();
                    }
                }, {
                    key: "pause",
                    value: function pause() {
                        this._paused || (this._paused = !0, this._intervalId && window.cancelAnimationFrame(this._intervalId), 
                        this._intervalId = 0);
                    }
                }, {
                    key: "resume",
                    value: function resume() {
                        this._paused && (this._paused = !1, this._runMainLoop());
                    }
                }, {
                    key: "isPaused",
                    value: function isPaused() {
                        return this._paused;
                    }
                }, {
                    key: "restart",
                    value: function restart() {
                        cc.director.once(cc.Director.EVENT_AFTER_DRAW, function() {
                            for (var id in cc.game._persistRootNodes) cc.game.removePersistRootNode(cc.game._persistRootNodes[id]);
                            cc.director.getScene().destroy(), cc.Object._deferredDestroy(), cc.director.purgeDirector(), 
                            cc.director.reset(), cc.game.onStart();
                        });
                    }
                }, {
                    key: "end",
                    value: function end() {
                        this._gfxDevice && (this._gfxDevice.destroy(), this._gfxDevice = null), close();
                    }
                }, {
                    key: "on",
                    value: function on(type, callback, target) {
                        this._prepared && type === Game.EVENT_ENGINE_INITED ? callback.call(target) : this.eventTargetOn(type, callback, target);
                    }
                }, {
                    key: "once",
                    value: function once(type, callback, target) {
                        this._prepared && type === Game.EVENT_ENGINE_INITED ? callback.call(target) : this.eventTargetOnce(type, callback, target);
                    }
                }, {
                    key: "run",
                    value: function run(config, onStart) {
                        this._initConfig(config), this._initRenderer(), this.onStart = onStart, this.prepare(cc.game.onStart && cc.game.onStart.bind(cc.game));
                    }
                }, {
                    key: "addPersistRootNode",
                    value: function addPersistRootNode(node) {
                        if (cc.Node.isNode(node) && node.uuid) {
                            var id = node.uuid;
                            if (!this._persistRootNodes[id]) {
                                var scene = cc.director._scene;
                                if (cc.isValid(scene)) if (node.parent) {
                                    if (!(node.parent instanceof cc.Scene)) return void warnID(3801);
                                    if (node.parent !== scene) return void warnID(3802);
                                } else node.parent = scene;
                                (this._persistRootNodes[id] = node)._persistNode = !0;
                            }
                        } else warnID(3800);
                    }
                }, {
                    key: "removePersistRootNode",
                    value: function removePersistRootNode(node) {
                        var id = node.uuid || "";
                        node === this._persistRootNodes[id] && (delete this._persistRootNodes[id], node._persistNode = !1);
                    }
                }, {
                    key: "isPersistRootNode",
                    value: function isPersistRootNode(node) {
                        return node._persistNode;
                    }
                }, {
                    key: "prepare",
                    value: function prepare(cb) {
                        if (this._prepared) cb && cb(); else {
                            var jsList = this.config.jsList;
                            if (jsList && 0 < jsList.length) {
                                var self = this;
                                cc.loader.load(jsList, function(err) {
                                    if (err) throw new Error(JSON.stringify(err));
                                    self._prepareFinished(cb);
                                });
                            } else this._prepareFinished(cb);
                        }
                    }
                }, {
                    key: "_initEngine",
                    value: function _initEngine() {
                        this._initEvents(), this.emit(Game.EVENT_ENGINE_INITED);
                    }
                }, {
                    key: "_prepareFinished",
                    value: function _prepareFinished(cb) {
                        var _this2 = this;
                        this._prepared = !0, this._initEngine(), console.log("Cocos Creator 3D v" + cc.ENGINE_VERSION);
                        function start() {
                            _this2._setAnimFrame(), _this2._runMainLoop(), _this2.emit(Game.EVENT_GAME_INITED), 
                            cb && cb();
                        }
                        start();
                    }
                }, {
                    key: "_setAnimFrame",
                    value: function _setAnimFrame() {
                        this._lastTime = new Date();
                        var frameRate = cc.game.config.frameRate;
                        this._frameTime = 1e3 / frameRate, 60 !== frameRate && 30 !== frameRate ? (window.requestAnimationFrame = this._stTime, 
                        window.cancelAnimationFrame = this._ctTime) : (window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime, 
                        window.cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.ocancelAnimationFrame || this._ctTime);
                    }
                }, {
                    key: "_stTime",
                    value: function _stTime(callback) {
                        var currTime = new Date().getTime(), timeToCall = Math.max(0, cc.game._frameTime - (currTime - cc.game._lastTime)), id = window.setTimeout(function() {
                            callback();
                        }, timeToCall);
                        return cc.game._lastTime = currTime + timeToCall, id;
                    }
                }, {
                    key: "_ctTime",
                    value: function _ctTime(id) {
                        window.clearTimeout(id);
                    }
                }, {
                    key: "_runMainLoop",
                    value: function _runMainLoop() {
                        var _callback, self = this, config = self.config, director = cc.director, skip = !0, frameRate = config.frameRate;
                        setDisplayStats(!!config.showFPS), _callback = function callback(time) {
                            if (!self._paused) {
                                if (self._intervalId = window.requestAnimationFrame(_callback), 30 === frameRate && (skip = !skip)) return;
                                director.mainLoop(time);
                            }
                        }, self._intervalId = window.requestAnimationFrame(_callback), self._paused = !1;
                    }
                }, {
                    key: "_initConfig",
                    value: function _initConfig(config) {
                        "number" != typeof config.debugMode && (config.debugMode = 0), config.exposeClassName = !!config.exposeClassName, 
                        "number" != typeof config.frameRate && (config.frameRate = 60);
                        var renderMode = config.renderMode;
                        ("number" != typeof renderMode || 2 < renderMode || renderMode < 0) && (config.renderMode = 0), 
                        "boolean" != typeof config.registerSystemEvent && (config.registerSystemEvent = !0), 
                        config.showFPS = !!config.showFPS, this._sceneInfos = config.scenes || [], this.collisionMatrix = config.collisionMatrix || [], 
                        this.groupList = config.groupList || [], _resetDebugSetting(config.debugMode), this.config = config, 
                        this._configLoaded = !0;
                    }
                }, {
                    key: "_determineRenderType",
                    value: function _determineRenderType() {
                        var config = this.config, userRenderMode = parseInt(config.renderMode);
                        this.renderType = Game.RENDER_TYPE_CANVAS;
                        var supportRender = !1;
                        if (0 === userRenderMode ? cc.sys.capabilities.opengl ? (this.renderType = Game.RENDER_TYPE_WEBGL, 
                        supportRender = !0) : cc.sys.capabilities.canvas && (this.renderType = Game.RENDER_TYPE_CANVAS, 
                        supportRender = !0) : 1 === userRenderMode && cc.sys.capabilities.canvas ? (this.renderType = Game.RENDER_TYPE_CANVAS, 
                        supportRender = !0) : 2 === userRenderMode && cc.sys.capabilities.opengl && (this.renderType = Game.RENDER_TYPE_WEBGL, 
                        supportRender = !0), !supportRender) throw new Error(getError(3820, userRenderMode));
                    }
                }, {
                    key: "_initRenderer",
                    value: function _initRenderer() {
                        if (!this._rendererInitialized) {
                            var width, height, localCanvas, localContainer, el = this.config.id, isWeChatGame = cc.sys.platform === cc.sys.WECHAT_GAME, isQQPlay = cc.sys.platform === cc.sys.QQ_PLAY;
                            if (isWeChatGame) this.container = localContainer = document.createElement("div"), 
                            this.frame = localContainer.parentNode === document.body ? document.documentElement : localContainer.parentNode, 
                            localCanvas = cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB ? window.sharedCanvas || wx.getSharedCanvas() : window.canvas, 
                            this.canvas = localCanvas; else if (isQQPlay) this.container = cc.container = document.createElement("div"), 
                            this.frame = document.documentElement, this.canvas = localCanvas = window.canvas; else {
                                var element = el ? el instanceof HTMLElement ? el : document.querySelector(el) || document.querySelector("#" + el) : null;
                                if (!element) throw new Error(getError(200));
                                "CANVAS" === element.tagName ? (width = element.width, height = element.height, 
                                this.canvas = localCanvas = element, this.container = localContainer = document.createElement("div"), 
                                localCanvas && localCanvas.parentNode && localCanvas.parentNode.insertBefore(localContainer, localCanvas)) : ("DIV" !== element.tagName && warnID(3819), 
                                width = element.clientWidth, height = element.clientHeight, this.canvas = localCanvas = document.createElement("canvas"), 
                                this.container = localContainer = document.createElement("div"), element.appendChild(localContainer)), 
                                localContainer.setAttribute("id", "Cocos3dGameContainer"), localContainer.appendChild(localCanvas), 
                                this.frame = localContainer.parentNode === document.body ? document.documentElement : localContainer.parentNode, 
                                function addClass(element, name) {
                                    -1 < (" " + element.className + " ").indexOf(" " + name + " ") || (element.className && (element.className += " "), 
                                    element.className += name);
                                }(localCanvas, "gameCanvas"), localCanvas.setAttribute("width", width || "480"), 
                                localCanvas.setAttribute("height", height || "320"), localCanvas.setAttribute("tabindex", "99");
                            }
                            if (this._determineRenderType(), this.renderType === Game.RENDER_TYPE_WEBGL) {
                                var useWebGL2 = !!window.WebGL2RenderingContext, userAgent = navigator.userAgent.toLowerCase();
                                -1 !== userAgent.indexOf("safari") && -1 === userAgent.indexOf("chrome") && (useWebGL2 = !1), 
                                useWebGL2 && cc.WebGL2GFXDevice ? this._gfxDevice = new cc.WebGL2GFXDevice() : cc.WebGLGFXDevice && (this._gfxDevice = new cc.WebGLGFXDevice());
                                var opts = {
                                    canvasElm: localCanvas,
                                    debug: !0,
                                    devicePixelRatio: window.devicePixelRatio,
                                    nativeWidth: Math.floor(screen.width * cc.view._devicePixelRatio),
                                    nativeHeight: Math.floor(screen.height * cc.view._devicePixelRatio)
                                };
                                !this._gfxDevice.initialize(opts) && useWebGL2 && (this._gfxDevice = new cc.WebGLGFXDevice(), 
                                this._gfxDevice.initialize(opts));
                            }
                            if (!this._gfxDevice) return console.error("can not support canvas rendering in 3D"), 
                            void (this.renderType = Game.RENDER_TYPE_CANVAS);
                            this.canvas.oncontextmenu = function() {
                                if (!cc._isContextMenuEnable) return !1;
                            }, this._rendererInitialized = !0, this.emit(Game.EVENT_RENDERER_INITED);
                        }
                    }
                }, {
                    key: "_initEvents",
                    value: function _initEvents() {
                        var hiddenPropName, win = window;
                        void 0 !== document.hidden ? hiddenPropName = "hidden" : void 0 !== document.mozHidden ? hiddenPropName = "mozHidden" : void 0 !== document.msHidden ? hiddenPropName = "msHidden" : void 0 !== document.webkitHidden && (hiddenPropName = "webkitHidden");
                        var hidden = !1;
                        function onHidden() {
                            hidden || (hidden = !0, cc.game.emit(Game.EVENT_HIDE));
                        }
                        function onShown() {
                            hidden && (hidden = !1, cc.game.emit(Game.EVENT_SHOW));
                        }
                        if (hiddenPropName) for (var changeList = [ "visibilitychange", "mozvisibilitychange", "msvisibilitychange", "webkitvisibilitychange", "qbrowserVisibilityChange" ], i = 0; i < changeList.length; i++) document.addEventListener(changeList[i], function(event) {
                            var visible = document[hiddenPropName];
                            (visible = visible || event.hidden) ? onHidden() : onShown();
                        }); else win.addEventListener("blur", onHidden), win.addEventListener("focus", onShown);
                        -1 < navigator.userAgent.indexOf("MicroMessenger") && (win.onfocus = onShown), "onpageshow" in window && "onpagehide" in window && (win.addEventListener("pagehide", onHidden), 
                        win.addEventListener("pageshow", onShown), document.addEventListener("pagehide", onHidden), 
                        document.addEventListener("pageshow", onShown)), this.on(Game.EVENT_HIDE, function() {
                            cc.game.pause();
                        }), this.on(Game.EVENT_SHOW, function() {
                            cc.game.resume();
                        });
                    }
                } ]), Game;
            }());
            Game.EVENT_HIDE = "game_on_hide", Game.EVENT_SHOW = "game_on_show", Game.EVENT_GAME_INITED = "game_inited", 
            Game.EVENT_ENGINE_INITED = "engine_inited", Game.EVENT_RENDERER_INITED = "renderer_inited", 
            Game.RENDER_TYPE_CANVAS = 0, Game.RENDER_TYPE_WEBGL = 1, Game.RENDER_TYPE_OPENGL = 2, 
            cc.Game = Game;
            var game = exports("game", cc.game = new Game()), __BrowserGetter = new (function() {
                function BrowserGetter() {
                    _classCallCheck(this, BrowserGetter), this.html = void 0, this.meta = {
                        width: "device-width"
                    }, this.adaptationType = cc.sys.browserType;
                }
                return _createClass(BrowserGetter, [ {
                    key: "init",
                    value: function init() {
                        this.html = document.getElementsByTagName("html")[0];
                    }
                }, {
                    key: "availWidth",
                    value: function availWidth(frame) {
                        return cc.sys.isMobile || !frame || frame === this.html ? window.innerWidth : frame.clientWidth;
                    }
                }, {
                    key: "availHeight",
                    value: function availHeight(frame) {
                        return cc.sys.isMobile || !frame || frame === this.html ? window.innerHeight : frame.clientHeight;
                    }
                } ]), BrowserGetter;
            }())();
            switch (cc.sys.os === cc.sys.OS_IOS && (__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_SAFARI), 
            __BrowserGetter.adaptationType) {
              case cc.sys.BROWSER_TYPE_SAFARI:
                __BrowserGetter.meta["minimal-ui"] = "true";

              case cc.sys.BROWSER_TYPE_SOUGOU:
              case cc.sys.BROWSER_TYPE_UC:
                __BrowserGetter.availWidth = function(frame) {
                    return frame.clientWidth;
                }, __BrowserGetter.availHeight = function(frame) {
                    return frame.clientHeight;
                };
                break;

              case cc.sys.BROWSER_TYPE_WECHAT_GAME:
                __BrowserGetter.availWidth = function() {
                    return window.innerWidth;
                }, __BrowserGetter.availHeight = function() {
                    return window.innerHeight;
                };
                break;

              case cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB:
                var sharedCanvas = window.sharedCanvas || wx.getSharedCanvas();
                __BrowserGetter.availWidth = function() {
                    return sharedCanvas.width;
                }, __BrowserGetter.availHeight = function() {
                    return sharedCanvas.height;
                };
            }
            var _scissorRect = null, View = exports("View", function() {
                function View() {
                    var _this;
                    _classCallCheck(this, View), (_this = _possibleConstructorReturn(this, _getPrototypeOf(View).call(this)))._frameSize = void 0, 
                    _this._scaleX = void 0, _this._scaleY = void 0, _this._viewportRect = void 0, _this._visibleRect = void 0, 
                    _this._autoFullScreen = void 0, _this._devicePixelRatio = void 0, _this._retinaEnabled = void 0, 
                    _this._resizeCallback = void 0, _this._resizing = void 0, _this._orientationChanging = void 0, 
                    _this._isRotated = void 0, _this._orientation = void 0, _this._isAdjustViewport = void 0, 
                    _this._antiAliasEnabled = void 0, _this._resolutionPolicy = void 0, _this._rpExactFit = void 0, 
                    _this._rpShowAll = void 0, _this._rpNoBorder = void 0, _this._rpFixedHeight = void 0, 
                    _this._rpFixedWidth = void 0, _this._resizeWithBrowserSize = void 0, _this._designResolutionSize = void 0, 
                    _this._originalDesignResolutionSize = void 0;
                    _assertThisInitialized(_this);
                    var _strategyer = ContainerStrategy, _strategy = ContentStrategy;
                    return _this._frameSize = new Size(0, 0), _this._designResolutionSize = new Size(0, 0), 
                    _this._originalDesignResolutionSize = new Size(0, 0), _this._scaleX = 1, _this._scaleY = 1, 
                    _this._viewportRect = new Rect(0, 0, 0, 0), _this._visibleRect = new Rect(0, 0, 0, 0), 
                    _this._autoFullScreen = !1, _this._devicePixelRatio = 1, _this._retinaEnabled = !1, 
                    _this._resizeCallback = null, _this._resizing = !1, _this._resizeWithBrowserSize = !1, 
                    _this._orientationChanging = !0, _this._isRotated = !1, _this._orientation = cc.macro.ORIENTATION_AUTO, 
                    _this._isAdjustViewport = !0, _this._antiAliasEnabled = !1, _this._resolutionPolicy = null, 
                    _this._rpExactFit = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT), 
                    _this._rpShowAll = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.SHOW_ALL), 
                    _this._rpNoBorder = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER), 
                    _this._rpFixedHeight = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT), 
                    _this._rpFixedWidth = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH), 
                    cc.game.once(cc.Game.EVENT_ENGINE_INITED, _this.init, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(View, EventTarget), _createClass(View, [ {
                    key: "init",
                    value: function init() {
                        __BrowserGetter.init(), this._initFrameSize(), this.enableAntiAlias(!0);
                        var w = cc.game.canvas.width, h = cc.game.canvas.height;
                        this._designResolutionSize.width = w, this._designResolutionSize.height = h, this._originalDesignResolutionSize.width = w, 
                        this._originalDesignResolutionSize.height = h, this._viewportRect.width = w, this._viewportRect.height = h, 
                        this._visibleRect.width = w, this._visibleRect.height = h, cc.winSize.width = this._visibleRect.width, 
                        cc.winSize.height = this._visibleRect.height, cc.visibleRect && cc.visibleRect.init(this._visibleRect);
                    }
                }, {
                    key: "resizeWithBrowserSize",
                    value: function resizeWithBrowserSize(enabled) {
                        enabled ? this._resizeWithBrowserSize || (this._resizeWithBrowserSize = !0, window.addEventListener("resize", this._resizeEvent), 
                        window.addEventListener("orientationchange", this._orientationChange)) : this._resizeWithBrowserSize && (this._resizeWithBrowserSize = !1, 
                        window.removeEventListener("resize", this._resizeEvent), window.removeEventListener("orientationchange", this._orientationChange));
                    }
                }, {
                    key: "setResizeCallback",
                    value: function setResizeCallback(callback) {
                        "function" != typeof callback && null != callback || (this._resizeCallback = callback);
                    }
                }, {
                    key: "setOrientation",
                    value: function setOrientation(orientation) {
                        (orientation &= cc.macro.ORIENTATION_AUTO) && this._orientation !== orientation && (this._orientation = orientation);
                    }
                }, {
                    key: "adjustViewportMeta",
                    value: function adjustViewportMeta(enabled) {
                        this._isAdjustViewport = enabled;
                    }
                }, {
                    key: "enableRetina",
                    value: function enableRetina(enabled) {
                        this._retinaEnabled = !!enabled;
                    }
                }, {
                    key: "isRetinaEnabled",
                    value: function isRetinaEnabled() {
                        return this._retinaEnabled;
                    }
                }, {
                    key: "enableAntiAlias",
                    value: function enableAntiAlias(enabled) {
                        if (this._antiAliasEnabled !== enabled) if (this._antiAliasEnabled = enabled, cc.game.renderType === cc.Game.RENDER_TYPE_WEBGL) {
                            var cache = cc.loader._cache;
                            for (var key in cache) {
                                var item = cache[key], tex = item && item.content instanceof cc.Texture2D ? item.content : null;
                                if (tex) {
                                    var Filter = cc.Texture2D.Filter;
                                    enabled ? tex.setFilters(Filter.LINEAR, Filter.LINEAR) : tex.setFilters(Filter.NEAREST, Filter.NEAREST);
                                }
                            }
                        } else if (cc.game.renderType === cc.Game.RENDER_TYPE_CANVAS) {
                            var ctx = cc.game.canvas.getContext("2d");
                            ctx.imageSmoothingEnabled = enabled, ctx.mozImageSmoothingEnabled = enabled;
                        }
                    }
                }, {
                    key: "isAntiAliasEnabled",
                    value: function isAntiAliasEnabled() {
                        return this._antiAliasEnabled;
                    }
                }, {
                    key: "enableAutoFullScreen",
                    value: function enableAutoFullScreen(enabled) {
                        enabled && enabled !== this._autoFullScreen && cc.sys.isMobile && cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT ? (this._autoFullScreen = !0, 
                        cc.screen.autoFullScreen(cc.game.frame)) : this._autoFullScreen = !1;
                    }
                }, {
                    key: "isAutoFullScreenEnabled",
                    value: function isAutoFullScreenEnabled() {
                        return this._autoFullScreen;
                    }
                }, {
                    key: "setCanvasSize",
                    value: function setCanvasSize(width, height) {
                        var canvas = cc.game.canvas, container = cc.game.container;
                        canvas.width = width * this._devicePixelRatio, canvas.height = height * this._devicePixelRatio, 
                        canvas.style.width = width + "px", canvas.style.height = height + "px", container.style.width = width + "px", 
                        container.style.height = height + "px", this._resizeEvent();
                    }
                }, {
                    key: "getCanvasSize",
                    value: function getCanvasSize() {
                        return cc.size(cc.game.canvas.width, cc.game.canvas.height);
                    }
                }, {
                    key: "getFrameSize",
                    value: function getFrameSize() {
                        return cc.size(this._frameSize.width, this._frameSize.height);
                    }
                }, {
                    key: "setFrameSize",
                    value: function setFrameSize(width, height) {
                        this._frameSize.width = width, this._frameSize.height = height, cc.frame.style.width = width + "px", 
                        cc.frame.style.height = height + "px", this._resizeEvent();
                    }
                }, {
                    key: "getVisibleSize",
                    value: function getVisibleSize() {
                        return cc.size(this._visibleRect.width, this._visibleRect.height);
                    }
                }, {
                    key: "getVisibleSizeInPixel",
                    value: function getVisibleSizeInPixel() {
                        return cc.size(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
                    }
                }, {
                    key: "getVisibleOrigin",
                    value: function getVisibleOrigin() {
                        return cc.v2(this._visibleRect.x, this._visibleRect.y);
                    }
                }, {
                    key: "getVisibleOriginInPixel",
                    value: function getVisibleOriginInPixel() {
                        return cc.v2(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
                    }
                }, {
                    key: "getResolutionPolicy",
                    value: function getResolutionPolicy() {
                        return this._resolutionPolicy;
                    }
                }, {
                    key: "setResolutionPolicy",
                    value: function setResolutionPolicy(resolutionPolicy) {
                        var _t = this;
                        if (resolutionPolicy instanceof ResolutionPolicy) _t._resolutionPolicy = resolutionPolicy; else {
                            var _locPolicy = ResolutionPolicy;
                            resolutionPolicy === _locPolicy.EXACT_FIT && (_t._resolutionPolicy = _t._rpExactFit), 
                            resolutionPolicy === _locPolicy.SHOW_ALL && (_t._resolutionPolicy = _t._rpShowAll), 
                            resolutionPolicy === _locPolicy.NO_BORDER && (_t._resolutionPolicy = _t._rpNoBorder), 
                            resolutionPolicy === _locPolicy.FIXED_HEIGHT && (_t._resolutionPolicy = _t._rpFixedHeight), 
                            resolutionPolicy === _locPolicy.FIXED_WIDTH && (_t._resolutionPolicy = _t._rpFixedWidth);
                        }
                    }
                }, {
                    key: "setDesignResolutionSize",
                    value: function setDesignResolutionSize(width, height, resolutionPolicy) {
                        if (0 < width || 0 < height) {
                            this.setResolutionPolicy(resolutionPolicy);
                            var policy = this._resolutionPolicy;
                            if (policy && policy.preApply(this), cc.sys.isMobile && this._adjustViewportMeta(), 
                            this._orientationChanging = !0, this._resizing || this._initFrameSize(), policy) {
                                this._originalDesignResolutionSize.width = this._designResolutionSize.width = width, 
                                this._originalDesignResolutionSize.height = this._designResolutionSize.height = height;
                                var result = policy.apply(this, this._designResolutionSize);
                                if (result.scale && 2 === result.scale.length && (this._scaleX = result.scale[0], 
                                this._scaleY = result.scale[1]), result.viewport) {
                                    var vp = this._viewportRect, vb = this._visibleRect, rv = result.viewport;
                                    vp.x = rv.x, vp.y = rv.y, vp.width = rv.width, vp.height = rv.height, vb.x = 0, 
                                    vb.y = 0, vb.width = rv.width / this._scaleX, vb.height = rv.height / this._scaleY;
                                }
                                policy.postApply(this), cc.winSize.width = this._visibleRect.width, cc.winSize.height = this._visibleRect.height, 
                                cc.visibleRect && cc.visibleRect.init(this._visibleRect), this.emit("design-resolution-changed");
                            } else cc.logID(2201);
                        } else cc.logID(2200);
                    }
                }, {
                    key: "getDesignResolutionSize",
                    value: function getDesignResolutionSize() {
                        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height);
                    }
                }, {
                    key: "setRealPixelResolution",
                    value: function setRealPixelResolution(width, height, resolutionPolicy) {
                        this._setViewportMeta({
                            width: width
                        }, !0), document.documentElement.style.width = width + "px", document.body.style.width = width + "px", 
                        document.body.style.left = "0px", document.body.style.top = "0px", this.setDesignResolutionSize(width, height, resolutionPolicy);
                    }
                }, {
                    key: "setViewportInPoints",
                    value: function setViewportInPoints(x, y, w, h) {
                        var locScaleX = this._scaleX, locScaleY = this._scaleY;
                        cc.game._renderContext.viewport(x * locScaleX + this._viewportRect.x, y * locScaleY + this._viewportRect.y, w * locScaleX, h * locScaleY);
                    }
                }, {
                    key: "setScissorInPoints",
                    value: function setScissorInPoints(x, y, w, h) {
                        var scaleX = this._scaleX, scaleY = this._scaleY, sx = Math.ceil(x * scaleX + this._viewportRect.x), sy = Math.ceil(y * scaleY + this._viewportRect.y), sw = Math.ceil(w * scaleX), sh = Math.ceil(h * scaleY), gl = cc.game._renderContext;
                        if (!_scissorRect) {
                            var boxArr = gl.getParameter(gl.SCISSOR_BOX);
                            _scissorRect = new Rect(boxArr[0], boxArr[1], boxArr[2], boxArr[3]);
                        }
                        _scissorRect.x === sx && _scissorRect.y === sy && _scissorRect.width === sw && _scissorRect.height === sh || (_scissorRect.x = sx, 
                        _scissorRect.y = sy, _scissorRect.width = sw, _scissorRect.height = sh, gl.scissor(sx, sy, sw, sh));
                    }
                }, {
                    key: "isScissorEnabled",
                    value: function isScissorEnabled() {
                        var gl = cc.game._renderContext;
                        return gl.isEnabled(gl.SCISSOR_TEST);
                    }
                }, {
                    key: "getScissorRect",
                    value: function getScissorRect() {
                        var gl = cc.game._renderContext;
                        if (!_scissorRect) {
                            var boxArr = gl.getParameter(gl.SCISSOR_BOX);
                            _scissorRect = new Rect(boxArr[0], boxArr[1], boxArr[2], boxArr[3]);
                        }
                        var scaleXFactor = 1 / this._scaleX, scaleYFactor = 1 / this._scaleY;
                        return new Rect((_scissorRect.x - this._viewportRect.x) * scaleXFactor, (_scissorRect.y - this._viewportRect.y) * scaleYFactor, _scissorRect.width * scaleXFactor, _scissorRect.height * scaleYFactor);
                    }
                }, {
                    key: "getViewportRect",
                    value: function getViewportRect() {
                        return this._viewportRect;
                    }
                }, {
                    key: "getScaleX",
                    value: function getScaleX() {
                        return this._scaleX;
                    }
                }, {
                    key: "getScaleY",
                    value: function getScaleY() {
                        return this._scaleY;
                    }
                }, {
                    key: "getDevicePixelRatio",
                    value: function getDevicePixelRatio() {
                        return this._devicePixelRatio;
                    }
                }, {
                    key: "convertToLocationInView",
                    value: function convertToLocationInView(tx, ty, relatedPos, out) {
                        var result = out || cc.v2(), x = this._devicePixelRatio * (tx - relatedPos.left), y = this._devicePixelRatio * (relatedPos.top + relatedPos.height - ty);
                        return this._isRotated ? (result.x = cc.game.canvas.width - y, result.y = x) : (result.x = x, 
                        result.y = y), result;
                    }
                }, {
                    key: "_resizeEvent",
                    value: function _resizeEvent() {
                        var view, prevFrameW = (view = this.setDesignResolutionSize ? this : cc.view)._frameSize.width, prevFrameH = view._frameSize.height, prevRotated = view._isRotated;
                        if (cc.sys.isMobile) {
                            var containerStyle = cc.game.container.style, margin = containerStyle.margin;
                            containerStyle.margin = "0", containerStyle.display = "none", view._initFrameSize(), 
                            containerStyle.margin = margin, containerStyle.display = "block";
                        } else view._initFrameSize();
                        if (view._orientationChanging || view._isRotated !== prevRotated || view._frameSize.width !== prevFrameW || view._frameSize.height !== prevFrameH) {
                            var width = view._originalDesignResolutionSize.width, height = view._originalDesignResolutionSize.height;
                            view._resizing = !0, 0 < width && view.setDesignResolutionSize(width, height, view._resolutionPolicy), 
                            view._resizing = !1, view._resizeCallback && view._resizeCallback.call();
                        }
                    }
                }, {
                    key: "_orientationChange",
                    value: function _orientationChange() {
                        cc.view._orientationChanging = !0, cc.view._resizeEvent();
                    }
                }, {
                    key: "_initFrameSize",
                    value: function _initFrameSize() {
                        var locFrameSize = this._frameSize, w = __BrowserGetter.availWidth(cc.game.frame), h = __BrowserGetter.availHeight(cc.game.frame), isLandscape = h <= w;
                        !cc.sys.isMobile || isLandscape && this._orientation & cc.macro.ORIENTATION_LANDSCAPE || !isLandscape && this._orientation & cc.macro.ORIENTATION_PORTRAIT ? (locFrameSize.width = w, 
                        locFrameSize.height = h, cc.game.container.style["-webkit-transform"] = "rotate(0deg)", 
                        cc.game.container.style.transform = "rotate(0deg)", this._isRotated = !1) : (locFrameSize.width = h, 
                        locFrameSize.height = w, cc.game.container.style["-webkit-transform"] = "rotate(90deg)", 
                        cc.game.container.style.transform = "rotate(90deg)", cc.game.container.style["-webkit-transform-origin"] = "0px 0px 0px", 
                        cc.game.container.style.transformOrigin = "0px 0px 0px", this._isRotated = !0, cc.game.canvas.style["-webkit-transform"] = "translateZ(0px)", 
                        cc.game.canvas.style.transform = "translateZ(0px)"), this._orientationChanging && setTimeout(function() {
                            cc.view._orientationChanging = !1;
                        }, 1e3);
                    }
                }, {
                    key: "_adjustSizeKeepCanvasSize",
                    value: function _adjustSizeKeepCanvasSize() {
                        var designWidth = this._originalDesignResolutionSize.width, designHeight = this._originalDesignResolutionSize.height;
                        0 < designWidth && this.setDesignResolutionSize(designWidth, designHeight, this._resolutionPolicy);
                    }
                }, {
                    key: "_setViewportMeta",
                    value: function _setViewportMeta(metas, overwrite) {
                        var vp = document.getElementById("cocosMetaElement");
                        vp && overwrite && document.head.removeChild(vp);
                        var content, key, pattern, elems = document.getElementsByName("viewport"), currentVP = elems ? elems[0] : null;
                        for (key in content = currentVP ? currentVP.content : "", (vp = vp || document.createElement("meta")).id = "cocosMetaElement", 
                        vp.name = "viewport", vp.content = "", metas) -1 === content.indexOf(key) ? content += "," + key + "=" + metas[key] : overwrite && (pattern = new RegExp(key + "s*=s*[^,]+"), 
                        content.replace(pattern, key + "=" + metas[key]));
                        /^,/.test(content) && (content = content.substr(1)), vp.content = content, currentVP && (currentVP.content = content), 
                        document.head.appendChild(vp);
                    }
                }, {
                    key: "_adjustViewportMeta",
                    value: function _adjustViewportMeta() {
                        this._isAdjustViewport && (this._setViewportMeta(__BrowserGetter.meta, !1), this._isAdjustViewport = !1);
                    }
                }, {
                    key: "_convertMouseToLocation",
                    value: function _convertMouseToLocation(in_out_point, relatedPos) {
                        in_out_point.x = this._devicePixelRatio * (in_out_point.x - relatedPos.left), in_out_point.y = this._devicePixelRatio * (relatedPos.top + relatedPos.height - in_out_point.y);
                    }
                }, {
                    key: "_convertPointWithScale",
                    value: function _convertPointWithScale(point) {
                        var viewport = this._viewportRect;
                        point.x = (point.x - viewport.x) / this._scaleX, point.y = (point.y - viewport.y) / this._scaleY;
                    }
                }, {
                    key: "_convertTouchWidthScale",
                    value: function _convertTouchWidthScale(selTouch) {
                        var viewport = this._viewportRect, scaleX = this._scaleX, scaleY = this._scaleY;
                        selTouch._point.x = (selTouch._point.x - viewport.x) / scaleX, selTouch._point.y = (selTouch._point.y - viewport.y) / scaleY, 
                        selTouch._prevPoint.x = (selTouch._prevPoint.x - viewport.x) / scaleX, selTouch._prevPoint.y = (selTouch._prevPoint.y - viewport.y) / scaleY;
                    }
                }, {
                    key: "_convertTouchesWithScale",
                    value: function _convertTouchesWithScale(touches) {
                        for (var selPoint, selPrePoint, viewport = this._viewportRect, scaleX = this._scaleX, scaleY = this._scaleY, i = 0; i < touches.length; i++) {
                            var selTouch = touches[i];
                            selPoint = selTouch._point, selPrePoint = selTouch._prevPoint, selPoint.x = (selPoint.x - viewport.x) / scaleX, 
                            selPoint.y = (selPoint.y - viewport.y) / scaleY, selPrePoint.x = (selPrePoint.x - viewport.x) / scaleX, 
                            selPrePoint.y = (selPrePoint.y - viewport.y) / scaleY;
                        }
                    }
                } ]), View;
            }());
            View.instance = void 0;
            var ContainerStrategy = function() {
                function ContainerStrategy() {
                    _classCallCheck(this, ContainerStrategy), this.name = "ContainerStrategy";
                }
                return _createClass(ContainerStrategy, [ {
                    key: "preApply",
                    value: function preApply() {}
                }, {
                    key: "apply",
                    value: function apply() {}
                }, {
                    key: "postApply",
                    value: function postApply() {}
                }, {
                    key: "_setupContainer",
                    value: function _setupContainer(view, w, h) {
                        var locCanvas = cc.game.canvas, locContainer = cc.game.container;
                        cc.sys.platform !== cc.sys.WECHAT_GAME && (cc.sys.os === cc.sys.OS_ANDROID && (document.body.style.width = (view._isRotated ? h : w) + "px", 
                        document.body.style.height = (view._isRotated ? w : h) + "px"), locContainer.style.width = locCanvas.style.width = w + "px", 
                        locContainer.style.height = locCanvas.style.height = h + "px");
                        var devicePixelRatio = view._devicePixelRatio = 1;
                        view.isRetinaEnabled() && (devicePixelRatio = view._devicePixelRatio = Math.min(2, window.devicePixelRatio || 1)), 
                        locCanvas.width = w * devicePixelRatio, locCanvas.height = h * devicePixelRatio;
                    }
                }, {
                    key: "_fixContainer",
                    value: function _fixContainer() {
                        document.body.insertBefore(cc.game.container, document.body.firstChild);
                        var bs = document.body.style;
                        bs.width = window.innerWidth + "px", bs.height = window.innerHeight + "px", bs.overflow = "hidden";
                        var contStyle = cc.game.container.style;
                        contStyle.position = "fixed", contStyle.left = contStyle.top = "0px", document.body.scrollTop = 0;
                    }
                } ]), ContainerStrategy;
            }();
            ContainerStrategy.EQUAL_TO_FRAME = void 0, ContainerStrategy.PROPORTION_TO_FRAME = void 0;
            var ContentStrategy = function() {
                function ContentStrategy() {
                    _classCallCheck(this, ContentStrategy), this.name = "ContentStrategy", this._result = void 0, 
                    this._result = {
                        scale: [ 1, 1 ],
                        viewport: null
                    };
                }
                return _createClass(ContentStrategy, [ {
                    key: "preApply",
                    value: function preApply() {}
                }, {
                    key: "apply",
                    value: function apply() {
                        return {
                            scale: [ 1, 1 ]
                        };
                    }
                }, {
                    key: "postApply",
                    value: function postApply() {}
                }, {
                    key: "_buildResult",
                    value: function _buildResult(containerW, containerH, contentW, contentH, scaleX, scaleY) {
                        Math.abs(containerW - contentW) < 2 && (contentW = containerW), Math.abs(containerH - contentH) < 2 && (contentH = containerH);
                        var viewport = new Rect(Math.round((containerW - contentW) / 2), Math.round((containerH - contentH) / 2), contentW, contentH);
                        return this._result.scale = [ scaleX, scaleY ], this._result.viewport = viewport, 
                        this._result;
                    }
                } ]), ContentStrategy;
            }();
            ContentStrategy.EXACT_FIT = void 0, ContentStrategy.SHOW_ALL = void 0, ContentStrategy.NO_BORDER = void 0, 
            ContentStrategy.FIXED_HEIGHT = void 0, ContentStrategy.FIXED_WIDTH = void 0, function() {
                var EqualToFrame = function() {
                    function EqualToFrame() {
                        var _getPrototypeOf2, _this2;
                        _classCallCheck(this, EqualToFrame);
                        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                        return (_this2 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EqualToFrame)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).name = "EqualToFrame", 
                        _this2;
                    }
                    return _inherits(EqualToFrame, ContainerStrategy), _createClass(EqualToFrame, [ {
                        key: "apply",
                        value: function apply(view) {
                            var frameH = view._frameSize.height, containerStyle = cc.game.container.style;
                            this._setupContainer(view, view._frameSize.width, view._frameSize.height), view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px", 
                            containerStyle.padding = "0px";
                        }
                    } ]), EqualToFrame;
                }(), ProportionalToFrame = function() {
                    function ProportionalToFrame() {
                        var _getPrototypeOf3, _this3;
                        _classCallCheck(this, ProportionalToFrame);
                        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                        return (_this3 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(ProportionalToFrame)).call.apply(_getPrototypeOf3, [ this ].concat(args)))).name = "ProportionalToFrame", 
                        _this3;
                    }
                    return _inherits(ProportionalToFrame, ContainerStrategy), _createClass(ProportionalToFrame, [ {
                        key: "apply",
                        value: function apply(view, designedResolution) {
                            var containerW, containerH, frameW = view._frameSize.width, frameH = view._frameSize.height, containerStyle = cc.game.container.style, designW = designedResolution.width, designH = designedResolution.height, scaleX = frameW / designW, scaleY = frameH / designH;
                            containerH = scaleX < scaleY ? (containerW = frameW, designH * scaleX) : (containerW = designW * scaleY, 
                            frameH);
                            var offx = Math.round((frameW - containerW) / 2), offy = Math.round((frameH - containerH) / 2);
                            containerW = frameW - 2 * offx, containerH = frameH - 2 * offy, this._setupContainer(view, containerW, containerH), 
                            view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px", 
                            containerStyle.paddingLeft = offx + "px", containerStyle.paddingRight = offx + "px", 
                            containerStyle.paddingTop = offy + "px", containerStyle.paddingBottom = offy + "px";
                        }
                    } ]), ProportionalToFrame;
                }();
                ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame(), ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame();
                var ExactFit = function() {
                    function ExactFit() {
                        var _getPrototypeOf4, _this4;
                        _classCallCheck(this, ExactFit);
                        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
                        return (_this4 = _possibleConstructorReturn(this, (_getPrototypeOf4 = _getPrototypeOf(ExactFit)).call.apply(_getPrototypeOf4, [ this ].concat(args)))).name = "ExactFit", 
                        _this4;
                    }
                    return _inherits(ExactFit, ContentStrategy), _createClass(ExactFit, [ {
                        key: "apply",
                        value: function apply(view, designedResolution) {
                            var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scaleX = containerW / designedResolution.width, scaleY = containerH / designedResolution.height;
                            return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
                        }
                    } ]), ExactFit;
                }(), ShowAll = function() {
                    function ShowAll() {
                        var _getPrototypeOf5, _this5;
                        _classCallCheck(this, ShowAll);
                        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];
                        return (_this5 = _possibleConstructorReturn(this, (_getPrototypeOf5 = _getPrototypeOf(ShowAll)).call.apply(_getPrototypeOf5, [ this ].concat(args)))).name = "ShowAll", 
                        _this5;
                    }
                    return _inherits(ShowAll, ContentStrategy), _createClass(ShowAll, [ {
                        key: "apply",
                        value: function apply(view, designedResolution) {
                            var contentW, contentH, containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH, scale = 0;
                            return contentH = scaleX < scaleY ? (contentW = containerW, designH * (scale = scaleX)) : (contentW = designW * (scale = scaleY), 
                            containerH), this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                        }
                    } ]), ShowAll;
                }(), NoBorder = function() {
                    function NoBorder() {
                        var _getPrototypeOf6, _this6;
                        _classCallCheck(this, NoBorder);
                        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) args[_key5] = arguments[_key5];
                        return (_this6 = _possibleConstructorReturn(this, (_getPrototypeOf6 = _getPrototypeOf(NoBorder)).call.apply(_getPrototypeOf6, [ this ].concat(args)))).name = "NoBorder", 
                        _this6;
                    }
                    return _inherits(NoBorder, ContentStrategy), _createClass(NoBorder, [ {
                        key: "apply",
                        value: function apply(view, designedResolution) {
                            var scale, contentW, contentH, containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH;
                            return contentH = scaleX < scaleY ? (contentW = designW * (scale = scaleY), containerH) : (contentW = containerW, 
                            designH * (scale = scaleX)), this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                        }
                    } ]), NoBorder;
                }(), FixedHeight = function() {
                    function FixedHeight() {
                        var _getPrototypeOf7, _this7;
                        _classCallCheck(this, FixedHeight);
                        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) args[_key6] = arguments[_key6];
                        return (_this7 = _possibleConstructorReturn(this, (_getPrototypeOf7 = _getPrototypeOf(FixedHeight)).call.apply(_getPrototypeOf7, [ this ].concat(args)))).name = "FixedHeight", 
                        _this7;
                    }
                    return _inherits(FixedHeight, ContentStrategy), _createClass(FixedHeight, [ {
                        key: "apply",
                        value: function apply(view, designedResolution) {
                            var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scale = containerH / designedResolution.height, contentW = containerW, contentH = containerH;
                            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                        }
                    } ]), FixedHeight;
                }(), FixedWidth = function() {
                    function FixedWidth() {
                        var _getPrototypeOf8, _this8;
                        _classCallCheck(this, FixedWidth);
                        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) args[_key7] = arguments[_key7];
                        return (_this8 = _possibleConstructorReturn(this, (_getPrototypeOf8 = _getPrototypeOf(FixedWidth)).call.apply(_getPrototypeOf8, [ this ].concat(args)))).name = "FixedWidth", 
                        _this8;
                    }
                    return _inherits(FixedWidth, ContentStrategy), _createClass(FixedWidth, [ {
                        key: "apply",
                        value: function apply(view, designedResolution) {
                            var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scale = containerW / designedResolution.width, contentW = containerW, contentH = containerH;
                            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                        }
                    } ]), FixedWidth;
                }();
                ContentStrategy.EXACT_FIT = new ExactFit(), ContentStrategy.SHOW_ALL = new ShowAll(), 
                ContentStrategy.NO_BORDER = new NoBorder(), ContentStrategy.FIXED_HEIGHT = new FixedHeight(), 
                ContentStrategy.FIXED_WIDTH = new FixedWidth();
            }();
            var ResolutionPolicy = exports("ResolutionPolicy", function() {
                function ResolutionPolicy(containerStg, contentStg) {
                    _classCallCheck(this, ResolutionPolicy), this.name = "ResolutionPolicy", this._containerStrategy = void 0, 
                    this._contentStrategy = void 0, this._containerStrategy = null, this._contentStrategy = null, 
                    this.setContainerStrategy(containerStg), this.setContentStrategy(contentStg);
                }
                return _createClass(ResolutionPolicy, [ {
                    key: "preApply",
                    value: function preApply(view) {
                        this._containerStrategy.preApply(view), this._contentStrategy.preApply(view);
                    }
                }, {
                    key: "apply",
                    value: function apply(view, designedResolution) {
                        return this._containerStrategy.apply(view, designedResolution), this._contentStrategy.apply(view, designedResolution);
                    }
                }, {
                    key: "postApply",
                    value: function postApply(view) {
                        this._containerStrategy.postApply(view), this._contentStrategy.postApply(view);
                    }
                }, {
                    key: "setContainerStrategy",
                    value: function setContainerStrategy(containerStg) {
                        containerStg instanceof ContainerStrategy && (this._containerStrategy = containerStg);
                    }
                }, {
                    key: "setContentStrategy",
                    value: function setContentStrategy(contentStg) {
                        contentStg instanceof ContentStrategy && (this._contentStrategy = contentStg);
                    }
                }, {
                    key: "canvasSize",
                    get: function get() {
                        return cc.v2(cc.game.canvas.width, cc.game.canvas.height);
                    }
                } ]), ResolutionPolicy;
            }());
            ResolutionPolicy.EXACT_FIT = void 0, ResolutionPolicy.SHOW_ALL = void 0, ResolutionPolicy.NO_BORDER = void 0, 
            ResolutionPolicy.FIXED_HEIGHT = void 0, ResolutionPolicy.FIXED_WIDTH = void 0, ResolutionPolicy.UNKNOWN = void 0, 
            ResolutionPolicy.ContainerStrategy = void 0, ResolutionPolicy.ContentStrategy = void 0, 
            ResolutionPolicy.EXACT_FIT = 0, ResolutionPolicy.NO_BORDER = 1, ResolutionPolicy.SHOW_ALL = 2, 
            ResolutionPolicy.FIXED_HEIGHT = 3, ResolutionPolicy.FIXED_WIDTH = 4, ResolutionPolicy.UNKNOWN = 5, 
            ResolutionPolicy.ContainerStrategy = ContainerStrategy, ResolutionPolicy.ContentStrategy = ContentStrategy, 
            cc.ResolutionPolicy = ResolutionPolicy;
            var view = exports("view", View.instance = cc.view = new View());
            cc.winSize = cc.v2();
            var EventMouse = exports("EventMouse", function() {
                function EventMouse(eventType, bubbles) {
                    var _this;
                    return _classCallCheck(this, EventMouse), (_this = _possibleConstructorReturn(this, _getPrototypeOf(EventMouse).call(this, Event.MOUSE, bubbles))).movementX = 0, 
                    _this.movementY = 0, _this._eventType = void 0, _this._button = 0, _this._x = 0, 
                    _this._y = 0, _this._prevX = 0, _this._prevY = 0, _this._scrollX = 0, _this._scrollY = 0, 
                    _this._eventType = eventType, _this;
                }
                return _inherits(EventMouse, Event), _createClass(EventMouse, [ {
                    key: "setScrollData",
                    value: function setScrollData(scrollX, scrollY) {
                        this._scrollX = scrollX, this._scrollY = scrollY;
                    }
                }, {
                    key: "getScrollX",
                    value: function getScrollX() {
                        return this._scrollX;
                    }
                }, {
                    key: "getScrollY",
                    value: function getScrollY() {
                        return this._scrollY;
                    }
                }, {
                    key: "setLocation",
                    value: function setLocation(x, y) {
                        this._x = x, this._y = y;
                    }
                }, {
                    key: "getLocation",
                    value: function getLocation(out) {
                        return out = out || new Vec2(), Vec2.set(out, this._x, this._y), out;
                    }
                }, {
                    key: "getLocationInView",
                    value: function getLocationInView(out) {
                        return out = out || new Vec2(), Vec2.set(out, this._x, cc.view._designResolutionSize.height - this._y), 
                        out;
                    }
                }, {
                    key: "getUILocation",
                    value: function getUILocation(out) {
                        return out = out || new Vec2(), Vec2.set(out, this._x, this._y), cc.view._convertPointWithScale(out), 
                        out;
                    }
                }, {
                    key: "_setPrevCursor",
                    value: function _setPrevCursor(x, y) {
                        this._prevX = x, this._prevY = y;
                    }
                }, {
                    key: "getPreviousLocation",
                    value: function getPreviousLocation(out) {
                        return out = out || new Vec2(), Vec2.set(out, this._prevX, this._prevY), out;
                    }
                }, {
                    key: "getUIPreviousLocation",
                    value: function getUIPreviousLocation(out) {
                        return out = out || new Vec2(), Vec2.set(out, this._prevX, this._prevY), cc.view._convertPointWithScale(out), 
                        out;
                    }
                }, {
                    key: "getDelta",
                    value: function getDelta(out) {
                        return out = out || new Vec2(), Vec2.set(out, this._x - this._prevX, this._y - this._prevY), 
                        out;
                    }
                }, {
                    key: "getDeltaX",
                    value: function getDeltaX() {
                        return this._x - this._prevX;
                    }
                }, {
                    key: "getDeltaY",
                    value: function getDeltaY() {
                        return this._y - this._prevY;
                    }
                }, {
                    key: "getUIDelta",
                    value: function getUIDelta(out) {
                        return out = out || new Vec2(), Vec2.set(out, (this._x - this._prevX) / cc.view.getScaleX(), (this._y - this._prevY) / cc.view.getScaleY()), 
                        out;
                    }
                }, {
                    key: "getUIDeltaX",
                    value: function getUIDeltaX() {
                        return (this._x - this._prevX) / cc.view.getScaleX();
                    }
                }, {
                    key: "getUIDeltaY",
                    value: function getUIDeltaY() {
                        return (this._y - this._prevY) / cc.view.getScaleY();
                    }
                }, {
                    key: "setButton",
                    value: function setButton(button) {
                        this._button = button;
                    }
                }, {
                    key: "getButton",
                    value: function getButton() {
                        return this._button;
                    }
                }, {
                    key: "getLocationX",
                    value: function getLocationX() {
                        return this._x;
                    }
                }, {
                    key: "getLocationY",
                    value: function getLocationY() {
                        return this._y;
                    }
                }, {
                    key: "getUILocationX",
                    value: function getUILocationX() {
                        var viewport = cc.view.getViewportRect();
                        return (this._x - viewport.x) / cc.view.getScaleX();
                    }
                }, {
                    key: "getUILocationY",
                    value: function getUILocationY() {
                        var viewport = cc.view.getViewportRect();
                        return (this._y - viewport.y) / cc.view.getScaleY();
                    }
                } ]), EventMouse;
            }());
            EventMouse.NONE = 0, EventMouse.DOWN = 1, EventMouse.UP = 2, EventMouse.MOVE = 3, 
            EventMouse.SCROLL = 4, EventMouse.BUTTON_LEFT = 0, EventMouse.BUTTON_RIGHT = 2, 
            EventMouse.BUTTON_MIDDLE = 1, EventMouse.BUTTON_4 = 3, EventMouse.BUTTON_5 = 4, 
            EventMouse.BUTTON_6 = 5, EventMouse.BUTTON_7 = 6, EventMouse.BUTTON_8 = 7;
            var EventTouch = exports("EventTouch", function() {
                function EventTouch(touches, bubbles) {
                    var _this2;
                    return _classCallCheck(this, EventTouch), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(EventTouch).call(this, Event.TOUCH, bubbles))).touch = null, 
                    _this2._eventCode = 0, _this2.simulate = !1, _this2._touches = void 0, _this2._eventCode = 0, 
                    _this2._touches = touches || [], _this2;
                }
                return _inherits(EventTouch, Event), _createClass(EventTouch, [ {
                    key: "getEventCode",
                    value: function getEventCode() {
                        return this._eventCode;
                    }
                }, {
                    key: "getTouches",
                    value: function getTouches() {
                        return this._touches;
                    }
                }, {
                    key: "_setEventCode",
                    value: function _setEventCode(eventCode) {
                        this._eventCode = eventCode;
                    }
                }, {
                    key: "_setTouches",
                    value: function _setTouches(touches) {
                        this._touches = touches;
                    }
                }, {
                    key: "setLocation",
                    value: function setLocation(x, y) {
                        this.touch && this.touch.setTouchInfo(this.touch.getID(), x, y);
                    }
                }, {
                    key: "getLocation",
                    value: function getLocation(out) {
                        return this.touch ? this.touch.getLocation(out) : new Vec2();
                    }
                }, {
                    key: "getUILocation",
                    value: function getUILocation(out) {
                        return this.touch ? this.touch.getUILocation(out) : new Vec2();
                    }
                }, {
                    key: "getLocationInView",
                    value: function getLocationInView(out) {
                        return this.touch ? this.touch.getLocationInView(out) : new Vec2();
                    }
                }, {
                    key: "getUILocationInView",
                    value: function getUILocationInView(out) {
                        return this.touch ? this.touch.getLocationInView(out) : new Vec2();
                    }
                }, {
                    key: "getPreviousLocation",
                    value: function getPreviousLocation(out) {
                        return this.touch ? this.touch.getPreviousLocation(out) : new Vec2();
                    }
                }, {
                    key: "getStartLocation",
                    value: function getStartLocation(out) {
                        return this.touch ? this.touch.getStartLocation(out) : new Vec2();
                    }
                }, {
                    key: "getUIStartLocation",
                    value: function getUIStartLocation(out) {
                        return this.touch ? this.touch.getUIStartLocation(out) : new Vec2();
                    }
                }, {
                    key: "getID",
                    value: function getID() {
                        return this.touch ? this.touch.getID() : null;
                    }
                }, {
                    key: "getDelta",
                    value: function getDelta(out) {
                        return this.touch ? this.touch.getDelta(out) : new Vec2();
                    }
                }, {
                    key: "getUIDelta",
                    value: function getUIDelta(out) {
                        return this.touch ? this.touch.getUIDelta(out) : new Vec2();
                    }
                }, {
                    key: "getDeltaX",
                    value: function getDeltaX(out) {
                        return this.touch ? this.touch.getDelta(out).x : 0;
                    }
                }, {
                    key: "getDeltaY",
                    value: function getDeltaY(out) {
                        return this.touch ? this.touch.getDelta(out).y : 0;
                    }
                }, {
                    key: "getLocationX",
                    value: function getLocationX() {
                        return this.touch ? this.touch.getLocationX() : 0;
                    }
                }, {
                    key: "getLocationY",
                    value: function getLocationY() {
                        return this.touch ? this.touch.getLocationY() : 0;
                    }
                } ]), EventTouch;
            }());
            EventTouch.MAX_TOUCHES = 5, EventTouch.BEGAN = 0, EventTouch.MOVED = 1, EventTouch.ENDED = 2, 
            EventTouch.CANCELLED = 3;
            var EventAcceleration = exports("EventAcceleration", function() {
                function EventAcceleration(acc, bubbles) {
                    var _this3;
                    return _classCallCheck(this, EventAcceleration), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(EventAcceleration).call(this, Event.ACCELERATION, bubbles))).acc = void 0, 
                    _this3.acc = acc, _this3;
                }
                return _inherits(EventAcceleration, Event), EventAcceleration;
            }()), EventKeyboard = exports("EventKeyboard", function() {
                function EventKeyboard(keyCode, isPressed, bubbles) {
                    var _this4;
                    return _classCallCheck(this, EventKeyboard), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(EventKeyboard).call(this, Event.KEYBOARD, bubbles))).keyCode = void 0, 
                    _this4.rawEvent = void 0, _this4.isPressed = void 0, "number" == typeof keyCode ? _this4.keyCode = keyCode : (_this4.keyCode = keyCode.keyCode, 
                    _this4.rawEvent = keyCode), _this4.isPressed = isPressed, _this4;
                }
                return _inherits(EventKeyboard, Event), EventKeyboard;
            }());
            Event.EventMouse = EventMouse, Event.EventTouch = EventTouch, Event.EventAcceleration = EventAcceleration, 
            Event.EventKeyboard = EventKeyboard;
            var EventListener = function() {
                function EventListener(type, listenerID, callback) {
                    _classCallCheck(this, EventListener), this.owner = null, this.mask = null, this._previousIn = !1, 
                    this._target = null, this._onEvent = void 0, this._type = void 0, this._listenerID = void 0, 
                    this._registered = !1, this._fixedPriority = 0, this._node = null, this._paused = !0, 
                    this._isEnabled = !0, this._onEvent = callback, this._type = type || 0, this._listenerID = listenerID || "";
                }
                return _createClass(EventListener, [ {
                    key: "onEvent",
                    get: function get() {
                        return this._onEvent;
                    }
                } ], [ {
                    key: "create",
                    value: function create(argObj) {
                        cc.assertID(argObj && argObj.event, 1900);
                        var listenerType = argObj.event;
                        delete argObj.event;
                        var listener = null;
                        if (listenerType === cc.EventListener.TOUCH_ONE_BY_ONE ? listener = new TouchOneByOne() : listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE ? listener = new TouchAllAtOnce() : listenerType === cc.EventListener.MOUSE ? listener = new Mouse() : listenerType === cc.EventListener.KEYBOARD ? listener = new Keyboard() : listenerType === cc.EventListener.ACCELERATION && (listener = new Acceleration(argObj.callback), 
                        delete argObj.callback), listener) for (var _i = 0, _Object$keys = Object.keys(argObj); _i < _Object$keys.length; _i++) {
                            var key = _Object$keys[_i];
                            listener[key] = argObj[key];
                        }
                        return listener;
                    }
                } ]), _createClass(EventListener, [ {
                    key: "_setPaused",
                    value: function _setPaused(paused) {
                        this._paused = paused;
                    }
                }, {
                    key: "_isPaused",
                    value: function _isPaused() {
                        return this._paused;
                    }
                }, {
                    key: "_setRegistered",
                    value: function _setRegistered(registered) {
                        this._registered = registered;
                    }
                }, {
                    key: "_isRegistered",
                    value: function _isRegistered() {
                        return this._registered;
                    }
                }, {
                    key: "_getType",
                    value: function _getType() {
                        return this._type;
                    }
                }, {
                    key: "_getListenerID",
                    value: function _getListenerID() {
                        return this._listenerID;
                    }
                }, {
                    key: "_setFixedPriority",
                    value: function _setFixedPriority(fixedPriority) {
                        this._fixedPriority = fixedPriority;
                    }
                }, {
                    key: "_getFixedPriority",
                    value: function _getFixedPriority() {
                        return this._fixedPriority;
                    }
                }, {
                    key: "_setSceneGraphPriority",
                    value: function _setSceneGraphPriority(node) {
                        this._target = node, this._node = node;
                    }
                }, {
                    key: "_getSceneGraphPriority",
                    value: function _getSceneGraphPriority() {
                        return this._node;
                    }
                }, {
                    key: "checkAvailable",
                    value: function checkAvailable() {
                        return null !== this._onEvent;
                    }
                }, {
                    key: "clone",
                    value: function clone() {
                        return null;
                    }
                }, {
                    key: "setEnabled",
                    value: function setEnabled(enabled) {
                        this._isEnabled = enabled;
                    }
                }, {
                    key: "isEnabled",
                    value: function isEnabled() {
                        return this._isEnabled;
                    }
                } ]), EventListener;
            }();
            EventListener.UNKNOWN = 0, EventListener.TOUCH_ONE_BY_ONE = 1, EventListener.TOUCH_ALL_AT_ONCE = 2, 
            EventListener.KEYBOARD = 3, EventListener.MOUSE = 4, EventListener.ACCELERATION = 6, 
            EventListener.CUSTOM = 8, EventListener.ListenerID = {
                MOUSE: "__cc_mouse",
                TOUCH_ONE_BY_ONE: "__cc_touch_one_by_one",
                TOUCH_ALL_AT_ONCE: "__cc_touch_all_at_once",
                KEYBOARD: "__cc_keyboard",
                ACCELERATION: "__cc_acceleration"
            };
            var ListenerID = EventListener.ListenerID, Mouse = function() {
                function Mouse() {
                    var _this;
                    return _classCallCheck(this, Mouse), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Mouse).call(this, EventListener.MOUSE, ListenerID.MOUSE, null))).onMouseDown = null, 
                    _this.onMouseUp = null, _this.onMouseMove = null, _this.onMouseScroll = null, _this._onEvent = function(event) {
                        return _this._callback(event);
                    }, _this;
                }
                return _inherits(Mouse, EventListener), _createClass(Mouse, [ {
                    key: "_callback",
                    value: function _callback(event) {
                        var eventType = cc.Event.EventMouse;
                        switch (event._eventType) {
                          case eventType.DOWN:
                            this.onMouseDown && this.onMouseDown(event);
                            break;

                          case eventType.UP:
                            this.onMouseUp && this.onMouseUp(event);
                            break;

                          case eventType.MOVE:
                            this.onMouseMove && this.onMouseMove(event);
                            break;

                          case eventType.SCROLL:
                            this.onMouseScroll && this.onMouseScroll(event);
                        }
                    }
                }, {
                    key: "clone",
                    value: function clone() {
                        var eventListener = new Mouse();
                        return eventListener.onMouseDown = this.onMouseDown, eventListener.onMouseUp = this.onMouseUp, 
                        eventListener.onMouseMove = this.onMouseMove, eventListener.onMouseScroll = this.onMouseScroll, 
                        eventListener;
                    }
                }, {
                    key: "checkAvailable",
                    value: function checkAvailable() {
                        return !0;
                    }
                } ]), Mouse;
            }(), TouchOneByOne = function() {
                function TouchOneByOne() {
                    var _this2;
                    return _classCallCheck(this, TouchOneByOne), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(TouchOneByOne).call(this, EventListener.TOUCH_ONE_BY_ONE, ListenerID.TOUCH_ONE_BY_ONE, null))).swallowTouches = !1, 
                    _this2.onTouchBegan = null, _this2.onTouchMoved = null, _this2.onTouchEnded = null, 
                    _this2.onTouchCancelled = null, _this2._claimedTouches = [], _this2;
                }
                return _inherits(TouchOneByOne, EventListener), _createClass(TouchOneByOne, [ {
                    key: "setSwallowTouches",
                    value: function setSwallowTouches(needSwallow) {
                        this.swallowTouches = needSwallow;
                    }
                }, {
                    key: "isSwallowTouches",
                    value: function isSwallowTouches() {
                        return this.swallowTouches;
                    }
                }, {
                    key: "clone",
                    value: function clone() {
                        var eventListener = new TouchOneByOne();
                        return eventListener.onTouchBegan = this.onTouchBegan, eventListener.onTouchMoved = this.onTouchMoved, 
                        eventListener.onTouchEnded = this.onTouchEnded, eventListener.onTouchCancelled = this.onTouchCancelled, 
                        eventListener.swallowTouches = this.swallowTouches, eventListener;
                    }
                }, {
                    key: "checkAvailable",
                    value: function checkAvailable() {
                        return !!this.onTouchBegan || (cc.logID(1801), !1);
                    }
                } ]), TouchOneByOne;
            }(), TouchAllAtOnce = function() {
                function TouchAllAtOnce() {
                    var _this3;
                    return _classCallCheck(this, TouchAllAtOnce), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(TouchAllAtOnce).call(this, EventListener.TOUCH_ALL_AT_ONCE, ListenerID.TOUCH_ALL_AT_ONCE, null))).onTouchesBegan = null, 
                    _this3.onTouchesMoved = null, _this3.onTouchesEnded = null, _this3.onTouchesCancelled = null, 
                    _this3;
                }
                return _inherits(TouchAllAtOnce, EventListener), _createClass(TouchAllAtOnce, [ {
                    key: "clone",
                    value: function clone() {
                        var eventListener = new TouchAllAtOnce();
                        return eventListener.onTouchesBegan = this.onTouchesBegan, eventListener.onTouchesMoved = this.onTouchesMoved, 
                        eventListener.onTouchesEnded = this.onTouchesEnded, eventListener.onTouchesCancelled = this.onTouchesCancelled, 
                        eventListener;
                    }
                }, {
                    key: "checkAvailable",
                    value: function checkAvailable() {
                        return null !== this.onTouchesBegan || null !== this.onTouchesMoved || null !== this.onTouchesEnded || null !== this.onTouchesCancelled || (cc.logID(1802), 
                        !1);
                    }
                } ]), TouchAllAtOnce;
            }(), Acceleration = function() {
                function Acceleration(callback) {
                    var _this4;
                    return _classCallCheck(this, Acceleration), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(Acceleration).call(this, EventListener.ACCELERATION, ListenerID.ACCELERATION, null)))._onAccelerationEvent = null, 
                    _this4._onEvent = function(event) {
                        return _this4._callback(event);
                    }, _this4._onAccelerationEvent = callback, _this4;
                }
                return _inherits(Acceleration, EventListener), _createClass(Acceleration, [ {
                    key: "_callback",
                    value: function _callback(event) {
                        this._onAccelerationEvent && this._onAccelerationEvent(event.acc, event);
                    }
                }, {
                    key: "checkAvailable",
                    value: function checkAvailable() {
                        return cc.assertID(this._onAccelerationEvent, 1803), !0;
                    }
                }, {
                    key: "clone",
                    value: function clone() {
                        return new Acceleration(this._onAccelerationEvent);
                    }
                } ]), Acceleration;
            }(), Keyboard = function() {
                function Keyboard() {
                    var _this5;
                    return _classCallCheck(this, Keyboard), (_this5 = _possibleConstructorReturn(this, _getPrototypeOf(Keyboard).call(this, EventListener.KEYBOARD, ListenerID.KEYBOARD, null))).onKeyPressed = null, 
                    _this5.onKeyReleased = null, _this5._onEvent = function(event) {
                        return _this5._callback(event);
                    }, _this5;
                }
                return _inherits(Keyboard, EventListener), _createClass(Keyboard, [ {
                    key: "_callback",
                    value: function _callback(event) {
                        event.isPressed ? this.onKeyPressed && this.onKeyPressed(event.keyCode, event) : this.onKeyReleased && this.onKeyReleased(event.keyCode, event);
                    }
                }, {
                    key: "clone",
                    value: function clone() {
                        var eventListener = new Keyboard();
                        return eventListener.onKeyPressed = this.onKeyPressed, eventListener.onKeyReleased = this.onKeyReleased, 
                        eventListener;
                    }
                }, {
                    key: "checkAvailable",
                    value: function checkAvailable() {
                        return null !== this.onKeyPressed || null !== this.onKeyReleased || (cc.logID(1800), 
                        !1);
                    }
                } ]), Keyboard;
            }(), ListenerID$1 = (cc.EventListener = EventListener).ListenerID;
            var _EventListenerVector = function() {
                function _EventListenerVector() {
                    _classCallCheck(this, _EventListenerVector), this.gt0Index = 0, this._fixedListeners = [], 
                    this._sceneGraphListeners = [];
                }
                return _createClass(_EventListenerVector, [ {
                    key: "size",
                    value: function size() {
                        return this._fixedListeners.length + this._sceneGraphListeners.length;
                    }
                }, {
                    key: "empty",
                    value: function empty() {
                        return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length;
                    }
                }, {
                    key: "push",
                    value: function push(listener) {
                        0 === listener._getFixedPriority() ? this._sceneGraphListeners.push(listener) : this._fixedListeners.push(listener);
                    }
                }, {
                    key: "clearSceneGraphListeners",
                    value: function clearSceneGraphListeners() {
                        this._sceneGraphListeners.length = 0;
                    }
                }, {
                    key: "clearFixedListeners",
                    value: function clearFixedListeners() {
                        this._fixedListeners.length = 0;
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        this._sceneGraphListeners.length = 0, this._fixedListeners.length = 0;
                    }
                }, {
                    key: "getFixedPriorityListeners",
                    value: function getFixedPriorityListeners() {
                        return this._fixedListeners;
                    }
                }, {
                    key: "getSceneGraphPriorityListeners",
                    value: function getSceneGraphPriorityListeners() {
                        return this._sceneGraphListeners;
                    }
                } ]), _EventListenerVector;
            }();
            var eventManager = exports("eventManager", new (function() {
                function EventManager() {
                    _classCallCheck(this, EventManager), this._listenersMap = {}, this._priorityDirtyFlagMap = {}, 
                    this._nodeListenersMap = {}, this._toAddedListeners = [], this._toRemovedListeners = [], 
                    this._dirtyListeners = [], this._inDispatch = 0, this._isEnabled = !1, this._internalCustomListenerIDs = [];
                }
                return _createClass(EventManager, [ {
                    key: "pauseTarget",
                    value: function pauseTarget(node, argument_1) {
                        var recursive = 1 < arguments.length && void 0 !== argument_1 && argument_1;
                        if (node instanceof cc._BaseNode) {
                            var listeners = this._nodeListenersMap[node.uuid];
                            if (listeners) for (var i = 0; i < listeners.length; ++i) {
                                listeners[i]._setPaused(!0);
                            }
                            if (!0 === recursive) {
                                var locChildren = node.children;
                                if (locChildren) for (var _i = 0; _i < locChildren.length; ++_i) {
                                    var locChild = locChildren[_i];
                                    this.pauseTarget(locChild, !0);
                                }
                            }
                        } else cc.warnID(3506);
                    }
                }, {
                    key: "resumeTarget",
                    value: function resumeTarget(node, argument_1) {
                        var recursive = 1 < arguments.length && void 0 !== argument_1 && argument_1;
                        if (node instanceof cc._BaseNode) {
                            var listeners = this._nodeListenersMap[node.uuid];
                            if (listeners) for (var i = 0; i < listeners.length; ++i) {
                                listeners[i]._setPaused(!1);
                            }
                            if (this._setDirtyForNode(node), !0 === recursive && 0 < node.children.length) {
                                var locChildren = node.children;
                                if (locChildren) for (var _i2 = 0; _i2 < locChildren.length; ++_i2) {
                                    var locChild = locChildren[_i2];
                                    this.resumeTarget(locChild, !0);
                                }
                            }
                        } else cc.warnID(3506);
                    }
                }, {
                    key: "frameUpdateListeners",
                    value: function frameUpdateListeners() {
                        var locListenersMap = this._listenersMap, locPriorityDirtyFlagMap = this._priorityDirtyFlagMap;
                        for (var selKey in locListenersMap) locListenersMap[selKey].empty() && (delete locPriorityDirtyFlagMap[selKey], 
                        delete locListenersMap[selKey]);
                        var locToAddedListeners = this._toAddedListeners;
                        if (0 !== locToAddedListeners.length) {
                            for (var i = 0, len = locToAddedListeners.length; i < len; i++) this._forceAddEventListener(locToAddedListeners[i]);
                            locToAddedListeners.length = 0;
                        }
                        0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
                    }
                }, {
                    key: "hasEventListener",
                    value: function hasEventListener(listenerID) {
                        return !!this._getListeners(listenerID);
                    }
                }, {
                    key: "addListener",
                    value: function addListener(listener, nodeOrPriority) {
                        if (cc.assertID(listener && nodeOrPriority, 3503), cc.js.isNumber(nodeOrPriority) || nodeOrPriority instanceof cc._BaseNode) {
                            if (listener instanceof cc.EventListener) {
                                if (listener._isRegistered()) return void cc.logID(3505);
                            } else cc.assertID(!cc.js.isNumber(nodeOrPriority), 3504), listener = cc.EventListener.create(listener);
                            if (listener.checkAvailable()) {
                                if (cc.js.isNumber(nodeOrPriority)) {
                                    if (0 === nodeOrPriority) return void cc.logID(3500);
                                    listener._setSceneGraphPriority(null), listener._setFixedPriority(nodeOrPriority), 
                                    listener._setRegistered(!0), listener._setPaused(!1), this._addListener(listener);
                                } else {
                                    if (!function checkUINode(node) {
                                        for (;node; ) {
                                            if (node.getComponent("cc.CanvasComponent")) return !0;
                                            node = node.parent;
                                        }
                                        return !1;
                                    }(nodeOrPriority)) return void cc.logID(3512);
                                    listener._setSceneGraphPriority(nodeOrPriority), listener._setFixedPriority(0), 
                                    listener._setRegistered(!0), this._addListener(listener);
                                }
                                return listener;
                            }
                        } else cc.warnID(3506);
                    }
                }, {
                    key: "addCustomListener",
                    value: function addCustomListener(eventName, callback) {
                        var listener = EventListener.create({
                            event: cc.EventListener.CUSTOM,
                            eventName: eventName,
                            callback: callback
                        });
                        return this.addListener(listener, 1), listener;
                    }
                }, {
                    key: "removeListener",
                    value: function removeListener(listener) {
                        if (null != listener) {
                            var isFound = !1, locListener = this._listenersMap;
                            for (var selKey in locListener) {
                                var listeners = locListener[selKey], fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                                if ((isFound = this._removeListenerInVector(sceneGraphPriorityListeners, listener)) ? this._setDirty(listener._getListenerID(), 2) : (isFound = this._removeListenerInVector(fixedPriorityListeners, listener)) && this._setDirty(listener._getListenerID(), 1), 
                                listeners.empty() && (delete this._priorityDirtyFlagMap[listener._getListenerID()], 
                                delete locListener[selKey]), isFound) break;
                            }
                            if (!isFound) for (var locToAddedListeners = this._toAddedListeners, i = locToAddedListeners.length - 1; 0 <= i; i--) {
                                var selListener = locToAddedListeners[i];
                                if (selListener === listener) {
                                    cc.js.array.removeAt(locToAddedListeners, i), selListener._setRegistered(!1);
                                    break;
                                }
                            }
                        }
                    }
                }, {
                    key: "removeListeners",
                    value: function removeListeners(listenerType, argument_1) {
                        var recursive = 1 < arguments.length && void 0 !== argument_1 && argument_1;
                        if (cc.js.isNumber(listenerType) || listenerType instanceof cc._BaseNode) if (void 0 !== listenerType._id) {
                            var listeners = this._nodeListenersMap[listenerType._id];
                            if (listeners) {
                                for (var listenersCopy = cc.js.array.copy(listeners), i = 0; i < listenersCopy.length; ++i) {
                                    var listenerCopy = listenersCopy[i];
                                    this.removeListener(listenerCopy);
                                }
                                delete this._nodeListenersMap[listenerType._id];
                            }
                            for (var locToAddedListeners = this._toAddedListeners, _i3 = 0; _i3 < locToAddedListeners.length; ) {
                                var listener = locToAddedListeners[_i3];
                                listener._getSceneGraphPriority() === listenerType ? (listener._setSceneGraphPriority(null), 
                                listener._setRegistered(!1), locToAddedListeners.splice(_i3, 1)) : ++_i3;
                            }
                            if (!0 === recursive) for (var locChildren = listenerType.getChildren(), _i4 = 0; _i4 < locChildren.length; ++_i4) {
                                var locChild = locChildren[_i4];
                                this.removeListeners(locChild, !0);
                            }
                        } else listenerType === cc.EventListener.TOUCH_ONE_BY_ONE ? this._removeListenersForListenerID(ListenerID$1.TOUCH_ONE_BY_ONE) : listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE ? this._removeListenersForListenerID(ListenerID$1.TOUCH_ALL_AT_ONCE) : listenerType === cc.EventListener.MOUSE ? this._removeListenersForListenerID(ListenerID$1.MOUSE) : listenerType === cc.EventListener.ACCELERATION ? this._removeListenersForListenerID(ListenerID$1.ACCELERATION) : listenerType === cc.EventListener.KEYBOARD ? this._removeListenersForListenerID(ListenerID$1.KEYBOARD) : cc.logID(3501); else cc.warnID(3506);
                    }
                }, {
                    key: "removeCustomListeners",
                    value: function removeCustomListeners(customEventName) {
                        this._removeListenersForListenerID(customEventName);
                    }
                }, {
                    key: "removeAllListeners",
                    value: function removeAllListeners() {
                        var locListeners = this._listenersMap, locInternalCustomEventIDs = this._internalCustomListenerIDs;
                        for (var selKey in locListeners) -1 === locInternalCustomEventIDs.indexOf(selKey) && this._removeListenersForListenerID(selKey);
                    }
                }, {
                    key: "setPriority",
                    value: function setPriority(listener, fixedPriority) {
                        if (null != listener) {
                            var locListeners = this._listenersMap;
                            for (var selKey in locListeners) {
                                var fixedPriorityListeners = locListeners[selKey].getFixedPriorityListeners();
                                if (fixedPriorityListeners) if (-1 !== fixedPriorityListeners.indexOf(listener)) return null != listener._getSceneGraphPriority() && cc.logID(3502), 
                                void (listener._getFixedPriority() !== fixedPriority && (listener._setFixedPriority(fixedPriority), 
                                this._setDirty(listener._getListenerID(), 1)));
                            }
                        }
                    }
                }, {
                    key: "setEnabled",
                    value: function setEnabled(enabled) {
                        this._isEnabled = enabled;
                    }
                }, {
                    key: "isEnabled",
                    value: function isEnabled() {
                        return this._isEnabled;
                    }
                }, {
                    key: "dispatchEvent",
                    value: function dispatchEvent(event) {
                        if (this._isEnabled) if (this._updateDirtyFlagForSceneGraph(), this._inDispatch++, 
                        event && event.getType) {
                            if (event.getType().startsWith(cc.Event.TOUCH)) return this._dispatchTouchEvent(event), 
                            void this._inDispatch--;
                            var listenerID = function __getListenerID(event) {
                                var eventType = Event, type = event.type;
                                return type === eventType.ACCELERATION ? ListenerID$1.ACCELERATION : type === eventType.KEYBOARD ? ListenerID$1.KEYBOARD : type.startsWith(eventType.MOUSE) ? ListenerID$1.MOUSE : (type.startsWith(eventType.TOUCH) && cc.logID(2e3), 
                                "");
                            }(event);
                            this._sortEventListeners(listenerID);
                            var selListeners = this._listenersMap[listenerID];
                            null != selListeners && (this._dispatchEventToListeners(selListeners, this._onListenerCallback, event), 
                            this._onUpdateListeners(selListeners)), this._inDispatch--;
                        } else cc.errorID(3511);
                    }
                }, {
                    key: "_onListenerCallback",
                    value: function _onListenerCallback(listener, event) {
                        event.currentTarget = listener._target;
                        var onEvent = listener.onEvent;
                        return onEvent && onEvent(event), event.isStopped();
                    }
                }, {
                    key: "dispatchCustomEvent",
                    value: function dispatchCustomEvent(eventName, optionalUserData) {
                        var ev = new cc.Event.EventCustom(eventName);
                        ev.setUserData(optionalUserData), this.dispatchEvent(ev);
                    }
                }, {
                    key: "_setDirtyForNode",
                    value: function _setDirtyForNode(node) {
                        var selListeners = this._nodeListenersMap[node._id];
                        if (void 0 !== selListeners) for (var j = 0, len = selListeners.length; j < len; j++) {
                            var listenerID = selListeners[j]._getListenerID();
                            null == this._dirtyListeners[listenerID] && (this._dirtyListeners[listenerID] = !0);
                        }
                        if (0 < node.children.length) for (var _children = node.children, i = 0, _len = _children ? _children.length : 0; i < _len; i++) this._setDirtyForNode(_children[i]);
                    }
                }, {
                    key: "_addListener",
                    value: function _addListener(listener) {
                        0 === this._inDispatch ? this._forceAddEventListener(listener) : this._toAddedListeners.push(listener);
                    }
                }, {
                    key: "_forceAddEventListener",
                    value: function _forceAddEventListener(listener) {
                        var listenerID = listener._getListenerID(), listeners = this._listenersMap[listenerID];
                        if (listeners || (listeners = new _EventListenerVector(), this._listenersMap[listenerID] = listeners), 
                        listeners.push(listener), 0 === listener._getFixedPriority()) {
                            this._setDirty(listenerID, 2);
                            var node = listener._getSceneGraphPriority();
                            null === node && cc.logID(3507), this._associateNodeAndEventListener(node, listener), 
                            node.activeInHierarchy && this.resumeTarget(node);
                        } else this._setDirty(listenerID, 1);
                    }
                }, {
                    key: "_getListeners",
                    value: function _getListeners(listenerID) {
                        return this._listenersMap[listenerID];
                    }
                }, {
                    key: "_updateDirtyFlagForSceneGraph",
                    value: function _updateDirtyFlagForSceneGraph() {
                        var locDirtyListeners = this._dirtyListeners;
                        for (var selKey in locDirtyListeners) this._setDirty(selKey, 2);
                        this._dirtyListeners.length = 0;
                    }
                }, {
                    key: "_removeAllListenersInVector",
                    value: function _removeAllListenersInVector(listenerVector) {
                        if (listenerVector) for (var selListener, i = listenerVector.length - 1; 0 <= i; i--) (selListener = listenerVector[i])._setRegistered(!1), 
                        null != selListener._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener), 
                        selListener._setSceneGraphPriority(null)), 0 === this._inDispatch && cc.js.array.removeAt(listenerVector, i);
                    }
                }, {
                    key: "_removeListenersForListenerID",
                    value: function _removeListenersForListenerID(listenerID) {
                        var listeners = this._listenersMap[listenerID];
                        if (listeners) {
                            var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                            this._removeAllListenersInVector(sceneGraphPriorityListeners), this._removeAllListenersInVector(fixedPriorityListeners), 
                            delete this._priorityDirtyFlagMap[listenerID], this._inDispatch || (listeners.clear(), 
                            delete this._listenersMap[listenerID]);
                        }
                        for (var locToAddedListeners = this._toAddedListeners, i = locToAddedListeners.length - 1; 0 <= i; i--) {
                            var listener = locToAddedListeners[i];
                            listener && listener._getListenerID() === listenerID && cc.js.array.removeAt(locToAddedListeners, i);
                        }
                    }
                }, {
                    key: "_sortEventListeners",
                    value: function _sortEventListeners(listenerID) {
                        var dirtyFlag = 0, locFlagMap = this._priorityDirtyFlagMap;
                        locFlagMap[listenerID] && (dirtyFlag = locFlagMap[listenerID]), 0 !== dirtyFlag && (locFlagMap[listenerID] = 0, 
                        1 & dirtyFlag && this._sortListenersOfFixedPriority(listenerID), 2 & dirtyFlag && cc.director.getScene() && this._sortListenersOfSceneGraphPriority(listenerID));
                    }
                }, {
                    key: "_sortListenersOfSceneGraphPriority",
                    value: function _sortListenersOfSceneGraphPriority(listenerID) {
                        var listeners = this._getListeners(listenerID);
                        if (listeners) {
                            var sceneGraphListener = listeners.getSceneGraphPriorityListeners();
                            sceneGraphListener && 0 !== sceneGraphListener.length && listeners.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes);
                        }
                    }
                }, {
                    key: "_sortEventListenersOfSceneGraphPriorityDes",
                    value: function _sortEventListenersOfSceneGraphPriorityDes(l1, l2) {
                        var node1 = l1._getSceneGraphPriority(), node2 = l2._getSceneGraphPriority();
                        if (!(l2 && node2 && node2._activeInHierarchy)) return -1;
                        if (!l1 || !node1 || !node1._activeInHierarchy) return 1;
                        for (var p1 = node1, p2 = node2, ex = !1; p1.parent._id !== p2.parent._id; ) p1 = null === p1.parent.parent ? (ex = !0) && node2 : p1.parent, 
                        p2 = null === p2.parent.parent ? (ex = !0) && node1 : p2.parent;
                        if (p1._id === p2._id) {
                            if (p1._id === node2._id) return -1;
                            if (p1._id === node1._id) return 1;
                        }
                        var priority1 = p1.getSiblingIndex(), priority2 = p2.getSiblingIndex();
                        return ex ? priority1 - priority2 : priority2 - priority1;
                    }
                }, {
                    key: "_sortListenersOfFixedPriority",
                    value: function _sortListenersOfFixedPriority(listenerID) {
                        var listeners = this._listenersMap[listenerID];
                        if (listeners) {
                            var fixedListeners = listeners.getFixedPriorityListeners();
                            if (fixedListeners && 0 !== fixedListeners.length) {
                                fixedListeners.sort(this._sortListenersOfFixedPriorityAsc);
                                for (var index = 0, len = fixedListeners.length; index < len && !(0 <= fixedListeners[index]._getFixedPriority()); ) ++index;
                                listeners.gt0Index = index;
                            }
                        }
                    }
                }, {
                    key: "_sortListenersOfFixedPriorityAsc",
                    value: function _sortListenersOfFixedPriorityAsc(l1, l2) {
                        return l1._getFixedPriority() - l2._getFixedPriority();
                    }
                }, {
                    key: "_onUpdateListeners",
                    value: function _onUpdateListeners(listeners) {
                        var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners(), toRemovedListeners = this._toRemovedListeners;
                        if (sceneGraphPriorityListeners) for (var i = sceneGraphPriorityListeners.length - 1; 0 <= i; i--) {
                            var selListener = sceneGraphPriorityListeners[i];
                            if (!selListener._isRegistered()) {
                                cc.js.array.removeAt(sceneGraphPriorityListeners, i);
                                var idx = toRemovedListeners.indexOf(selListener);
                                -1 !== idx && toRemovedListeners.splice(idx, 1);
                            }
                        }
                        if (fixedPriorityListeners) for (var _i5 = fixedPriorityListeners.length - 1; 0 <= _i5; _i5--) {
                            var _selListener = fixedPriorityListeners[_i5];
                            if (!_selListener._isRegistered()) {
                                cc.js.array.removeAt(fixedPriorityListeners, _i5);
                                var _idx = toRemovedListeners.indexOf(_selListener);
                                -1 !== _idx && toRemovedListeners.splice(_idx, 1);
                            }
                        }
                        sceneGraphPriorityListeners && 0 === sceneGraphPriorityListeners.length && listeners.clearSceneGraphListeners(), 
                        fixedPriorityListeners && 0 === fixedPriorityListeners.length && listeners.clearFixedListeners();
                    }
                }, {
                    key: "_updateTouchListeners",
                    value: function _updateTouchListeners() {
                        var locInDispatch = this._inDispatch;
                        if (cc.assertID(0 < locInDispatch, 3508), !(1 < locInDispatch)) {
                            var listeners;
                            (listeners = this._listenersMap[ListenerID$1.TOUCH_ONE_BY_ONE]) && this._onUpdateListeners(listeners), 
                            (listeners = this._listenersMap[ListenerID$1.TOUCH_ALL_AT_ONCE]) && this._onUpdateListeners(listeners), 
                            cc.assertID(1 === locInDispatch, 3509);
                            var locToAddedListeners = this._toAddedListeners;
                            if (0 !== locToAddedListeners.length) {
                                for (var i = 0, len = locToAddedListeners.length; i < len; i++) this._forceAddEventListener(locToAddedListeners[i]);
                                this._toAddedListeners.length = 0;
                            }
                            0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
                        }
                    }
                }, {
                    key: "_cleanToRemovedListeners",
                    value: function _cleanToRemovedListeners() {
                        for (var toRemovedListeners = this._toRemovedListeners, i = 0; i < toRemovedListeners.length; ++i) {
                            var selListener = toRemovedListeners[i], listeners = this._listenersMap[selListener._getListenerID()];
                            if (listeners) {
                                var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                                if (sceneGraphPriorityListeners) {
                                    var idx = sceneGraphPriorityListeners.indexOf(selListener);
                                    -1 !== idx && sceneGraphPriorityListeners.splice(idx, 1);
                                }
                                if (fixedPriorityListeners) {
                                    var _idx2 = fixedPriorityListeners.indexOf(selListener);
                                    -1 !== _idx2 && fixedPriorityListeners.splice(_idx2, 1);
                                }
                            }
                        }
                        toRemovedListeners.length = 0;
                    }
                }, {
                    key: "_onTouchEventCallback",
                    value: function _onTouchEventCallback(listener, argsObj) {
                        if (!listener._isRegistered()) return !1;
                        var event = argsObj.event, selTouch = event.touch;
                        event.currentTarget = listener._getSceneGraphPriority();
                        var isClaimed = !1, removedIdx = -1, getCode = event.getEventCode();
                        return getCode === EventTouch.BEGAN ? listener.onTouchBegan && (isClaimed = listener.onTouchBegan(selTouch, event)) && listener._isRegistered() && listener._claimedTouches.push(selTouch) : 0 < listener._claimedTouches.length && -1 !== (removedIdx = listener._claimedTouches.indexOf(selTouch)) && (isClaimed = !0, 
                        getCode === EventTouch.MOVED && listener.onTouchMoved ? listener.onTouchMoved(selTouch, event) : getCode === EventTouch.ENDED ? (listener.onTouchEnded && listener.onTouchEnded(selTouch, event), 
                        listener._isRegistered() && listener._claimedTouches.splice(removedIdx, 1)) : getCode === EventTouch.CANCELLED && (listener.onTouchCancelled && listener.onTouchCancelled(selTouch, event), 
                        listener._isRegistered() && listener._claimedTouches.splice(removedIdx, 1))), event.isStopped() ? (eventManager._updateTouchListeners(event), 
                        !0) : !!(isClaimed && listener._isRegistered() && listener.swallowTouches) && (argsObj.needsMutableSet && argsObj.touches.splice(selTouch, 1), 
                        !0);
                    }
                }, {
                    key: "_dispatchTouchEvent",
                    value: function _dispatchTouchEvent(event) {
                        this._sortEventListeners(ListenerID$1.TOUCH_ONE_BY_ONE), this._sortEventListeners(ListenerID$1.TOUCH_ALL_AT_ONCE);
                        var oneByOneListeners = this._getListeners(ListenerID$1.TOUCH_ONE_BY_ONE), allAtOnceListeners = this._getListeners(ListenerID$1.TOUCH_ALL_AT_ONCE);
                        if (null !== oneByOneListeners || null !== allAtOnceListeners) {
                            var originalTouches = event.getTouches(), mutableTouches = cc.js.array.copy(originalTouches), oneByOneArgsObj = {
                                event: event,
                                needsMutableSet: oneByOneListeners && allAtOnceListeners,
                                touches: mutableTouches,
                                selTouch: null
                            };
                            if (oneByOneListeners) for (var i = 0; i < originalTouches.length; ++i) {
                                var originalTouch = originalTouches[i];
                                event.touch = originalTouch, event.propagationStopped = event.propagationImmediateStopped = !1, 
                                this._dispatchEventToListeners(oneByOneListeners, this._onTouchEventCallback, oneByOneArgsObj);
                            }
                            allAtOnceListeners && 0 < mutableTouches.length && (this._dispatchEventToListeners(allAtOnceListeners, this._onTouchesEventCallback, {
                                event: event,
                                touches: mutableTouches
                            }), event.isStopped()) || this._updateTouchListeners(event);
                        }
                    }
                }, {
                    key: "_onTouchesEventCallback",
                    value: function _onTouchesEventCallback(listener, callbackParams) {
                        if (!listener._isRegistered()) return !1;
                        var event = callbackParams.event, touches = callbackParams.touches, getCode = event.getEventCode();
                        return event.currentTarget = listener._getSceneGraphPriority(), getCode === EventTouch.BEGAN && listener.onTouchesBegan ? listener.onTouchesBegan(touches, event) : getCode === EventTouch.MOVED && listener.onTouchesMoved ? listener.onTouchesMoved(touches, event) : getCode === EventTouch.ENDED && listener.onTouchesEnded ? listener.onTouchesEnded(touches, event) : getCode === EventTouch.CANCELLED && listener.onTouchesCancelled && listener.onTouchesCancelled(touches, event), 
                        !!event.isStopped() && (eventManager._updateTouchListeners(event), !0);
                    }
                }, {
                    key: "_associateNodeAndEventListener",
                    value: function _associateNodeAndEventListener(node, listener) {
                        var listeners = this._nodeListenersMap[node.uuid];
                        listeners || (listeners = [], this._nodeListenersMap[node.uuid] = listeners), listeners.push(listener);
                    }
                }, {
                    key: "_dissociateNodeAndEventListener",
                    value: function _dissociateNodeAndEventListener(node, listener) {
                        var listeners = this._nodeListenersMap[node.uuid];
                        listeners && (cc.js.array.remove(listeners, listener), 0 === listeners.length && delete this._nodeListenersMap[node.uuid]);
                    }
                }, {
                    key: "_dispatchEventToListeners",
                    value: function _dispatchEventToListeners(listeners, onEvent, eventOrArgs) {
                        var shouldStopPropagation = !1, fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners(), i = 0;
                        if (fixedPriorityListeners && 0 !== fixedPriorityListeners.length) for (;i < listeners.gt0Index; ++i) {
                            var selListener = fixedPriorityListeners[i];
                            if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                                shouldStopPropagation = !0;
                                break;
                            }
                        }
                        if (sceneGraphPriorityListeners && !shouldStopPropagation) for (var _i6 = 0; _i6 < sceneGraphPriorityListeners.length; ++_i6) {
                            var _selListener2 = sceneGraphPriorityListeners[_i6];
                            if (_selListener2.isEnabled() && !_selListener2._isPaused() && _selListener2._isRegistered() && onEvent(_selListener2, eventOrArgs)) {
                                shouldStopPropagation = !0;
                                break;
                            }
                        }
                        if (fixedPriorityListeners && !shouldStopPropagation) for (;i < fixedPriorityListeners.length; ++i) {
                            var _selListener3 = fixedPriorityListeners[i];
                            if (_selListener3.isEnabled() && !_selListener3._isPaused() && _selListener3._isRegistered() && onEvent(_selListener3, eventOrArgs)) {
                                shouldStopPropagation = !0;
                                break;
                            }
                        }
                    }
                }, {
                    key: "_setDirty",
                    value: function _setDirty(listenerID, flag) {
                        var locDirtyFlagMap = this._priorityDirtyFlagMap;
                        null == locDirtyFlagMap[listenerID] ? locDirtyFlagMap[listenerID] = flag : locDirtyFlagMap[listenerID] = flag | locDirtyFlagMap[listenerID];
                    }
                }, {
                    key: "_sortNumberAsc",
                    value: function _sortNumberAsc(a, b) {
                        return a - b;
                    }
                }, {
                    key: "_removeListenerInCallback",
                    value: function _removeListenerInCallback(listeners, callback) {
                        if (null == listeners) return !1;
                        for (var i = listeners.length - 1; 0 <= i; i--) {
                            var selListener = listeners[i];
                            if (selListener._onCustomEvent === callback || selListener.onEvent === callback) return selListener._setRegistered(!1), 
                            null != selListener._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener), 
                            selListener._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.js.array.removeAt(listeners, i) : this._toRemovedListeners.push(selListener), 
                            !0;
                        }
                        return !1;
                    }
                }, {
                    key: "_removeListenerInVector",
                    value: function _removeListenerInVector(listeners, listener) {
                        if (null == listeners) return !1;
                        for (var i = listeners.length - 1; 0 <= i; i--) {
                            var selListener = listeners[i];
                            if (selListener === listener) return selListener._setRegistered(!1), null != selListener._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener), 
                            selListener._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.js.array.removeAt(listeners, i) : this._toRemovedListeners.push(selListener), 
                            !0;
                        }
                        return !1;
                    }
                } ]), EventManager;
            }())());
            cc.eventManager = eventManager;
            var _vec2 = new Vec2(), Touch = exports("Touch", function() {
                function Touch(x, y) {
                    var id = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
                    _classCallCheck(this, Touch), this._point = new Vec2(), this._prevPoint = new Vec2(), 
                    this._lastModified = 0, this._id = null, this._startPoint = new Vec2(), this._startPointCaptured = !1, 
                    this.setTouchInfo(id, x, y);
                }
                return _createClass(Touch, [ {
                    key: "getLocation",
                    value: function getLocation(out) {
                        return (out = out || new Vec2()).set(this._point.x, this._point.y), out;
                    }
                }, {
                    key: "getLocationX",
                    value: function getLocationX() {
                        return this._point.x;
                    }
                }, {
                    key: "getLocationY",
                    value: function getLocationY() {
                        return this._point.y;
                    }
                }, {
                    key: "getUILocation",
                    value: function getUILocation(out) {
                        return (out = out || new Vec2()).set(this._point.x, this._point.y), cc.view._convertPointWithScale(out), 
                        out;
                    }
                }, {
                    key: "getUILocationX",
                    value: function getUILocationX() {
                        var viewport = cc.view.getViewportRect();
                        return (this._point.x - viewport.x) / cc.view.getScaleX();
                    }
                }, {
                    key: "getUILocationY",
                    value: function getUILocationY() {
                        var viewport = cc.view.getViewportRect();
                        return (this._point.y - viewport.y) / cc.view.getScaleY();
                    }
                }, {
                    key: "getPreviousLocation",
                    value: function getPreviousLocation(out) {
                        return (out = out || new Vec2()).set(this._prevPoint.x, this._prevPoint.y), out;
                    }
                }, {
                    key: "getUIPreviousLocation",
                    value: function getUIPreviousLocation(out) {
                        return (out = out || new Vec2()).set(this._prevPoint.x, this._prevPoint.y), cc.view._convertPointWithScale(out), 
                        out;
                    }
                }, {
                    key: "getStartLocation",
                    value: function getStartLocation(out) {
                        return (out = out || new Vec2()).set(this._startPoint.x, this._startPoint.y), out;
                    }
                }, {
                    key: "getUIStartLocation",
                    value: function getUIStartLocation(out) {
                        return (out = out || new Vec2()).set(this._startPoint.x, this._startPoint.y), cc.view._convertPointWithScale(out), 
                        out;
                    }
                }, {
                    key: "getDelta",
                    value: function getDelta(out) {
                        return (out = out || new Vec2()).set(this._point), out.subtract(this._prevPoint), 
                        out;
                    }
                }, {
                    key: "getUIDelta",
                    value: function getUIDelta(out) {
                        return out = out || new Vec2(), _vec2.set(this._point), _vec2.subtract(this._prevPoint), 
                        out.set(cc.view.getScaleX(), cc.view.getScaleY()), Vec2.divide(out, _vec2, out), 
                        out;
                    }
                }, {
                    key: "getLocationInView",
                    value: function getLocationInView(out) {
                        return (out = out || new Vec2()).set(this._point.x, cc.view._designResolutionSize.height - this._point.y), 
                        out;
                    }
                }, {
                    key: "getPreviousLocationInView",
                    value: function getPreviousLocationInView(out) {
                        return (out = out || new Vec2()).set(this._prevPoint.x, cc.view._designResolutionSize.height - this._prevPoint.y), 
                        out;
                    }
                }, {
                    key: "getStartLocationInView",
                    value: function getStartLocationInView(out) {
                        return (out = out || new Vec2()).set(this._startPoint.x, cc.view._designResolutionSize.height - this._startPoint.y), 
                        out;
                    }
                }, {
                    key: "getID",
                    value: function getID() {
                        return this._id;
                    }
                }, {
                    key: "setTouchInfo",
                    value: function setTouchInfo(argument_0, argument_1, argument_2) {
                        var id = 0 < arguments.length && void 0 !== argument_0 ? argument_0 : null, x = 1 < arguments.length ? argument_1 : void 0, y = 2 < arguments.length ? argument_2 : void 0;
                        this._prevPoint = this._point, this._point = new Vec2(x || 0, y || 0), this._id = id, 
                        this._startPointCaptured || (this._startPoint = new Vec2(this._point), this._startPointCaptured = !0);
                    }
                }, {
                    key: "_setPoint",
                    value: function _setPoint(x, y) {
                        "object" === _typeof(x) ? (this._point.x = x.x, this._point.y = x.y) : (this._point.x = x || 0, 
                        this._point.y = y || 0);
                    }
                }, {
                    key: "_setPrevPoint",
                    value: function _setPrevPoint(x, y) {
                        "object" === _typeof(x) ? this._prevPoint = new Vec2(x.x, x.y) : this._prevPoint = new Vec2(x || 0, y || 0);
                    }
                } ]), Touch;
            }());
            cc.Touch = Touch;
            function Acceleration$1() {
                var x = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, y = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, z = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, timestamp = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0;
                _classCallCheck(this, Acceleration$1), this.x = void 0, this.y = void 0, this.z = void 0, 
                this.timestamp = void 0, this.x = x, this.y = y, this.z = z, this.timestamp = timestamp;
            }
            var _didAccelerateFun, SystemEventType, TOUCH_TIMEOUT = macro.TOUCH_TIMEOUT, _vec2$1 = new Vec2(), _preLocation = new Vec2(), inputManager = new (function() {
                function InputManager() {
                    _classCallCheck(this, InputManager), this._mousePressed = !1, this._isRegisterEvent = !1, 
                    this._preTouchPoint = new Vec2(), this._prevMousePoint = new Vec2(), this._preTouchPool = [], 
                    this._preTouchPoolPointer = 0, this._touches = [], this._touchesIntegerDict = {}, 
                    this._indexBitsUsed = 0, this._maxTouches = 8, this._accelEnabled = !1, this._accelInterval = .2, 
                    this._accelMinus = 1, this._accelCurTime = 0, this._acceleration = null, this._accelDeviceEvent = null, 
                    this._glView = null, this._minus = 0, this._pointLocked = !1;
                }
                return _createClass(InputManager, [ {
                    key: "handleTouchesBegin",
                    value: function handleTouchesBegin(touches) {
                        for (var handleTouches = [], locTouchIntDict = this._touchesIntegerDict, now = sys.now(), i = 0; i < touches.length; ++i) {
                            var touch = touches[i], touchID = touch.getID();
                            if (null !== touchID) if (void 0 === locTouchIntDict[touchID]) {
                                var unusedIndex = this._getUnUsedIndex();
                                if (-1 === unusedIndex) {
                                    cc.logID(2300, unusedIndex);
                                    continue;
                                }
                                var curTouch = new Touch(touch._point.x, touch._point.y, touch.getID());
                                (this._touches[unusedIndex] = curTouch)._lastModified = now, curTouch._setPrevPoint(touch._prevPoint), 
                                locTouchIntDict[touchID] = unusedIndex, handleTouches.push(curTouch);
                            }
                        }
                        if (0 < handleTouches.length) {
                            var touchEvent = new EventTouch(handleTouches);
                            touchEvent._eventCode = EventTouch.BEGAN, eventManager.dispatchEvent(touchEvent);
                        }
                    }
                }, {
                    key: "handleTouchesMove",
                    value: function handleTouchesMove(touches) {
                        for (var handleTouches = [], locTouches = this._touches, now = sys.now(), i = 0; i < touches.length; ++i) {
                            var touch = touches[i], touchID = touch.getID();
                            if (null !== touchID) {
                                var _index2 = this._touchesIntegerDict[touchID];
                                void 0 !== _index2 && locTouches[_index2] && (locTouches[_index2]._setPoint(touch._point), 
                                locTouches[_index2]._setPrevPoint(touch._prevPoint), locTouches[_index2]._lastModified = now, 
                                handleTouches.push(locTouches[_index2]));
                            }
                        }
                        if (0 < handleTouches.length) {
                            var touchEvent = new EventTouch(handleTouches);
                            touchEvent._eventCode = EventTouch.MOVED, eventManager.dispatchEvent(touchEvent);
                        }
                    }
                }, {
                    key: "handleTouchesEnd",
                    value: function handleTouchesEnd(touches) {
                        var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
                        if (0 < handleTouches.length) {
                            var touchEvent = new EventTouch(handleTouches);
                            touchEvent._eventCode = EventTouch.ENDED, eventManager.dispatchEvent(touchEvent);
                        }
                        this._preTouchPool.length = 0;
                    }
                }, {
                    key: "handleTouchesCancel",
                    value: function handleTouchesCancel(touches) {
                        var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
                        if (0 < handleTouches.length) {
                            var touchEvent = new EventTouch(handleTouches);
                            touchEvent._eventCode = EventTouch.CANCELLED, eventManager.dispatchEvent(touchEvent);
                        }
                        this._preTouchPool.length = 0;
                    }
                }, {
                    key: "getSetOfTouchesEndOrCancel",
                    value: function getSetOfTouchesEndOrCancel(touches) {
                        for (var handleTouches = [], locTouches = this._touches, locTouchesIntDict = this._touchesIntegerDict, i = 0; i < touches.length; ++i) {
                            var touch = touches[i], touchID = touch.getID();
                            if (null !== touchID) {
                                var _index3 = locTouchesIntDict[touchID];
                                void 0 !== _index3 && locTouches[_index3] && (locTouches[_index3]._setPoint(touch._point), 
                                locTouches[_index3]._setPrevPoint(touch._prevPoint), handleTouches.push(locTouches[_index3]), 
                                this._removeUsedIndexBit(_index3), delete locTouchesIntDict[touchID]);
                            }
                        }
                        return handleTouches;
                    }
                }, {
                    key: "getHTMLElementPosition",
                    value: function getHTMLElementPosition(element) {
                        if (sys.platform === sys.WECHAT_GAME) return {
                            left: 0,
                            top: 0,
                            width: window.innerWidth,
                            height: window.innerHeight
                        };
                        var docElem = document.documentElement, leftOffset = window.pageXOffset - docElem.clientLeft, topOffset = window.pageYOffset - docElem.clientTop;
                        if (element.getBoundingClientRect) {
                            var box = element.getBoundingClientRect();
                            return {
                                left: box.left + leftOffset,
                                top: box.top + topOffset,
                                width: box.width,
                                height: box.height
                            };
                        }
                        return element instanceof HTMLCanvasElement ? {
                            left: leftOffset,
                            top: topOffset,
                            width: element.width,
                            height: element.height
                        } : {
                            left: leftOffset,
                            top: topOffset,
                            width: parseInt(element.style.width || "0", void 0),
                            height: parseInt(element.style.height || "0", void 0)
                        };
                    }
                }, {
                    key: "getPreTouch",
                    value: function getPreTouch(touch) {
                        for (var preTouch = null, locPreTouchPool = this._preTouchPool, id = touch.getID(), i = locPreTouchPool.length - 1; 0 <= i; i--) if (locPreTouchPool[i].getID() === id) {
                            preTouch = locPreTouchPool[i];
                            break;
                        }
                        return preTouch = preTouch || touch;
                    }
                }, {
                    key: "setPreTouch",
                    value: function setPreTouch(touch) {
                        for (var find = !1, locPreTouchPool = this._preTouchPool, id = touch.getID(), i = locPreTouchPool.length - 1; 0 <= i; i--) if (locPreTouchPool[i].getID() === id) {
                            locPreTouchPool[i] = touch, find = !0;
                            break;
                        }
                        find || (locPreTouchPool.length <= 50 ? locPreTouchPool.push(touch) : (locPreTouchPool[this._preTouchPoolPointer] = touch, 
                        this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50));
                    }
                }, {
                    key: "getTouchByXY",
                    value: function getTouchByXY(event, tx, ty, pos) {
                        var locPreTouch = this._preTouchPoint, location = this._glView.convertToLocationInView(tx, ty, pos);
                        this._pointLocked && (location.x = locPreTouch.x + event.movementX, location.y = locPreTouch.y - event.movementY);
                        var touch = new Touch(location.x, location.y, 0);
                        return touch._setPrevPoint(locPreTouch.x, locPreTouch.y), locPreTouch.x = location.x, 
                        locPreTouch.y = location.y, touch;
                    }
                }, {
                    key: "getMouseEvent",
                    value: function getMouseEvent(location, pos, eventType) {
                        var locPreMouse = this._prevMousePoint, mouseEvent = new EventMouse(eventType);
                        return mouseEvent._setPrevCursor(locPreMouse.x, locPreMouse.y), locPreMouse.x = location.x, 
                        locPreMouse.y = location.y, this._glView._convertMouseToLocation(locPreMouse, pos), 
                        mouseEvent.setLocation(locPreMouse.x, locPreMouse.y), mouseEvent;
                    }
                }, {
                    key: "getPointByEvent",
                    value: function getPointByEvent(event, pos) {
                        return null != event.pageX ? {
                            x: event.pageX,
                            y: event.pageY
                        } : (sys.platform === sys.WECHAT_GAME ? (pos.left = 0, pos.top = 0) : (pos.left -= document.body.scrollLeft, 
                        pos.top -= document.body.scrollTop), {
                            x: event.clientX,
                            y: event.clientY
                        });
                    }
                }, {
                    key: "getTouchesByEvent",
                    value: function getTouchesByEvent(event, position) {
                        for (var touches = [], locView = this._glView, locPreTouch = this._preTouchPoint, length = event.changedTouches.length, i = 0; i < length; i++) {
                            var changedTouch = event.changedTouches[i];
                            if (changedTouch) {
                                var _location = void 0;
                                _location = sys.BROWSER_TYPE_FIREFOX === sys.browserType ? locView.convertToLocationInView(changedTouch.pageX, changedTouch.pageY, position, _vec2$1) : locView.convertToLocationInView(changedTouch.clientX, changedTouch.clientY, position, _vec2$1);
                                var touch = void 0;
                                null != changedTouch.identifier ? (touch = new Touch(_location.x, _location.y, changedTouch.identifier), 
                                this.getPreTouch(touch).getLocation(_preLocation), touch._setPrevPoint(_preLocation.x, _preLocation.y), 
                                this.setPreTouch(touch)) : (touch = new Touch(_location.x, _location.y))._setPrevPoint(locPreTouch.x, locPreTouch.y), 
                                locPreTouch.x = _location.x, locPreTouch.y = _location.y, touches.push(touch);
                            }
                        }
                        return touches;
                    }
                }, {
                    key: "registerSystemEvent",
                    value: function registerSystemEvent(element) {
                        if (!this._isRegisterEvent && element) {
                            this._glView = cc.view;
                            var prohibition = sys.isMobile, supportMouse = "mouse" in sys.capabilities, supportTouches = "touches" in sys.capabilities;
                            sys.platform === sys.WECHAT_GAME && (supportMouse = !(supportTouches = !(prohibition = !1))), 
                            supportMouse && this._registerMouseEvents(element, prohibition), window.navigator.msPointerEnabled && this._registerMousePointerEvents(element), 
                            supportTouches && this._registerTouchEvents(element), cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB && this._registerKeyboardEvent(), 
                            this._isRegisterEvent = !0;
                        }
                    }
                }, {
                    key: "setAccelerometerEnabled",
                    value: function setAccelerometerEnabled(isEnable) {
                        if (this._accelEnabled !== isEnable) {
                            this._accelEnabled = isEnable;
                            var scheduler = cc.director.getScheduler();
                            scheduler.enableForTarget(this), this._accelEnabled ? (this._registerAccelerometerEvent(), 
                            this._accelCurTime = 0, scheduler.scheduleUpdate(this)) : (this._unregisterAccelerometerEvent(), 
                            this._accelCurTime = 0, scheduler.unscheduleUpdate(this));
                        }
                    }
                }, {
                    key: "didAccelerate",
                    value: function didAccelerate(eventData) {
                        if (this._accelEnabled) {
                            var mAcceleration = this._acceleration, x = 0, y = 0, z = 0;
                            if (this._accelDeviceEvent === window.DeviceMotionEvent) {
                                var eventAcceleration = eventData.accelerationIncludingGravity;
                                eventAcceleration && (x = this._accelMinus * (eventAcceleration.x || 0) * .1, y = this._accelMinus * (eventAcceleration.y || 0) * .1, 
                                z = .1 * (eventAcceleration.z || 0));
                            } else {
                                var deviceOrientationEvent = eventData;
                                x = (deviceOrientationEvent.gamma || 0) / 90 * .981, y = -(deviceOrientationEvent.beta || 0) / 90 * .981, 
                                z = (deviceOrientationEvent.alpha || 0) / 90 * .981;
                            }
                            if (cc.view._isRotated) {
                                var tmp = x;
                                x = -y, y = tmp;
                            }
                            mAcceleration.x = x, mAcceleration.y = y, mAcceleration.z = z, mAcceleration.timestamp = eventData.timeStamp || Date.now();
                            var tmpX = mAcceleration.x;
                            90 === window.orientation ? (mAcceleration.x = -mAcceleration.y, mAcceleration.y = tmpX) : -90 === window.orientation ? (mAcceleration.x = mAcceleration.y, 
                            mAcceleration.y = -tmpX) : 180 === window.orientation && (mAcceleration.x = -mAcceleration.x, 
                            mAcceleration.y = -mAcceleration.y), cc.sys.os === cc.sys.OS_ANDROID && cc.sys.browserType !== cc.sys.BROWSER_TYPE_MOBILE_QQ && (mAcceleration.x = -mAcceleration.x, 
                            mAcceleration.y = -mAcceleration.y);
                        }
                    }
                }, {
                    key: "update",
                    value: function update(dt) {
                        this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval, 
                        eventManager.dispatchEvent(new EventAcceleration(this._acceleration))), this._accelCurTime += dt;
                    }
                }, {
                    key: "setAccelerometerInterval",
                    value: function setAccelerometerInterval(interval) {
                        this._accelInterval !== interval && (this._accelInterval = interval);
                    }
                }, {
                    key: "_getUnUsedIndex",
                    value: function _getUnUsedIndex() {
                        for (var temp = this._indexBitsUsed, now = cc.sys.now(), i = 0; i < this._maxTouches; i++) {
                            if (!(1 & temp)) return this._indexBitsUsed |= 1 << i, i;
                            var touch = this._touches[i];
                            if (now - touch._lastModified > TOUCH_TIMEOUT) {
                                this._removeUsedIndexBit(i);
                                var touchID = touch.getID();
                                return null !== touchID && delete this._touchesIntegerDict[touchID], i;
                            }
                            temp >>= 1;
                        }
                        return -1;
                    }
                }, {
                    key: "_removeUsedIndexBit",
                    value: function _removeUsedIndexBit(index) {
                        if (!(index < 0 || index >= this._maxTouches)) {
                            var temp = 1 << index;
                            temp = ~temp, this._indexBitsUsed &= temp;
                        }
                    }
                }, {
                    key: "_registerMouseEvents",
                    value: function _registerMouseEvents(element, prohibition) {
                        this._registerPointerLockEvent(), prohibition || this._registerWindowMouseEvents(element), 
                        this._registerElementMouseEvents(element, prohibition);
                    }
                }, {
                    key: "_registerPointerLockEvent",
                    value: function _registerPointerLockEvent() {
                        function lockChangeAlert() {
                            var canvas = cc.game.canvas;
                            document.pointerLockElement === canvas || document.mozPointerLockElement === canvas ? _this._pointLocked = !0 : _this._pointLocked = !1;
                        }
                        var _this = this;
                        "onpointerlockchange" in document ? document.addEventListener("pointerlockchange", lockChangeAlert, !1) : "onmozpointerlockchange" in document && document.addEventListener("mozpointerlockchange", lockChangeAlert, !1);
                    }
                }, {
                    key: "_registerWindowMouseEvents",
                    value: function _registerWindowMouseEvents(element) {
                        var _this2 = this;
                        window.addEventListener("mousedown", function() {
                            _this2._mousePressed = !0;
                        }, !1), window.addEventListener("mouseup", function(event) {
                            if (_this2._mousePressed) {
                                _this2._mousePressed = !1;
                                var position = _this2.getHTMLElementPosition(element), location = _this2.getPointByEvent(event, position);
                                if (!rect(position.left, position.top, position.width, position.height).contains(new Vec2(location.x, location.y))) {
                                    _this2.handleTouchesEnd([ _this2.getTouchByXY(event, location.x, location.y, position) ]);
                                    var _mouseEvent = _this2.getMouseEvent(location, position, EventMouse.UP);
                                    _mouseEvent.setButton(event.button), eventManager.dispatchEvent(_mouseEvent);
                                }
                            }
                        }, !1);
                    }
                }, {
                    key: "_registerElementMouseEvents",
                    value: function _registerElementMouseEvents(element, prohibition) {
                        function listenDOMMouseEvent(eventName, type, handler) {
                            element.addEventListener(eventName, function(event) {
                                var pos = _this3.getHTMLElementPosition(element), location = _this3.getPointByEvent(event, pos), mouseEvent = _this3.getMouseEvent(location, pos, type);
                                mouseEvent.setButton(event.button), handler(event, mouseEvent, location, pos), eventManager.dispatchEvent(mouseEvent), 
                                event.stopPropagation(), event.preventDefault();
                            });
                        }
                        var _this3 = this;
                        prohibition || (listenDOMMouseEvent("mousedown", EventMouse.DOWN, function(event, mouseEvent, location, pos) {
                            _this3._mousePressed = !0, _this3.handleTouchesBegin([ _this3.getTouchByXY(event, location.x, location.y, pos) ]), 
                            element.focus();
                        }), listenDOMMouseEvent("mouseup", EventMouse.UP, function(event, mouseEvent, location, pos) {
                            _this3._mousePressed = !1, _this3.handleTouchesEnd([ _this3.getTouchByXY(event, location.x, location.y, pos) ]);
                        }), listenDOMMouseEvent("mousemove", EventMouse.MOVE, function(event, mouseEvent, location, pos) {
                            _this3.handleTouchesMove([ _this3.getTouchByXY(event, location.x, location.y, pos) ]), 
                            _this3._mousePressed || mouseEvent.setButton(null), void 0 !== event.movementX && void 0 !== event.movementY && (mouseEvent.movementX = event.movementX, 
                            mouseEvent.movementY = event.movementY);
                        })), listenDOMMouseEvent("mousewheel", EventMouse.SCROLL, function(event, mouseEvent, location, pos) {
                            mouseEvent.setScrollData(0, event.wheelDelta);
                        }), listenDOMMouseEvent("DOMMouseScroll", EventMouse.SCROLL, function(event, mouseEvent, location, pos) {
                            mouseEvent.setScrollData(0, -120 * event.detail);
                        });
                    }
                }, {
                    key: "_registerMousePointerEvents",
                    value: function _registerMousePointerEvents(element) {
                        function _loop(eventName) {
                            var touchEvent = _pointerEventsMap[eventName];
                            element.addEventListener(eventName, function(event) {
                                var pos = _this4.getHTMLElementPosition(element);
                                pos.left -= document.documentElement.scrollLeft, pos.top -= document.documentElement.scrollTop, 
                                touchEvent.call(_this4, [ _this4.getTouchByXY(event, event.clientX, event.clientY, pos) ]), 
                                event.stopPropagation();
                            }, !1);
                        }
                        var _this4 = this, _pointerEventsMap = {
                            MSPointerDown: this.handleTouchesBegin,
                            MSPointerMove: this.handleTouchesMove,
                            MSPointerUp: this.handleTouchesEnd,
                            MSPointerCancel: this.handleTouchesCancel
                        };
                        for (var eventName in _pointerEventsMap) _loop(eventName);
                    }
                }, {
                    key: "_registerTouchEvents",
                    value: function _registerTouchEvents(element) {
                        cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB ? this._registerWXGameTouchEvents(element) : this._registerHTMLTouchEvents(element);
                    }
                }, {
                    key: "_registerWXGameTouchEvents",
                    value: function _registerWXGameTouchEvents(element) {
                        function makeTouchListener(touchesHandler) {
                            return function(event) {
                                var pos = _this5.getHTMLElementPosition(element), body = document.body;
                                pos.left -= body.scrollLeft || 0, pos.top -= body.scrollTop || 0, touchesHandler(_this5.getTouchesByEvent(event, pos));
                            };
                        }
                        var _this5 = this;
                        wx.onTouchStart(makeTouchListener(function(touchesToHandle) {
                            _this5.handleTouchesBegin(touchesToHandle);
                        })), wx.onTouchEnd(makeTouchListener(function(touchesToHandle) {
                            _this5.handleTouchesEnd(touchesToHandle);
                        })), wx.onTouchMove(makeTouchListener(function(touchesToHandle) {
                            _this5.handleTouchesMove(touchesToHandle);
                        })), wx.onTouchCancel(makeTouchListener(function(touchesToHandle) {
                            _this5.handleTouchesCancel(touchesToHandle);
                        }));
                    }
                }, {
                    key: "_registerHTMLTouchEvents",
                    value: function _registerHTMLTouchEvents(element) {
                        function makeTouchListener(touchesHandler) {
                            return function(event) {
                                if (event.changedTouches) {
                                    var pos = _this6.getHTMLElementPosition(element), body = document.body;
                                    pos.left -= body.scrollLeft || 0, pos.top -= body.scrollTop || 0, touchesHandler(_this6.getTouchesByEvent(event, pos)), 
                                    event.stopPropagation(), event.preventDefault();
                                }
                            };
                        }
                        var _this6 = this;
                        element.addEventListener("touchstart", makeTouchListener(function(touchesToHandle) {
                            _this6.handleTouchesBegin(touchesToHandle), sys.platform !== sys.WECHAT_GAME && element.focus();
                        }), !1), element.addEventListener("touchmove", makeTouchListener(function(touchesToHandle) {
                            _this6.handleTouchesMove(touchesToHandle);
                        }), !1), element.addEventListener("touchend", makeTouchListener(function(touchesToHandle) {
                            _this6.handleTouchesEnd(touchesToHandle);
                        }), !1), element.addEventListener("touchcancel", makeTouchListener(function(touchesToHandle) {
                            _this6.handleTouchesCancel(touchesToHandle);
                        }), !1);
                    }
                }, {
                    key: "_registerKeyboardEvent",
                    value: function _registerKeyboardEvent() {
                        var canvas = cc.game.canvas;
                        canvas.addEventListener("keydown", function(event) {
                            eventManager.dispatchEvent(new EventKeyboard(event, !0)), event.stopPropagation(), 
                            event.preventDefault();
                        }, !1), canvas.addEventListener("keyup", function(event) {
                            eventManager.dispatchEvent(new EventKeyboard(event, !1)), event.stopPropagation(), 
                            event.preventDefault();
                        }, !1);
                    }
                }, {
                    key: "_registerAccelerometerEvent",
                    value: function _registerAccelerometerEvent() {
                        var _this7 = this;
                        this._acceleration = new Acceleration$1(), this._accelDeviceEvent = window.DeviceMotionEvent || window.DeviceOrientationEvent, 
                        cc.sys.browserType === cc.sys.BROWSER_TYPE_MOBILE_QQ && (this._accelDeviceEvent = window.DeviceOrientationEvent);
                        var _deviceEventType = this._accelDeviceEvent === window.DeviceMotionEvent ? "devicemotion" : "deviceorientation", ua = navigator.userAgent;
                        (/Android/.test(ua) || /Adr/.test(ua) && cc.sys.browserType === cc.BROWSER_TYPE_UC) && (this._minus = -1), 
                        _didAccelerateFun = function _didAccelerateFun() {
                            return _this7.didAccelerate.apply(_this7, arguments);
                        }, window.addEventListener(_deviceEventType, _didAccelerateFun, !1);
                    }
                }, {
                    key: "_unregisterAccelerometerEvent",
                    value: function _unregisterAccelerometerEvent() {
                        var _deviceEventType = this._accelDeviceEvent === window.DeviceMotionEvent ? "devicemotion" : "deviceorientation";
                        _didAccelerateFun && window.removeEventListener(_deviceEventType, _didAccelerateFun, !1);
                    }
                } ]), InputManager;
            }())();
            game.on(Game.EVENT_ENGINE_INITED, function() {
                game.config.registerSystemEvent && inputManager.registerSystemEvent(game.canvas);
            }), cc.internal.inputManager = inputManager, function(SystemEventType) {
                SystemEventType.TOUCH_START = "touch-start", SystemEventType.TOUCH_MOVE = "touch-move", 
                SystemEventType.TOUCH_END = "touch-end", SystemEventType.TOUCH_CANCEL = "touch-cancel", 
                SystemEventType.MOUSE_DOWN = "mouse-down", SystemEventType.MOUSE_MOVE = "mouse-move", 
                SystemEventType.MOUSE_UP = "mouse-up", SystemEventType.MOUSE_WHEEL = "mouse-wheel", 
                SystemEventType.MOUSE_ENTER = "mouse-enter", SystemEventType.MOUSE_LEAVE = "mouse-leave", 
                SystemEventType.KEY_DOWN = "keydown", SystemEventType.KEY_UP = "keyup", SystemEventType.DEVICEMOTION = "devicemotion", 
                SystemEventType.TRANSFORM_CHANGED = "transform-changed", SystemEventType.POSITION_PART = "position-part", 
                SystemEventType.ROTATION_PART = "rotation-part", SystemEventType.SCALE_PART = "scale-part", 
                SystemEventType.SCENE_CHANGED_FOR_PERSISTS = "scene-changed-for-persists", SystemEventType.SIZE_CHANGED = "size-changed", 
                SystemEventType.ANCHOR_CHANGED = "anchor-changed", SystemEventType.CHILD_ADDED = "child-added", 
                SystemEventType.CHILD_REMOVED = "child-removed", SystemEventType.PARENT_CHANGED = "parent-changed";
            }(SystemEventType = SystemEventType || exports("SystemEventType", {})), ccenum(SystemEventType), 
            cc.SystemEventType = SystemEventType;
            var keyboardListener = null, accelerationListener = null, touchListener = null, mouseListener = null, SystemEvent = exports("SystemEvent", function() {
                function SystemEvent() {
                    return _classCallCheck(this, SystemEvent), _possibleConstructorReturn(this, _getPrototypeOf(SystemEvent).call(this));
                }
                return _inherits(SystemEvent, EventTarget), _createClass(SystemEvent, [ {
                    key: "setAccelerometerEnabled",
                    value: function setAccelerometerEnabled(isEnable) {
                        inputManager.setAccelerometerEnabled(isEnable);
                    }
                }, {
                    key: "setAccelerometerInterval",
                    value: function setAccelerometerInterval(interval) {
                        inputManager.setAccelerometerInterval(interval);
                    }
                }, {
                    key: "on",
                    value: function on(type, callback, target) {
                        return _get(_getPrototypeOf(SystemEvent.prototype), "on", this).call(this, type, callback, target), 
                        type !== SystemEventType.KEY_DOWN && type !== SystemEventType.KEY_UP || keyboardListener || (keyboardListener = EventListener.create({
                            event: EventListener.KEYBOARD,
                            onKeyPressed: function onKeyPressed(keyCode, event) {
                                event.type = SystemEventType.KEY_DOWN, systemEvent.emit(event.type, event);
                            },
                            onKeyReleased: function onKeyReleased(keyCode, event) {
                                event.type = SystemEventType.KEY_UP, systemEvent.emit(event.type, event);
                            }
                        }), eventManager.addListener(keyboardListener, 256)), type === SystemEventType.DEVICEMOTION && (accelerationListener || (accelerationListener = EventListener.create({
                            event: EventListener.ACCELERATION,
                            callback: function callback(acc, event) {
                                event.type = SystemEventType.DEVICEMOTION, cc.systemEvent.emit(event.type, event);
                            }
                        }), eventManager.addListener(accelerationListener, 256))), type !== SystemEventType.TOUCH_START && type !== SystemEventType.TOUCH_MOVE && type !== SystemEventType.TOUCH_END && type !== SystemEventType.TOUCH_CANCEL || touchListener || (touchListener = EventListener.create({
                            event: EventListener.TOUCH_ONE_BY_ONE,
                            onTouchBegan: function onTouchBegan(touch, event) {
                                return event.type = SystemEventType.TOUCH_START, cc.systemEvent.emit(event.type, touch, event), 
                                !0;
                            },
                            onTouchMoved: function onTouchMoved(touch, event) {
                                event.type = SystemEventType.TOUCH_MOVE, cc.systemEvent.emit(event.type, touch, event);
                            },
                            onTouchEnded: function onTouchEnded(touch, event) {
                                event.type = SystemEventType.TOUCH_END, cc.systemEvent.emit(event.type, touch, event);
                            },
                            onTouchCancelled: function onTouchCancelled(touch, event) {
                                event.type = SystemEventType.TOUCH_CANCEL, cc.systemEvent.emit(event.type, touch, event);
                            }
                        }), eventManager.addListener(touchListener, 256)), type !== SystemEventType.MOUSE_DOWN && type !== SystemEventType.MOUSE_MOVE && type !== SystemEventType.MOUSE_UP && type !== SystemEventType.MOUSE_WHEEL || mouseListener || (mouseListener = EventListener.create({
                            event: EventListener.MOUSE,
                            onMouseDown: function onMouseDown(event) {
                                event.type = SystemEventType.MOUSE_DOWN, cc.systemEvent.emit(event.type, event);
                            },
                            onMouseMove: function onMouseMove(event) {
                                event.type = SystemEventType.MOUSE_MOVE, cc.systemEvent.emit(event.type, event);
                            },
                            onMouseUp: function onMouseUp(event) {
                                event.type = SystemEventType.MOUSE_UP, cc.systemEvent.emit(event.type, event);
                            },
                            onMouseScroll: function onMouseScroll(event) {
                                event.type = SystemEventType.MOUSE_WHEEL, cc.systemEvent.emit(event.type, event);
                            }
                        }), eventManager.addListener(mouseListener, 256)), callback;
                    }
                }, {
                    key: "off",
                    value: function off(type, callback, target) {
                        if (_get(_getPrototypeOf(SystemEvent.prototype), "off", this).call(this, type, callback, target), 
                        keyboardListener && (type === SystemEventType.KEY_DOWN || type === SystemEventType.KEY_UP)) {
                            var hasKeyDownEventListener = this.hasEventListener(SystemEventType.KEY_DOWN), hasKeyUpEventListener = this.hasEventListener(SystemEventType.KEY_UP);
                            hasKeyDownEventListener || hasKeyUpEventListener || (eventManager.removeListener(keyboardListener), 
                            keyboardListener = null);
                        }
                        if (accelerationListener && type === SystemEventType.DEVICEMOTION && (eventManager.removeListener(accelerationListener), 
                        accelerationListener = null), touchListener && (type === SystemEventType.TOUCH_START || type === SystemEventType.TOUCH_MOVE || type === SystemEventType.TOUCH_END || type === SystemEventType.TOUCH_CANCEL)) {
                            var hasTouchStart = this.hasEventListener(SystemEventType.TOUCH_START), hasTouchMove = this.hasEventListener(SystemEventType.TOUCH_MOVE), hasTouchEnd = this.hasEventListener(SystemEventType.TOUCH_END), hasTouchCancel = this.hasEventListener(SystemEventType.TOUCH_CANCEL);
                            hasTouchStart || hasTouchMove || hasTouchEnd || hasTouchCancel || (eventManager.removeListener(touchListener), 
                            touchListener = null);
                        }
                        if (mouseListener && (type === SystemEventType.MOUSE_DOWN || type === SystemEventType.MOUSE_MOVE || type === SystemEventType.MOUSE_UP || type === SystemEventType.MOUSE_WHEEL)) {
                            var hasMouseDown = this.hasEventListener(SystemEventType.MOUSE_DOWN), hasMouseMove = this.hasEventListener(SystemEventType.MOUSE_MOVE), hasMouseUp = this.hasEventListener(SystemEventType.MOUSE_UP), hasMouseWheel = this.hasEventListener(SystemEventType.MOUSE_WHEEL);
                            hasMouseDown || hasMouseMove || hasMouseUp || hasMouseWheel || (eventManager.removeListener(mouseListener), 
                            mouseListener = null);
                        }
                    }
                } ]), SystemEvent;
            }());
            SystemEvent.EventType = SystemEventType, cc.SystemEvent = SystemEvent;
            var systemEvent = exports("systemEvent", new SystemEvent());
            cc.systemEvent = systemEvent;
            var screen$1 = exports("screen", {
                _supportsFullScreen: !1,
                _preOnFullScreenChange: null,
                _touchEvent: "",
                _fn: null,
                _fnMap: [ [ "requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement" ], [ "requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement" ], [ "webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement" ], [ "mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement" ], [ "msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement" ] ],
                init: function init() {
                    this._fn = {};
                    var i, l, val, valL, map = this._fnMap;
                    for (i = 0, l = map.length; i < l; i++) if ((val = map[i]) && void 0 !== document[val[1]]) {
                        for (i = 0, valL = val.length; i < valL; i++) this._fn[map[0][i]] = val[i];
                        break;
                    }
                    this._supportsFullScreen = void 0 !== this._fn.requestFullscreen, this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown";
                },
                fullScreen: function fullScreen() {
                    return !!this._supportsFullScreen && (void 0 !== document[this._fn.fullscreenElement] && null !== document[this._fn.fullscreenElement]);
                },
                requestFullScreen: function requestFullScreen(element, onFullScreenChange) {
                    if (this._supportsFullScreen) {
                        if (element = element || document.documentElement, onFullScreenChange) {
                            var eventName = this._fn.fullscreenchange;
                            this._preOnFullScreenChange && document.removeEventListener(eventName, this._preOnFullScreenChange), 
                            this._preOnFullScreenChange = onFullScreenChange, document.addEventListener(eventName, onFullScreenChange, !1);
                        }
                        return element[this._fn.requestFullscreen]();
                    }
                },
                exitFullScreen: function exitFullScreen() {
                    return !this._supportsFullScreen || document[this._fn.exitFullscreen]();
                },
                autoFullScreen: function autoFullScreen(element, onFullScreenChange) {
                    element = element || document.body;
                    var touchTarget = cc.game.canvas || element, theScreen = this;
                    this.requestFullScreen(element, onFullScreenChange), touchTarget.addEventListener(this._touchEvent, function callback() {
                        touchTarget.removeEventListener(theScreen._touchEvent, callback), theScreen.requestFullScreen(element, onFullScreenChange);
                    });
                }
            });
            screen$1.init(), cc.screen = screen$1;
            function ListEntry(target, priority, paused, markedForDeletion) {
                _classCallCheck(this, ListEntry), this.target = void 0, this.priority = void 0, 
                this.paused = void 0, this.markedForDeletion = void 0, this.target = target, this.priority = priority, 
                this.paused = paused, this.markedForDeletion = markedForDeletion;
            }
            var System = exports("System", function() {
                function System() {
                    _classCallCheck(this, System), this._id = "", this._priority = 0, this._executeInEditMode = !1;
                }
                return _createClass(System, [ {
                    key: "init",
                    value: function init() {}
                }, {
                    key: "update",
                    value: function update() {}
                }, {
                    key: "postUpdate",
                    value: function postUpdate() {}
                }, {
                    key: "priority",
                    set: function set(value) {
                        this._priority = value;
                    },
                    get: function get() {
                        return this._priority;
                    }
                }, {
                    key: "id",
                    set: function set(id) {
                        this._id = id;
                    },
                    get: function get() {
                        return this._id;
                    }
                } ], [ {
                    key: "sortByPriority",
                    value: function sortByPriority(a, b) {
                        return a._priority < b._priority ? 1 : a._priority > b.priority ? -1 : 0;
                    }
                } ]), System;
            }()), idGenerator$1 = new IDGenerator("Scheduler");
            ListEntry.get = function(target, priority, paused, markedForDeletion) {
                var result = ListEntry._listEntries.pop();
                return result ? (result.target = target, result.priority = priority, result.paused = paused, 
                result.markedForDeletion = markedForDeletion) : result = new ListEntry(target, priority, paused, markedForDeletion), 
                result;
            }, ListEntry.put = function(entry) {
                ListEntry._listEntries.length < 20 && (entry.target = null, ListEntry._listEntries.push(entry));
            }, ListEntry._listEntries = [];
            function HashUpdateEntry(list, entry, target, callback) {
                _classCallCheck(this, HashUpdateEntry), this.list = void 0, this.entry = void 0, 
                this.target = void 0, this.callback = void 0, this.list = list, this.entry = entry, 
                this.target = target, this.callback = callback;
            }
            HashUpdateEntry.get = function(list, entry, target, callback) {
                var result = HashUpdateEntry._hashUpdateEntries.pop();
                return result ? (result.list = list, result.entry = entry, result.target = target, 
                result.callback = callback) : result = new HashUpdateEntry(list, entry, target, callback), 
                result;
            }, HashUpdateEntry.put = function(entry) {
                HashUpdateEntry._hashUpdateEntries.length < 20 && (entry.list = entry.entry = entry.target = entry.callback = null, 
                HashUpdateEntry._hashUpdateEntries.push(entry));
            }, HashUpdateEntry._hashUpdateEntries = [];
            function HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
                _classCallCheck(this, HashTimerEntry), this.timers = void 0, this.target = void 0, 
                this.timerIndex = void 0, this.currentTimer = void 0, this.currentTimerSalvaged = void 0, 
                this.paused = void 0, this.timers = timers, this.target = target, this.timerIndex = timerIndex, 
                this.currentTimer = currentTimer, this.currentTimerSalvaged = currentTimerSalvaged, 
                this.paused = paused;
            }
            HashTimerEntry.get = function(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
                var result = HashTimerEntry._hashTimerEntries.pop();
                return result ? (result.timers = timers, result.target = target, result.timerIndex = timerIndex, 
                result.currentTimer = currentTimer, result.currentTimerSalvaged = currentTimerSalvaged, 
                result.paused = paused) : result = new HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused), 
                result;
            }, HashTimerEntry.put = function(entry) {
                HashTimerEntry._hashTimerEntries.length < 20 && (entry.timers = entry.target = entry.currentTimer = null, 
                HashTimerEntry._hashTimerEntries.push(entry));
            }, HashTimerEntry._hashTimerEntries = [];
            var CallbackTimer = function() {
                function CallbackTimer() {
                    _classCallCheck(this, CallbackTimer), this._lock = void 0, this._scheduler = void 0, 
                    this._elapsed = void 0, this._runForever = void 0, this._useDelay = void 0, this._timesExecuted = void 0, 
                    this._repeat = void 0, this._delay = void 0, this._interval = void 0, this._target = void 0, 
                    this._callback = void 0, this._lock = !1, this._scheduler = null, this._elapsed = -1, 
                    this._runForever = !1, this._useDelay = !1, this._timesExecuted = 0, this._repeat = 0, 
                    this._delay = 0, this._interval = 0, this._target = null, this._callback = null;
                }
                return _createClass(CallbackTimer, [ {
                    key: "initWithCallback",
                    value: function initWithCallback(scheduler, callback, target, seconds, repeat, delay) {
                        return this._lock = !1, this._scheduler = scheduler, this._target = target, this._callback = callback, 
                        this._elapsed = -1, this._interval = seconds, this._delay = delay, this._useDelay = 0 < this._delay, 
                        this._repeat = repeat, this._runForever = this._repeat === cc.macro.REPEAT_FOREVER, 
                        !0;
                    }
                }, {
                    key: "getInterval",
                    value: function getInterval() {
                        return this._interval;
                    }
                }, {
                    key: "setInterval",
                    value: function setInterval(interval) {
                        this._interval = interval;
                    }
                }, {
                    key: "update",
                    value: function update(dt) {
                        -1 === this._elapsed ? (this._elapsed = 0, this._timesExecuted = 0) : (this._elapsed += dt, 
                        this._runForever && !this._useDelay ? this._elapsed >= this._interval && (this.trigger(), 
                        this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (this.trigger(), 
                        this._elapsed -= this._delay, this._timesExecuted += 1, this._useDelay = !1) : this._elapsed >= this._interval && (this.trigger(), 
                        this._elapsed = 0, this._timesExecuted += 1), this._callback && !this._runForever && this._timesExecuted > this._repeat && this.cancel()));
                    }
                }, {
                    key: "getCallback",
                    value: function getCallback() {
                        return this._callback;
                    }
                }, {
                    key: "trigger",
                    value: function trigger() {
                        this._target && this._callback && (this._lock = !0, this._callback.call(this._target, this._elapsed), 
                        this._lock = !1);
                    }
                }, {
                    key: "cancel",
                    value: function cancel() {
                        this._scheduler.unschedule(this._callback, this._target);
                    }
                } ]), CallbackTimer;
            }();
            CallbackTimer._timers = [], CallbackTimer.get = function() {
                return CallbackTimer._timers.pop() || new CallbackTimer();
            }, CallbackTimer.put = function(timer) {
                CallbackTimer._timers.length < 20 && !timer._lock && (timer._scheduler = timer._target = timer._callback = null, 
                CallbackTimer._timers.push(timer));
            };
            var LightType, Scheduler = exports("Scheduler", function() {
                function Scheduler() {
                    var _this;
                    return _classCallCheck(this, Scheduler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Scheduler).call(this)))._timeScale = void 0, 
                    _this._updatesNegList = void 0, _this._updates0List = void 0, _this._updatesPosList = void 0, 
                    _this._hashForUpdates = void 0, _this._hashForTimers = void 0, _this._currentTarget = void 0, 
                    _this._currentTargetSalvaged = void 0, _this._updateHashLocked = void 0, _this._arrayForTimers = void 0, 
                    _this._timeScale = 1, _this._updatesNegList = [], _this._updates0List = [], _this._updatesPosList = [], 
                    _this._hashForUpdates = createMap(!0), _this._hashForTimers = createMap(!0), _this._currentTarget = null, 
                    _this._currentTargetSalvaged = !1, _this._updateHashLocked = !1, _this._arrayForTimers = [], 
                    _this;
                }
                return _inherits(Scheduler, System), _createClass(Scheduler, null, [ {
                    key: "enableForTarget",
                    value: function enableForTarget(target) {
                        var found = !1;
                        target.uuid ? found = !0 : target.id && (found = !0), found || (target.__instanceId ? cc.warnID(1513) : target.id = idGenerator$1.getNewId());
                    }
                } ]), _createClass(Scheduler, [ {
                    key: "setTimeScale",
                    value: function setTimeScale(timeScale) {
                        this._timeScale = timeScale;
                    }
                }, {
                    key: "getTimeScale",
                    value: function getTimeScale() {
                        return this._timeScale;
                    }
                }, {
                    key: "update",
                    value: function update(dt) {
                        var i, list, len, entry, elt;
                        for (this._updateHashLocked = !0, 1 !== this._timeScale && (dt *= this._timeScale), 
                        i = 0, len = (list = this._updatesNegList).length; i < len; i++) (entry = list[i]).paused || entry.markedForDeletion || entry.target.update(dt);
                        for (i = 0, len = (list = this._updates0List).length; i < len; i++) (entry = list[i]).paused || entry.markedForDeletion || entry.target.update(dt);
                        for (i = 0, len = (list = this._updatesPosList).length; i < len; i++) (entry = list[i]).paused || entry.markedForDeletion || entry.target.update(dt);
                        var arr = this._arrayForTimers;
                        for (i = 0; i < arr.length; i++) {
                            if (elt = arr[i], this._currentTarget = elt, this._currentTargetSalvaged = !1, !elt.paused) for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) elt.currentTimer = elt.timers[elt.timerIndex], 
                            elt.currentTimerSalvaged = !1, elt.currentTimer.update(dt), elt.currentTimer = null;
                            this._currentTargetSalvaged && 0 === this._currentTarget.timers.length && (this._removeHashElement(this._currentTarget), 
                            --i);
                        }
                        for (i = 0, list = this._updatesNegList; i < list.length; ) (entry = list[i]).markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
                        for (i = 0, list = this._updates0List; i < list.length; ) (entry = list[i]).markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
                        for (i = 0, list = this._updatesPosList; i < list.length; ) (entry = list[i]).markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
                        this._updateHashLocked = !1, this._currentTarget = null;
                    }
                }, {
                    key: "schedule",
                    value: function schedule(callback, target, interval, repeat, delay, paused) {
                        if ("function" != typeof callback) {
                            var tmp = callback;
                            callback = target, target = tmp;
                        }
                        4 !== arguments.length && 5 !== arguments.length || (paused = !!repeat, repeat = cc.macro.REPEAT_FOREVER, 
                        delay = 0), cc.assertID(target, 1502);
                        var targetId = target.uuid || target.id;
                        if (targetId) {
                            var timer, i, element = this._hashForTimers[targetId];
                            if (element ? element.paused !== paused && cc.warnID(1511) : (element = HashTimerEntry.get(null, target, 0, null, null, paused), 
                            this._arrayForTimers.push(element), this._hashForTimers[targetId] = element), null == element.timers) element.timers = []; else for (i = 0; i < element.timers.length; ++i) if ((timer = element.timers[i]) && callback === timer._callback) return cc.logID(1507, timer.getInterval(), interval), 
                            void (timer._interval = interval);
                            (timer = CallbackTimer.get()).initWithCallback(this, callback, target, interval, repeat, delay), 
                            element.timers.push(timer), this._currentTarget === element && this._currentTargetSalvaged && (this._currentTargetSalvaged = !1);
                        } else cc.errorID(1510);
                    }
                }, {
                    key: "scheduleUpdate",
                    value: function scheduleUpdate(target, priority, paused) {
                        var targetId = target.uuid || target.id;
                        if (targetId) {
                            var hashElement = this._hashForUpdates[targetId];
                            if (hashElement && hashElement.entry) {
                                if (hashElement.entry.priority === priority) return hashElement.entry.markedForDeletion = !1, 
                                void (hashElement.entry.paused = paused);
                                if (this._updateHashLocked) return cc.logID(1506), hashElement.entry.markedForDeletion = !1, 
                                void (hashElement.entry.paused = paused);
                                this.unscheduleUpdate(target);
                            }
                            var ppList, listElement = ListEntry.get(target, priority, paused, !1);
                            0 === priority ? (ppList = this._updates0List, this._appendIn(ppList, listElement)) : (ppList = priority < 0 ? this._updatesNegList : this._updatesPosList, 
                            this._priorityIn(ppList, listElement, priority)), this._hashForUpdates[targetId] = HashUpdateEntry.get(ppList, listElement, target, null);
                        } else cc.errorID(1510);
                    }
                }, {
                    key: "unschedule",
                    value: function unschedule(callback, target) {
                        if (target && callback) {
                            var targetId = target.uuid || target.id;
                            if (targetId) {
                                var element = this._hashForTimers[targetId];
                                if (element) for (var timers = element.timers, i = 0, li = timers.length; i < li; i++) {
                                    var timer = timers[i];
                                    if (callback === timer._callback) return timer !== element.currentTimer || element.currentTimerSalvaged || (element.currentTimerSalvaged = !0), 
                                    timers.splice(i, 1), CallbackTimer.put(timer), element.timerIndex >= i && element.timerIndex--, 
                                    void (0 === timers.length && (this._currentTarget === element ? this._currentTargetSalvaged = !0 : this._removeHashElement(element)));
                                }
                            } else cc.errorID(1510);
                        }
                    }
                }, {
                    key: "unscheduleUpdate",
                    value: function unscheduleUpdate(target) {
                        if (target) {
                            var targetId = target.uuid || target.id;
                            if (targetId) {
                                var element = this._hashForUpdates[targetId];
                                element && (this._updateHashLocked ? element.entry.markedForDeletion = !0 : this._removeUpdateFromHash(element.entry));
                            } else cc.errorID(1510);
                        }
                    }
                }, {
                    key: "unscheduleAllForTarget",
                    value: function unscheduleAllForTarget(target) {
                        if (target) {
                            var targetId = target.uuid || target.id;
                            if (targetId) {
                                var element = this._hashForTimers[targetId];
                                if (element) {
                                    var timers = element.timers;
                                    -1 < timers.indexOf(element.currentTimer) && !element.currentTimerSalvaged && (element.currentTimerSalvaged = !0);
                                    for (var i = 0, l = timers.length; i < l; i++) CallbackTimer.put(timers[i]);
                                    timers.length = 0, this._currentTarget === element ? this._currentTargetSalvaged = !0 : this._removeHashElement(element);
                                }
                                this.unscheduleUpdate(target);
                            } else cc.errorID(1510);
                        }
                    }
                }, {
                    key: "unscheduleAll",
                    value: function unscheduleAll() {
                        this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
                    }
                }, {
                    key: "unscheduleAllWithMinPriority",
                    value: function unscheduleAllWithMinPriority(minPriority) {
                        var i, element, entry, arr = this._arrayForTimers;
                        for (i = arr.length - 1; 0 <= i; i--) element = arr[i], this.unscheduleAllForTarget(element.target);
                        var temp_length = 0;
                        if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; ) temp_length = this._updatesNegList.length, 
                        (entry = this._updatesNegList[i]) && entry.priority >= minPriority && this.unscheduleUpdate(entry.target), 
                        temp_length === this._updatesNegList.length && i++;
                        if (minPriority <= 0) for (i = 0; i < this._updates0List.length; ) temp_length = this._updates0List.length, 
                        (entry = this._updates0List[i]) && this.unscheduleUpdate(entry.target), temp_length === this._updates0List.length && i++;
                        for (i = 0; i < this._updatesPosList.length; ) temp_length = this._updatesPosList.length, 
                        (entry = this._updatesPosList[i]) && entry.priority >= minPriority && this.unscheduleUpdate(entry.target), 
                        temp_length === this._updatesPosList.length && i++;
                    }
                }, {
                    key: "isScheduled",
                    value: function isScheduled(callback, target) {
                        cc.assertID(callback, 1508), cc.assertID(target, 1509);
                        var targetId = target.uuid || target.id;
                        if (targetId) {
                            var element = this._hashForTimers[targetId];
                            if (!element) return !1;
                            if (null == element.timers) return !1;
                            for (var timers = element.timers, i = 0; i < timers.length; ++i) {
                                if (callback === timers[i]._callback) return !0;
                            }
                            return !1;
                        }
                        cc.errorID(1510);
                    }
                }, {
                    key: "pauseAllTargets",
                    value: function pauseAllTargets() {
                        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
                    }
                }, {
                    key: "pauseAllTargetsWithMinPriority",
                    value: function pauseAllTargetsWithMinPriority(minPriority) {
                        var element, i, li, entry, idsWithSelectors = [], locArrayForTimers = this._arrayForTimers;
                        for (i = 0, li = locArrayForTimers.length; i < li; i++) (element = locArrayForTimers[i]) && (element.paused = !0, 
                        idsWithSelectors.push(element.target));
                        if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; i++) (entry = this._updatesNegList[i]) && entry.priority >= minPriority && (entry.paused = !0, 
                        idsWithSelectors.push(entry.target));
                        if (minPriority <= 0) for (i = 0; i < this._updates0List.length; i++) (entry = this._updates0List[i]) && (entry.paused = !0, 
                        idsWithSelectors.push(entry.target));
                        for (i = 0; i < this._updatesPosList.length; i++) (entry = this._updatesPosList[i]) && entry.priority >= minPriority && (entry.paused = !0, 
                        idsWithSelectors.push(entry.target));
                        return idsWithSelectors;
                    }
                }, {
                    key: "resumeTargets",
                    value: function resumeTargets(targetsToResume) {
                        if (targetsToResume) for (var i = 0; i < targetsToResume.length; i++) this.resumeTarget(targetsToResume[i]);
                    }
                }, {
                    key: "pauseTarget",
                    value: function pauseTarget(target) {
                        cc.assertID(target, 1503);
                        var targetId = target.uuid || target.id;
                        if (targetId) {
                            var element = this._hashForTimers[targetId];
                            element && (element.paused = !0);
                            var elementUpdate = this._hashForUpdates[targetId];
                            elementUpdate && (elementUpdate.entry.paused = !0);
                        } else cc.errorID(1510);
                    }
                }, {
                    key: "resumeTarget",
                    value: function resumeTarget(target) {
                        cc.assertID(target, 1504);
                        var targetId = target.uuid || target.id;
                        if (targetId) {
                            var element = this._hashForTimers[targetId];
                            element && (element.paused = !1);
                            var elementUpdate = this._hashForUpdates[targetId];
                            elementUpdate && (elementUpdate.entry.paused = !1);
                        } else cc.errorID(1510);
                    }
                }, {
                    key: "isTargetPaused",
                    value: function isTargetPaused(target) {
                        cc.assertID(target, 1505);
                        var targetId = target.uuid || target.id;
                        if (targetId) {
                            var element = this._hashForTimers[targetId];
                            if (element) return element.paused;
                            var elementUpdate = this._hashForUpdates[targetId];
                            return !!elementUpdate && elementUpdate.entry.paused;
                        }
                        cc.errorID(1510);
                    }
                }, {
                    key: "_removeHashElement",
                    value: function _removeHashElement(element) {
                        var targetId = element.target.uuid || element.target.id;
                        delete this._hashForTimers[targetId];
                        for (var arr = this._arrayForTimers, i = 0, l = arr.length; i < l; i++) if (arr[i] === element) {
                            arr.splice(i, 1);
                            break;
                        }
                        HashTimerEntry.put(element);
                    }
                }, {
                    key: "_removeUpdateFromHash",
                    value: function _removeUpdateFromHash(entry) {
                        var targetId = entry.target.uuid || entry.target.id, element = this._hashForUpdates[targetId];
                        if (element) {
                            for (var list = element.list, listEntry = element.entry, i = 0, l = list.length; i < l; i++) if (list[i] === listEntry) {
                                list.splice(i, 1);
                                break;
                            }
                            delete this._hashForUpdates[targetId], ListEntry.put(listEntry), HashUpdateEntry.put(element);
                        }
                    }
                }, {
                    key: "_priorityIn",
                    value: function _priorityIn(ppList, listElement, priority) {
                        for (var i = 0; i < ppList.length; i++) if (priority < ppList[i].priority) return void ppList.splice(i, 0, listElement);
                        ppList.push(listElement);
                    }
                }, {
                    key: "_appendIn",
                    value: function _appendIn(ppList, listElement) {
                        ppList.push(listElement);
                    }
                } ]), Scheduler;
            }());
            function parseDepends(key, parsed) {
                var item = cc.loader.getItem(key);
                if (item) {
                    var depends = item.dependKeys;
                    if (depends) for (var i = 0; i < depends.length; i++) {
                        var depend = depends[i];
                        parsed[depend] || (parsed[depend] = !0, parseDepends(depend, parsed));
                    }
                }
            }
            function visitAsset(asset, excludeMap) {
                if (asset._uuid) {
                    var key = cc.loader._getReferenceKey(asset);
                    excludeMap[key] || (excludeMap[key] = !0, parseDepends(key, excludeMap));
                }
            }
            function visitComponent(comp, excludeMap) {
                for (var props = Object.getOwnPropertyNames(comp), i = 0; i < props.length; i++) {
                    var value = comp[props[i]];
                    if ("object" === _typeof(value) && value) if (Array.isArray(value)) for (var j = 0; j < value.length; j++) {
                        var val = value[j];
                        val instanceof RawAsset && visitAsset(val, excludeMap);
                    } else if (value.constructor && value.constructor !== Object) value instanceof RawAsset && visitAsset(value, excludeMap); else for (var keys = Object.getOwnPropertyNames(value), _j = 0; _j < keys.length; _j++) {
                        var _val = value[keys[_j]];
                        _val instanceof RawAsset && visitAsset(_val, excludeMap);
                    }
                }
            }
            function visitNode(node, excludeMap) {
                for (var i = 0; i < node._components.length; i++) visitComponent(node._components[i], excludeMap);
                for (var _i = 0; _i < node._children.length; _i++) visitNode(node._children[_i], excludeMap);
            }
            function getDependsRecursively(key) {
                var depends = {};
                return parseDepends(key, depends), Object.keys(depends);
            }
            Scheduler.PRIORITY_SYSTEM = 1 << 31, Scheduler.PRIORITY_NON_SYSTEM = Scheduler.PRIORITY_SYSTEM + 1, 
            Scheduler.ID = "scheduler", cc.Scheduler = Scheduler, function(LightType) {
                LightType[LightType.DIRECTIONAL = 0] = "DIRECTIONAL", LightType[LightType.SPHERE = 1] = "SPHERE", 
                LightType[LightType.SPOT = 2] = "SPOT", LightType[LightType.UNKNOWN = 3] = "UNKNOWN";
            }(LightType = LightType || {});
            function nt2lm(size) {
                return 4 * Math.PI * Math.PI * size * size;
            }
            var Light = function() {
                function Light(scene, name, node) {
                    _classCallCheck(this, Light), this._enabled = !0, this._color = new Vec3(1, 1, 1), 
                    this._useColorTemp = !1, this._colorTemp = 6550, this._colorTempRGB = new Vec3(1, 1, 1), 
                    this._scene = void 0, this._node = void 0, this._type = void 0, this._name = void 0, 
                    this._scene = scene, this._name = name, this._type = LightType.UNKNOWN, this._node = node;
                }
                return _createClass(Light, [ {
                    key: "enabled",
                    set: function set(val) {
                        this._enabled = val;
                    },
                    get: function get() {
                        return this._enabled;
                    }
                }, {
                    key: "color",
                    set: function set(color) {
                        this._color.set(color);
                    },
                    get: function get() {
                        return this._color;
                    }
                }, {
                    key: "useColorTemperature",
                    set: function set(enable) {
                        this._useColorTemp = enable;
                    },
                    get: function get() {
                        return this._useColorTemp;
                    }
                }, {
                    key: "colorTemperature",
                    set: function set(val) {
                        this._colorTemp = val, function ColorTemperatureToRGB(rgb, kelvin) {
                            kelvin < 1e3 ? kelvin = 1e3 : 15e3 < kelvin && (kelvin = 15e3);
                            var kSqr = kelvin * kelvin, u = (.860117757 + .000154118254 * kelvin + 1.28641212e-7 * kSqr) / (1 + .000842420235 * kelvin + 7.08145163e-7 * kSqr), v = (.317398726 + 422806245e-13 * kelvin + 4.20481691e-8 * kSqr) / (1 - 289741816e-13 * kelvin + 1.61456053e-7 * kSqr), d = 2 * u - 8 * v + 4, x = 3 * u / d, y = 2 * v / d, X = 1 / y * x, Z = 1 / y * (1 - x - y);
                            rgb.x = 3.2404542 * X - 1.5371385 + -.4985314 * Z, rgb.y = -.969266 * X + 1.8760108 + .041556 * Z, 
                            rgb.z = .0556434 * X - .2040259 + 1.0572252 * Z;
                        }(this._colorTempRGB, this._colorTemp);
                    },
                    get: function get() {
                        return this._colorTemp;
                    }
                }, {
                    key: "colorTemperatureRGB",
                    get: function get() {
                        return this._colorTempRGB;
                    }
                }, {
                    key: "node",
                    set: function set(n) {
                        this._node = n;
                    },
                    get: function get() {
                        return this._node;
                    }
                }, {
                    key: "type",
                    get: function get() {
                        return this._type;
                    }
                }, {
                    key: "name",
                    get: function get() {
                        return this._name;
                    }
                } ]), _createClass(Light, [ {
                    key: "update",
                    value: function update() {}
                } ]), Light;
            }();
            function cullSphereLight(light, model) {
                return !(!model.worldBounds || intersect.aabb_aabb(model.worldBounds, light.aabb));
            }
            function cullSpotLight(light, model) {
                return !(!model.worldBounds || intersect.aabb_aabb(model.worldBounds, light.aabb) && intersect.aabb_frustum(model.worldBounds, light.frustum));
            }
            (lightFrustum = new frustum()).accurate = !0;
            var lightFrustum, CameraProjection, CameraAperture, CameraISO, CameraShutter, calcDirectionalLightCullFrustum = function() {
                var lightPos = new Vec3(), lightViewCenter = new Vec3(), lightRot = new Quat(), camFrustum = new frustum();
                camFrustum.accurate = !0;
                var lightViewMat = new Mat4(), lightVeiwMatInv = new Mat4(), minBoxCorner = new Vec3(), maxBoxCorner = new Vec3();
                return function(out, sceneCamera, light, near, far, nearBias) {
                    Mat4.fromRT(lightViewMat, light.node.getWorldRotation(lightRot), sceneCamera.node.getWorldPosition(lightPos)), 
                    Mat4.invert(lightVeiwMatInv, lightViewMat), sceneCamera.getSplitFrustum(camFrustum, near, far), 
                    camFrustum.transform(lightVeiwMatInv), Vec3.set(minBoxCorner, camFrustum.vertices[0].x, camFrustum.vertices[0].y, camFrustum.vertices[0].z), 
                    Vec3.copy(maxBoxCorner, minBoxCorner);
                    for (var i = 1; i < camFrustum.vertices.length; i++) minBoxCorner.x = Math.min(minBoxCorner.x, camFrustum.vertices[i].x), 
                    minBoxCorner.y = Math.min(minBoxCorner.y, camFrustum.vertices[i].y), minBoxCorner.z = Math.min(minBoxCorner.z, camFrustum.vertices[i].z), 
                    maxBoxCorner.x = Math.max(maxBoxCorner.x, camFrustum.vertices[i].x), maxBoxCorner.y = Math.max(maxBoxCorner.y, camFrustum.vertices[i].y), 
                    maxBoxCorner.z = Math.max(maxBoxCorner.z, camFrustum.vertices[i].z);
                    Vec3.set(lightViewCenter, (minBoxCorner.x + maxBoxCorner.x) / 2, (minBoxCorner.y + maxBoxCorner.y) / 2, maxBoxCorner.z), 
                    lightViewCenter.z += nearBias, Vec3.transformMat4(lightPos, lightViewCenter, lightViewMat), 
                    Mat4.fromRT(lightViewMat, light.node.getWorldRotation(lightRot), lightPos), frustum.createOrtho(out, maxBoxCorner.x - minBoxCorner.x, maxBoxCorner.y - minBoxCorner.y, 0, minBoxCorner.z - nearBias - maxBoxCorner.z, lightViewMat);
                };
            }(), RenderFlow = function() {
                function RenderFlow(pipeline) {
                    _classCallCheck(this, RenderFlow), this._device = void 0, this._pipeline = void 0, 
                    this._name = "", this._priority = 0, this._stages = [], this._material = new Material(), 
                    this._device = pipeline.device, this._pipeline = pipeline;
                }
                return _createClass(RenderFlow, [ {
                    key: "device",
                    get: function get() {
                        return this._device;
                    }
                }, {
                    key: "pipeline",
                    get: function get() {
                        return this._pipeline;
                    }
                }, {
                    key: "name",
                    get: function get() {
                        return this._name;
                    }
                }, {
                    key: "priority",
                    get: function get() {
                        return this._priority;
                    }
                }, {
                    key: "stages",
                    get: function get() {
                        return this._stages;
                    }
                }, {
                    key: "material",
                    get: function get() {
                        return this._material;
                    }
                } ]), _createClass(RenderFlow, [ {
                    key: "resize",
                    value: function resize(width, height) {
                        var _iterator = this._stages, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            _ref.resize(width, height);
                        }
                    }
                }, {
                    key: "render",
                    value: function render(view) {
                        var _iterator2 = this._stages, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            _ref2.render(view);
                        }
                    }
                }, {
                    key: "createStage",
                    value: function createStage(clazz, info) {
                        var stage = new clazz(this);
                        return stage.initialize(info) ? (this._stages.push(stage), this._stages.sort(function(a, b) {
                            return a.priority - b.priority;
                        }), stage) : null;
                    }
                }, {
                    key: "destroyStages",
                    value: function destroyStages() {
                        var _iterator3 = this._stages, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i3 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i3++];
                            } else {
                                if ((_i3 = _iterator3.next()).done) break;
                                _ref3 = _i3.value;
                            }
                            _ref3.destroy();
                        }
                        this._stages = [];
                    }
                } ]), RenderFlow;
            }(), RenderStage = function() {
                function RenderStage(flow) {
                    if (_classCallCheck(this, RenderStage), this._flow = void 0, this._pipeline = void 0, 
                    this._device = void 0, this._name = "", this._priority = 0, this._framebuffer = null, 
                    this._cmdBuff = null, this._clearColors = void 0, this._clearDepth = 1, this._clearStencil = 0, 
                    this._renderArea = void 0, this._pass = null, this._pso = null, this._flow = flow, 
                    this._pipeline = flow.pipeline, this._device = flow.device, !this._flow.pipeline.root.device) throw new Error("");
                    this._device = this._flow.pipeline.root.device, this._clearColors = [ {
                        r: .3,
                        g: .6,
                        b: .9,
                        a: 1
                    } ], this._renderArea = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    };
                }
                return _createClass(RenderStage, [ {
                    key: "flow",
                    get: function get() {
                        return this._flow;
                    }
                }, {
                    key: "pipeline",
                    get: function get() {
                        return this._pipeline;
                    }
                }, {
                    key: "priority",
                    get: function get() {
                        return this._priority;
                    }
                }, {
                    key: "framebuffer",
                    get: function get() {
                        return this._framebuffer;
                    }
                } ]), _createClass(RenderStage, [ {
                    key: "setClearColor",
                    value: function setClearColor(color) {
                        0 < this._clearColors.length ? this._clearColors[0] = color : this._clearColors.push(color);
                    }
                }, {
                    key: "setClearColors",
                    value: function setClearColors(colors) {
                        this._clearColors = colors;
                    }
                }, {
                    key: "setClearDepth",
                    value: function setClearDepth(depth) {
                        this._clearDepth = depth;
                    }
                }, {
                    key: "setClearStencil",
                    value: function setClearStencil(stencil) {
                        this._clearStencil = stencil;
                    }
                }, {
                    key: "setRenderArea",
                    value: function setRenderArea(width, height) {
                        this._renderArea.width = width, this._renderArea.height = height;
                    }
                } ]), RenderStage;
            }(), ToneMapStage = function() {
                function ToneMapStage(flow) {
                    var _this;
                    return _classCallCheck(this, ToneMapStage), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ToneMapStage).call(this, flow)))._hTexSampler = 0, 
                    _this._hBlendTexSampler = 0, _this._bindingLayout = null, _this;
                }
                return _inherits(ToneMapStage, RenderStage), _createClass(ToneMapStage, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
                        void 0 !== info.framebuffer && (this._framebuffer = info.framebuffer), this._cmdBuff = this._device.createCommandBuffer({
                            allocator: this._device.commandAllocator,
                            type: GFXCommandBufferType.PRIMARY
                        }), this.rebuild(), !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
                    }
                }, {
                    key: "resize",
                    value: function resize() {}
                }, {
                    key: "rebuild",
                    value: function rebuild() {
                        this._pass = this._flow.material.passes[0], this._hTexSampler = this._pass.getBinding("u_texSampler");
                        var globalUBO = this._pipeline.globalBindings.get(UBOGlobal.BLOCK.name);
                        this._pso = this._pass.createPipelineState(), this._bindingLayout = this._pso.pipelineLayout.layouts[0], 
                        this._pass.bindBuffer(UBOGlobal.BLOCK.binding, globalUBO.buffer), this._pass.bindTextureView(this._hTexSampler, this._pipeline.curShadingTexView), 
                        this._pipeline.useSMAA && (this._hBlendTexSampler = this._pass.getBinding("u_blendTexSampler"), 
                        this._pass.bindTextureView(this._hBlendTexSampler, this._pipeline.smaaBlendTexView)), 
                        this._pass.update(), this._bindingLayout.update();
                    }
                }, {
                    key: "render",
                    value: function render(view) {
                        var camera = view.camera;
                        if (this._cmdBuff) {
                            this._renderArea.width = camera.width, this._renderArea.height = camera.height;
                            var framebuffer = view.window.framebuffer;
                            this._cmdBuff.begin(), this._cmdBuff.beginRenderPass(framebuffer, this._renderArea, GFXClearFlag.ALL, [ {
                                r: 0,
                                g: 0,
                                b: 0,
                                a: 1
                            } ], 1, 0), this._cmdBuff.bindPipelineState(this._pso), this._cmdBuff.bindBindingLayout(this._pso.pipelineLayout.layouts[0]), 
                            this._cmdBuff.bindInputAssembler(this._pipeline.quadIA), this._cmdBuff.draw(this._pipeline.quadIA), 
                            this._cmdBuff.endRenderPass(), this._cmdBuff.end();
                        }
                        this._device.queue.submit([ this._cmdBuff ]);
                    }
                } ]), ToneMapStage;
            }(), ToneMapFlow = function() {
                function ToneMapFlow(pipeline) {
                    return _classCallCheck(this, ToneMapFlow), _possibleConstructorReturn(this, _getPrototypeOf(ToneMapFlow).call(this, pipeline));
                }
                return _inherits(ToneMapFlow, RenderFlow), _createClass(ToneMapFlow, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
                        this._material.initialize({
                            effectName: "pipeline/tonemap",
                            defines: {
                                CC_USE_SMAA: this._pipeline.useSMAA
                            }
                        });
                        var framebuffer = this._pipeline.root.mainWindow.framebuffer;
                        return this.createStage(ToneMapStage, {
                            name: "ToneMapStage",
                            priority: 0,
                            framebuffer: framebuffer
                        }), !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._material && this._material.destroy(), this.destroyStages();
                    }
                }, {
                    key: "rebuild",
                    value: function rebuild() {
                        this._material && (this._material.destroy(), this._material.initialize({
                            effectName: "pipeline/tonemap",
                            defines: {
                                CC_USE_SMAA: this._pipeline.useSMAA
                            }
                        }));
                        var _iterator = this._stages, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            _ref.rebuild();
                        }
                    }
                } ]), ToneMapFlow;
            }();
            !function(CameraProjection) {
                CameraProjection[CameraProjection.ORTHO = 0] = "ORTHO", CameraProjection[CameraProjection.PERSPECTIVE = 1] = "PERSPECTIVE";
            }(CameraProjection = CameraProjection || {}), function(CameraAperture) {
                CameraAperture[CameraAperture.F1_8 = 0] = "F1_8", CameraAperture[CameraAperture.F2_0 = 1] = "F2_0", 
                CameraAperture[CameraAperture.F2_2 = 2] = "F2_2", CameraAperture[CameraAperture.F2_5 = 3] = "F2_5", 
                CameraAperture[CameraAperture.F2_8 = 4] = "F2_8", CameraAperture[CameraAperture.F3_2 = 5] = "F3_2", 
                CameraAperture[CameraAperture.F3_5 = 6] = "F3_5", CameraAperture[CameraAperture.F4_0 = 7] = "F4_0", 
                CameraAperture[CameraAperture.F4_5 = 8] = "F4_5", CameraAperture[CameraAperture.F5_0 = 9] = "F5_0", 
                CameraAperture[CameraAperture.F5_6 = 10] = "F5_6", CameraAperture[CameraAperture.F6_3 = 11] = "F6_3", 
                CameraAperture[CameraAperture.F7_1 = 12] = "F7_1", CameraAperture[CameraAperture.F8_0 = 13] = "F8_0", 
                CameraAperture[CameraAperture.F9_0 = 14] = "F9_0", CameraAperture[CameraAperture.F10_0 = 15] = "F10_0", 
                CameraAperture[CameraAperture.F11_0 = 16] = "F11_0", CameraAperture[CameraAperture.F13_0 = 17] = "F13_0", 
                CameraAperture[CameraAperture.F14_0 = 18] = "F14_0", CameraAperture[CameraAperture.F16_0 = 19] = "F16_0", 
                CameraAperture[CameraAperture.F18_0 = 20] = "F18_0", CameraAperture[CameraAperture.F20_0 = 21] = "F20_0", 
                CameraAperture[CameraAperture.F22_0 = 22] = "F22_0";
            }(CameraAperture = CameraAperture || {}), function(CameraISO) {
                CameraISO[CameraISO.ISO100 = 0] = "ISO100", CameraISO[CameraISO.ISO200 = 1] = "ISO200", 
                CameraISO[CameraISO.ISO400 = 2] = "ISO400", CameraISO[CameraISO.ISO800 = 3] = "ISO800";
            }(CameraISO = CameraISO || {}), function(CameraShutter) {
                CameraShutter[CameraShutter.D1 = 0] = "D1", CameraShutter[CameraShutter.D2 = 1] = "D2", 
                CameraShutter[CameraShutter.D4 = 2] = "D4", CameraShutter[CameraShutter.D8 = 3] = "D8", 
                CameraShutter[CameraShutter.D15 = 4] = "D15", CameraShutter[CameraShutter.D30 = 5] = "D30", 
                CameraShutter[CameraShutter.D60 = 6] = "D60", CameraShutter[CameraShutter.D125 = 7] = "D125", 
                CameraShutter[CameraShutter.D250 = 8] = "D250", CameraShutter[CameraShutter.D500 = 9] = "D500", 
                CameraShutter[CameraShutter.D1000 = 10] = "D1000", CameraShutter[CameraShutter.D2000 = 11] = "D2000", 
                CameraShutter[CameraShutter.D4000 = 12] = "D4000";
            }(CameraShutter = CameraShutter || {});
            var FSTOPS = [ 1.8, 2, 2.2, 2.5, 2.8, 3.2, 3.5, 4, 4.5, 5, 5.6, 6.3, 7.1, 8, 9, 10, 11, 13, 14, 16, 18, 20, 22 ], SHUTERS = [ 1, .5, .25, 1 / 8, 1 / 15, 1 / 30, 1 / 60, .008, .004, .002, .001, 5e-4, 25e-5 ], ISOS = [ 100, 200, 400, 800 ], v_a = new Vec3(), v_b = new Vec3(), _tempMat1 = new Mat4(), _tempMat2 = new Mat4(), SKYBOX_FLAG = GFXClearFlag.STENCIL << 1, Camera = function() {
                function Camera(scene, info) {
                    _classCallCheck(this, Camera), this._scene = void 0, this._name = void 0, this._enabled = !1, 
                    this._proj = void 0, this._isWindowSize = !0, this._width = void 0, this._height = void 0, 
                    this._screenScale = void 0, this._aspect = void 0, this._orthoHeight = 10, this._fov = toRadian(45), 
                    this._nearClip = 1, this._farClip = 1e3, this._clearStencil = 0, this._clearDepth = 1, 
                    this._clearFlag = GFXClearFlag.NONE, this._clearColor = {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0
                    }, this._viewport = new Rect(0, 0, 1, 1), this._isProjDirty = !0, this._matView = new Mat4(), 
                    this._matProj = new Mat4(), this._matProjInv = new Mat4(), this._matViewProj = new Mat4(), 
                    this._matViewProjInv = new Mat4(), this._frustum = new frustum(), this._forward = new Vec3(), 
                    this._position = new Vec3(), this._node = null, this._view = void 0, this._visibility = CameraDefaultMask, 
                    this._priority = 0, this._aperture = CameraAperture.F16_0, this._apertureValue = void 0, 
                    this._shutter = CameraShutter.D125, this._shutterValue = 0, this._iso = CameraISO.ISO100, 
                    this._isoValue = 0, this._ec = 0, this._exposure = 0, this._scene = scene, this._name = info.name, 
                    this._node = info.node, this._proj = info.projection, this._priority = info.priority || 0, 
                    this._apertureValue = FSTOPS[this._aperture], this._shutterValue = SHUTERS[this._shutter], 
                    this._isoValue = ISOS[this._iso], this.updateExposure(), this._aspect = this._width = this._height = this._screenScale = 1, 
                    this._view = this._scene.root.createView({
                        camera: this,
                        name: this._name,
                        priority: this._priority,
                        flows: info.flows
                    }), this.changeTargetWindow(info.window), console.log("Create Camera: " + this._name + " " + this._width + " x " + this._height);
                }
                return _createClass(Camera, [ {
                    key: "destroy",
                    value: function destroy() {
                        this._scene.root.destroyView(this._view);
                    }
                }, {
                    key: "resize",
                    value: function resize(width, height) {
                        this._width = width, this._height = height, this._aspect = this._width / this._height, 
                        this._isProjDirty = !0;
                    }
                }, {
                    key: "setFixedSize",
                    value: function setFixedSize(width, height) {
                        this._width = width, this._height = height, this._aspect = this._width / this._height, 
                        this._isWindowSize = !1;
                    }
                }, {
                    key: "update",
                    value: function update(argument_0) {
                        var forceUpdate = 0 < arguments.length && void 0 !== argument_0 && argument_0;
                        if (this._node) {
                            if ((this._node.hasChangedFlags || forceUpdate) && (Mat4.invert(this._matView, this.node.worldMatrix), 
                            this._forward.x = -this._matView.m02, this._forward.y = -this._matView.m06, this._forward.z = -this._matView.m10, 
                            this._node.getWorldPosition(this._position)), this._isProjDirty) {
                                if (this._proj === CameraProjection.PERSPECTIVE) Mat4.perspective(this._matProj, this._fov, this._aspect, this._nearClip, this._farClip); else {
                                    var x = this._orthoHeight * this._aspect, y = this._orthoHeight;
                                    Mat4.ortho(this._matProj, -x, x, -y, y, this._nearClip, this._farClip);
                                }
                                Mat4.invert(this._matProjInv, this._matProj);
                            }
                            (this._node.hasChangedFlags || this._isProjDirty || forceUpdate) && (Mat4.multiply(this._matViewProj, this._matProj, this._matView), 
                            Mat4.invert(this._matViewProjInv, this._matViewProj), this._frustum.update(this._matViewProj, this._matViewProjInv)), 
                            this._isProjDirty = !1;
                        }
                    }
                }, {
                    key: "getSplitFrustum",
                    value: function getSplitFrustum(out, nearClip, farClip) {
                        if (this._node) {
                            if (nearClip = Math.max(nearClip, this._nearClip), farClip = Math.min(farClip, this._farClip), 
                            Mat4.invert(this._matView, this.node.worldMatrix), this._proj === CameraProjection.PERSPECTIVE) Mat4.perspective(_tempMat1, this._fov, this._aspect, nearClip, farClip); else {
                                var x = this._orthoHeight * this._aspect, y = this._orthoHeight;
                                Mat4.ortho(_tempMat1, -x, x, -y, y, nearClip, farClip);
                            }
                            Mat4.multiply(_tempMat2, _tempMat1, this._matView), Mat4.invert(_tempMat1, _tempMat2), 
                            out.update(_tempMat2, _tempMat1);
                        }
                    }
                }, {
                    key: "changeTargetWindow",
                    value: function changeTargetWindow(argument_0) {
                        var window = 0 < arguments.length && void 0 !== argument_0 ? argument_0 : null, scene = this._scene, win = window || scene.root.mainWindow;
                        win && (this._view.window = win, this.resize(win.width, win.height));
                    }
                }, {
                    key: "screenPointToRay",
                    value: function screenPointToRay(out, x, y) {
                        var cx = this._viewport.x * this._width, cy = this._viewport.y * this._height, cw = this._viewport.width * this._width, ch = this._viewport.height * this._height;
                        return Vec3.set(v_a, (x - cx) / cw * 2 - 1, (y - cy) / ch * 2 - 1, 1), Vec3.transformMat4(v_a, v_a, this._matViewProjInv), 
                        this._proj === CameraProjection.PERSPECTIVE ? this._node && this._node.getWorldPosition(v_b) : (Vec3.set(v_b, (x - cx) / cw * 2 - 1, (y - cy) / ch * 2 - 1, -1), 
                        Vec3.transformMat4(v_b, v_b, this._matViewProjInv)), ray.fromPoints(out, v_b, v_a);
                    }
                }, {
                    key: "screenToWorld",
                    value: function screenToWorld(out, screenPos) {
                        var cx = this._viewport.x * this._width, cy = this._viewport.y * this._height, cw = this._viewport.width * this._width, ch = this._viewport.height * this._height;
                        return this._proj === CameraProjection.PERSPECTIVE ? (Vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, 1), 
                        Vec3.transformMat4(out, out, this._matViewProjInv), this._node && this._node.getWorldPosition(v_a), 
                        Vec3.lerp(out, v_a, out, lerp(this._nearClip / this._farClip, 1, screenPos.z))) : (Vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, 2 * screenPos.z - 1), 
                        Vec3.transformMat4(out, out, this.matViewProjInv)), out;
                    }
                }, {
                    key: "worldToScreen",
                    value: function worldToScreen(out, worldPos) {
                        var cx = this._viewport.x * this._width, cy = this._viewport.y * this._height, cw = this._viewport.width * this._width, ch = this._viewport.height * this._height;
                        return Vec3.transformMat4(out, worldPos, this.matViewProj), out.x = cx + .5 * (out.x + 1) * cw, 
                        out.y = cy + .5 * (out.y + 1) * ch, out.z = .5 * out.z + .5, out;
                    }
                }, {
                    key: "updateExposure",
                    value: function updateExposure() {
                        var ev100 = Math.log2(this._apertureValue * this._apertureValue / this._shutterValue * 100 / this._isoValue);
                        this._exposure = .833333 / Math.pow(2, ev100);
                    }
                }, {
                    key: "screenScale",
                    set: function set(val) {
                        this._screenScale = val;
                    },
                    get: function get() {
                        return this._screenScale;
                    }
                }, {
                    key: "enabled",
                    set: function set(val) {
                        this._enabled = val, this._view.enable(val);
                    },
                    get: function get() {
                        return this._enabled;
                    }
                }, {
                    key: "view",
                    get: function get() {
                        return this._view;
                    }
                }, {
                    key: "node",
                    set: function set(val) {
                        this._node = val;
                    },
                    get: function get() {
                        return this._node;
                    }
                }, {
                    key: "isWindowSize",
                    get: function get() {
                        return this._isWindowSize;
                    },
                    set: function set(value) {
                        this._isWindowSize = value;
                    }
                }, {
                    key: "orthoHeight",
                    set: function set(val) {
                        this._orthoHeight = val, this._isProjDirty = !0;
                    },
                    get: function get() {
                        return this._orthoHeight;
                    }
                }, {
                    key: "projectionType",
                    set: function set(val) {
                        this._proj = val, this._isProjDirty = !0;
                    },
                    get: function get() {
                        return this._proj;
                    }
                }, {
                    key: "viewport",
                    set: function set(v) {
                        this._viewport = v;
                    },
                    get: function get() {
                        return this._viewport;
                    }
                }, {
                    key: "fov",
                    set: function set(fov) {
                        this._fov = fov, this._isProjDirty = !0;
                    },
                    get: function get() {
                        return this._fov;
                    }
                }, {
                    key: "nearClip",
                    set: function set(nearClip) {
                        this._nearClip = nearClip, this._isProjDirty = !0;
                    },
                    get: function get() {
                        return this._nearClip;
                    }
                }, {
                    key: "farClip",
                    set: function set(farClip) {
                        this._farClip = farClip, this._isProjDirty = !0;
                    },
                    get: function get() {
                        return this._farClip;
                    }
                }, {
                    key: "clearColor",
                    set: function set(val) {
                        this._clearColor.r = val.r, this._clearColor.g = val.g, this._clearColor.b = val.b, 
                        this._clearColor.a = val.a;
                    },
                    get: function get() {
                        return this._clearColor;
                    }
                }, {
                    key: "clearDepth",
                    set: function set(val) {
                        this._clearDepth = val;
                    },
                    get: function get() {
                        return this._clearDepth;
                    }
                }, {
                    key: "clearStencil",
                    set: function set(val) {
                        this._clearStencil = val;
                    },
                    get: function get() {
                        return this._clearStencil;
                    }
                }, {
                    key: "clearFlag",
                    set: function set(val) {
                        this._clearFlag = val;
                    },
                    get: function get() {
                        return this._clearFlag;
                    }
                }, {
                    key: "scene",
                    get: function get() {
                        return this._scene;
                    }
                }, {
                    key: "name",
                    get: function get() {
                        return this._name;
                    }
                }, {
                    key: "width",
                    get: function get() {
                        return this._width;
                    }
                }, {
                    key: "height",
                    get: function get() {
                        return this._height;
                    }
                }, {
                    key: "aspect",
                    get: function get() {
                        return this._aspect;
                    }
                }, {
                    key: "matView",
                    get: function get() {
                        return this._matView;
                    }
                }, {
                    key: "matProj",
                    get: function get() {
                        return this._matProj;
                    }
                }, {
                    key: "matProjInv",
                    get: function get() {
                        return this._matProjInv;
                    }
                }, {
                    key: "matViewProj",
                    get: function get() {
                        return this._matViewProj;
                    }
                }, {
                    key: "matViewProjInv",
                    get: function get() {
                        return this._matViewProjInv;
                    }
                }, {
                    key: "frustum",
                    get: function get() {
                        return this._frustum;
                    }
                }, {
                    key: "forward",
                    get: function get() {
                        return this._forward;
                    }
                }, {
                    key: "position",
                    get: function get() {
                        return this._position;
                    }
                }, {
                    key: "visibility",
                    set: function set(vis) {
                        this._visibility = vis, this._view.visibility = vis;
                    },
                    get: function get() {
                        return this._visibility;
                    }
                }, {
                    key: "priority",
                    get: function get() {
                        return this._view.priority;
                    },
                    set: function set(val) {
                        this._priority = val, this._view.priority = this._priority;
                    }
                }, {
                    key: "aperture",
                    set: function set(val) {
                        this._aperture = val, this._apertureValue = FSTOPS[this._aperture], this.updateExposure();
                    },
                    get: function get() {
                        return this._aperture;
                    }
                }, {
                    key: "apertureValue",
                    get: function get() {
                        return this._apertureValue;
                    }
                }, {
                    key: "shutter",
                    set: function set(val) {
                        this._shutter = val, this._shutterValue = SHUTERS[this._shutter], this.updateExposure();
                    },
                    get: function get() {
                        return this._shutter;
                    }
                }, {
                    key: "shutterValue",
                    get: function get() {
                        return this._shutterValue;
                    }
                }, {
                    key: "iso",
                    set: function set(val) {
                        this._iso = val, this._isoValue = ISOS[this._iso], this.updateExposure();
                    },
                    get: function get() {
                        return this._iso;
                    }
                }, {
                    key: "isoValue",
                    get: function get() {
                        return this._isoValue;
                    }
                }, {
                    key: "ec",
                    set: function set(val) {
                        this._ec = val;
                    },
                    get: function get() {
                        return this._ec;
                    }
                }, {
                    key: "exposure",
                    get: function get() {
                        return this._exposure;
                    }
                } ]), Camera;
            }(), _cachedArray = (array.fastRemove, new Array(16)), _currentHovered = null, pos = new Vec2(), _touchEvents = [ SystemEventType.TOUCH_START.toString(), SystemEventType.TOUCH_MOVE.toString(), SystemEventType.TOUCH_END.toString(), SystemEventType.TOUCH_CANCEL.toString() ], _mouseEvents = [ SystemEventType.MOUSE_DOWN.toString(), SystemEventType.MOUSE_ENTER.toString(), SystemEventType.MOUSE_MOVE.toString(), SystemEventType.MOUSE_LEAVE.toString(), SystemEventType.MOUSE_UP.toString(), SystemEventType.MOUSE_WHEEL.toString() ];
            function _touchStartHandler(touch, event) {
                var node = this.owner;
                return !(!node || !node.uiTransfromComp) && (touch.getUILocation(pos), !!node.uiTransfromComp.isHit(pos, this) && (event.type = SystemEventType.TOUCH_START.toString(), 
                event.touch = touch, event.bubbles = !0, node.dispatchEvent(event), !0));
            }
            function _touchMoveHandler(touch, event) {
                var node = this.owner;
                if (!node || !node.uiTransfromComp) return !1;
                event.type = SystemEventType.TOUCH_MOVE.toString(), event.touch = touch, event.bubbles = !0, 
                node.dispatchEvent(event);
            }
            function _touchEndHandler(touch, event) {
                var node = this.owner;
                node && node.uiTransfromComp && (touch.getUILocation(pos), node.uiTransfromComp.isHit(pos, this) ? event.type = SystemEventType.TOUCH_END.toString() : event.type = SystemEventType.TOUCH_CANCEL.toString(), 
                event.touch = touch, event.bubbles = !0, node.dispatchEvent(event));
            }
            function _touchCancelHandler(touch, event) {
                var node = this.owner;
                node && node.uiTransfromComp && (event.type = SystemEventType.TOUCH_CANCEL.toString(), 
                event.touch = touch, event.bubbles = !0, node.dispatchEvent(event));
            }
            function _mouseDownHandler(event) {
                var node = this.owner;
                node && node.uiTransfromComp && (pos = event.getUILocation(), node.uiTransfromComp.isHit(pos, this) && (event.type = SystemEventType.MOUSE_DOWN.toString(), 
                event.bubbles = !0, node.dispatchEvent(event)));
            }
            function _mouseMoveHandler(event) {
                var node = this.owner;
                if (node && node.uiTransfromComp) {
                    if (pos = event.getUILocation(), node.uiTransfromComp.isHit(pos, this)) this._previousIn || (_currentHovered && _currentHovered.eventProcessor.mouseListener && (event.type = SystemEventType.MOUSE_LEAVE, 
                    _currentHovered.dispatchEvent(event), _currentHovered.eventProcessor.mouseListener && (_currentHovered.eventProcessor.mouseListener._previousIn = !1)), 
                    _currentHovered = node, event.type = SystemEventType.MOUSE_ENTER.toString(), node.dispatchEvent(event), 
                    this._previousIn = !0), event.type = SystemEventType.MOUSE_MOVE.toString(), event.bubbles = !0, 
                    node.dispatchEvent(event); else {
                        if (!this._previousIn) return;
                        event.type = SystemEventType.MOUSE_LEAVE.toString(), node.dispatchEvent(event), 
                        this._previousIn = !1, _currentHovered = null;
                    }
                    event.propagationStopped = !0;
                }
            }
            function _mouseUpHandler(event) {
                var node = this.owner;
                node && node.uiTransfromComp && (pos = event.getUILocation(), node.uiTransfromComp.isHit(pos, this) && (event.type = SystemEventType.MOUSE_UP.toString(), 
                event.bubbles = !0, node.dispatchEvent(event), event.propagationStopped = !0));
            }
            function _mouseWheelHandler(event) {
                var node = this.owner;
                node && node.uiTransfromComp && (pos = event.getUILocation(), node.uiTransfromComp.isHit(pos, this) && (event.type = SystemEventType.MOUSE_WHEEL.toString(), 
                event.bubbles = !0, node.dispatchEvent(event), event.propagationStopped = !0));
            }
            function _searchMaskInParent(node) {
                var Mask = cc.MaskComponent;
                if (Mask) for (var index = 0, curr = node; curr && cc.Node.isNode(curr); curr = curr.parent, 
                ++index) if (curr.getComponent(Mask)) return {
                    index: index,
                    node: curr
                };
                return null;
            }
            function _checkListeners(node, events) {
                if (node._persistNode) return !0;
                var i = 0;
                if (node.eventProcessor.bubblingTargets) for (;i < events.length; ++i) if (node.eventProcessor.bubblingTargets.hasEventListener(events[i])) return !0;
                if (node.eventProcessor.capturingTargets) for (;i < events.length; ++i) if (node.eventProcessor.capturingTargets.hasEventListener(events[i])) return !0;
                return !1;
            }
            var _class$d, _class2$a, _class3$6, NodeEventProcessor = function() {
                function NodeEventProcessor(node) {
                    _classCallCheck(this, NodeEventProcessor), this.bubblingTargets = null, this.capturingTargets = null, 
                    this.touchListener = null, this.mouseListener = null, this._node = void 0, this._node = node;
                }
                return _createClass(NodeEventProcessor, [ {
                    key: "node",
                    get: function get() {
                        return this._node;
                    }
                } ]), _createClass(NodeEventProcessor, [ {
                    key: "reattach",
                    value: function reattach() {
                        if (this.touchListener) {
                            var mask = this.touchListener.mask = _searchMaskInParent(this._node);
                            this.mouseListener && (this.mouseListener.mask = mask);
                        } else this.mouseListener && (this.mouseListener.mask = _searchMaskInParent(this._node));
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        _currentHovered === this._node && (_currentHovered = null), (this.touchListener || this.mouseListener) && (eventManager.removeListeners(this._node), 
                        this.touchListener && (this.touchListener.owner = null, this.touchListener.mask = null, 
                        this.touchListener = null), this.mouseListener && (this.mouseListener.owner = null, 
                        this.mouseListener.mask = null, this.mouseListener = null));
                    }
                }, {
                    key: "on",
                    value: function on(type, callback, target, useCapture) {
                        return this._checknSetupSysEvent(type) ? this._onDispatch(type, callback, target, useCapture) : (this.bubblingTargets || (this.bubblingTargets = new EventTarget()), 
                        this.bubblingTargets.on(type, callback, target));
                    }
                }, {
                    key: "once",
                    value: function once(type, callback, target, useCapture) {
                        (this._checknSetupSysEvent(type) && useCapture ? this.capturingTargets = this.capturingTargets || new EventTarget() : this.bubblingTargets = this.bubblingTargets || new EventTarget()).once(type, callback, target);
                    }
                }, {
                    key: "off",
                    value: function off(type, callback, target, useCapture) {
                        var touchEvent = -1 !== _touchEvents.indexOf(type), mouseEvent = !touchEvent && -1 !== _mouseEvents.indexOf(type);
                        touchEvent || mouseEvent ? (this._offDispatch(type, callback, target, useCapture), 
                        touchEvent ? this.touchListener && !_checkListeners(this._node, _touchEvents) && (eventManager.removeListener(this.touchListener), 
                        this.touchListener = null) : mouseEvent && this.mouseListener && !_checkListeners(this._node, _mouseEvents) && (eventManager.removeListener(this.mouseListener), 
                        this.mouseListener = null)) : this.bubblingTargets && this.bubblingTargets.off(type, callback, target);
                    }
                }, {
                    key: "emit",
                    value: function emit(type) {
                        if (this.bubblingTargets) {
                            for (var _this$bubblingTargets, _len = arguments.length, args = new Array(1 < _len ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                            (_this$bubblingTargets = this.bubblingTargets).emit.apply(_this$bubblingTargets, [ type ].concat(args));
                        }
                    }
                }, {
                    key: "dispatchEvent",
                    value: function dispatchEvent(event) {
                        !function _doDispatchEvent(owner, event) {
                            var target, i = 0;
                            for (event.target = owner, _cachedArray.length = 0, owner.eventProcessor.getCapturingTargets(event.type, _cachedArray), 
                            event.eventPhase = 1, i = _cachedArray.length - 1; 0 <= i; --i) if ((target = _cachedArray[i]).eventProcessor.capturingTargets && ((event.currentTarget = target).eventProcessor.capturingTargets.emit(event.type, event, _cachedArray), 
                            event.propagationStopped)) return void (_cachedArray.length = 0);
                            if (_cachedArray.length = 0, event.eventPhase = 2, (event.currentTarget = owner).eventProcessor.capturingTargets && owner.eventProcessor.capturingTargets.emit(event.type, event), 
                            !event.propagationImmediateStopped && owner.eventProcessor.bubblingTargets && owner.eventProcessor.bubblingTargets.emit(event.type, event), 
                            !event.propagationStopped && event.bubbles) for (owner.eventProcessor.getBubblingTargets(event.type, _cachedArray), 
                            event.eventPhase = 3, i = 0; i < _cachedArray.length; ++i) if ((target = _cachedArray[i]).eventProcessor.bubblingTargets && ((event.currentTarget = target).eventProcessor.bubblingTargets.emit(event.type, event), 
                            event.propagationStopped)) return void (_cachedArray.length = 0);
                            _cachedArray.length = 0;
                        }(this._node, event), _cachedArray.length = 0;
                    }
                }, {
                    key: "hasEventListener",
                    value: function hasEventListener(type) {
                        var has = !1;
                        return this.bubblingTargets && (has = this.bubblingTargets.hasEventListener(type)), 
                        !has && this.capturingTargets && (has = this.capturingTargets.hasEventListener(type)), 
                        has;
                    }
                }, {
                    key: "targetOff",
                    value: function targetOff(target) {
                        this.capturingTargets && this.capturingTargets.targetOff(target), this.bubblingTargets && this.bubblingTargets.targetOff(target), 
                        this.touchListener && !_checkListeners(this.node, _touchEvents) && (eventManager.removeListener(this.touchListener), 
                        this.touchListener = null), this.mouseListener && !_checkListeners(this.node, _mouseEvents) && (eventManager.removeListener(this.mouseListener), 
                        this.mouseListener = null);
                    }
                }, {
                    key: "getCapturingTargets",
                    value: function getCapturingTargets(type, targets) {
                        for (var parent = this._node.parent; parent; ) parent.eventProcessor.capturingTargets && parent.eventProcessor.capturingTargets.hasEventListener(type) && targets.push(parent), 
                        parent = parent.parent;
                    }
                }, {
                    key: "getBubblingTargets",
                    value: function getBubblingTargets(type, targets) {
                        for (var parent = this._node.parent; parent; ) parent.eventProcessor.bubblingTargets && parent.eventProcessor.bubblingTargets.hasEventListener(type) && targets.push(parent), 
                        parent = parent.parent;
                    }
                }, {
                    key: "_checknSetupSysEvent",
                    value: function _checknSetupSysEvent(type) {
                        var _this = this, newAdded = !1, forDispatch = !1;
                        return -1 !== _touchEvents.indexOf(type) ? (this.touchListener || (this.touchListener = cc.EventListener.create({
                            event: cc.EventListener.TOUCH_ONE_BY_ONE,
                            swallowTouches: !0,
                            owner: this._node,
                            mask: _searchMaskInParent(this._node),
                            onTouchBegan: _touchStartHandler,
                            onTouchMoved: _touchMoveHandler,
                            onTouchEnded: _touchEndHandler,
                            onTouchCancelled: _touchCancelHandler
                        }), eventManager.addListener(this.touchListener, this._node), newAdded = !0), forDispatch = !0) : -1 !== _mouseEvents.indexOf(type) && (this.mouseListener || (this.mouseListener = cc.EventListener.create({
                            event: cc.EventListener.MOUSE,
                            _previousIn: !1,
                            owner: this._node,
                            mask: _searchMaskInParent(this._node),
                            onMouseDown: _mouseDownHandler,
                            onMouseMove: _mouseMoveHandler,
                            onMouseUp: _mouseUpHandler,
                            onMouseScroll: _mouseWheelHandler
                        }), eventManager.addListener(this.mouseListener, this._node), newAdded = !0), forDispatch = !0), 
                        newAdded && !this._node.activeInHierarchy && cc.director.getScheduler().schedule(function() {
                            _this._node.activeInHierarchy || eventManager.pauseTarget(_this._node);
                        }, this._node, 0, 0, 0, !1), forDispatch;
                    }
                }, {
                    key: "_onDispatch",
                    value: function _onDispatch(type, callback, target, useCapture) {
                        if ("boolean" == typeof target ? (useCapture = target, target = void 0) : useCapture = !!useCapture, 
                        callback) {
                            var listeners = null;
                            return (listeners = useCapture ? this.capturingTargets = this.capturingTargets || new EventTarget() : this.bubblingTargets = this.bubblingTargets || new EventTarget()).hasEventListener(type, callback, target) || listeners.on(type, callback, target), 
                            callback;
                        }
                        cc.errorID(6800);
                    }
                }, {
                    key: "_offDispatch",
                    value: function _offDispatch(type, callback, target, useCapture) {
                        if ("boolean" == typeof target ? (useCapture = target, target = void 0) : useCapture = !!useCapture, 
                        callback) {
                            var listeners = useCapture ? this.capturingTargets : this.bubblingTargets;
                            listeners && listeners.off(type, callback, target);
                        } else this.capturingTargets && this.capturingTargets.removeAll(type), this.bubblingTargets && this.bubblingTargets.removeAll(type);
                    }
                } ]), NodeEventProcessor;
            }();
            cc.NodeEventProcessor = NodeEventProcessor;
            var Script = exports("Script", ccclass("cc.Script")(_class$d = function() {
                function Script() {
                    return _classCallCheck(this, Script), _possibleConstructorReturn(this, _getPrototypeOf(Script).apply(this, arguments));
                }
                return _inherits(Script, Asset), Script;
            }()) || _class$d);
            cc._Script = Script;
            var JavaScript = exports("JavaScript", ccclass("cc.JavaScript")(_class2$a = function() {
                function JavaScript() {
                    return _classCallCheck(this, JavaScript), _possibleConstructorReturn(this, _getPrototypeOf(JavaScript).apply(this, arguments));
                }
                return _inherits(JavaScript, Script), JavaScript;
            }()) || _class2$a);
            cc._JavaScript = JavaScript;
            var _dec$e, _dec2$5, _dec3$1, _dec4, _dec5, _dec6, _dec7, _class$e, _class2$b, _descriptor$9, _descriptor2$5, _class3$7, _temp$d, TypeScript = exports("TypeScript", ccclass("cc.TypeScript")(_class3$6 = function() {
                function TypeScript() {
                    return _classCallCheck(this, TypeScript), _possibleConstructorReturn(this, _getPrototypeOf(TypeScript).apply(this, arguments));
                }
                return _inherits(TypeScript, Script), TypeScript;
            }()) || _class3$6);
            cc._TypeScript = TypeScript;
            var idGenerator$2 = new IDGenerator("Comp"), IsOnLoadCalled$1 = (CCObject.Flags.IsOnEnableCalled, 
            CCObject.Flags.IsOnLoadCalled), Component = exports("Component", (_dec$e = ccclass("cc.Component"), 
            _dec2$5 = property({
                visible: !1
            }), _dec3$1 = property({
                visible: !1
            }), _dec4 = property({
                displayName: "Script",
                type: Script,
                tooltip: void 0
            }), _dec5 = property({
                visible: !1
            }), _dec6 = property({
                visible: !1
            }), _dec7 = property({
                visible: !1
            }), _dec$e((_temp$d = _class3$7 = function() {
                function Component() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, Component);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Component)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "node", _descriptor$9, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_enabled", _descriptor2$5, _assertThisInitialized(_this)), 
                    _this._sceneGetter = null, _this._id = idGenerator$2.getNewId(), _this._eventTargets = [], 
                    _this;
                }
                return _inherits(Component, CCObject), _createClass(Component, [ {
                    key: "_getRenderScene",
                    value: function _getRenderScene() {
                        return this._sceneGetter ? this._sceneGetter() : this.node.scene._renderScene;
                    }
                }, {
                    key: "addComponent",
                    value: function addComponent(typeOrClassName) {
                        return this.node.addComponent(typeOrClassName);
                    }
                }, {
                    key: "getComponent",
                    value: function getComponent(typeOrClassName) {
                        return this.node.getComponent(typeOrClassName);
                    }
                }, {
                    key: "getComponents",
                    value: function getComponents(typeOrClassName) {
                        return this.node.getComponents(typeOrClassName);
                    }
                }, {
                    key: "getComponentInChildren",
                    value: function getComponentInChildren(typeOrClassName) {
                        return this.node.getComponentInChildren(typeOrClassName);
                    }
                }, {
                    key: "getComponentsInChildren",
                    value: function getComponentsInChildren(typeOrClassName) {
                        return this.node.getComponentsInChildren(typeOrClassName);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        _get(_getPrototypeOf(Component.prototype), "destroy", this).call(this) && this._enabled && this.node.activeInHierarchy && cc.director._compScheduler.disableComp(this);
                    }
                }, {
                    key: "_onPreDestroy",
                    value: function _onPreDestroy() {
                        this.unscheduleAllCallbacks();
                        for (var eventTargets = this._eventTargets, i = 0, l = eventTargets.length; i < l; ++i) {
                            var target = eventTargets[i];
                            target && target.targetOff(this);
                        }
                        eventTargets.length = 0, cc.director._nodeActivator.destroyComp(this), this.node._removeComponent(this);
                    }
                }, {
                    key: "_instantiate",
                    value: function _instantiate(cloned) {
                        return (cloned = cloned || cc.instantiate._clone(this, this)).node = null, cloned;
                    }
                }, {
                    key: "schedule",
                    value: function schedule(callback, argument_1, argument_2, argument_3) {
                        var interval = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : 0, repeat = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : cc.macro.REPEAT_FOREVER, delay = 3 < arguments.length && void 0 !== argument_3 ? argument_3 : 0;
                        cc.assertID(callback, 1619), cc.assertID(0 <= interval, 1620), interval = interval || 0, 
                        repeat = isNaN(repeat) ? cc.macro.REPEAT_FOREVER : repeat, delay = delay || 0;
                        var scheduler = cc.director.getScheduler(), paused = scheduler.isTargetPaused(this);
                        scheduler.schedule(callback, this, interval, repeat, delay, paused);
                    }
                }, {
                    key: "scheduleOnce",
                    value: function scheduleOnce(callback, argument_1) {
                        var delay = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : 0;
                        this.schedule(callback, 0, 0, delay);
                    }
                }, {
                    key: "unschedule",
                    value: function unschedule(callback_fn) {
                        callback_fn && cc.director.getScheduler().unschedule(callback_fn, this);
                    }
                }, {
                    key: "unscheduleAllCallbacks",
                    value: function unscheduleAllCallbacks() {
                        cc.director.getScheduler().unscheduleAllForTarget(this);
                    }
                }, {
                    key: "name",
                    get: function get() {
                        if (this._name) return this._name;
                        var className = getClassName(this), trimLeft = className.lastIndexOf(".");
                        return 0 <= trimLeft && (className = className.slice(trimLeft + 1)), this.node.name + "<" + className + ">";
                    },
                    set: function set(value) {
                        this._name = value;
                    }
                }, {
                    key: "uuid",
                    get: function get() {
                        return this._id;
                    }
                }, {
                    key: "__scriptAsset",
                    get: function get() {
                        return null;
                    }
                }, {
                    key: "enabled",
                    get: function get() {
                        return this._enabled;
                    },
                    set: function set(value) {
                        if (this._enabled !== value && (this._enabled = value, this.node.activeInHierarchy)) {
                            var compScheduler = cc.director._compScheduler;
                            value ? compScheduler.enableComp(this) : compScheduler.disableComp(this);
                        }
                    }
                }, {
                    key: "enabledInHierarchy",
                    get: function get() {
                        return this._enabled && this.node && this.node.activeInHierarchy;
                    }
                }, {
                    key: "_isOnLoadCalled",
                    get: function get() {
                        return this._objFlags & IsOnLoadCalled$1;
                    }
                } ]), Component;
            }(), _class3$7.system = null, _applyDecoratedDescriptor((_class2$b = _temp$d).prototype, "name", [ _dec2$5 ], Object.getOwnPropertyDescriptor(_class2$b.prototype, "name"), _class2$b.prototype), 
            _applyDecoratedDescriptor(_class2$b.prototype, "uuid", [ _dec3$1 ], Object.getOwnPropertyDescriptor(_class2$b.prototype, "uuid"), _class2$b.prototype), 
            _applyDecoratedDescriptor(_class2$b.prototype, "__scriptAsset", [ _dec4 ], Object.getOwnPropertyDescriptor(_class2$b.prototype, "__scriptAsset"), _class2$b.prototype), 
            _applyDecoratedDescriptor(_class2$b.prototype, "enabled", [ _dec5 ], Object.getOwnPropertyDescriptor(_class2$b.prototype, "enabled"), _class2$b.prototype), 
            _applyDecoratedDescriptor(_class2$b.prototype, "enabledInHierarchy", [ _dec6 ], Object.getOwnPropertyDescriptor(_class2$b.prototype, "enabledInHierarchy"), _class2$b.prototype), 
            _descriptor$9 = _applyDecoratedDescriptor(_class2$b.prototype, "node", [ _dec7 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor2$5 = _applyDecoratedDescriptor(_class2$b.prototype, "_enabled", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _class$e = _class2$b)) || _class$e)), proto = Component.prototype;
            proto.update = null, proto.lateUpdate = null, proto.__preload = null, proto.onLoad = null, 
            proto.start = null, proto.onEnable = null, proto.onDisable = null, proto.onDestroy = null, 
            proto.onFocusInEditor = null, proto.onLostFocusInEditor = null, proto.resetInEditor = null, 
            proto._getLocalBounds = null, proto.onRestore = null, Component._requireComponent = null, 
            Component._executionOrder = 0, value(Component, "_registerEditorProps", function(cls, props) {
                var reqComp = props.requireComponent;
                reqComp && (cls._requireComponent = reqComp);
                var order = props.executionOrder;
                order && "number" == typeof order && (cls._executionOrder = order);
            }), cc.Component = Component;
            var _class$f, _class2$c, _descriptor$a, _descriptor2$6, _descriptor3$4, _descriptor4$3, _descriptor5$3, _class3$8, _temp$e;
            CCObject.Flags.Destroying;
            var Destroying$2 = CCObject.Flags.Destroying, DontDestroy$1 = CCObject.Flags.DontDestroy, Deactivating$1 = CCObject.Flags.Deactivating, idGenerator$3 = new IDGenerator("Node");
            function getConstructor(typeOrClassName) {
                return typeOrClassName ? "string" == typeof typeOrClassName ? getClassByName(typeOrClassName) : typeOrClassName : (cc.errorID(3804), 
                null);
            }
            var NodeSpace, TransformDirtyBit, _dec$g, _dec2$6, _class$g, _class2$d, _descriptor$b, _descriptor2$7, _descriptor3$5, _descriptor4$4, _descriptor5$4, _class3$9, _temp$f, BaseNode = exports("BaseNode", ccclass("cc._BaseNode")((_temp$e = _class3$8 = function() {
                function BaseNode(name) {
                    var _this;
                    return _classCallCheck(this, BaseNode), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(BaseNode).call(this, name)), "_parent", _descriptor$a, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_children", _descriptor2$6, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_active", _descriptor3$4, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_components", _descriptor4$3, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_prefab", _descriptor5$3, _assertThisInitialized(_this)), 
                    _this._scene = null, _this._activeInHierarchy = !1, _this._id = idGenerator$3.getNewId(), 
                    _this._name = void 0, _this.__eventTargets = [], _this._siblingIndex = 0, _this._name = void 0 !== name ? name : "New Node", 
                    _this;
                }
                return _inherits(BaseNode, CCObject), _createClass(BaseNode, [ {
                    key: "components",
                    get: function get() {
                        return this._components;
                    }
                }, {
                    key: "_persistNode",
                    get: function get() {
                        return 0 < (this._objFlags & DontDestroy$1);
                    },
                    set: function set(value) {
                        value ? this._objFlags |= DontDestroy$1 : this._objFlags &= ~DontDestroy$1;
                    }
                }, {
                    key: "name",
                    get: function get() {
                        return this._name;
                    },
                    set: function set(value) {
                        this._name = value;
                    }
                }, {
                    key: "uuid",
                    get: function get() {
                        return this._id;
                    }
                }, {
                    key: "children",
                    get: function get() {
                        return this._children;
                    }
                }, {
                    key: "active",
                    get: function get() {
                        return this._active;
                    },
                    set: function set(isActive) {
                        if (this._active !== isActive) {
                            this._active = isActive;
                            var parent = this._parent;
                            if (parent) parent._activeInHierarchy && cc.director._nodeActivator.activateNode(this, isActive);
                        }
                    }
                }, {
                    key: "activeInHierarchy",
                    get: function get() {
                        return this._activeInHierarchy;
                    }
                }, {
                    key: "parent",
                    get: function get() {
                        return this._parent;
                    },
                    set: function set(value) {
                        this.setParent(value);
                    }
                }, {
                    key: "scene",
                    get: function get() {
                        return this._scene;
                    }
                } ], [ {
                    key: "_setScene",
                    value: function _setScene(node) {
                        node instanceof cc.Scene ? node._scene = node : null == node._parent ? cc.error("Node %s(%s) has not attached to a scene.", node.name, node.uuid) : node._scene = node._parent._scene;
                    }
                }, {
                    key: "_findComponent",
                    value: function _findComponent(node, constructor) {
                        var cls = constructor, comps = node._components;
                        if (cls._sealed) for (var i = 0; i < comps.length; ++i) {
                            var comp = comps[i];
                            if (comp.constructor === constructor) return comp;
                        } else for (var _i = 0; _i < comps.length; ++_i) {
                            var _comp = comps[_i];
                            if (_comp instanceof constructor) return _comp;
                        }
                        return null;
                    }
                }, {
                    key: "_findComponents",
                    value: function _findComponents(node, constructor, components) {
                        var cls = constructor, comps = node._components;
                        if (cls._sealed) for (var i = 0; i < comps.length; ++i) {
                            var comp = comps[i];
                            comp.constructor === constructor && components.push(comp);
                        } else for (var _i2 = 0; _i2 < comps.length; ++_i2) {
                            var _comp2 = comps[_i2];
                            _comp2 instanceof constructor && components.push(_comp2);
                        }
                    }
                }, {
                    key: "_findChildComponent",
                    value: function _findChildComponent(children, constructor) {
                        for (var i = 0; i < children.length; ++i) {
                            var node = children[i], comp = BaseNode._findComponent(node, constructor);
                            if (comp) return comp;
                            if (0 < node._children.length && (comp = BaseNode._findChildComponent(node._children, constructor))) return comp;
                        }
                        return null;
                    }
                }, {
                    key: "_findChildComponents",
                    value: function _findChildComponents(children, constructor, components) {
                        for (var i = 0; i < children.length; ++i) {
                            var node = children[i];
                            BaseNode._findComponents(node, constructor, components), 0 < node._children.length && BaseNode._findChildComponents(node._children, constructor, components);
                        }
                    }
                } ]), _createClass(BaseNode, [ {
                    key: "getParent",
                    value: function getParent() {
                        return this._parent;
                    }
                }, {
                    key: "setParent",
                    value: function setParent(value, argument_1) {
                        var keepWorldTransform = 1 < arguments.length && void 0 !== argument_1 && argument_1;
                        if (this._parent !== value) {
                            var oldParent = this._parent;
                            if (oldParent && oldParent._objFlags & Deactivating$1 && cc.errorID(3821), this._parent = value, 
                            this._siblingIndex = 0, this._onSetParent(oldParent, keepWorldTransform), this.emit && this.emit(SystemEventType.PARENT_CHANGED, oldParent), 
                            value && (value._objFlags & Deactivating$1 && cc.errorID(3821), value._children.push(this), 
                            this._siblingIndex = value._children.length - 1, value.emit && value.emit(SystemEventType.CHILD_ADDED, this)), 
                            oldParent && !(oldParent._objFlags & Destroying$2)) {
                                var removeAt = oldParent._children.indexOf(this);
                                0, oldParent._children.splice(removeAt, 1), oldParent._updateSiblingIndex(), oldParent.emit && oldParent.emit(SystemEventType.CHILD_REMOVED, this);
                            }
                            this._onHierarchyChanged(oldParent);
                        }
                    }
                }, {
                    key: "attr",
                    value: function attr(attrs) {
                        mixin(this, attrs);
                    }
                }, {
                    key: "getChildByUuid",
                    value: function getChildByUuid(uuid) {
                        if (!uuid) return cc.log("Invalid uuid"), null;
                        for (var locChildren = this._children, i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._id === uuid) return locChildren[i];
                        return null;
                    }
                }, {
                    key: "getChildByName",
                    value: function getChildByName(name) {
                        if (!name) return cc.log("Invalid name"), null;
                        for (var locChildren = this._children, i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._name === name) return locChildren[i];
                        return null;
                    }
                }, {
                    key: "getChildByPath",
                    value: function getChildByPath(path) {
                        for (var segments = path.split("/"), lastNode = this, _loop = function _loop(i) {
                            var segment = segments[i];
                            if (0 === segment.length) return "continue";
                            var next = lastNode.children.find(function(childNode) {
                                return childNode.name === segment;
                            });
                            if (!next) return {
                                v: null
                            };
                            lastNode = next;
                        }, i = 0; i < segments.length; ++i) {
                            var _ret = _loop(i);
                            switch (_ret) {
                              case "continue":
                                continue;

                              default:
                                if ("object" === _typeof(_ret)) return _ret.v;
                            }
                        }
                        return lastNode;
                    }
                }, {
                    key: "addChild",
                    value: function addChild(child) {
                        cc.assertID(child, 1606), cc.assertID(null === child._parent, 1605), child.setParent(this);
                    }
                }, {
                    key: "insertChild",
                    value: function insertChild(child, siblingIndex) {
                        child.parent = this, child.setSiblingIndex(siblingIndex);
                    }
                }, {
                    key: "getSiblingIndex",
                    value: function getSiblingIndex() {
                        return this._siblingIndex;
                    }
                }, {
                    key: "setSiblingIndex",
                    value: function setSiblingIndex(index) {
                        if (this._parent) if (this._parent._objFlags & Deactivating$1) cc.errorID(3821); else {
                            var siblings = this._parent._children;
                            index = -1 !== index ? index : siblings.length - 1;
                            var oldIndex = siblings.indexOf(this);
                            index !== oldIndex && (siblings.splice(oldIndex, 1), index < siblings.length ? siblings.splice(index, 0, this) : siblings.push(this), 
                            this._parent._updateSiblingIndex(), this._onSiblingIndexChanged && this._onSiblingIndexChanged(index));
                        }
                    }
                }, {
                    key: "walk",
                    value: function walk(prefunc, postfunc) {
                        var index = 1, children = null, curr = null, i = 0, stack = BaseNode._stacks[BaseNode._stackId];
                        stack || (stack = [], BaseNode._stacks.push(stack)), BaseNode._stackId++, stack.length = 0, 
                        stack[0] = this;
                        for (var parent = null, afterChildren = !1; index; ) if (curr = stack[--index]) if (!afterChildren && prefunc ? prefunc(curr) : afterChildren && postfunc && postfunc(curr), 
                        stack[index] = null, afterChildren) {
                            if (afterChildren = !1, children) if (children[++i]) stack[index] = children[i], 
                            index++; else if (parent && (stack[index] = parent, index++, afterChildren = !0, 
                            parent._parent ? (i = (children = parent._parent._children).indexOf(parent), parent = parent._parent) : children = parent = null, 
                            i < 0)) break;
                        } else 0 < curr._children.length ? (children = (parent = curr)._children, i = 0, 
                        stack[index] = children[i], index++) : (stack[index] = curr, index++, afterChildren = !0);
                        stack.length = 0, BaseNode._stackId--;
                    }
                }, {
                    key: "removeFromParent",
                    value: function removeFromParent() {
                        this._parent && this._parent.removeChild(this);
                    }
                }, {
                    key: "removeChild",
                    value: function removeChild(child) {
                        -1 < this._children.indexOf(child) && (child.parent = null);
                    }
                }, {
                    key: "removeAllChildren",
                    value: function removeAllChildren() {
                        for (var children = this._children, i = children.length - 1; 0 <= i; i--) {
                            var node = children[i];
                            node && (node.parent = null);
                        }
                        this._children.length = 0;
                    }
                }, {
                    key: "isChildOf",
                    value: function isChildOf(parent) {
                        var child = this;
                        do {
                            if (child === parent) return !0;
                            child = child._parent;
                        } while (child);
                        return !1;
                    }
                }, {
                    key: "getComponent",
                    value: function getComponent(typeOrClassName) {
                        var constructor = getConstructor(typeOrClassName);
                        return constructor ? BaseNode._findComponent(this, constructor) : null;
                    }
                }, {
                    key: "getComponents",
                    value: function getComponents(typeOrClassName) {
                        var constructor = getConstructor(typeOrClassName), components = [];
                        return constructor && BaseNode._findComponents(this, constructor, components), components;
                    }
                }, {
                    key: "getComponentInChildren",
                    value: function getComponentInChildren(typeOrClassName) {
                        var constructor = getConstructor(typeOrClassName);
                        return constructor ? BaseNode._findChildComponent(this._children, constructor) : null;
                    }
                }, {
                    key: "getComponentsInChildren",
                    value: function getComponentsInChildren(typeOrClassName) {
                        var constructor = getConstructor(typeOrClassName), components = [];
                        return constructor && (BaseNode._findComponents(this, constructor, components), 
                        BaseNode._findChildComponents(this._children, constructor, components)), components;
                    }
                }, {
                    key: "addComponent",
                    value: function addComponent(typeOrClassName) {
                        var constructor;
                        if ("string" == typeof typeOrClassName) {
                            if (!(constructor = getClassByName(typeOrClassName))) return cc.errorID(3807, typeOrClassName), 
                            cc._RF.peek() && cc.errorID(3808, typeOrClassName), null;
                        } else {
                            if (!typeOrClassName) return cc.errorID(3804), null;
                            constructor = typeOrClassName;
                        }
                        if ("function" != typeof constructor) return cc.errorID(3809), null;
                        if (!isChildClassOf(constructor, cc.Component)) return cc.errorID(3810), null;
                        var ReqComp = constructor._requireComponent;
                        if (ReqComp && !this.getComponent(ReqComp) && !this.addComponent(ReqComp)) return null;
                        var component = new constructor();
                        return (component.node = this)._components.push(component), this._activeInHierarchy && cc.director._nodeActivator.activateComp(component), 
                        component;
                    }
                }, {
                    key: "removeComponent",
                    value: function removeComponent(component) {
                        if (component) {
                            var componentInstance = null;
                            (componentInstance = component instanceof Component ? component : this.getComponent(component)) && componentInstance.destroy();
                        } else cc.errorID(3813);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        return !!_get(_getPrototypeOf(BaseNode.prototype), "destroy", this).call(this) && (this._activeInHierarchy && this._disableChildComps(), 
                        !0);
                    }
                }, {
                    key: "destroyAllChildren",
                    value: function destroyAllChildren() {
                        for (var children = this._children, i = 0; i < children.length; ++i) children[i].destroy();
                    }
                }, {
                    key: "_removeComponent",
                    value: function _removeComponent(component) {
                        if (component) {
                            if (!(this._objFlags & Destroying$2)) {
                                var i = this._components.indexOf(component);
                                -1 !== i ? this._components.splice(i, 1) : component.node !== this && cc.errorID(3815);
                            }
                        } else cc.errorID(3814);
                    }
                }, {
                    key: "_updateSiblingIndex",
                    value: function _updateSiblingIndex() {
                        for (var i = 0; i < this._children.length; ++i) this._children[i]._siblingIndex = i;
                    }
                }, {
                    key: "_onSetParent",
                    value: function _onSetParent(oldParent) {
                        this._parent && (null != oldParent && oldParent._scene === this._parent._scene || null == this._parent._scene || this.walk(function(node) {
                            BaseNode._setScene(node);
                        }));
                    }
                }, {
                    key: "_onPostActivated",
                    value: function _onPostActivated() {}
                }, {
                    key: "_onBatchRestored",
                    value: function _onBatchRestored() {}
                }, {
                    key: "_onBatchCreated",
                    value: function _onBatchCreated() {
                        this._parent && (this._siblingIndex = this._parent.children.indexOf(this));
                    }
                }, {
                    key: "_onPreDestroy",
                    value: function _onPreDestroy() {
                        this._onPreDestroyBase();
                    }
                }, {
                    key: "_onHierarchyChanged",
                    value: function _onHierarchyChanged(oldParent) {
                        return this._onHierarchyChangedBase(oldParent);
                    }
                }, {
                    key: "_instantiate",
                    value: function _instantiate(cloned) {
                        cloned = cloned || cc.instantiate._clone(this, this);
                        var thisPrefabInfo = this._prefab;
                        thisPrefabInfo && this === thisPrefabInfo.root && thisPrefabInfo.sync;
                        return cloned._parent = null, cloned._onBatchRestored(), cloned;
                    }
                }, {
                    key: "_onHierarchyChangedBase",
                    value: function _onHierarchyChangedBase() {
                        var newParent = this._parent;
                        !this._persistNode || newParent instanceof cc.Scene || cc.game.removePersistRootNode(this);
                        var shouldActiveNow = this._active && !(!newParent || !newParent._activeInHierarchy);
                        this._activeInHierarchy !== shouldActiveNow && cc.director._nodeActivator.activateNode(this, shouldActiveNow);
                    }
                }, {
                    key: "_onPreDestroyBase",
                    value: function _onPreDestroyBase() {
                        this._objFlags |= Destroying$2;
                        var parent = this._parent, destroyByParent = null !== parent && 0 != (parent._objFlags & Destroying$2);
                        for (var children = this._children, i = 0; i < children.length; ++i) children[i]._destroyImmediate();
                        for (var comps = this._components, _i3 = 0; _i3 < comps.length; ++_i3) comps[_i3]._destroyImmediate();
                        for (var eventTargets = this.__eventTargets, _i4 = 0; _i4 < eventTargets.length; ++_i4) {
                            var et = eventTargets[_i4];
                            et && et.targetOff(this);
                        }
                        if (eventTargets.length = 0, this._persistNode && cc.game.removePersistRootNode(this), 
                        !destroyByParent && parent) {
                            var childIndex = parent._children.indexOf(this);
                            parent._children.splice(childIndex, 1), this._siblingIndex = 0, parent.emit && parent.emit("child-removed", this);
                        }
                        return destroyByParent;
                    }
                }, {
                    key: "_disableChildComps",
                    value: function _disableChildComps() {
                        for (var comps = this._components, i = 0; i < comps.length; ++i) {
                            var component = comps[i];
                            component._enabled && cc.director._compScheduler.disableComp(component);
                        }
                        for (var children = this._children, _i5 = 0; _i5 < children.length; ++_i5) {
                            var node = children[_i5];
                            node._active && node._disableChildComps();
                        }
                    }
                } ]), BaseNode;
            }(), _class3$8.idGenerator = idGenerator$3, _class3$8._stacks = [ [] ], _class3$8._stackId = 0, 
            _applyDecoratedDescriptor((_class2$c = _temp$e).prototype, "_persistNode", [ property ], Object.getOwnPropertyDescriptor(_class2$c.prototype, "_persistNode"), _class2$c.prototype), 
            _applyDecoratedDescriptor(_class2$c.prototype, "name", [ property ], Object.getOwnPropertyDescriptor(_class2$c.prototype, "name"), _class2$c.prototype), 
            _applyDecoratedDescriptor(_class2$c.prototype, "uuid", [ property ], Object.getOwnPropertyDescriptor(_class2$c.prototype, "uuid"), _class2$c.prototype), 
            _applyDecoratedDescriptor(_class2$c.prototype, "children", [ property ], Object.getOwnPropertyDescriptor(_class2$c.prototype, "children"), _class2$c.prototype), 
            _applyDecoratedDescriptor(_class2$c.prototype, "active", [ property ], Object.getOwnPropertyDescriptor(_class2$c.prototype, "active"), _class2$c.prototype), 
            _applyDecoratedDescriptor(_class2$c.prototype, "activeInHierarchy", [ property ], Object.getOwnPropertyDescriptor(_class2$c.prototype, "activeInHierarchy"), _class2$c.prototype), 
            _applyDecoratedDescriptor(_class2$c.prototype, "parent", [ property ], Object.getOwnPropertyDescriptor(_class2$c.prototype, "parent"), _class2$c.prototype), 
            _descriptor$a = _applyDecoratedDescriptor(_class2$c.prototype, "_parent", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor2$6 = _applyDecoratedDescriptor(_class2$c.prototype, "_children", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor3$4 = _applyDecoratedDescriptor(_class2$c.prototype, "_active", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor4$3 = _applyDecoratedDescriptor(_class2$c.prototype, "_components", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor5$3 = _applyDecoratedDescriptor(_class2$c.prototype, "_prefab", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _class$f = _class2$c)) || _class$f);
            cc._BaseNode = BaseNode, function(NodeSpace) {
                NodeSpace[NodeSpace.LOCAL = 0] = "LOCAL", NodeSpace[NodeSpace.WORLD = 1] = "WORLD";
            }(NodeSpace = NodeSpace || {}), function(TransformDirtyBit) {
                TransformDirtyBit[TransformDirtyBit.NONE = 0] = "NONE", TransformDirtyBit[TransformDirtyBit.POSITION = 1] = "POSITION", 
                TransformDirtyBit[TransformDirtyBit.ROTATION = 2] = "ROTATION", TransformDirtyBit[TransformDirtyBit.SCALE = 4] = "SCALE", 
                TransformDirtyBit[TransformDirtyBit.RS = TransformDirtyBit.ROTATION | TransformDirtyBit.SCALE] = "RS", 
                TransformDirtyBit[TransformDirtyBit.TRS = TransformDirtyBit.POSITION | TransformDirtyBit.ROTATION | TransformDirtyBit.SCALE] = "TRS", 
                TransformDirtyBit[TransformDirtyBit.TRS_MASK = ~TransformDirtyBit.TRS] = "TRS_MASK";
            }(TransformDirtyBit = TransformDirtyBit || {});
            var v3_a = new Vec3(), q_a = new Quat(), q_b = new Quat(), array_a = new Array(10), qt_1$2 = new Quat(), m3_1$2 = new Mat3(), m3_scaling = new Mat3(), m4_1$3 = new Mat4(), bookOfChange = new Map(), Node$1 = exports("Node", (_dec$g = ccclass("cc.Node"), 
            _dec2$6 = property({
                type: Vec3
            }), _dec$g((_temp$f = _class3$9 = function() {
                function Node() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, Node);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Node)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._pos = new Vec3(), 
                    _this._rot = new Quat(), _this._scale = new Vec3(1, 1, 1), _this._mat = new Mat4(), 
                    _initializerDefineProperty(_this, "_lpos", _descriptor$b, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_lrot", _descriptor2$7, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_lscale", _descriptor3$5, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_layer", _descriptor4$4, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_euler", _descriptor5$4, _assertThisInitialized(_this)), 
                    _this._dirtyFlags = TransformDirtyBit.NONE, _this._eulerDirty = !1, _this._eventProcessor = new NodeEventProcessor(_assertThisInitialized(_this)), 
                    _this._eventMask = 0, _this._uiTransfromComp = null, _this._uiComp = null, _this;
                }
                return _inherits(Node, BaseNode), _createClass(Node, [ {
                    key: "setParent",
                    value: function setParent(value, argument_1) {
                        var keepWorldTransform = 1 < arguments.length && void 0 !== argument_1 && argument_1;
                        keepWorldTransform && this.updateWorldTransform(), _get(_getPrototypeOf(Node.prototype), "setParent", this).call(this, value, keepWorldTransform);
                    }
                }, {
                    key: "_onSetParent",
                    value: function _onSetParent(oldParent, keepWorldTransform) {
                        if (_get(_getPrototypeOf(Node.prototype), "_onSetParent", this).call(this, oldParent, keepWorldTransform), 
                        keepWorldTransform) {
                            var parent = this._parent;
                            parent ? (parent.updateWorldTransform(), Mat4.multiply(m4_1$3, Mat4.invert(m4_1$3, parent._mat), this._mat), 
                            Mat4.toRTS(m4_1$3, this._lrot, this._lpos, this._lscale)) : (Vec3.copy(this._lpos, this._pos), 
                            Quat.copy(this._lrot, this._rot), Vec3.copy(this._lscale, this._scale)), this._eulerDirty = !0;
                        }
                        this.invalidateChildren(TransformDirtyBit.TRS);
                    }
                }, {
                    key: "_onBatchCreated",
                    value: function _onBatchCreated() {
                        _get(_getPrototypeOf(Node.prototype), "_onBatchCreated", this).call(this), bookOfChange.set(this._id, TransformDirtyBit.TRS), 
                        this._dirtyFlags = TransformDirtyBit.TRS;
                        for (var len = this._children.length, i = 0; i < len; ++i) this._children[i]._onBatchCreated();
                    }
                }, {
                    key: "_onBatchRestored",
                    value: function _onBatchRestored() {
                        this._onBatchCreated();
                    }
                }, {
                    key: "_onBeforeSerialize",
                    value: function _onBeforeSerialize() {
                        this.eulerAngles;
                    }
                }, {
                    key: "translate",
                    value: function translate(trans, ns) {
                        var space = ns || NodeSpace.LOCAL;
                        if (space === NodeSpace.LOCAL) Vec3.transformQuat(v3_a, trans, this._lrot), this._lpos.x += v3_a.x, 
                        this._lpos.y += v3_a.y, this._lpos.z += v3_a.z; else if (space === NodeSpace.WORLD) if (this._parent) {
                            Quat.invert(q_a, this.worldRotation), Vec3.transformQuat(v3_a, trans, q_a);
                            var _scale = this.worldScale;
                            this._lpos.x += v3_a.x / _scale.x, this._lpos.y += v3_a.y / _scale.y, this._lpos.z += v3_a.z / _scale.z;
                        } else this._lpos.x += trans.x, this._lpos.y += trans.y, this._lpos.z += trans.z;
                        this.invalidateChildren(TransformDirtyBit.POSITION), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.POSITION_PART);
                    }
                }, {
                    key: "rotate",
                    value: function rotate(rot, ns) {
                        var space = ns || NodeSpace.LOCAL;
                        if (Quat.normalize(q_a, rot), space === NodeSpace.LOCAL) Quat.multiply(this._lrot, this._lrot, q_a); else if (space === NodeSpace.WORLD) {
                            var worldRot = this.worldRotation;
                            Quat.multiply(q_b, q_a, worldRot), Quat.invert(q_a, worldRot), Quat.multiply(q_b, q_a, q_b), 
                            Quat.multiply(this._lrot, this._lrot, q_b);
                        }
                        this._eulerDirty = !0, this.invalidateChildren(TransformDirtyBit.ROTATION), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.ROTATION_PART);
                    }
                }, {
                    key: "lookAt",
                    value: function lookAt(pos, up) {
                        this.getWorldPosition(v3_a), Vec3.subtract(v3_a, v3_a, pos), Vec3.normalize(v3_a, v3_a), 
                        Quat.fromViewUp(q_a, v3_a, up), this.setWorldRotation(q_a);
                    }
                }, {
                    key: "invalidateChildren",
                    value: function invalidateChildren(dirtyBit) {
                        if ((this._dirtyFlags & this.hasChangedFlags & dirtyBit) !== dirtyBit) {
                            this._dirtyFlags |= dirtyBit, bookOfChange.set(this._id, this.hasChangedFlags | dirtyBit), 
                            dirtyBit |= TransformDirtyBit.POSITION;
                            for (var len = this._children.length, i = 0; i < len; ++i) this._children[i].invalidateChildren(dirtyBit);
                        }
                    }
                }, {
                    key: "updateWorldTransform",
                    value: function updateWorldTransform() {
                        if (this._dirtyFlags) {
                            for (var child, cur = this, i = 0; cur && cur._dirtyFlags; ) cur = (array_a[i++] = cur)._parent;
                            for (var dirtyBits = 0; i; ) dirtyBits |= (child = array_a[--i])._dirtyFlags, cur ? (dirtyBits & TransformDirtyBit.POSITION && (Vec3.transformMat4(child._pos, child._lpos, cur._mat), 
                            child._mat.m12 = child._pos.x, child._mat.m13 = child._pos.y, child._mat.m14 = child._pos.z), 
                            dirtyBits & TransformDirtyBit.RS && (Mat4.fromRTS(child._mat, child._lrot, child._lpos, child._lscale), 
                            Mat4.multiply(child._mat, cur._mat, child._mat), dirtyBits & TransformDirtyBit.ROTATION && Quat.multiply(child._rot, cur._rot, child._lrot), 
                            Mat3.fromQuat(m3_1$2, Quat.conjugate(qt_1$2, child._rot)), Mat3.multiplyMat4(m3_1$2, m3_1$2, child._mat), 
                            child._scale.x = m3_1$2.m00, child._scale.y = m3_1$2.m04, child._scale.z = m3_1$2.m08)) : (dirtyBits & TransformDirtyBit.POSITION && (Vec3.copy(child._pos, child._lpos), 
                            child._mat.m12 = child._pos.x, child._mat.m13 = child._pos.y, child._mat.m14 = child._pos.z), 
                            dirtyBits & TransformDirtyBit.RS && (dirtyBits & TransformDirtyBit.ROTATION ? Quat.copy(child._rot, child._lrot) : Vec3.copy(child._scale, child._lscale), 
                            Mat4.fromRTS(child._mat, child._rot, child._pos, child._scale))), child._dirtyFlags = TransformDirtyBit.NONE, 
                            cur = child;
                        }
                    }
                }, {
                    key: "setPosition",
                    value: function setPosition(val, y, z) {
                        void 0 === y || void 0 === z ? Vec3.copy(this._lpos, val) : Vec3.set(this._lpos, val, y, z), 
                        this.invalidateChildren(TransformDirtyBit.POSITION), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.POSITION_PART);
                    }
                }, {
                    key: "getPosition",
                    value: function getPosition(out) {
                        return out ? Vec3.set(out, this._lpos.x, this._lpos.y, this._lpos.z) : Vec3.copy(new Vec3(), this._lpos);
                    }
                }, {
                    key: "setRotation",
                    value: function setRotation(val, y, z, w) {
                        void 0 === y || void 0 === z || void 0 === w ? Quat.copy(this._lrot, val) : Quat.set(this._lrot, val, y, z, w), 
                        this._eulerDirty = !0, this.invalidateChildren(TransformDirtyBit.ROTATION), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.ROTATION_PART);
                    }
                }, {
                    key: "setRotationFromEuler",
                    value: function setRotationFromEuler(x, y, z) {
                        Vec3.set(this._euler, x, y, z), Quat.fromEuler(this._lrot, x, y, z), this._eulerDirty = !1, 
                        this.invalidateChildren(TransformDirtyBit.ROTATION), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.ROTATION_PART);
                    }
                }, {
                    key: "getRotation",
                    value: function getRotation(out) {
                        return out ? Quat.set(out, this._lrot.x, this._lrot.y, this._lrot.z, this._lrot.w) : Quat.copy(new Quat(), this._lrot);
                    }
                }, {
                    key: "setScale",
                    value: function setScale(val, y, z) {
                        void 0 === y || void 0 === z ? Vec3.copy(this._lscale, val) : Vec3.set(this._lscale, val, y, z), 
                        this.invalidateChildren(TransformDirtyBit.SCALE), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.SCALE_PART);
                    }
                }, {
                    key: "getScale",
                    value: function getScale(out) {
                        return out ? Vec3.set(out, this._lscale.x, this._lscale.y, this._lscale.z) : Vec3.copy(new Vec3(), this._lscale);
                    }
                }, {
                    key: "inverseTransformPoint",
                    value: function inverseTransformPoint(out, p) {
                        Vec3.copy(out, p);
                        for (var cur = this, i = 0; cur._parent; ) cur = (array_a[i++] = cur)._parent;
                        for (;0 <= i; ) Vec3.transformInverseRTS(out, out, cur._lrot, cur._lpos, cur._lscale), 
                        cur = array_a[--i];
                        return out;
                    }
                }, {
                    key: "setWorldPosition",
                    value: function setWorldPosition(val, y, z) {
                        void 0 === y || void 0 === z ? Vec3.copy(this._pos, val) : Vec3.set(this._pos, val, y, z);
                        var parent = this._parent, local = this._lpos;
                        parent ? (parent.updateWorldTransform(), Vec3.transformMat4(local, this._pos, Mat4.invert(m4_1$3, parent._mat))) : Vec3.copy(local, this._pos), 
                        this.invalidateChildren(TransformDirtyBit.POSITION), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.POSITION_PART);
                    }
                }, {
                    key: "getWorldPosition",
                    value: function getWorldPosition(out) {
                        return this.updateWorldTransform(), out ? Vec3.copy(out, this._pos) : Vec3.copy(new Vec3(), this._pos);
                    }
                }, {
                    key: "setWorldRotation",
                    value: function setWorldRotation(val, y, z, w) {
                        void 0 === y || void 0 === z || void 0 === w ? Quat.copy(this._rot, val) : Quat.set(this._rot, val, y, z, w), 
                        this._parent ? (this._parent.updateWorldTransform(), Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), this._rot)) : Quat.copy(this._lrot, this._rot), 
                        this._eulerDirty = !0, this.invalidateChildren(TransformDirtyBit.ROTATION), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.ROTATION_PART);
                    }
                }, {
                    key: "setWorldRotationFromEuler",
                    value: function setWorldRotationFromEuler(x, y, z) {
                        Quat.fromEuler(this._rot, x, y, z), this._parent ? (this._parent.updateWorldTransform(), 
                        Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), this._rot)) : Quat.copy(this._lrot, this._rot), 
                        this._eulerDirty = !0, this.invalidateChildren(TransformDirtyBit.ROTATION), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.ROTATION_PART);
                    }
                }, {
                    key: "getWorldRotation",
                    value: function getWorldRotation(out) {
                        return this.updateWorldTransform(), out ? Quat.copy(out, this._rot) : Quat.copy(new Quat(), this._rot);
                    }
                }, {
                    key: "setWorldScale",
                    value: function setWorldScale(val, y, z) {
                        void 0 === y || void 0 === z ? Vec3.copy(this._scale, val) : Vec3.set(this._scale, val, y, z);
                        var parent = this._parent;
                        parent ? (parent.updateWorldTransform(), Mat3.fromQuat(m3_1$2, Quat.conjugate(qt_1$2, parent._rot)), 
                        Mat3.multiplyMat4(m3_1$2, m3_1$2, parent._mat), m3_scaling.m00 = this._scale.x, 
                        m3_scaling.m04 = this._scale.x, m3_scaling.m08 = this._scale.z, Mat3.multiply(m3_1$2, m3_scaling, Mat3.invert(m3_1$2, m3_1$2)), 
                        this._lscale.x = m3_1$2.m00, this._lscale.y = m3_1$2.m04, this._lscale.z = m3_1$2.m08) : Vec3.copy(this._lscale, this._scale), 
                        this.invalidateChildren(TransformDirtyBit.SCALE), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.SCALE_PART);
                    }
                }, {
                    key: "getWorldScale",
                    value: function getWorldScale(out) {
                        return this.updateWorldTransform(), out ? Vec3.copy(out, this._scale) : Vec3.copy(new Vec3(), this._scale);
                    }
                }, {
                    key: "getWorldMatrix",
                    value: function getWorldMatrix(out) {
                        return this.updateWorldTransform(), out = out || new Mat4(), Mat4.copy(out, this._mat);
                    }
                }, {
                    key: "getWorldRS",
                    value: function getWorldRS(out) {
                        return this.updateWorldTransform(), out = out || new Mat4(), Mat4.copy(out, this._mat), 
                        out.m12 = 0, out.m13 = 0, out.m14 = 0, out;
                    }
                }, {
                    key: "getWorldRT",
                    value: function getWorldRT(out) {
                        return this.updateWorldTransform(), out = out || new Mat4(), Mat4.fromRT(out, this._rot, this._pos);
                    }
                }, {
                    key: "getAnchorPoint",
                    value: function getAnchorPoint(out) {
                        return (out = out || new Vec2()).set(this.uiTransfromComp.anchorPoint), out;
                    }
                }, {
                    key: "setAnchorPoint",
                    value: function setAnchorPoint(point, y) {
                        this.uiTransfromComp.setAnchorPoint(point, y);
                    }
                }, {
                    key: "getContentSize",
                    value: function getContentSize(out) {
                        return (out = out || new Size()).set(this.uiTransfromComp.contentSize), out;
                    }
                }, {
                    key: "setContentSize",
                    value: function setContentSize(size, height) {
                        this.uiTransfromComp.setContentSize(size, height);
                    }
                }, {
                    key: "on",
                    value: function on(type, callback, target, useCapture) {
                        switch (type) {
                          case SystemEventType.TRANSFORM_CHANGED:
                            this._eventMask |= 1;
                        }
                        this._eventProcessor.on(type, callback, target, useCapture);
                    }
                }, {
                    key: "off",
                    value: function off(type, callback, target, useCapture) {
                        if (this._eventProcessor.off(type, callback, target, useCapture), !this._eventProcessor.hasEventListener(type)) switch (type) {
                          case SystemEventType.TRANSFORM_CHANGED:
                            this._eventMask &= -2;
                        }
                    }
                }, {
                    key: "once",
                    value: function once(type, callback, target, useCapture) {
                        this._eventProcessor.once(type, callback, target, useCapture);
                    }
                }, {
                    key: "emit",
                    value: function emit(type) {
                        for (var _this$_eventProcessor, _len2 = arguments.length, args = new Array(1 < _len2 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) args[_key2 - 1] = arguments[_key2];
                        (_this$_eventProcessor = this._eventProcessor).emit.apply(_this$_eventProcessor, [ type ].concat(args));
                    }
                }, {
                    key: "dispatchEvent",
                    value: function dispatchEvent(event) {
                        this._eventProcessor.dispatchEvent(event);
                    }
                }, {
                    key: "hasEventListener",
                    value: function hasEventListener(type) {
                        return this._eventProcessor.hasEventListener(type);
                    }
                }, {
                    key: "targetOff",
                    value: function targetOff(target) {
                        this._eventProcessor.targetOff(target), 1 & this._eventMask && !this._eventProcessor.hasEventListener(SystemEventType.TRANSFORM_CHANGED) && (this._eventMask &= -2);
                    }
                }, {
                    key: "pauseSystemEvents",
                    value: function pauseSystemEvents(recursive) {
                        eventManager.pauseTarget(this, recursive);
                    }
                }, {
                    key: "resumeSystemEvents",
                    value: function resumeSystemEvents(recursive) {
                        eventManager.resumeTarget(this, recursive);
                    }
                }, {
                    key: "_onPostActivated",
                    value: function _onPostActivated(active) {
                        active ? (eventManager.resumeTarget(this), this.eventProcessor.reattach()) : eventManager.pauseTarget(this);
                    }
                }, {
                    key: "_onPreDestroy",
                    value: function _onPreDestroy() {
                        this._eventProcessor.destroy(), _get(_getPrototypeOf(Node.prototype), "_onPreDestroy", this).call(this);
                    }
                }, {
                    key: "position",
                    get: function get() {
                        return this._lpos;
                    },
                    set: function set(val) {
                        this.setPosition(val);
                    }
                }, {
                    key: "worldPosition",
                    get: function get() {
                        return this.updateWorldTransform(), this._pos;
                    },
                    set: function set(val) {
                        this.setWorldPosition(val);
                    }
                }, {
                    key: "rotation",
                    get: function get() {
                        return this._lrot;
                    },
                    set: function set(val) {
                        this.setRotation(val);
                    }
                }, {
                    key: "eulerAngles",
                    set: function set(val) {
                        this.setRotationFromEuler(val.x, val.y, val.z);
                    },
                    get: function get() {
                        return this._eulerDirty && (Quat.toEuler(this._euler, this._lrot), this._eulerDirty = !1), 
                        this._euler;
                    }
                }, {
                    key: "worldRotation",
                    get: function get() {
                        return this.updateWorldTransform(), this._rot;
                    },
                    set: function set(val) {
                        this.setWorldRotation(val);
                    }
                }, {
                    key: "scale",
                    get: function get() {
                        return this._lscale;
                    },
                    set: function set(val) {
                        this.setScale(val);
                    }
                }, {
                    key: "worldScale",
                    get: function get() {
                        return this.updateWorldTransform(), this._scale;
                    },
                    set: function set(val) {
                        this.setWorldScale(val);
                    }
                }, {
                    key: "matrix",
                    set: function set(val) {
                        Mat4.toRTS(val, this._lrot, this._lpos, this._lscale), this.invalidateChildren(TransformDirtyBit.TRS), 
                        this._eulerDirty = !0, 1 & this._eventMask && (this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.POSITION_PART), 
                        this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.ROTATION_PART), this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.SCALE_PART));
                    }
                }, {
                    key: "worldMatrix",
                    get: function get() {
                        return this.updateWorldTransform(), this._mat;
                    }
                }, {
                    key: "forward",
                    get: function get() {
                        return this.getWorldRotation(q_a), Vec3.transformQuat(new Vec3(), Vec3.UNIT_Z, q_a);
                    },
                    set: function set(dir) {
                        var len = dir.length();
                        Vec3.multiplyScalar(v3_a, dir, -1 / len), Quat.fromViewUp(q_a, v3_a), this.setWorldRotation(q_a);
                    }
                }, {
                    key: "layer",
                    set: function set(l) {
                        this._layer = l;
                    },
                    get: function get() {
                        return this._layer;
                    }
                }, {
                    key: "hasChangedFlags",
                    get: function get() {
                        return bookOfChange.get(this._id) || 0;
                    },
                    set: function set(val) {
                        bookOfChange.set(this._id, val);
                    }
                }, {
                    key: "uiTransfromComp",
                    get: function get() {
                        return this._uiTransfromComp || (this._uiTransfromComp = this.getComponent("cc.UITransformComponent")), 
                        this._uiTransfromComp;
                    },
                    set: function set(value) {
                        this._uiTransfromComp = value;
                    }
                }, {
                    key: "width",
                    get: function get() {
                        return this.uiTransfromComp.width;
                    },
                    set: function set(value) {
                        this.uiTransfromComp.width = value;
                    }
                }, {
                    key: "height",
                    get: function get() {
                        return this.uiTransfromComp.height;
                    },
                    set: function set(value) {
                        this.uiTransfromComp.height = value;
                    }
                }, {
                    key: "anchorX",
                    get: function get() {
                        return this.uiTransfromComp.anchorX;
                    },
                    set: function set(value) {
                        this.uiTransfromComp.anchorX = value;
                    }
                }, {
                    key: "anchorY",
                    get: function get() {
                        return this.uiTransfromComp.anchorY;
                    },
                    set: function set(value) {
                        this.uiTransfromComp.anchorY = value;
                    }
                }, {
                    key: "eventProcessor",
                    get: function get() {
                        return this._eventProcessor;
                    }
                } ], [ {
                    key: "isNode",
                    value: function isNode(obj) {
                        return obj instanceof Node && (obj.constructor === Node || !(obj instanceof cc.Scene));
                    }
                } ]), Node;
            }(), _class3$9.bookOfChange = bookOfChange, _class3$9.EventType = SystemEventType, 
            _class3$9.NodeSpace = NodeSpace, _class3$9.TransformDirtyBit = TransformDirtyBit, 
            _descriptor$b = _applyDecoratedDescriptor((_class2$d = _temp$f).prototype, "_lpos", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec3();
                }
            }), _descriptor2$7 = _applyDecoratedDescriptor(_class2$d.prototype, "_lrot", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Quat();
                }
            }), _descriptor3$5 = _applyDecoratedDescriptor(_class2$d.prototype, "_lscale", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec3(1, 1, 1);
                }
            }), _descriptor4$4 = _applyDecoratedDescriptor(_class2$d.prototype, "_layer", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Layers.Enum.DEFAULT;
                }
            }), _descriptor5$4 = _applyDecoratedDescriptor(_class2$d.prototype, "_euler", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec3();
                }
            }), _applyDecoratedDescriptor(_class2$d.prototype, "eulerAngles", [ _dec2$6 ], Object.getOwnPropertyDescriptor(_class2$d.prototype, "eulerAngles"), _class2$d.prototype), 
            _applyDecoratedDescriptor(_class2$d.prototype, "layer", [ property ], Object.getOwnPropertyDescriptor(_class2$d.prototype, "layer"), _class2$d.prototype), 
            _class$g = _class2$d)) || _class$g));
            cc.Node = Node$1;
            var _dec$h, _dec2$7, _dec3$2, _dec4$1, _class$h, _class2$e, _descriptor$c, _descriptor2$8, _descriptor3$6, _dec5$1, _dec6$1, _dec7$1, _dec8, _dec9, _dec10, _class4, _class5, _descriptor4$5, _descriptor5$5, _descriptor6$1, _descriptor7$1, _dec11, _dec12, _dec13, _dec14, _dec15, _class7, _class8, _descriptor8$1, _descriptor9$1, _descriptor10$1, _descriptor11, _dec16, _dec17, _dec18, _dec19, _class10, _class11, _descriptor12, _descriptor13, _descriptor14, Ambient = function() {
                function Ambient(scene) {
                    _classCallCheck(this, Ambient), this._enabled = !0, this._skyColor = Float32Array.from([ .2, .5, .8, 1 ]), 
                    this._skyIllum = Ambient.SKY_ILLUM, this._groundAlbedo = Float32Array.from([ .2, .2, .2, 1 ]), 
                    this._scene = void 0, this._scene = scene;
                }
                return _createClass(Ambient, [ {
                    key: "enabled",
                    set: function set(val) {
                        this._enabled = val;
                    },
                    get: function get() {
                        return this._enabled;
                    }
                }, {
                    key: "skyColor",
                    get: function get() {
                        return this._skyColor;
                    },
                    set: function set(color) {
                        this._skyColor = color;
                    }
                }, {
                    key: "skyIllum",
                    set: function set(illum) {
                        this._skyIllum = illum;
                    },
                    get: function get() {
                        return this._skyIllum;
                    }
                }, {
                    key: "groundAlbedo",
                    get: function get() {
                        return this._groundAlbedo;
                    },
                    set: function set(color) {
                        this._groundAlbedo = color;
                    }
                } ]), _createClass(Ambient, [ {
                    key: "update",
                    value: function update() {}
                } ]), Ambient;
            }();
            Ambient.SUN_ILLUM = 65e3, Ambient.SKY_ILLUM = 2e4;
            var _up = new Vec3(0, 1, 0), _v3 = new Vec3(), _qt = new Quat(), AmbientInfo = (_dec$h = ccclass("cc.AmbientInfo"), 
            _dec2$7 = property({
                type: Color
            }), _dec3$2 = property({
                type: CCFloat
            }), _dec4$1 = property({
                type: Color
            }), _dec$h((_descriptor$c = _applyDecoratedDescriptor((_class2$e = function() {
                function AmbientInfo() {
                    _classCallCheck(this, AmbientInfo), _initializerDefineProperty(this, "_skyColor", _descriptor$c, this), 
                    _initializerDefineProperty(this, "_skyIllum", _descriptor2$8, this), _initializerDefineProperty(this, "_groundAlbedo", _descriptor3$6, this), 
                    this._resource = null;
                }
                return _createClass(AmbientInfo, [ {
                    key: "skyColor",
                    set: function set(val) {
                        this._skyColor.set(val), this._resource && Color.toArray(this._resource.skyColor, this.skyColor);
                    },
                    get: function get() {
                        return this._skyColor;
                    }
                }, {
                    key: "skyIllum",
                    set: function set(val) {
                        this._skyIllum = val, this._resource && (this._resource.skyIllum = this.skyIllum);
                    },
                    get: function get() {
                        return this._skyIllum;
                    }
                }, {
                    key: "groundAlbedo",
                    set: function set(val) {
                        this._groundAlbedo.set(val), this._resource && Vec3.toArray(this._resource.groundAlbedo, this.groundAlbedo);
                    },
                    get: function get() {
                        return this._groundAlbedo;
                    }
                }, {
                    key: "renderScene",
                    set: function set(rs) {
                        this._resource = rs.ambient, this.skyColor = this._skyColor, this.skyIllum = this._skyIllum, 
                        this.groundAlbedo = this._groundAlbedo;
                    }
                } ]), AmbientInfo;
            }()).prototype, "_skyColor", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Color(51, 128, 204, 1);
                }
            }), _descriptor2$8 = _applyDecoratedDescriptor(_class2$e.prototype, "_skyIllum", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Ambient.SKY_ILLUM;
                }
            }), _descriptor3$6 = _applyDecoratedDescriptor(_class2$e.prototype, "_groundAlbedo", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Color(51, 51, 51, 255);
                }
            }), _applyDecoratedDescriptor(_class2$e.prototype, "skyColor", [ _dec2$7 ], Object.getOwnPropertyDescriptor(_class2$e.prototype, "skyColor"), _class2$e.prototype), 
            _applyDecoratedDescriptor(_class2$e.prototype, "skyIllum", [ _dec3$2 ], Object.getOwnPropertyDescriptor(_class2$e.prototype, "skyIllum"), _class2$e.prototype), 
            _applyDecoratedDescriptor(_class2$e.prototype, "groundAlbedo", [ _dec4$1 ], Object.getOwnPropertyDescriptor(_class2$e.prototype, "groundAlbedo"), _class2$e.prototype), 
            _class$h = _class2$e)) || _class$h);
            cc.AmbientInfo = AmbientInfo;
            var SkyboxInfo = (_dec5$1 = ccclass("cc.SkyboxInfo"), _dec6$1 = property(TextureCube), 
            _dec7$1 = property({
                type: CCBoolean
            }), _dec8 = property({
                type: CCBoolean
            }), _dec9 = property({
                type: TextureCube
            }), _dec10 = property({
                type: CCBoolean
            }), _dec5$1((_descriptor4$5 = _applyDecoratedDescriptor((_class5 = function() {
                function SkyboxInfo() {
                    _classCallCheck(this, SkyboxInfo), _initializerDefineProperty(this, "_envmap", _descriptor4$5, this), 
                    _initializerDefineProperty(this, "_isRGBE", _descriptor5$5, this), _initializerDefineProperty(this, "_enabled", _descriptor6$1, this), 
                    _initializerDefineProperty(this, "_useIBL", _descriptor7$1, this), this._resource = null;
                }
                return _createClass(SkyboxInfo, [ {
                    key: "enabled",
                    set: function set(val) {
                        this._enabled = val, this._resource && (this._resource.enabled = this._enabled);
                    },
                    get: function get() {
                        return this._enabled;
                    }
                }, {
                    key: "useIBL",
                    set: function set(val) {
                        this._useIBL = val, this._resource && (this._resource.useIBL = this._useIBL);
                    },
                    get: function get() {
                        return this._useIBL;
                    }
                }, {
                    key: "envmap",
                    set: function set(val) {
                        this._envmap = val, this._resource && (this._resource.envmap = this._envmap);
                    },
                    get: function get() {
                        return this._envmap;
                    }
                }, {
                    key: "isRGBE",
                    set: function set(val) {
                        this._isRGBE = val, this._resource && (this._resource.isRGBE = this._isRGBE);
                    },
                    get: function get() {
                        return this._isRGBE;
                    }
                }, {
                    key: "renderScene",
                    set: function set(val) {
                        this._resource = val.skybox, this.isRGBE = this._isRGBE, this.envmap = this._envmap, 
                        this.enabled = this._enabled, this.useIBL = this._useIBL;
                    }
                } ]), SkyboxInfo;
            }()).prototype, "_envmap", [ _dec6$1 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor5$5 = _applyDecoratedDescriptor(_class5.prototype, "_isRGBE", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor6$1 = _applyDecoratedDescriptor(_class5.prototype, "_enabled", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor7$1 = _applyDecoratedDescriptor(_class5.prototype, "_useIBL", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _applyDecoratedDescriptor(_class5.prototype, "enabled", [ _dec7$1 ], Object.getOwnPropertyDescriptor(_class5.prototype, "enabled"), _class5.prototype), 
            _applyDecoratedDescriptor(_class5.prototype, "useIBL", [ _dec8 ], Object.getOwnPropertyDescriptor(_class5.prototype, "useIBL"), _class5.prototype), 
            _applyDecoratedDescriptor(_class5.prototype, "envmap", [ _dec9 ], Object.getOwnPropertyDescriptor(_class5.prototype, "envmap"), _class5.prototype), 
            _applyDecoratedDescriptor(_class5.prototype, "isRGBE", [ _dec10 ], Object.getOwnPropertyDescriptor(_class5.prototype, "isRGBE"), _class5.prototype), 
            _class4 = _class5)) || _class4);
            cc.SkyboxInfo = SkyboxInfo;
            var PlanarShadowInfo = (_dec11 = ccclass("cc.PlanarShadowInfo"), _dec12 = property({
                type: CCBoolean
            }), _dec13 = property({
                type: Vec3
            }), _dec14 = property({
                type: CCFloat
            }), _dec15 = property({
                type: Color
            }), _dec11((_descriptor8$1 = _applyDecoratedDescriptor((_class8 = function() {
                function PlanarShadowInfo() {
                    _classCallCheck(this, PlanarShadowInfo), _initializerDefineProperty(this, "_enabled", _descriptor8$1, this), 
                    _initializerDefineProperty(this, "_normal", _descriptor9$1, this), _initializerDefineProperty(this, "_distance", _descriptor10$1, this), 
                    _initializerDefineProperty(this, "_shadowColor", _descriptor11, this), this._resource = null;
                }
                return _createClass(PlanarShadowInfo, [ {
                    key: "setPlaneFromNode",
                    value: function setPlaneFromNode(node) {
                        node.getWorldRotation(_qt), this.normal = Vec3.transformQuat(_v3, _up, _qt), node.getWorldPosition(_v3), 
                        this.distance = Vec3.dot(this._normal, _v3);
                    }
                }, {
                    key: "enabled",
                    set: function set(val) {
                        this._enabled = val, this._resource && (this._resource.enabled = val);
                    },
                    get: function get() {
                        return this._enabled;
                    }
                }, {
                    key: "normal",
                    set: function set(val) {
                        Vec3.copy(this._normal, val), this._resource && (this._resource.normal = val);
                    },
                    get: function get() {
                        return this._normal;
                    }
                }, {
                    key: "distance",
                    set: function set(val) {
                        this._distance = val, this._resource && (this._resource.distance = val);
                    },
                    get: function get() {
                        return this._distance;
                    }
                }, {
                    key: "shadowColor",
                    set: function set(val) {
                        this._shadowColor.set(val), this._resource && (this._resource.shadowColor = val);
                    },
                    get: function get() {
                        return this._shadowColor;
                    }
                }, {
                    key: "renderScene",
                    set: function set(val) {
                        this._resource = val.planarShadows, this.normal = this._normal, this.distance = this._distance, 
                        this.shadowColor = this._shadowColor, this.enabled = this._enabled;
                    }
                } ]), PlanarShadowInfo;
            }()).prototype, "_enabled", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor9$1 = _applyDecoratedDescriptor(_class8.prototype, "_normal", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec3(0, 1, 0);
                }
            }), _descriptor10$1 = _applyDecoratedDescriptor(_class8.prototype, "_distance", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor11 = _applyDecoratedDescriptor(_class8.prototype, "_shadowColor", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Color(0, 0, 0, 76);
                }
            }), _applyDecoratedDescriptor(_class8.prototype, "enabled", [ _dec12 ], Object.getOwnPropertyDescriptor(_class8.prototype, "enabled"), _class8.prototype), 
            _applyDecoratedDescriptor(_class8.prototype, "normal", [ _dec13 ], Object.getOwnPropertyDescriptor(_class8.prototype, "normal"), _class8.prototype), 
            _applyDecoratedDescriptor(_class8.prototype, "distance", [ _dec14 ], Object.getOwnPropertyDescriptor(_class8.prototype, "distance"), _class8.prototype), 
            _applyDecoratedDescriptor(_class8.prototype, "shadowColor", [ _dec15 ], Object.getOwnPropertyDescriptor(_class8.prototype, "shadowColor"), _class8.prototype), 
            _class7 = _class8)) || _class7);
            cc.PlanarShadowInfo = PlanarShadowInfo;
            var _class$i, _class2$f, _descriptor$d, _descriptor2$9, SceneGlobals = (_dec16 = ccclass("cc.SceneGlobals"), 
            _dec17 = property({
                type: AmbientInfo
            }), _dec18 = property({
                type: SkyboxInfo
            }), _dec19 = property({
                type: PlanarShadowInfo
            }), _dec16((_descriptor12 = _applyDecoratedDescriptor((_class11 = function() {
                function SceneGlobals() {
                    _classCallCheck(this, SceneGlobals), _initializerDefineProperty(this, "ambient", _descriptor12, this), 
                    _initializerDefineProperty(this, "skybox", _descriptor13, this), _initializerDefineProperty(this, "planarShadows", _descriptor14, this);
                }
                return _createClass(SceneGlobals, [ {
                    key: "renderScene",
                    set: function set(rs) {
                        this.ambient.renderScene = rs, this.skybox.renderScene = rs, this.planarShadows.renderScene = rs;
                    }
                } ]), SceneGlobals;
            }()).prototype, "ambient", [ _dec17 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new AmbientInfo();
                }
            }), _descriptor13 = _applyDecoratedDescriptor(_class11.prototype, "skybox", [ _dec18 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new SkyboxInfo();
                }
            }), _descriptor14 = _applyDecoratedDescriptor(_class11.prototype, "planarShadows", [ _dec19 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new PlanarShadowInfo();
                }
            }), _class10 = _class11)) || _class10);
            cc.SceneGlobals = SceneGlobals;
            var _class$j, Scene = exports("Scene", ccclass("cc.Scene")((_descriptor$d = _applyDecoratedDescriptor((_class2$f = function() {
                function Scene(name) {
                    var _this;
                    return _classCallCheck(this, Scene), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Scene).call(this, name)), "autoReleaseAssets", _descriptor$d, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_globals", _descriptor2$9, _assertThisInitialized(_this)), 
                    _this._renderScene = null, _this.dependAssets = null, _this._inited = void 0, _this._prefabSyncedInLiveReload = !1, 
                    _this._activeInHierarchy = !1, cc.director && cc.director.root && (_this._renderScene = cc.director.root.createScene({})), 
                    _this._inited = !cc.game || !cc.game._isCloning, _this;
                }
                return _inherits(Scene, Node$1), _createClass(Scene, [ {
                    key: "renderScene",
                    get: function get() {
                        return this._renderScene;
                    }
                }, {
                    key: "globals",
                    get: function get() {
                        return this._globals;
                    }
                } ]), _createClass(Scene, [ {
                    key: "destroy",
                    value: function destroy() {
                        var success = _get(_getPrototypeOf(Scene.prototype), "destroy", this).call(this);
                        return cc.director.root.destroyScene(this._renderScene), this._activeInHierarchy = !1, 
                        success;
                    }
                }, {
                    key: "_onHierarchyChanged",
                    value: function _onHierarchyChanged() {}
                }, {
                    key: "_instantiate",
                    value: function _instantiate() {}
                }, {
                    key: "_load",
                    value: function _load() {
                        this._inited || (this._onBatchCreated(), this._inited = !0), this.walk(BaseNode._setScene);
                    }
                }, {
                    key: "_activate",
                    value: function _activate(active) {
                        active = !1 !== active, cc.director._nodeActivator.activateNode(this, active), this._globals.renderScene = this._renderScene;
                    }
                } ]), Scene;
            }()).prototype, "autoReleaseAssets", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor2$9 = _applyDecoratedDescriptor(_class2$f.prototype, "_globals", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new SceneGlobals();
                }
            }), _class$i = _class2$f)) || _class$i);
            cc.Scene = Scene;
            var HideInHierarchy$1 = CCObject.Flags.HideInHierarchy, PrivateNode = exports("PrivateNode", ccclass("cc.PrivateNode")(_class$j = function() {
                function PrivateNode(name) {
                    var _this;
                    return _classCallCheck(this, PrivateNode), (_this = _possibleConstructorReturn(this, _getPrototypeOf(PrivateNode).call(this, name)))._objFlags |= HideInHierarchy$1, 
                    _this;
                }
                return _inherits(PrivateNode, Node$1), PrivateNode;
            }()) || _class$j);
            cc.PrivateNode = PrivateNode;
            var fastRemoveAt$2 = array.fastRemoveAt, IsStartCalled$1 = CCObject.Flags.IsStartCalled, IsOnEnableCalled$2 = CCObject.Flags.IsOnEnableCalled, callStart = (CCObject.Flags.IsEditorOnEnableCalled, 
            "c.start();c._objFlags|=" + IsStartCalled$1);
            function sortedIndex(array, comp) {
                for (var order = comp.constructor._executionOrder, id = comp._id, l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
                    var test = array[m], testOrder = test.constructor._executionOrder;
                    if (order < testOrder) h = m - 1; else if (testOrder < order) l = m + 1; else {
                        var testId = test._id;
                        if (id < testId) h = m - 1; else {
                            if (!(testId < id)) return m;
                            l = m + 1;
                        }
                    }
                }
                return ~l;
            }
            function stableRemoveInactive(iterator, flagToClear) {
                for (var array = iterator.array, next = iterator.i + 1; next < array.length; ) {
                    var comp = array[next];
                    comp._enabled && comp.node._activeInHierarchy ? ++next : (iterator.removeAt(next), 
                    flagToClear && (comp._objFlags &= ~flagToClear));
                }
            }
            function LifeCycleInvoker(invokeFunc) {
                _classCallCheck(this, LifeCycleInvoker), this._zero = void 0, this._neg = void 0, 
                this._pos = void 0, this._invoke = void 0;
                var Iterator = MutableForwardIterator;
                this._zero = new Iterator([]), this._neg = new Iterator([]), this._pos = new Iterator([]), 
                this._invoke = invokeFunc;
            }
            function compareOrder(a, b) {
                return a.constructor._executionOrder - b.constructor._executionOrder;
            }
            LifeCycleInvoker.stableRemoveInactive = stableRemoveInactive;
            var OneOffInvoker = function() {
                function OneOffInvoker() {
                    return _classCallCheck(this, OneOffInvoker), _possibleConstructorReturn(this, _getPrototypeOf(OneOffInvoker).apply(this, arguments));
                }
                return _inherits(OneOffInvoker, LifeCycleInvoker), _createClass(OneOffInvoker, [ {
                    key: "add",
                    value: function add(comp) {
                        var order = comp.constructor._executionOrder;
                        (0 === order ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
                    }
                }, {
                    key: "remove",
                    value: function remove(comp) {
                        var order = comp.constructor._executionOrder;
                        (0 === order ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
                    }
                }, {
                    key: "cancelInactive",
                    value: function cancelInactive(flagToClear) {
                        stableRemoveInactive(this._zero, flagToClear), stableRemoveInactive(this._neg, flagToClear), 
                        stableRemoveInactive(this._pos, flagToClear);
                    }
                }, {
                    key: "invoke",
                    value: function invoke() {
                        var compsNeg = this._neg;
                        0 < compsNeg.array.length && (compsNeg.array.sort(compareOrder), this._invoke(compsNeg), 
                        compsNeg.array.length = 0), this._invoke(this._zero), this._zero.array.length = 0;
                        var compsPos = this._pos;
                        0 < compsPos.array.length && (compsPos.array.sort(compareOrder), this._invoke(compsPos), 
                        compsPos.array.length = 0);
                    }
                } ]), OneOffInvoker;
            }(), ReusableInvoker = function() {
                function ReusableInvoker() {
                    return _classCallCheck(this, ReusableInvoker), _possibleConstructorReturn(this, _getPrototypeOf(ReusableInvoker).apply(this, arguments));
                }
                return _inherits(ReusableInvoker, LifeCycleInvoker), _createClass(ReusableInvoker, [ {
                    key: "add",
                    value: function add(comp) {
                        var order = comp.constructor._executionOrder;
                        if (0 === order) this._zero.array.push(comp); else {
                            var _array = order < 0 ? this._neg.array : this._pos.array, i = sortedIndex(_array, comp);
                            i < 0 && _array.splice(~i, 0, comp);
                        }
                    }
                }, {
                    key: "remove",
                    value: function remove(comp) {
                        var order = comp.constructor._executionOrder;
                        if (0 === order) this._zero.fastRemove(comp); else {
                            var iterator = order < 0 ? this._neg : this._pos, i = sortedIndex(iterator.array, comp);
                            0 <= i && iterator.removeAt(i);
                        }
                    }
                }, {
                    key: "invoke",
                    value: function invoke(dt) {
                        0 < this._neg.array.length && this._invoke(this._neg, dt), this._invoke(this._zero, dt), 
                        0 < this._pos.array.length && this._invoke(this._pos, dt);
                    }
                } ]), ReusableInvoker;
            }();
            function createInvokeImpl(funcOrCode, useDt) {
                if ("function" == typeof funcOrCode) return useDt ? function(iterator, dt) {
                    var array = iterator.array;
                    for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                        var comp = array[iterator.i];
                        funcOrCode(comp, dt);
                    }
                } : function(iterator) {
                    var array = iterator.array;
                    for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                        var comp = array[iterator.i];
                        funcOrCode(comp);
                    }
                };
                var body = "var a=it.array;for(it.i=0;it.i<a.length;++it.i){var c=a[it.i];" + funcOrCode + "}";
                return useDt ? Function("it", "dt", body) : Function("it", body);
            }
            var ComponentScheduler = function() {
                function ComponentScheduler() {
                    _classCallCheck(this, ComponentScheduler), this.startInvoker = void 0, this.updateInvoker = void 0, 
                    this.lateUpdateInvoker = void 0, this.scheduleInNextFrame = void 0, this._updating = void 0, 
                    this.unscheduleAll();
                }
                return _createClass(ComponentScheduler, [ {
                    key: "unscheduleAll",
                    value: function unscheduleAll() {
                        this.startInvoker = new OneOffInvoker(createInvokeImpl(callStart)), this.updateInvoker = new ReusableInvoker(createInvokeImpl("c.update(dt)", !0)), 
                        this.lateUpdateInvoker = new ReusableInvoker(createInvokeImpl("c.lateUpdate(dt)", !0)), 
                        this.scheduleInNextFrame = [], this._updating = !1;
                    }
                }, {
                    key: "_onEnabled",
                    value: function _onEnabled(comp) {
                        cc.director.getScheduler().resumeTarget(comp), comp._objFlags |= IsOnEnableCalled$2, 
                        this._updating ? this.scheduleInNextFrame.push(comp) : this._scheduleImmediate(comp);
                    }
                }, {
                    key: "_onDisabled",
                    value: function _onDisabled(comp) {
                        cc.director.getScheduler().pauseTarget(comp), comp._objFlags &= ~IsOnEnableCalled$2;
                        var index = this.scheduleInNextFrame.indexOf(comp);
                        0 <= index ? fastRemoveAt$2(this.scheduleInNextFrame, index) : (!comp.start || comp._objFlags & IsStartCalled$1 || this.startInvoker.remove(comp), 
                        comp.update && this.updateInvoker.remove(comp), comp.lateUpdate && this.lateUpdateInvoker.remove(comp));
                    }
                }, {
                    key: "enableComp",
                    value: function enableComp(comp, invoker) {
                        if (!(comp._objFlags & IsOnEnableCalled$2)) {
                            if (comp.onEnable) {
                                if (invoker) return void invoker.add(comp);
                                if (comp.onEnable(), !comp.node._activeInHierarchy) return;
                            }
                            this._onEnabled(comp);
                        }
                    }
                }, {
                    key: "disableComp",
                    value: function disableComp(comp) {
                        comp._objFlags & IsOnEnableCalled$2 && (comp.onDisable && comp.onDisable(), this._onDisabled(comp));
                    }
                }, {
                    key: "startPhase",
                    value: function startPhase() {
                        this._updating = !0, 0 < this.scheduleInNextFrame.length && this._deferredSchedule(), 
                        this.startInvoker.invoke();
                    }
                }, {
                    key: "updatePhase",
                    value: function updatePhase(dt) {
                        this.updateInvoker.invoke(dt);
                    }
                }, {
                    key: "lateUpdatePhase",
                    value: function lateUpdatePhase(dt) {
                        this.lateUpdateInvoker.invoke(dt), this._updating = !1;
                    }
                }, {
                    key: "_scheduleImmediate",
                    value: function _scheduleImmediate(comp) {
                        !comp.start || comp._objFlags & IsStartCalled$1 || this.startInvoker.add(comp), 
                        comp.update && this.updateInvoker.add(comp), comp.lateUpdate && this.lateUpdateInvoker.add(comp);
                    }
                }, {
                    key: "_deferredSchedule",
                    value: function _deferredSchedule() {
                        for (var comps = this.scheduleInNextFrame, i = 0, len = comps.length; i < len; i++) {
                            var comp = comps[i];
                            this._scheduleImmediate(comp);
                        }
                        comps.length = 0;
                    }
                } ]), ComponentScheduler;
            }();
            ComponentScheduler.LifeCycleInvoker = LifeCycleInvoker, ComponentScheduler.OneOffInvoker = OneOffInvoker, 
            ComponentScheduler.createInvokeImpl = createInvokeImpl, ComponentScheduler.invokeOnEnable = function(iterator) {
                var compScheduler = cc.director._compScheduler, array = iterator.array;
                for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                    var comp = array[iterator.i];
                    if (comp._enabled) comp.onEnable(), comp.node._activeInHierarchy && compScheduler._onEnabled(comp);
                }
            };
            var IsPreloadStarted$1 = CCObject.Flags.IsPreloadStarted, IsOnLoadStarted$1 = CCObject.Flags.IsOnLoadStarted, IsOnLoadCalled$2 = CCObject.Flags.IsOnLoadCalled, Deactivating$2 = CCObject.Flags.Deactivating, callOnLoad = "c.onLoad();c._objFlags|=" + IsOnLoadCalled$2, UnsortedInvoker = function() {
                function UnsortedInvoker() {
                    return _classCallCheck(this, UnsortedInvoker), _possibleConstructorReturn(this, _getPrototypeOf(UnsortedInvoker).apply(this, arguments));
                }
                return _inherits(UnsortedInvoker, ComponentScheduler.LifeCycleInvoker), _createClass(UnsortedInvoker, [ {
                    key: "add",
                    value: function add(comp) {
                        this._zero.array.push(comp);
                    }
                }, {
                    key: "remove",
                    value: function remove(comp) {
                        this._zero.fastRemove(comp);
                    }
                }, {
                    key: "cancelInactive",
                    value: function cancelInactive(flagToClear) {
                        ComponentScheduler.LifeCycleInvoker.stableRemoveInactive(this._zero, flagToClear);
                    }
                }, {
                    key: "invoke",
                    value: function invoke() {
                        this._invoke(this._zero), this._zero.array.length = 0;
                    }
                } ]), UnsortedInvoker;
            }(), invokePreload = ComponentScheduler.createInvokeImpl("c.__preload();"), invokeOnLoad = ComponentScheduler.createInvokeImpl(callOnLoad), activateTasksPool = new Pool(4);
            function _componentCorrupted(node, comp, index) {
                comp ? node._removeComponent(comp) : array.removeAt(node._components, index);
            }
            activateTasksPool.get = function getActivateTask() {
                var task = this._get() || {
                    preload: new UnsortedInvoker(invokePreload),
                    onLoad: new ComponentScheduler.OneOffInvoker(invokeOnLoad),
                    onEnable: new ComponentScheduler.OneOffInvoker(ComponentScheduler.invokeOnEnable)
                };
                task.preload._zero.i = -1;
                var invoker = task.onLoad;
                return invoker._zero.i = -1, invoker._neg.i = -1, invoker._pos.i = -1, (invoker = task.onEnable)._zero.i = -1, 
                invoker._neg.i = -1, invoker._pos.i = -1, task;
            };
            var NodeActivator = exports("NodeActivator", function() {
                function NodeActivator() {
                    _classCallCheck(this, NodeActivator), this.resetComp = void 0, this._activatingStack = void 0, 
                    this.reset();
                }
                return _createClass(NodeActivator, [ {
                    key: "reset",
                    value: function reset() {
                        this._activatingStack = [];
                    }
                }, {
                    key: "activateNode",
                    value: function activateNode(node, active) {
                        if (active) {
                            var task = activateTasksPool.get();
                            this._activatingStack.push(task), this._activateNodeRecursively(node, task.preload, task.onLoad, task.onEnable), 
                            task.preload.invoke(), task.onLoad.invoke(), task.onEnable.invoke(), this._activatingStack.pop(), 
                            activateTasksPool.put(task);
                        } else {
                            this._deactivateNodeRecursively(node);
                            var _iterator = this._activatingStack, _isArray = Array.isArray(_iterator), _i = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i >= _iterator.length) break;
                                    _ref = _iterator[_i++];
                                } else {
                                    if ((_i = _iterator.next()).done) break;
                                    _ref = _i.value;
                                }
                                var lastTask = _ref;
                                lastTask.preload.cancelInactive(IsPreloadStarted$1), lastTask.onLoad.cancelInactive(IsOnLoadStarted$1), 
                                lastTask.onEnable.cancelInactive();
                            }
                        }
                        node.emit("active-in-hierarchy-changed", node);
                    }
                }, {
                    key: "activateComp",
                    value: function activateComp(comp, preloadInvoker, onLoadInvoker, onEnableInvoker) {
                        if (comp._objFlags & IsPreloadStarted$1 || (comp._objFlags |= IsPreloadStarted$1, 
                        comp.__preload && (preloadInvoker ? preloadInvoker.add(comp) : comp.__preload())), 
                        comp._objFlags & IsOnLoadStarted$1 || (comp._objFlags |= IsOnLoadStarted$1, comp.onLoad ? onLoadInvoker ? onLoadInvoker.add(comp) : (comp.onLoad(), 
                        comp._objFlags |= IsOnLoadCalled$2) : comp._objFlags |= IsOnLoadCalled$2), comp._enabled) {
                            if (!comp.node._activeInHierarchy) return;
                            cc.director._compScheduler.enableComp(comp, onEnableInvoker);
                        }
                    }
                }, {
                    key: "destroyComp",
                    value: function destroyComp(comp) {
                        cc.director._compScheduler.disableComp(comp), comp.onDestroy && comp._objFlags & IsOnLoadCalled$2 && comp.onDestroy();
                    }
                }, {
                    key: "_activateNodeRecursively",
                    value: function _activateNodeRecursively(node, preloadInvoker, onLoadInvoker, onEnableInvoker) {
                        if (node._objFlags & Deactivating$2) cc.errorID(3816, node.name); else {
                            node._activeInHierarchy = !0;
                            for (var originCount = node._components.length, i = 0; i < originCount; ++i) {
                                var component = node._components[i];
                                component instanceof cc.Component ? this.activateComp(component, preloadInvoker, onLoadInvoker, onEnableInvoker) : (_componentCorrupted(node, component, i), 
                                --i, --originCount);
                            }
                            node._childArrivalOrder = node._children.length;
                            for (var _i2 = 0, len = node._children.length; _i2 < len; ++_i2) {
                                var child = node._children[_i2];
                                child._active && this._activateNodeRecursively(child, preloadInvoker, onLoadInvoker, onEnableInvoker);
                            }
                            node._onPostActivated(!0);
                        }
                    }
                }, {
                    key: "_deactivateNodeRecursively",
                    value: function _deactivateNodeRecursively(node) {
                        node._objFlags |= Deactivating$2, node._activeInHierarchy = !1;
                        for (var originCount = node._components.length, c = 0; c < originCount; ++c) {
                            var component = node._components[c];
                            if (component._enabled && (cc.director._compScheduler.disableComp(component), node._activeInHierarchy)) return void (node._objFlags &= ~Deactivating$2);
                        }
                        for (var i = 0, len = node._children.length; i < len; ++i) {
                            var child = node._children[i];
                            if (child._activeInHierarchy && (this._deactivateNodeRecursively(child), node._activeInHierarchy)) return void (node._objFlags &= ~Deactivating$2);
                        }
                        node._onPostActivated(!1), node._objFlags &= ~Deactivating$2;
                    }
                } ]), NodeActivator;
            }());
            replaceProperty(BaseNode.prototype, "BaseNode", [ {
                name: "childrenCount",
                newName: "children.length",
                customGetter: function customGetter() {
                    return this.children.length;
                }
            } ]), removeProperty(Node$1.prototype, "Node.prototype", [ {
                name: "addLayer"
            }, {
                name: "removeLayer"
            } ]), removeProperty(Layers, "Layers", [ {
                name: "All"
            }, {
                name: "RaycastMask"
            }, {
                name: "check"
            } ]), replaceProperty(Layers, "Layers", [ {
                name: "Default",
                newName: "DEFAULT",
                target: Layers.Enum,
                targetName: "Layers.Enum"
            }, {
                name: "Always",
                newName: "ALWAYS",
                target: Layers.Enum,
                targetName: "Layers.Enum"
            }, {
                name: "IgnoreRaycast",
                newName: "IGNORE_RAYCAST",
                target: Layers.Enum,
                targetName: "Layers.Enum"
            }, {
                name: "Gizmos",
                newName: "GIZMOS",
                target: Layers.Enum,
                targetName: "Layers.Enum"
            }, {
                name: "Editor",
                newName: "EDITOR",
                target: Layers.Enum,
                targetName: "Layers.Enum"
            }, {
                name: "UI",
                newName: "UI_3D",
                target: Layers.Enum,
                targetName: "Layers.Enum"
            }, {
                name: "UI2D",
                newName: "UI_2D",
                target: Layers.Enum,
                targetName: "Layers.Enum"
            }, {
                name: "SceneGizmo",
                newName: "SCENE_GIZMO",
                target: Layers.Enum,
                targetName: "Layers.Enum"
            }, {
                name: "makeInclusiveMask",
                newName: "makeMaskInclude",
                target: Layers,
                targetName: "Layers"
            }, {
                name: "makeExclusiveMask",
                newName: "makeMaskExclude",
                target: Layers,
                targetName: "Layers"
            } ]), removeProperty(Layers.Enum, "Layers.Enum", [ {
                name: "ALWAYS"
            } ]), removeProperty(Layers.BitMask, "Layers.BitMask", [ {
                name: "ALWAYS"
            } ]);
            var _vec4Array = new Float32Array(4), _v3tmp = (new Mat4(), new Vec3()), _v4Zero = new Vec4(0, 0, 0, 0), RenderPipeline = function() {
                function RenderPipeline(root) {
                    _classCallCheck(this, RenderPipeline), this._root = void 0, this._device = void 0, 
                    this._name = "BasePipeline", this._renderObjects = [], this._renderPasses = new Map(), 
                    this._flows = [], this._isHDRSupported = !1, this._isHDR = !1, this._lightMeterScale = 1e4, 
                    this._shadingPass = null, this._fboCount = 0, this._msaaShadingTex = null, this._msaaShadingTexView = null, 
                    this._msaaDepthStencilTex = null, this._msaaDepthStencilTexView = null, this._msaaShadingFBO = null, 
                    this._colorFmt = GFXFormat.UNKNOWN, this._depthStencilFmt = GFXFormat.UNKNOWN, this._shadingTextures = [], 
                    this._shadingTexViews = [], this._depthStencilTex = null, this._depthStencilTexView = null, 
                    this._shadingFBOs = [], this._shadingWidth = 0, this._shadingHeight = 0, this._shadingScale = 1, 
                    this._curIdx = 0, this._prevIdx = 1, this._usePostProcess = !1, this._useMSAA = !1, 
                    this._useSMAA = !1, this._smaaPass = null, this._smaaEdgeFBO = null, this._smaaEdgeTex = null, 
                    this._smaaEdgeTexView = null, this._smaaBlendFBO = null, this._smaaBlendTex = null, 
                    this._smaaBlendTexView = null, this._quadVB = null, this._quadIB = null, this._quadIA = null, 
                    this._uboGlobal = new UBOGlobal(), this._globalBindings = new Map(), this._defaultTex = null, 
                    this._defaultTexView = null, this._fpScale = 1 / 1024, this._fpScaleInv = 1024, 
                    this._macros = {}, this._useDynamicBatching = !1, this._root = root, this._device = root.device;
                }
                return _createClass(RenderPipeline, [ {
                    key: "root",
                    get: function get() {
                        return this._root;
                    }
                }, {
                    key: "device",
                    get: function get() {
                        return this._device;
                    }
                }, {
                    key: "name",
                    get: function get() {
                        return this._name;
                    }
                }, {
                    key: "renderObjects",
                    get: function get() {
                        return this._renderObjects;
                    }
                }, {
                    key: "flows",
                    get: function get() {
                        return this._flows;
                    }
                }, {
                    key: "usePostProcess",
                    get: function get() {
                        return this._usePostProcess;
                    }
                }, {
                    key: "isHDRSupported",
                    get: function get() {
                        return this._isHDRSupported;
                    }
                }, {
                    key: "isHDR",
                    get: function get() {
                        return this._isHDR;
                    }
                }, {
                    key: "shadingScale",
                    get: function get() {
                        return this._shadingScale;
                    }
                }, {
                    key: "lightMeterScale",
                    set: function set(scale) {
                        this._lightMeterScale = scale;
                    },
                    get: function get() {
                        return this._lightMeterScale;
                    }
                }, {
                    key: "depthStencilTexView",
                    get: function get() {
                        return this._depthStencilTexView;
                    }
                }, {
                    key: "curShadingTexView",
                    get: function get() {
                        return this._shadingTexViews[this._curIdx];
                    }
                }, {
                    key: "prevShadingTexView",
                    get: function get() {
                        return this._shadingTexViews[this._prevIdx];
                    }
                }, {
                    key: "curShadingFBO",
                    get: function get() {
                        return this._shadingFBOs[this._curIdx];
                    }
                }, {
                    key: "prevShadingFBO",
                    get: function get() {
                        return this._shadingFBOs[this._prevIdx];
                    }
                }, {
                    key: "msaaShadingFBO",
                    get: function get() {
                        return this._msaaShadingFBO;
                    }
                }, {
                    key: "useMSAA",
                    get: function get() {
                        return this._useMSAA;
                    }
                }, {
                    key: "useSMAA",
                    get: function get() {
                        return this._useSMAA;
                    }
                }, {
                    key: "smaaEdgeTexView",
                    get: function get() {
                        return this._smaaEdgeTexView;
                    }
                }, {
                    key: "smaaEdgeFBO",
                    get: function get() {
                        return this._smaaEdgeFBO;
                    }
                }, {
                    key: "smaaBlendTexView",
                    get: function get() {
                        return this._smaaBlendTexView;
                    }
                }, {
                    key: "smaaBlendFBO",
                    get: function get() {
                        return this._smaaBlendFBO;
                    }
                }, {
                    key: "quadIA",
                    get: function get() {
                        return this._quadIA;
                    }
                }, {
                    key: "globalBindings",
                    get: function get() {
                        return this._globalBindings;
                    }
                }, {
                    key: "defaultTexture",
                    get: function get() {
                        return this._defaultTex;
                    }
                }, {
                    key: "fpScale",
                    get: function get() {
                        return this._fpScale;
                    }
                }, {
                    key: "fpScaleInv",
                    get: function get() {
                        return this._fpScaleInv;
                    }
                }, {
                    key: "macros",
                    get: function get() {
                        return this._macros;
                    }
                }, {
                    key: "defaultGlobalUBOData",
                    get: function get() {
                        return this._uboGlobal.view;
                    }
                }, {
                    key: "useDynamicBatching",
                    get: function get() {
                        return this._useDynamicBatching;
                    }
                } ]), _createClass(RenderPipeline, [ {
                    key: "render",
                    value: function render(view) {
                        view.camera.update(), this.sceneCulling(view), this.updateUBOs(view);
                        var _iterator = view.flows, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            _ref.render(view);
                        }
                    }
                }, {
                    key: "rebuild",
                    value: function rebuild() {
                        this.updateMacros();
                    }
                }, {
                    key: "resize",
                    value: function resize(width, height) {
                        var w = Math.floor(width * this._shadingScale), h = Math.floor(height * this._shadingScale);
                        (w > this._shadingWidth || h > this._shadingHeight) && this.resizeFBOs(w, h);
                        var _iterator2 = this._flows, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            _ref2.resize(width, height);
                        }
                    }
                }, {
                    key: "swapFBOs",
                    value: function swapFBOs() {
                        var temp = this._curIdx;
                        this._curIdx = this._prevIdx, this._prevIdx = temp;
                    }
                }, {
                    key: "addRenderPass",
                    value: function addRenderPass(stage, renderPass) {
                        renderPass && this._renderPasses.set(stage, renderPass);
                    }
                }, {
                    key: "getRenderPass",
                    value: function getRenderPass(stage) {
                        var renderPass = this._renderPasses.get(stage);
                        return renderPass || null;
                    }
                }, {
                    key: "removeRenderPass",
                    value: function removeRenderPass(stage) {
                        this._renderPasses.delete(stage);
                    }
                }, {
                    key: "clearRenderPasses",
                    value: function clearRenderPasses() {
                        this._renderPasses.clear();
                    }
                }, {
                    key: "createFlow",
                    value: function createFlow(clazz, info) {
                        var flow = new clazz(this);
                        return flow.initialize(info) ? (this._flows.push(flow), this._flows.sort(function(a, b) {
                            return a.priority - b.priority;
                        }), flow) : null;
                    }
                }, {
                    key: "destroyFlows",
                    value: function destroyFlows() {
                        var _iterator3 = this._flows, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i3 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i3++];
                            } else {
                                if ((_i3 = _iterator3.next()).done) break;
                                _ref3 = _i3.value;
                            }
                            _ref3.destroy();
                        }
                        this._flows = [];
                    }
                }, {
                    key: "getFlow",
                    value: function getFlow(name) {
                        var _iterator4 = this._flows, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                        for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                            var _ref4;
                            if (_isArray4) {
                                if (_i4 >= _iterator4.length) break;
                                _ref4 = _iterator4[_i4++];
                            } else {
                                if ((_i4 = _iterator4.next()).done) break;
                                _ref4 = _i4.value;
                            }
                            var flow = _ref4;
                            if (flow.name === name) return flow;
                        }
                        return null;
                    }
                }, {
                    key: "updateMacros",
                    value: function updateMacros() {
                        programLib.destroyShaderByDefines(this._macros), this._macros.CC_USE_HDR = this._isHDR;
                        var _iterator5 = this._root.scenes, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                            var _ref5;
                            if (_isArray5) {
                                if (_i5 >= _iterator5.length) break;
                                _ref5 = _iterator5[_i5++];
                            } else {
                                if ((_i5 = _iterator5.next()).done) break;
                                _ref5 = _i5.value;
                            }
                            _ref5.onPipelineChange();
                        }
                    }
                }, {
                    key: "_initialize",
                    value: function _initialize(info) {
                        if (void 0 !== info.enablePostProcess ? this._usePostProcess = info.enablePostProcess : this._usePostProcess = !1, 
                        this._usePostProcess && ((this._device.hasFeature(GFXFeature.FORMAT_R11G11B10F) || this._device.hasFeature(GFXFeature.TEXTURE_HALF_FLOAT) || this._device.hasFeature(GFXFeature.TEXTURE_FLOAT)) && (this._isHDRSupported = !0), 
                        this._fboCount = 1, this._shadingTextures = new Array(this._fboCount), this._shadingTexViews = new Array(this._fboCount), 
                        this._shadingFBOs = new Array(this._fboCount), this._isHDR = void 0 === info.enableHDR || info.enableHDR, 
                        this._useSMAA = void 0 !== info.enableSMAA && info.enableSMAA, this._useMSAA = void 0 !== info.enableMSAA && info.enableMSAA, 
                        this._useMSAA && (this._useMSAA = this.device.hasFeature(GFXFeature.MSAA))), this._isHDR && this._isHDRSupported && (this._device.hasFeature(GFXFeature.COLOR_HALF_FLOAT) && this._device.hasFeature(GFXFeature.TEXTURE_HALF_FLOAT_LINEAR) ? this._device.hasFeature(GFXFeature.FORMAT_R11G11B10F) ? (this._colorFmt = GFXFormat.R11G11B10F, 
                        this._isHDR = !0) : this._device.hasFeature(GFXFeature.TEXTURE_HALF_FLOAT) && (this._colorFmt = GFXFormat.RGBA16F, 
                        this._isHDR = !0) : this._device.hasFeature(GFXFeature.COLOR_FLOAT) && this._device.hasFeature(GFXFeature.TEXTURE_FLOAT_LINEAR) && this._device.hasFeature(GFXFeature.TEXTURE_FLOAT) && (this._colorFmt = GFXFormat.RGBA32F, 
                        this._isHDR = !0), this._isHDR = !1), this._isHDR || (this._colorFmt = GFXFormat.RGBA8), 
                        24 === this._device.depthBits ? 8 === this._device.stencilBits ? this._depthStencilFmt = GFXFormat.D24S8 : this._depthStencilFmt = GFXFormat.D24 : this._depthStencilFmt = GFXFormat.D16, 
                        this.updateMacros(), this._shadingScale = 1, this._shadingWidth = Math.floor(this._device.nativeWidth), 
                        this._shadingHeight = Math.floor(this._device.nativeHeight), console.info("USE_POST_PROCESS: " + this._usePostProcess), 
                        this._usePostProcess && (console.info("USE_MSAA: " + this._useMSAA), console.info("USE_SMAA: " + this._useSMAA), 
                        console.info("USE_HDR: " + this._isHDR)), console.info("SHADING_SIZE: " + this._shadingWidth + " x " + this._shadingHeight), 
                        console.info("SHADING_SCALE: " + this._shadingScale.toFixed(4)), console.info("SHADING_COLOR_FORMAT: " + GFXFormatInfos[this._colorFmt].name), 
                        console.info("SHADING_DEPTH_FORMAT: " + GFXFormatInfos[this._depthStencilFmt].name), 
                        this._shadingPass = this._device.createRenderPass({
                            colorAttachments: [ {
                                format: this._colorFmt,
                                loadOp: GFXLoadOp.CLEAR,
                                storeOp: GFXStoreOp.STORE,
                                sampleCount: 1,
                                beginLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL,
                                endLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL
                            } ],
                            depthStencilAttachment: {
                                format: this._depthStencilFmt,
                                depthLoadOp: GFXLoadOp.CLEAR,
                                depthStoreOp: GFXStoreOp.STORE,
                                stencilLoadOp: GFXLoadOp.CLEAR,
                                stencilStoreOp: GFXStoreOp.STORE,
                                sampleCount: 1,
                                beginLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
                                endLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL
                            }
                        }), this._useMSAA && (this._msaaShadingTex = this._device.createTexture({
                            type: GFXTextureType.TEX2D,
                            usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                            format: this._colorFmt,
                            width: this._shadingWidth,
                            height: this._shadingHeight
                        }), this._msaaShadingTexView = this._device.createTextureView({
                            texture: this._msaaShadingTex,
                            type: GFXTextureViewType.TV2D,
                            format: this._colorFmt
                        }), this._msaaDepthStencilTex = this._device.createTexture({
                            type: GFXTextureType.TEX2D,
                            usage: GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                            format: this._depthStencilFmt,
                            width: this._shadingWidth,
                            height: this._shadingHeight
                        }), this._msaaDepthStencilTexView = this._device.createTextureView({
                            texture: this._msaaDepthStencilTex,
                            type: GFXTextureViewType.TV2D,
                            format: this._depthStencilFmt
                        }), this._msaaShadingFBO = this._device.createFramebuffer({
                            renderPass: this._shadingPass,
                            colorViews: [ this._msaaShadingTexView ],
                            depthStencilView: this._msaaDepthStencilTexView
                        })), 0 < this._fboCount) {
                            this._depthStencilTex = this._device.createTexture({
                                type: GFXTextureType.TEX2D,
                                usage: GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                                format: this._depthStencilFmt,
                                width: this._shadingWidth,
                                height: this._shadingHeight
                            }), this._depthStencilTexView = this._device.createTextureView({
                                texture: this._depthStencilTex,
                                type: GFXTextureViewType.TV2D,
                                format: this._depthStencilFmt
                            });
                            for (var i = 0; i < this._fboCount; ++i) this._shadingTextures[i] = this._device.createTexture({
                                type: GFXTextureType.TEX2D,
                                usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                                format: this._colorFmt,
                                width: this._shadingWidth,
                                height: this._shadingHeight
                            }), this._shadingTexViews[i] = this._device.createTextureView({
                                texture: this._shadingTextures[i],
                                type: GFXTextureViewType.TV2D,
                                format: this._colorFmt
                            }), this._shadingFBOs[i] = this._device.createFramebuffer({
                                renderPass: this._shadingPass,
                                colorViews: [ this._shadingTexViews[i] ],
                                depthStencilView: this._depthStencilTexView
                            });
                        }
                        if (this._useSMAA) {
                            var smaaColorFmt = GFXFormat.RGBA8;
                            this._smaaPass = this._device.createRenderPass({
                                colorAttachments: [ {
                                    format: smaaColorFmt,
                                    loadOp: GFXLoadOp.CLEAR,
                                    storeOp: GFXStoreOp.STORE,
                                    sampleCount: 1,
                                    beginLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL,
                                    endLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL
                                } ]
                            }), this._smaaEdgeTex = this._device.createTexture({
                                type: GFXTextureType.TEX2D,
                                usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                                format: smaaColorFmt,
                                width: this._shadingWidth,
                                height: this._shadingHeight
                            }), this._smaaEdgeTexView = this._device.createTextureView({
                                texture: this._smaaEdgeTex,
                                type: GFXTextureViewType.TV2D,
                                format: smaaColorFmt
                            }), this._smaaEdgeFBO = this._device.createFramebuffer({
                                renderPass: this._smaaPass,
                                colorViews: [ this._smaaEdgeTexView ],
                                depthStencilView: null
                            }), this._smaaBlendTex = this._device.createTexture({
                                type: GFXTextureType.TEX2D,
                                usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                                format: smaaColorFmt,
                                width: this._shadingWidth,
                                height: this._shadingHeight
                            }), this._smaaBlendTexView = this._device.createTextureView({
                                texture: this._smaaBlendTex,
                                type: GFXTextureViewType.TV2D,
                                format: smaaColorFmt
                            }), this._smaaBlendFBO = this._device.createFramebuffer({
                                renderPass: this._smaaPass,
                                colorViews: [ this._smaaBlendTexView ],
                                depthStencilView: null
                            });
                        }
                        return !!this.createQuadInputAssembler() && !!this.createUBOs();
                    }
                }, {
                    key: "_destroy",
                    value: function _destroy() {
                        this.destroyFlows(), this.clearRenderPasses(), this.destroyQuadInputAssembler(), 
                        this.destroyUBOs(), this._smaaEdgeTexView && (this._smaaEdgeTexView.destroy(), this._smaaEdgeTexView = null), 
                        this._smaaEdgeTex && (this._smaaEdgeTex.destroy(), this._smaaEdgeTex = null), this._smaaEdgeFBO && (this._smaaEdgeFBO.destroy(), 
                        this._smaaEdgeFBO = null), this._smaaBlendTexView && (this._smaaBlendTexView.destroy(), 
                        this._smaaBlendTexView = null), this._smaaBlendTex && (this._smaaBlendTex.destroy(), 
                        this._smaaBlendTex = null), this._smaaBlendFBO && (this._smaaBlendFBO.destroy(), 
                        this._smaaBlendFBO = null), this._msaaShadingTexView && (this._msaaShadingTexView.destroy(), 
                        this._msaaShadingTexView = null), this._msaaShadingTex && (this._msaaShadingTex.destroy(), 
                        this._msaaShadingTex = null), this._msaaDepthStencilTexView && (this._msaaDepthStencilTexView.destroy(), 
                        this._msaaDepthStencilTexView = null), this._msaaDepthStencilTex && (this._msaaDepthStencilTex.destroy(), 
                        this._msaaDepthStencilTex = null), this._msaaShadingFBO && (this._msaaShadingFBO.destroy(), 
                        this._msaaShadingFBO = null);
                        for (var i = 0; i < this._shadingTexViews.length; ++i) this._shadingTexViews[i] && this._shadingTexViews[i].destroy(), 
                        this._shadingTextures[i] && this._shadingTextures[i].destroy(), this._shadingFBOs[i] && this._shadingFBOs[i].destroy();
                        this._shadingTexViews.splice(0), this._shadingTextures.splice(0), this._shadingFBOs.splice(0), 
                        this._depthStencilTexView && (this._depthStencilTexView.destroy(), this._depthStencilTexView = null), 
                        this._depthStencilTex && (this._depthStencilTex.destroy(), this._depthStencilTex = null), 
                        this._shadingPass && (this._shadingPass.destroy(), this._shadingPass = null);
                    }
                }, {
                    key: "resizeFBOs",
                    value: function resizeFBOs(width, height) {
                        this._shadingWidth = width, this._shadingHeight = height, this._depthStencilTex && (this._depthStencilTex.resize(width, height), 
                        this._depthStencilTexView.destroy(), this._depthStencilTexView.initialize({
                            texture: this._depthStencilTex,
                            type: GFXTextureViewType.TV2D,
                            format: this._depthStencilFmt
                        }));
                        for (var i = 0; i < this._fboCount; ++i) this._shadingTextures[i].resize(width, height), 
                        this._shadingTexViews[i].destroy(), this._shadingTexViews[i].initialize({
                            texture: this._shadingTextures[i],
                            type: GFXTextureViewType.TV2D,
                            format: this._colorFmt
                        }), this._shadingFBOs[i].destroy(), this._shadingFBOs[i].initialize({
                            renderPass: this._shadingPass,
                            colorViews: [ this._shadingTexViews[i] ],
                            depthStencilView: this._depthStencilTexView
                        });
                        if (this._useMSAA && (this._msaaShadingTex.resize(width, height), this._msaaShadingTexView.destroy(), 
                        this._msaaShadingTexView.initialize({
                            texture: this._msaaShadingTex,
                            type: GFXTextureViewType.TV2D,
                            format: this._colorFmt
                        }), this._msaaDepthStencilTex.resize(width, height), this._msaaDepthStencilTexView.destroy(), 
                        this._msaaDepthStencilTexView.initialize({
                            texture: this._msaaDepthStencilTex,
                            type: GFXTextureViewType.TV2D,
                            format: this._depthStencilFmt
                        }), this._msaaShadingFBO.destroy(), this._msaaShadingFBO.initialize({
                            renderPass: this._shadingPass,
                            colorViews: [ this._msaaShadingTexView ],
                            depthStencilView: this._msaaDepthStencilTexView
                        })), this._useSMAA) {
                            var smaaColorFmt = this._smaaEdgeTex.format;
                            this._smaaEdgeTex.resize(width, height), this._smaaEdgeTexView.destroy(), this._smaaEdgeTexView.initialize({
                                texture: this._smaaEdgeTex,
                                type: GFXTextureViewType.TV2D,
                                format: smaaColorFmt
                            }), this._smaaEdgeFBO.destroy(), this._smaaEdgeFBO.initialize({
                                renderPass: this._smaaPass,
                                colorViews: [ this._smaaEdgeTexView ],
                                depthStencilView: null
                            }), this._smaaBlendTex.resize(width, height), this._smaaBlendTexView.destroy(), 
                            this._smaaBlendTexView.initialize({
                                texture: this._smaaBlendTex,
                                type: GFXTextureViewType.TV2D,
                                format: smaaColorFmt
                            }), this._smaaBlendFBO.destroy(), this._smaaBlendFBO.initialize({
                                renderPass: this._smaaPass,
                                colorViews: [ this._smaaBlendTexView ],
                                depthStencilView: null
                            });
                        }
                        console.info("Resizing shading fbos: " + this._shadingWidth + "x" + this._shadingHeight);
                    }
                }, {
                    key: "createQuadInputAssembler",
                    value: function createQuadInputAssembler() {
                        var vbStride = 4 * Float32Array.BYTES_PER_ELEMENT, vbSize = 4 * vbStride;
                        if (this._quadVB = this._device.createBuffer({
                            usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                            size: vbSize,
                            stride: vbStride
                        }), !this._quadVB) return !1;
                        var verts = new Float32Array(16), n = 0;
                        verts[n++] = -1, verts[n++] = -1, verts[n++] = 0, verts[n++] = 0, verts[n++] = 1, 
                        verts[n++] = -1, verts[n++] = 1, verts[n++] = 0, verts[n++] = -1, verts[n++] = 1, 
                        verts[n++] = 0, verts[n++] = 1, verts[n++] = 1, verts[n++] = 1, verts[n++] = 1, 
                        verts[n++] = 1, this._quadVB.update(verts);
                        var ibStride = Uint8Array.BYTES_PER_ELEMENT, ibSize = 6 * ibStride;
                        if (this._quadIB = this._device.createBuffer({
                            usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                            size: ibSize,
                            stride: ibStride
                        }), !this._quadIB) return !1;
                        var indices = new Uint8Array(6);
                        indices[0] = 0, indices[1] = 1, indices[2] = 2, indices[3] = 1, indices[4] = 3, 
                        indices[5] = 2, this._quadIB.update(indices);
                        var attributes = [ {
                            name: "a_position",
                            format: GFXFormat.RG32F
                        }, {
                            name: "a_texCoord",
                            format: GFXFormat.RG32F
                        } ];
                        return this._quadIA = this._device.createInputAssembler({
                            attributes: attributes,
                            vertexBuffers: [ this._quadVB ],
                            indexBuffer: this._quadIB
                        }), !0;
                    }
                }, {
                    key: "destroyQuadInputAssembler",
                    value: function destroyQuadInputAssembler() {
                        this._quadVB && (this._quadVB.destroy(), this._quadVB = null), this._quadIB && (this._quadIB.destroy(), 
                        this._quadIB = null), this._quadIA && (this._quadIA.destroy(), this._quadIA = null);
                    }
                }, {
                    key: "createUBOs",
                    value: function createUBOs() {
                        if (!this._globalBindings.get(UBOGlobal.BLOCK.name)) {
                            var globalUBO = this._root.device.createBuffer({
                                usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                                size: UBOGlobal.SIZE
                            });
                            this._globalBindings.set(UBOGlobal.BLOCK.name, {
                                type: GFXBindingType.UNIFORM_BUFFER,
                                blockInfo: UBOGlobal.BLOCK,
                                buffer: globalUBO
                            });
                        }
                        if (!this._globalBindings.get(UBOShadow.BLOCK.name)) {
                            var shadowUBO = this._root.device.createBuffer({
                                usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                                size: UBOShadow.SIZE
                            });
                            this._globalBindings.set(UBOShadow.BLOCK.name, {
                                type: GFXBindingType.UNIFORM_BUFFER,
                                blockInfo: UBOShadow.BLOCK,
                                buffer: shadowUBO
                            });
                        }
                        return this._globalBindings.get(UNIFORM_ENVIRONMENT.name) || this._globalBindings.set(UNIFORM_ENVIRONMENT.name, {
                            type: GFXBindingType.SAMPLER,
                            samplerInfo: UNIFORM_ENVIRONMENT
                        }), !0;
                    }
                }, {
                    key: "destroyUBOs",
                    value: function destroyUBOs() {
                        var globalUBO = this._globalBindings.get(UBOGlobal.BLOCK.name);
                        globalUBO && (globalUBO.buffer.destroy(), this._globalBindings.delete(UBOGlobal.BLOCK.name));
                        var shadowUBO = this._globalBindings.get(UBOShadow.BLOCK.name);
                        shadowUBO && (shadowUBO.buffer.destroy(), this._globalBindings.delete(UBOShadow.BLOCK.name));
                    }
                }, {
                    key: "updateUBOs",
                    value: function updateUBOs(view) {
                        var camera = view.camera, scene = camera.scene, device = this._root.device, mainLight = scene.mainLight, ambient = scene.ambient, fv = this._uboGlobal.view;
                        fv[UBOGlobal.TIME_OFFSET] = this._root.cumulativeTime, fv[UBOGlobal.SCREEN_SIZE_OFFSET] = device.width, 
                        fv[UBOGlobal.SCREEN_SIZE_OFFSET + 1] = device.height, fv[UBOGlobal.SCREEN_SIZE_OFFSET + 2] = 1 / fv[UBOGlobal.SCREEN_SIZE_OFFSET], 
                        fv[UBOGlobal.SCREEN_SIZE_OFFSET + 3] = 1 / fv[UBOGlobal.SCREEN_SIZE_OFFSET + 1], 
                        fv[UBOGlobal.SCREEN_SCALE_OFFSET] = camera.width / this._shadingWidth * this._shadingScale, 
                        fv[UBOGlobal.SCREEN_SCALE_OFFSET + 1] = camera.height / this._shadingHeight * this._shadingScale, 
                        fv[UBOGlobal.SCREEN_SCALE_OFFSET + 2] = 1 / fv[UBOGlobal.SCREEN_SCALE_OFFSET], fv[UBOGlobal.SCREEN_SCALE_OFFSET + 3] = 1 / fv[UBOGlobal.SCREEN_SCALE_OFFSET + 1], 
                        fv[UBOGlobal.NATIVE_SIZE_OFFSET] = this._shadingWidth, fv[UBOGlobal.NATIVE_SIZE_OFFSET + 1] = this._shadingHeight, 
                        fv[UBOGlobal.NATIVE_SIZE_OFFSET + 2] = 1 / fv[UBOGlobal.NATIVE_SIZE_OFFSET], fv[UBOGlobal.NATIVE_SIZE_OFFSET + 3] = 1 / fv[UBOGlobal.NATIVE_SIZE_OFFSET + 1], 
                        Mat4.toArray(fv, camera.matView, UBOGlobal.MAT_VIEW_OFFSET), Mat4.toArray(fv, camera.node.worldMatrix, UBOGlobal.MAT_VIEW_INV_OFFSET), 
                        Mat4.toArray(fv, camera.matProj, UBOGlobal.MAT_PROJ_OFFSET), Mat4.toArray(fv, camera.matProjInv, UBOGlobal.MAT_PROJ_INV_OFFSET), 
                        Mat4.toArray(fv, camera.matViewProj, UBOGlobal.MAT_VIEW_PROJ_OFFSET), Mat4.toArray(fv, camera.matViewProjInv, UBOGlobal.MAT_VIEW_PROJ_INV_OFFSET), 
                        Vec3.toArray(fv, camera.position, UBOGlobal.CAMERA_POS_OFFSET);
                        var exposure = camera.exposure;
                        if (fv[UBOGlobal.EXPOSURE_OFFSET] = exposure, fv[UBOGlobal.EXPOSURE_OFFSET + 1] = 1 / exposure, 
                        fv[UBOGlobal.EXPOSURE_OFFSET + 2] = this._isHDR ? 1 : 0, fv[UBOGlobal.EXPOSURE_OFFSET + 3] = this._fpScale / exposure, 
                        Vec3.toArray(fv, mainLight.direction, UBOGlobal.MAIN_LIT_DIR_OFFSET), mainLight.enabled) {
                            if (Vec3.toArray(fv, mainLight.color, UBOGlobal.MAIN_LIT_COLOR_OFFSET), mainLight.useColorTemperature) {
                                var colorTempRGB = mainLight.colorTemperatureRGB;
                                fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET] *= colorTempRGB.x, fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 1] *= colorTempRGB.y, 
                                fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 2] *= colorTempRGB.z;
                            }
                            this._isHDR ? fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 3] = mainLight.illuminance * this._fpScale : fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 3] = mainLight.illuminance * exposure;
                        } else Vec4.toArray(fv, _v4Zero, UBOGlobal.MAIN_LIT_COLOR_OFFSET);
                        _vec4Array.set(ambient.skyColor), this._isHDR ? _vec4Array[3] = ambient.skyIllum * this._fpScale : _vec4Array[3] = ambient.skyIllum * exposure, 
                        this._uboGlobal.view.set(_vec4Array, UBOGlobal.AMBIENT_SKY_OFFSET), this._uboGlobal.view.set(ambient.groundAlbedo, UBOGlobal.AMBIENT_GROUND_OFFSET), 
                        this._globalBindings.get(UBOGlobal.BLOCK.name).buffer.update(this._uboGlobal.view.buffer);
                    }
                }, {
                    key: "sceneCulling",
                    value: function sceneCulling(view) {
                        var camera = view.camera, scene = camera.scene;
                        this._renderObjects.splice(0);
                        var mainLight = scene.mainLight;
                        mainLight && mainLight.enabled && mainLight.update();
                        var planarShadows = scene.planarShadows;
                        planarShadows.enabled && mainLight.node.hasChangedFlags && planarShadows.updateDirLight(mainLight), 
                        scene.skybox.enabled && camera.clearFlag & SKYBOX_FLAG && this.addVisibleModel(scene.skybox, camera);
                        var _iterator6 = scene.models, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                        for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                            var _ref6;
                            if (_isArray6) {
                                if (_i6 >= _iterator6.length) break;
                                _ref6 = _iterator6[_i6++];
                            } else {
                                if ((_i6 = _iterator6.next()).done) break;
                                _ref6 = _i6.value;
                            }
                            var model = _ref6;
                            if (model._resetUBOUpdateFlag(), model.enabled) if (view.visibility & Layers.BitMask.UI_2D) (model.node && view.visibility === model.node.layer || view.visibility === model.visFlags) && (model.updateTransform(), 
                            model.updateUBOs(), this.addVisibleModel(model, camera)); else if (model.node && view.visibility & model.node.layer || view.visibility & model.visFlags) {
                                if (model.updateTransform(), model.worldBounds && !intersect.aabb_frustum(model.worldBounds, camera.frustum)) continue;
                                model.updateUBOs(), this.addVisibleModel(model, camera);
                            }
                        }
                        planarShadows.enabled && planarShadows.updateCommandBuffers();
                    }
                }, {
                    key: "addVisibleModel",
                    value: function addVisibleModel(model, camera) {
                        var depth = 0;
                        model.node && (model.node.getWorldPosition(_v3tmp), Vec3.subtract(_v3tmp, _v3tmp, camera.position), 
                        depth = Vec3.dot(_v3tmp, camera.forward)), this._renderObjects.push({
                            model: model,
                            depth: depth
                        });
                    }
                } ]), RenderPipeline;
            }(), CachedArray = function() {
                function CachedArray(length, compareFn) {
                    _classCallCheck(this, CachedArray), this.array = void 0, this.length = 0, this.cache = void 0, 
                    this._compareFn = void 0, this.array = new Array(length), this.cache = this.array, 
                    this.length = 0, this._compareFn = void 0 !== compareFn ? compareFn : function(a, b) {
                        return a - b;
                    };
                }
                return _createClass(CachedArray, [ {
                    key: "push",
                    value: function push(item) {
                        this.array[this.length++] = item;
                    }
                }, {
                    key: "pop",
                    value: function pop() {
                        return this.array[this.length--];
                    }
                }, {
                    key: "get",
                    value: function get(idx) {
                        return this.array[idx];
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        this.cache.fill(null), this.length = 0;
                    }
                }, {
                    key: "sort",
                    value: function sort() {
                        this.array.length = this.length, this.array.sort(this._compareFn);
                    }
                }, {
                    key: "concat",
                    value: function concat(array) {
                        for (var i = 0; i < array.length; ++i) this.array[this.length++] = array.array[i];
                    }
                }, {
                    key: "append",
                    value: function append(array) {
                        var _iterator = array, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var item = _ref;
                            this.array[this.length++] = item;
                        }
                    }
                } ]), CachedArray;
            }();
            function opaqueCompareFn(a, b) {
                return a.hash === b.hash ? a.depth === b.depth ? a.shaderId - b.shaderId : a.depth - b.depth : a.hash - b.hash;
            }
            function transparentCompareFn(a, b) {
                return a.hash === b.hash ? a.depth === b.depth ? a.shaderId - b.shaderId : b.depth - a.depth : a.hash - b.hash;
            }
            var RenderQueue = function() {
                function RenderQueue(desc) {
                    _classCallCheck(this, RenderQueue), this.queue = void 0, this.cmdBuffs = void 0, 
                    this.cmdBuffCount = 0, this._passDesc = void 0, this._passDesc = desc, this.cmdBuffs = new CachedArray(64), 
                    this.queue = new CachedArray(64, this._passDesc.sortFunc);
                }
                return _createClass(RenderQueue, [ {
                    key: "clear",
                    value: function clear() {
                        this.queue.clear(), this.cmdBuffCount = 0;
                    }
                }, {
                    key: "insertRenderPass",
                    value: function insertRenderPass(renderObj, modelIdx, passIdx) {
                        var subModel = renderObj.model.getSubModel(modelIdx), pass = subModel.passes[passIdx], pso = subModel.psos[passIdx];
                        if (pso.blendState.targets[0].blend !== this._passDesc.isTransparent || !(pass.phase & this._passDesc.phases)) return !1;
                        var hash = 0 | pass.priority << 16 | subModel.priority << 8 | passIdx;
                        return this.queue.push({
                            hash: hash,
                            depth: renderObj.depth,
                            shaderId: pso.shader.id,
                            subModel: subModel,
                            cmdBuff: subModel.commandBuffers[passIdx]
                        }), !0;
                    }
                }, {
                    key: "sort",
                    value: function sort() {
                        this.queue.sort(), this.cmdBuffCount = this.queue.length;
                        for (var i = 0; i < this.queue.length; ++i) this.cmdBuffs.array[i] = this.queue.array[i].cmdBuff;
                    }
                } ]), RenderQueue;
            }(), bufs = [], UIStage = function() {
                function UIStage(flow) {
                    var _this;
                    return _classCallCheck(this, UIStage), (_this = _possibleConstructorReturn(this, _getPrototypeOf(UIStage).call(this, flow)))._uiQueue = void 0, 
                    _this._uiQueue = new RenderQueue({
                        isTransparent: !0,
                        phases: getPhaseID("default"),
                        sortFunc: transparentCompareFn
                    }), _this;
                }
                return _inherits(UIStage, RenderStage), _createClass(UIStage, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
                        void 0 !== info.framebuffer && (this._framebuffer = info.framebuffer), this._cmdBuff = this._device.createCommandBuffer({
                            allocator: this._device.commandAllocator,
                            type: GFXCommandBufferType.PRIMARY
                        }), !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
                    }
                }, {
                    key: "resize",
                    value: function resize() {}
                }, {
                    key: "rebuild",
                    value: function rebuild() {}
                }, {
                    key: "render",
                    value: function render(view) {
                        this._uiQueue.clear();
                        var _iterator = this._pipeline.renderObjects, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            for (var ro = _ref, i = 0; i < ro.model.subModelNum; i++) for (var j = 0; j < ro.model.getSubModel(i).passes.length; j++) this._uiQueue.insertRenderPass(ro, i, j);
                        }
                        this._uiQueue.sort();
                        var framebuffer = view.window.framebuffer, cmdBuff = this._cmdBuff, camera = view.camera;
                        this._renderArea.width = this.flow.pipeline.root.device.width, this._renderArea.height = this.flow.pipeline.root.device.height, 
                        cmdBuff.begin(), cmdBuff.beginRenderPass(framebuffer, this._renderArea, camera.clearFlag, [ camera.clearColor ], camera.clearDepth, camera.clearStencil), 
                        cmdBuff.execute(this._uiQueue.cmdBuffs.array, this._uiQueue.cmdBuffCount), cmdBuff.endRenderPass(), 
                        cmdBuff.end(), bufs[0] = cmdBuff, this._device.queue.submit(bufs);
                    }
                } ]), UIStage;
            }(), UIFlow = function() {
                function UIFlow(pipeline) {
                    return _classCallCheck(this, UIFlow), _possibleConstructorReturn(this, _getPrototypeOf(UIFlow).call(this, pipeline));
                }
                return _inherits(UIFlow, RenderFlow), _createClass(UIFlow, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        void 0 !== info.name && (this._name = info.name), this._priority = info.priority;
                        var mainWindow = this._pipeline.root.mainWindow;
                        return !(!mainWindow || !mainWindow.framebuffer) && (this.createStage(UIStage, {
                            name: "UIStage",
                            priority: 0,
                            framebuffer: mainWindow.framebuffer
                        }), !0);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.destroyStages();
                    }
                }, {
                    key: "rebuild",
                    value: function rebuild() {}
                }, {
                    key: "render",
                    value: function render(view) {
                        var isHDR = this.pipeline.defaultGlobalUBOData[UBOGlobal.EXPOSURE_OFFSET + 2];
                        this.pipeline.defaultGlobalUBOData[UBOGlobal.EXPOSURE_OFFSET + 2] = 0, this.pipeline.globalBindings.get(UBOGlobal.BLOCK.name).buffer.update(this.pipeline.defaultGlobalUBOData.buffer), 
                        _get(_getPrototypeOf(UIFlow.prototype), "render", this).call(this, view), this.pipeline.defaultGlobalUBOData[UBOGlobal.EXPOSURE_OFFSET + 2] = isHDR, 
                        this.pipeline.globalBindings.get(UBOGlobal.BLOCK.name).buffer.update(this.pipeline.defaultGlobalUBOData.buffer);
                    }
                } ]), UIFlow;
            }();
            var ForwardStagePriority, RenderBatchedQueue = function() {
                function RenderBatchedQueue() {
                    _classCallCheck(this, RenderBatchedQueue), this.queue = new Set();
                }
                return _createClass(RenderBatchedQueue, [ {
                    key: "clear",
                    value: function clear() {
                        var _iterator = this.queue.values(), _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            _ref.clear();
                        }
                        this.queue.clear();
                    }
                }, {
                    key: "recordCommandBuffer",
                    value: function recordCommandBuffer(cmdBuff) {
                        var _iterator2 = this.queue.values(), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            var batchedBuffer = _ref2;
                            batchedBuffer.pso && (cmdBuff.bindPipelineState(batchedBuffer.pso), cmdBuff.bindBindingLayout(batchedBuffer.pso.pipelineLayout.layouts[0]));
                            for (var b = 0; b < batchedBuffer.batches.length; ++b) {
                                var batch = batchedBuffer.batches[b];
                                batchedBuffer.ubo.update(batch.uboLocal.view), cmdBuff.bindInputAssembler(batch.ia), 
                                cmdBuff.draw(batch.ia);
                            }
                        }
                    }
                } ]), RenderBatchedQueue;
            }(), colors = [], bufs$1 = [], ForwardStage = function() {
                function ForwardStage(flow) {
                    var _this;
                    return _classCallCheck(this, ForwardStage), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ForwardStage).call(this, flow)))._opaqueQueue = void 0, 
                    _this._transparentQueue = void 0, _this._opaqueBatchedQueue = void 0, _this._opaqueQueue = new RenderQueue({
                        isTransparent: !1,
                        phases: getPhaseID("default"),
                        sortFunc: opaqueCompareFn
                    }), _this._transparentQueue = new RenderQueue({
                        isTransparent: !0,
                        phases: getPhaseID("default") | getPhaseID("planarShadow"),
                        sortFunc: transparentCompareFn
                    }), _this._opaqueBatchedQueue = new RenderBatchedQueue(), _this;
                }
                return _inherits(ForwardStage, RenderStage), _createClass(ForwardStage, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
                        this._cmdBuff = this._device.createCommandBuffer({
                            allocator: this._device.commandAllocator,
                            type: GFXCommandBufferType.PRIMARY
                        }), !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
                    }
                }, {
                    key: "resize",
                    value: function resize() {}
                }, {
                    key: "rebuild",
                    value: function rebuild() {}
                }, {
                    key: "render",
                    value: function render(view) {
                        this._opaqueBatchedQueue.clear(), this._opaqueQueue.clear(), this._transparentQueue.clear();
                        for (var renderObjects = this._pipeline.renderObjects, i = 0; i < renderObjects.length; ++i) {
                            var ro = renderObjects[i];
                            if (ro.model.isDynamicBatching) for (var m = 0; m < ro.model.subModels.length; ++m) for (var subModel = ro.model.subModels[m], passes = subModel.passes, p = 0; p < passes.length; ++p) {
                                var pass = subModel.passes[p];
                                if (pass.batchedBuffer) {
                                    var pso = subModel.psos[p];
                                    if (pso.blendState.targets[0].blend) {
                                        var hash = 0 | pass.priority << 16 | subModel.priority << 8 | p;
                                        this._transparentQueue.queue.push({
                                            hash: hash,
                                            depth: ro.depth,
                                            shaderId: pso.shader.id,
                                            subModel: subModel,
                                            cmdBuff: subModel.commandBuffers[p]
                                        });
                                    } else pass.batchedBuffer.merge(subModel, ro), this._opaqueBatchedQueue.queue.add(pass.batchedBuffer);
                                }
                            } else for (var subModels = ro.model.subModels, _m = 0; _m < subModels.length; ++_m) for (var _subModel = subModels[_m], _passes = _subModel.passes, _p = 0; _p < _passes.length; ++_p) {
                                var _pass = _subModel.passes[_p], _pso = _subModel.psos[_p], _isTransparent = _pso.blendState.targets[0].blend, _hash = 0 | _pass.priority << 16 | _subModel.priority << 8 | _p;
                                _isTransparent ? this._transparentQueue.queue.push({
                                    hash: _hash,
                                    depth: ro.depth,
                                    shaderId: _pso.shader.id,
                                    subModel: _subModel,
                                    cmdBuff: _subModel.commandBuffers[_p]
                                }) : this._opaqueQueue.queue.push({
                                    hash: _hash,
                                    depth: ro.depth,
                                    shaderId: _pso.shader.id,
                                    subModel: _subModel,
                                    cmdBuff: _subModel.commandBuffers[_p]
                                });
                            }
                        }
                        this._opaqueQueue.sort(), this._transparentQueue.sort();
                        var camera = view.camera, cmdBuff = this._cmdBuff, vp = camera.viewport;
                        if (this._renderArea.x = vp.x * camera.width, this._renderArea.y = vp.y * camera.height, 
                        this._renderArea.width = vp.width * camera.width * this.pipeline.shadingScale, this._renderArea.height = vp.height * camera.height * this.pipeline.shadingScale, 
                        camera.clearFlag & GFXClearFlag.COLOR) {
                            if (colors[0] = camera.clearColor, this._pipeline.isHDR) {
                                colors[0] = function SRGBToLinear(gamma) {
                                    return {
                                        r: Math.pow(gamma.r, 2.2),
                                        g: Math.pow(gamma.g, 2.2),
                                        b: Math.pow(gamma.b, 2.2),
                                        a: 1
                                    };
                                }(colors[0]);
                                var scale = this._pipeline.fpScale / camera.exposure;
                                colors[0].r *= scale, colors[0].g *= scale, colors[0].b *= scale;
                            }
                            colors.length = 1;
                        }
                        this._pipeline.usePostProcess ? this._pipeline.useMSAA ? this._framebuffer = this._pipeline.msaaShadingFBO : this._framebuffer = this._pipeline.curShadingFBO : this._framebuffer = view.window.framebuffer;
                        var planarShadow = camera.scene.planarShadows;
                        cmdBuff.begin(), cmdBuff.beginRenderPass(this._framebuffer, this._renderArea, camera.clearFlag, colors, camera.clearDepth, camera.clearStencil), 
                        cmdBuff.execute(this._opaqueQueue.cmdBuffs.array, this._opaqueQueue.cmdBuffCount), 
                        this._opaqueBatchedQueue.recordCommandBuffer(cmdBuff), cmdBuff.execute(planarShadow.cmdBuffs.array, planarShadow.cmdBuffCount), 
                        cmdBuff.execute(this._transparentQueue.cmdBuffs.array, this._transparentQueue.cmdBuffCount), 
                        cmdBuff.endRenderPass(), cmdBuff.end(), bufs$1[0] = cmdBuff, this._device.queue.submit(bufs$1), 
                        this._pipeline.useMSAA && this._device.blitFramebuffer(this._framebuffer, this._pipeline.curShadingFBO, this._renderArea, this._renderArea, GFXFilter.POINT);
                    }
                } ]), ForwardStage;
            }();
            !function(ForwardStagePriority) {
                ForwardStagePriority[ForwardStagePriority.FORWARD = 0] = "FORWARD";
            }(ForwardStagePriority = ForwardStagePriority || {});
            var ForwardFlowPriority, ForwardFlow = function() {
                function ForwardFlow(pipeline) {
                    return _classCallCheck(this, ForwardFlow), _possibleConstructorReturn(this, _getPrototypeOf(ForwardFlow).call(this, pipeline));
                }
                return _inherits(ForwardFlow, RenderFlow), _createClass(ForwardFlow, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
                        this.createStage(ForwardStage, {
                            name: "ForwardStage",
                            priority: ForwardStagePriority.FORWARD
                        }), !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.destroyStages();
                    }
                }, {
                    key: "rebuild",
                    value: function rebuild() {}
                } ]), ForwardFlow;
            }();
            !function(ForwardFlowPriority) {
                ForwardFlowPriority[ForwardFlowPriority.FORWARD = 0] = "FORWARD", ForwardFlowPriority[ForwardFlowPriority.UI = 10] = "UI";
            }(ForwardFlowPriority = ForwardFlowPriority || {});
            var RenderViewPriority, _vec4Array$1 = new Float32Array(4), _sphere = sphere.create(0, 0, 0, 1), _tempLightIndex = [], _tempLightDist = [], _tempVec3 = new Vec3(), ForwardPipeline = function() {
                function ForwardPipeline(root) {
                    var _this;
                    return _classCallCheck(this, ForwardPipeline), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ForwardPipeline).call(this, root)))._uboLights = new UBOForwardLight(), 
                    _this._lightsUBO = null, _this._validLights = void 0, _this._lightIndexOffset = void 0, 
                    _this._lightIndices = void 0, _this._validLights = [], _this._lightIndexOffset = [], 
                    _this._lightIndices = [], _this;
                }
                return _inherits(ForwardPipeline, RenderPipeline), _createClass(ForwardPipeline, [ {
                    key: "lightsUBO",
                    get: function get() {
                        return this._lightsUBO;
                    }
                } ]), _createClass(ForwardPipeline, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        if (!this._initialize(info)) return !1;
                        if (this._name = "ForwardPipeline", !this._globalBindings.get(UBOForwardLight.BLOCK.name)) {
                            var lightsUBO = this._root.device.createBuffer({
                                usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                                size: UBOForwardLight.SIZE
                            });
                            if (!lightsUBO) return !1;
                            this._globalBindings.set(UBOForwardLight.BLOCK.name, {
                                type: GFXBindingType.UNIFORM_BUFFER,
                                blockInfo: UBOForwardLight.BLOCK,
                                buffer: lightsUBO
                            });
                        }
                        var mainWindow = this._root.mainWindow, windowPass = null;
                        return mainWindow && (windowPass = mainWindow.renderPass), windowPass ? (this.addRenderPass(RenderPassStage.DEFAULT, windowPass), 
                        this.createFlow(ForwardFlow, {
                            name: "ForwardFlow",
                            priority: ForwardFlowPriority.FORWARD
                        }), this._usePostProcess && (this._useSMAA, this.createFlow(ToneMapFlow, {
                            name: "ToneMapFlow",
                            priority: 0
                        })), this.createFlow(UIFlow, {
                            name: "UIFlow",
                            priority: ForwardFlowPriority.UI
                        }), !0) : (console.error("RenderPass of main window is null."), !1);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        var lightsUBO = this._globalBindings.get(UBOForwardLight.BLOCK.name);
                        lightsUBO && (lightsUBO.buffer.destroy(), this._globalBindings.delete(UBOForwardLight.BLOCK.name)), 
                        this._destroy();
                    }
                }, {
                    key: "rebuild",
                    value: function rebuild() {
                        _get(_getPrototypeOf(ForwardPipeline.prototype), "rebuild", this).call(this);
                        var _iterator = this._flows, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            _ref.rebuild();
                        }
                    }
                }, {
                    key: "updateUBOs",
                    value: function updateUBOs(view) {
                        _get(_getPrototypeOf(ForwardPipeline.prototype), "updateUBOs", this).call(this, view);
                        for (var exposure = view.camera.exposure, i = 0; i < this._renderObjects.length; i++) {
                            this._uboLights.view.fill(0);
                            var nextLightIndex = i + 1 < this._renderObjects.length ? this._lightIndexOffset[i + 1] : this._lightIndices.length;
                            if (this._renderObjects[i].model.localBindings.get(UBOForwardLight.BLOCK.name)) {
                                for (var sphereNum = 0, spotNum = 0, l = this._lightIndexOffset[i]; l < nextLightIndex; l++) {
                                    var light = this._validLights[this._lightIndices[l]];
                                    if (light && light.enabled) switch (light.type) {
                                      case LightType.SPHERE:
                                        if (UBOForwardLight.MAX_SPHERE_LIGHTS <= sphereNum) continue;
                                        var sphereLit = light;
                                        if (Vec3.toArray(_vec4Array$1, sphereLit.position), this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPHERE_LIGHT_POS_OFFSET + 4 * sphereNum), 
                                        _vec4Array$1[0] = sphereLit.size, _vec4Array$1[1] = sphereLit.range, _vec4Array$1[2] = 0, 
                                        this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPHERE_LIGHT_SIZE_RANGE_OFFSET + 4 * sphereNum), 
                                        Vec3.toArray(_vec4Array$1, light.color), light.useColorTemperature) {
                                            var tempRGB = light.colorTemperatureRGB;
                                            _vec4Array$1[0] *= tempRGB.x, _vec4Array$1[1] *= tempRGB.y, _vec4Array$1[2] *= tempRGB.z;
                                        }
                                        _vec4Array$1[3] = sphereLit.luminance * this._lightMeterScale, this._isHDR ? _vec4Array$1[3] = sphereLit.luminance * this._fpScale * this._lightMeterScale : _vec4Array$1[3] = sphereLit.luminance * exposure * this._lightMeterScale, 
                                        this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPHERE_LIGHT_COLOR_OFFSET + 4 * sphereNum), 
                                        sphereNum++;
                                        break;

                                      case LightType.SPOT:
                                        if (UBOForwardLight.MAX_SPOT_LIGHTS <= spotNum) continue;
                                        var spotLit = light;
                                        if (Vec3.toArray(_vec4Array$1, spotLit.position), _vec4Array$1[3] = spotLit.size, 
                                        this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPOT_LIGHT_POS_OFFSET + 4 * spotNum), 
                                        _vec4Array$1[0] = spotLit.size, _vec4Array$1[1] = spotLit.range, _vec4Array$1[2] = spotLit.spotAngle, 
                                        this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPOT_LIGHT_SIZE_RANGE_ANGLE_OFFSET + 4 * spotNum), 
                                        Vec3.toArray(_vec4Array$1, spotLit.direction), this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPOT_LIGHT_DIR_OFFSET + 4 * spotNum), 
                                        Vec3.toArray(_vec4Array$1, light.color), light.useColorTemperature) {
                                            var _tempRGB = light.colorTemperatureRGB;
                                            _vec4Array$1[0] *= _tempRGB.x, _vec4Array$1[1] *= _tempRGB.y, _vec4Array$1[2] *= _tempRGB.z;
                                        }
                                        this._isHDR ? _vec4Array$1[3] = spotLit.luminance * this._fpScale * this._lightMeterScale : _vec4Array$1[3] = spotLit.luminance * exposure * this._lightMeterScale, 
                                        this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPOT_LIGHT_COLOR_OFFSET + 4 * spotNum), 
                                        spotNum++;
                                    }
                                }
                                this._renderObjects[i].model.localBindings.get(UBOForwardLight.BLOCK.name).buffer.update(this._uboLights.view);
                            }
                        }
                    }
                }, {
                    key: "sceneCulling",
                    value: function sceneCulling(view) {
                        _get(_getPrototypeOf(ForwardPipeline.prototype), "sceneCulling", this).call(this, view), 
                        this._validLights.splice(0);
                        var _iterator2 = view.camera.scene.sphereLights, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            var light = _ref2;
                            light.enabled && (light.update(), sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range), 
                            intersect.sphere_frustum(_sphere, view.camera.frustum) && this._validLights.push(light));
                        }
                        var _iterator3 = view.camera.scene.spotLights, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i3 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i3++];
                            } else {
                                if ((_i3 = _iterator3.next()).done) break;
                                _ref3 = _i3.value;
                            }
                            var _light = _ref3;
                            _light.enabled && (_light.update(), sphere.set(_sphere, _light.position.x, _light.position.y, _light.position.z, _light.range), 
                            intersect.sphere_frustum(_sphere, view.camera.frustum) && this._validLights.push(_light));
                        }
                        this._lightIndexOffset.splice(0), this._lightIndices.splice(0);
                        for (var i = 0; i < this._renderObjects.length; i++) this._lightIndexOffset[i] = this._lightIndices.length, 
                        this._renderObjects[i].model.localBindings.get(UBOForwardLight.BLOCK.name) && this.cullLightPerModel(this._renderObjects[i].model);
                    }
                }, {
                    key: "cullLightPerModel",
                    value: function cullLightPerModel(model) {
                        var _this$_lightIndices;
                        _tempLightIndex.splice(0);
                        for (var i = 0; i < this._validLights.length; i++) {
                            var isCulled = !1;
                            switch (this._validLights[i].type) {
                              case LightType.DIRECTIONAL:
                                this._validLights[i], isCulled = !1;
                                break;

                              case LightType.SPHERE:
                                isCulled = cullSphereLight(this._validLights[i], model);
                                break;

                              case LightType.SPOT:
                                isCulled = cullSpotLight(this._validLights[i], model);
                            }
                            isCulled || (_tempLightIndex.push(i), this._validLights[i].type === LightType.DIRECTIONAL ? _tempLightDist[i] = 0 : _tempLightDist[i] = Vec3.distance(this._validLights[i].position, model.node.getWorldPosition(_tempVec3)));
                        }
                        _tempLightIndex.sort(this.sortLight), (_this$_lightIndices = this._lightIndices).push.apply(_this$_lightIndices, _tempLightIndex);
                    }
                }, {
                    key: "sortLight",
                    value: function sortLight(a, b) {
                        return _tempLightDist[a] - _tempLightDist[b];
                    }
                } ]), ForwardPipeline;
            }();
            !function(RenderViewPriority) {
                RenderViewPriority[RenderViewPriority.GENERAL = 100] = "GENERAL";
            }(RenderViewPriority = RenderViewPriority || {});
            var RenderView = function() {
                function RenderView(root, camera) {
                    _classCallCheck(this, RenderView), this._root = void 0, this._name = "", this._window = null, 
                    this._priority = 0, this._visibility = CameraDefaultMask, this._camera = void 0, 
                    this._isEnable = !0, this._flows = [], this._root = root, this._camera = camera;
                }
                return _createClass(RenderView, [ {
                    key: "name",
                    get: function get() {
                        return this._name;
                    }
                }, {
                    key: "window",
                    get: function get() {
                        return this._window;
                    },
                    set: function set(val) {
                        this._window = val;
                    }
                }, {
                    key: "priority",
                    get: function get() {
                        return this._priority;
                    },
                    set: function set(val) {
                        this._priority = val;
                    }
                }, {
                    key: "visibility",
                    set: function set(vis) {
                        this._visibility = vis;
                    },
                    get: function get() {
                        return this._visibility;
                    }
                }, {
                    key: "camera",
                    get: function get() {
                        return this._camera;
                    }
                }, {
                    key: "isEnable",
                    get: function get() {
                        return this._isEnable;
                    }
                }, {
                    key: "flows",
                    get: function get() {
                        return this._flows;
                    }
                } ], [ {
                    key: "registerCreateFunc",
                    value: function registerCreateFunc(root) {
                        root._createViewFun = function(_root, _camera) {
                            return new RenderView(_root, _camera);
                        };
                    }
                } ]), _createClass(RenderView, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        this._name = info.name, this.priority = info.priority, info.flows || (info.flows = [ "ForwardFlow", "ToneMapFlow", "SMAAFlow" ]);
                        var _iterator = cc.director.root.pipeline.flows, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var f = _ref;
                            -1 !== info.flows.indexOf(f.name) && this.flows.push(f);
                        }
                        return !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._window = null, this._priority = 0;
                    }
                }, {
                    key: "enable",
                    value: function enable(isEnable) {
                        this._isEnable = isEnable;
                    }
                } ]), RenderView;
            }(), _forward = new Vec3(0, 0, -1), _v3$1 = new Vec3(), _qt$1 = new Quat(), DirectionalLight = function() {
                function DirectionalLight(scene, name, node) {
                    var _this;
                    return _classCallCheck(this, DirectionalLight), (_this = _possibleConstructorReturn(this, _getPrototypeOf(DirectionalLight).call(this, scene, name, node)))._dir = new Vec3(1, -1, -1), 
                    _this._illum = 65e3, _this._type = LightType.DIRECTIONAL, _this;
                }
                return _inherits(DirectionalLight, Light), _createClass(DirectionalLight, [ {
                    key: "direction",
                    set: function set(dir) {
                        this._dir = dir, Vec3.normalize(this._dir, this._dir);
                    },
                    get: function get() {
                        return this._dir;
                    }
                }, {
                    key: "illuminance",
                    set: function set(illum) {
                        this._illum = illum;
                    },
                    get: function get() {
                        return this._illum;
                    }
                } ]), _createClass(DirectionalLight, [ {
                    key: "update",
                    value: function update() {
                        this._node && (this._dir = Vec3.transformQuat(_v3$1, _forward, this._node.getWorldRotation(_qt$1)), 
                        Vec3.normalize(this._dir, this._dir));
                    }
                } ]), DirectionalLight;
            }(), _forward$1 = new Vec3(0, 0, -1), _v3$2 = new Vec3(), _qt$2 = new Quat(), PlanarShadows = function() {
                function PlanarShadows(scene) {
                    _classCallCheck(this, PlanarShadows), this._scene = void 0, this._enabled = !1, 
                    this._normal = new Vec3(0, 1, 0), this._distance = 0, this._matLight = new Mat4(), 
                    this._data = Float32Array.from([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, .3 ]), 
                    this._globalBindings = void 0, this._cmdBuffs = void 0, this._cmdBuffCount = 0, 
                    this._psoRecord = new Map(), this._cbRecord = new Map(), this._passNormal = void 0, 
                    this._passSkinning = void 0, this._scene = scene, this._globalBindings = scene.root.pipeline.globalBindings.get(UBOShadow.BLOCK.name), 
                    this._cmdBuffs = new CachedArray(64);
                    var effectAsset = EffectAsset.get("pipeline/planar-shadow"), defines = {
                        CC_USE_SKINNING: selectJointsMediumType(scene.root.device)
                    };
                    this._passNormal = Pass.createPasses(effectAsset, {
                        techIdx: 0,
                        defines: [],
                        states: []
                    })[0], this._passSkinning = Pass.createPasses(effectAsset, {
                        techIdx: 0,
                        defines: [ defines ],
                        states: []
                    })[0];
                }
                return _createClass(PlanarShadows, [ {
                    key: "enabled",
                    set: function set(enable) {
                        this._enabled = enable, this.updateDirLight(), this._cmdBuffs.clear();
                    },
                    get: function get() {
                        return this._enabled;
                    }
                }, {
                    key: "normal",
                    set: function set(val) {
                        Vec3.copy(this._normal, val), this.updateDirLight();
                    },
                    get: function get() {
                        return this._normal;
                    }
                }, {
                    key: "distance",
                    set: function set(val) {
                        this._distance = val, this.updateDirLight();
                    },
                    get: function get() {
                        return this._distance;
                    }
                }, {
                    key: "shadowColor",
                    set: function set(color) {
                        Color.toArray(this._data, color, UBOShadow.SHADOW_COLOR_OFFSET), this._globalBindings.buffer.update(this.data);
                    }
                }, {
                    key: "matLight",
                    get: function get() {
                        return this._matLight;
                    }
                }, {
                    key: "data",
                    get: function get() {
                        return this._data;
                    }
                }, {
                    key: "cmdBuffs",
                    get: function get() {
                        return this._cmdBuffs;
                    }
                }, {
                    key: "cmdBuffCount",
                    get: function get() {
                        return this._cmdBuffs.length;
                    }
                } ]), _createClass(PlanarShadows, [ {
                    key: "updateSphereLight",
                    value: function updateSphereLight(light) {
                        light.node.getWorldPosition(_v3$2);
                        var n = this._normal, d = this._distance, NdL = Vec3.dot(n, _v3$2), lx = _v3$2.x, ly = _v3$2.y, lz = _v3$2.z, nx = n.x, ny = n.y, nz = n.z, m = this._matLight;
                        m.m00 = NdL - d - lx * nx, m.m01 = -ly * nx, m.m02 = -lz * nx, m.m03 = -nx, m.m04 = -lx * ny, 
                        m.m05 = NdL - d - ly * ny, m.m06 = -lz * ny, m.m07 = -ny, m.m08 = -lx * nz, m.m09 = -ly * nz, 
                        m.m10 = NdL - d - lz * nz, m.m11 = -nz, m.m12 = lx * d, m.m13 = ly * d, m.m14 = lz * d, 
                        m.m15 = NdL, Mat4.toArray(this.data, this._matLight), this._globalBindings.buffer.update(this.data);
                    }
                }, {
                    key: "updateDirLight",
                    value: function updateDirLight(argument_0) {
                        (0 < arguments.length && void 0 !== argument_0 ? argument_0 : this._scene.mainLight).node.getWorldRotation(_qt$2), 
                        Vec3.transformQuat(_v3$2, _forward$1, _qt$2);
                        var n = this._normal, d = this._distance, scale = 1 / Vec3.dot(n, _v3$2), lx = _v3$2.x * scale, ly = _v3$2.y * scale, lz = _v3$2.z * scale, nx = n.x, ny = n.y, nz = n.z, m = this._matLight;
                        m.m00 = 1 - nx * lx, m.m01 = -nx * ly, m.m02 = -nx * lz, m.m03 = 0, m.m04 = -ny * lx, 
                        m.m05 = 1 - ny * ly, m.m06 = -ny * lz, m.m07 = 0, m.m08 = -nz * lx, m.m09 = -nz * ly, 
                        m.m10 = 1 - nz * lz, m.m11 = 0, m.m12 = lx * d, m.m13 = ly * d, m.m14 = lz * d, 
                        m.m15 = 1, Mat4.toArray(this.data, this._matLight, UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET), 
                        this._globalBindings.buffer.update(this.data);
                    }
                }, {
                    key: "updateCommandBuffers",
                    value: function updateCommandBuffers() {
                        if (this._cmdBuffs.clear(), this._scene.mainLight.enabled) {
                            var _iterator = this._scene.models, _isArray = Array.isArray(_iterator), _i = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i >= _iterator.length) break;
                                    _ref = _iterator[_i++];
                                } else {
                                    if ((_i = _iterator.next()).done) break;
                                    _ref = _i.value;
                                }
                                var model = _ref;
                                if (model.enabled && model.node && model.castShadow) {
                                    var pso = this._psoRecord.get(model);
                                    pso || (pso = this._createPSO(model), this._psoRecord.set(model, pso)), model.UBOUpdated || model.updateUBOs();
                                    for (var i = 0; i < model.subModelNum; i++) {
                                        var ia = model.getSubModel(i).inputAssembler;
                                        if (ia) {
                                            var cb = this._cbRecord.get(ia);
                                            cb || ((cb = this._createCommandBuffer()).begin(), cb.bindPipelineState(pso), cb.bindBindingLayout(pso.pipelineLayout.layouts[0]), 
                                            cb.bindInputAssembler(ia), cb.draw(ia), cb.end(), this._cbRecord.set(ia, cb)), this.cmdBuffs.push(cb);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }, {
                    key: "onPipelineChange",
                    value: function onPipelineChange() {
                        for (var cbs = this._cbRecord.values(), cbRes = cbs.next(); !cbRes.done; ) cbRes.value.destroy(), 
                        cbRes = cbs.next();
                        this._cbRecord.clear();
                        for (var models = this._psoRecord.keys(), modelRes = models.next(); !modelRes.done; ) {
                            (modelRes.value instanceof SkinningModel ? this._passSkinning : this._passNormal).destroyPipelineState(this._psoRecord.get(modelRes.value)), 
                            modelRes = models.next();
                        }
                        this._psoRecord.clear();
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.onPipelineChange(), this._passNormal.destroy(), this._passSkinning.destroy();
                    }
                }, {
                    key: "_createPSO",
                    value: function _createPSO(model) {
                        var pass = model instanceof SkinningModel ? this._passSkinning : this._passNormal, pso = model._doCreatePSO(pass);
                        return pso.pipelineLayout.layouts[0].update(), pso;
                    }
                }, {
                    key: "_createCommandBuffer",
                    value: function _createCommandBuffer() {
                        var device = this._scene.root.device;
                        return device.createCommandBuffer({
                            allocator: device.commandAllocator,
                            type: GFXCommandBufferType.SECONDARY
                        });
                    }
                } ]), PlanarShadows;
            }();
            function applyDefaultGeometryOptions(options) {
                return void 0 === (options = options || {}).includeNormal && (options.includeNormal = !0), 
                void 0 === options.includeUV && (options.includeUV = !0), options;
            }
            function box(options) {
                var ws = (options = options || {}).widthSegments || 1, hs = options.heightSegments || 1, ls = options.lengthSegments || 1, hw = (options.width || 1) / 2, hh = (options.height || 1) / 2, hl = (options.length || 1) / 2, corners = [ Vec3.set(c0, -hw, -hh, hl), Vec3.set(c1, hw, -hh, hl), Vec3.set(c2, hw, hh, hl), Vec3.set(c3, -hw, hh, hl), Vec3.set(c4, hw, -hh, -hl), Vec3.set(c5, -hw, -hh, -hl), Vec3.set(c6, -hw, hh, -hl), Vec3.set(c7, hw, hh, -hl) ], faceAxes = [ [ 2, 3, 1 ], [ 4, 5, 7 ], [ 7, 6, 2 ], [ 1, 0, 4 ], [ 1, 4, 2 ], [ 5, 0, 6 ] ], faceNormals = [ [ 0, 0, 1 ], [ 0, 0, -1 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 1, 0, 0 ], [ -1, 0, 0 ] ], positions = [], normals = [], uvs = [], indices = [], minPos = new Vec3(-hw, -hh, -hl), maxPos = new Vec3(hw, hh, hl), boundingRadius = Math.sqrt(hw * hw + hh * hh + hl * hl);
                function _buildPlane(side, uSegments, vSegments) {
                    var u, v, ix, iy, offset = positions.length / 3, faceAxe = faceAxes[side], faceNormal = faceNormals[side];
                    for (iy = 0; iy <= vSegments; iy++) for (ix = 0; ix <= uSegments; ix++) if (u = ix / uSegments, 
                    v = iy / vSegments, Vec3.lerp(temp1, corners[faceAxe[0]], corners[faceAxe[1]], u), 
                    Vec3.lerp(temp2, corners[faceAxe[0]], corners[faceAxe[2]], v), Vec3.subtract(temp3, temp2, corners[faceAxe[0]]), 
                    Vec3.add(r, temp1, temp3), positions.push(r.x, r.y, r.z), normals.push(faceNormal[0], faceNormal[1], faceNormal[2]), 
                    uvs.push(u, v), ix < uSegments && iy < vSegments) {
                        var useg1 = uSegments + 1, a = ix + iy * useg1, b = ix + (iy + 1) * useg1, c = ix + 1 + (iy + 1) * useg1, d = ix + 1 + iy * useg1;
                        indices.push(offset + a, offset + d, offset + b), indices.push(offset + b, offset + d, offset + c);
                    }
                }
                return _buildPlane(0, ws, hs), _buildPlane(4, ls, hs), _buildPlane(1, ws, hs), _buildPlane(5, ls, hs), 
                _buildPlane(3, ws, ls), _buildPlane(2, ws, ls), {
                    positions: positions,
                    normals: normals,
                    uvs: uvs,
                    indices: indices,
                    minPos: minPos,
                    maxPos: maxPos,
                    boundingRadius: boundingRadius
                };
            }
            var temp1 = new Vec3(), temp2 = new Vec3(), temp3 = new Vec3(), r = new Vec3(), c0 = new Vec3(), c1 = new Vec3(), c2 = new Vec3(), c3 = new Vec3(), c4 = new Vec3(), c5 = new Vec3(), c6 = new Vec3(), c7 = new Vec3(), temp1$1 = new Vec3(0, 0, 0), temp2$1 = new Vec3(0, 0, 0);
            function cylinder() {
                var radiusTop = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : .5, radiusBottom = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : .5, height = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 2, opts = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : {}, halfHeight = .5 * height, radialSegments = opts.radialSegments || 32, heightSegments = opts.heightSegments || 1, capped = void 0 === opts.capped || opts.capped, arc = opts.arc || 2 * Math.PI, cntCap = 0;
                capped || (0 < radiusTop && cntCap++, 0 < radiusBottom && cntCap++);
                var vertCount = (radialSegments + 1) * (heightSegments + 1);
                capped && (vertCount += (radialSegments + 1) * cntCap + radialSegments * cntCap);
                var indexCount = radialSegments * heightSegments * 2 * 3;
                capped && (indexCount += radialSegments * cntCap * 3);
                var indices = new Array(indexCount), positions = new Array(3 * vertCount), normals = new Array(3 * vertCount), uvs = new Array(2 * vertCount), maxRadius = Math.max(radiusTop, radiusBottom), minPos = new Vec3(-maxRadius, -halfHeight, -maxRadius), maxPos = new Vec3(maxRadius, halfHeight, maxRadius), boundingRadius = Math.sqrt(maxRadius * maxRadius + halfHeight * halfHeight), index = 0, indexOffset = 0;
                return function generateTorso() {
                    for (var indexArray = [], r = radiusTop - radiusBottom, slope = r * r / height * Math.sign(r), y = 0; y <= heightSegments; y++) {
                        for (var indexRow = [], v = y / heightSegments, radius = v * r + radiusBottom, x = 0; x <= radialSegments; ++x) {
                            var u = x / radialSegments, theta = u * arc, sinTheta = Math.sin(theta), cosTheta = Math.cos(theta);
                            positions[3 * index] = radius * sinTheta, positions[3 * index + 1] = v * height - halfHeight, 
                            positions[3 * index + 2] = radius * cosTheta, Vec3.normalize(temp1$1, Vec3.set(temp2$1, sinTheta, -slope, cosTheta)), 
                            normals[3 * index] = temp1$1.x, normals[3 * index + 1] = temp1$1.y, normals[3 * index + 2] = temp1$1.z, 
                            uvs[2 * index] = 2 * (1 - u) % 1, uvs[2 * index + 1] = v, indexRow.push(index), 
                            ++index;
                        }
                        indexArray.push(indexRow);
                    }
                    for (var _y = 0; _y < heightSegments; ++_y) for (var _x = 0; _x < radialSegments; ++_x) {
                        var i1 = indexArray[_y][_x], i2 = indexArray[_y + 1][_x], i3 = indexArray[_y + 1][_x + 1], i4 = indexArray[_y][_x + 1];
                        indices[indexOffset] = i1, indices[++indexOffset] = i4, indices[++indexOffset] = i2, 
                        indices[++indexOffset] = i4, indices[++indexOffset] = i3, indices[++indexOffset] = i2, 
                        ++indexOffset;
                    }
                }(), capped && (0 < radiusBottom && generateCap(!1), 0 < radiusTop && generateCap(!0)), 
                {
                    positions: positions,
                    normals: normals,
                    uvs: uvs,
                    indices: indices,
                    minPos: minPos,
                    maxPos: maxPos,
                    boundingRadius: boundingRadius
                };
                function generateCap(top) {
                    for (var radius = top ? radiusTop : radiusBottom, sign = top ? 1 : -1, centerIndexStart = index, x = 1; x <= radialSegments; ++x) positions[3 * index] = 0, 
                    positions[3 * index + 1] = halfHeight * sign, positions[3 * index + 2] = 0, normals[3 * index] = 0, 
                    normals[3 * index + 1] = sign, normals[3 * index + 2] = 0, uvs[2 * index] = .5, 
                    uvs[2 * index + 1] = .5, ++index;
                    for (var centerIndexEnd = index, _x2 = 0; _x2 <= radialSegments; ++_x2) {
                        var theta = _x2 / radialSegments * arc, cosTheta = Math.cos(theta), sinTheta = Math.sin(theta);
                        positions[3 * index] = radius * sinTheta, positions[3 * index + 1] = halfHeight * sign, 
                        positions[3 * index + 2] = radius * cosTheta, normals[3 * index] = 0, normals[3 * index + 1] = sign, 
                        normals[3 * index + 2] = 0, uvs[2 * index] = .5 - .5 * sinTheta * sign, uvs[2 * index + 1] = .5 + .5 * cosTheta, 
                        ++index;
                    }
                    for (var _x3 = 0; _x3 < radialSegments; ++_x3) {
                        var c = centerIndexStart + _x3, i = centerIndexEnd + _x3;
                        top ? (indices[indexOffset] = i + 1, indices[++indexOffset] = c) : (indices[indexOffset] = c, 
                        indices[++indexOffset] = i + 1), indices[++indexOffset] = i, ++indexOffset;
                    }
                }
            }
            var temp1$2 = new Vec3(0, 0, 0), temp2$2 = new Vec3(0, 0, 0), temp3$1 = new Vec3(0, 0, 0), r$1 = new Vec3(0, 0, 0), c00 = new Vec3(0, 0, 0), c10 = new Vec3(0, 0, 0), c01 = new Vec3(0, 0, 0);
            var temp1$3 = new Vec3(0, 0, 0), temp2$3 = new Vec3(0, 0, 0);
            var primitives = Object.freeze({
                box: box,
                cone: function cone() {
                    return cylinder(0, 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : .5, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {});
                },
                cylinder: cylinder,
                plane: function plane$1(options) {
                    var normalizedOptions = function applyDefaultPlaneOptions(options) {
                        return (options = applyDefaultGeometryOptions(options)).width = options.width || 10, 
                        options.length = options.length || 10, options.widthSegments = options.widthSegments || 10, 
                        options.lengthSegments = options.lengthSegments || 10, options;
                    }(options), width = normalizedOptions.width, length = normalizedOptions.length, uSegments = normalizedOptions.widthSegments, vSegments = normalizedOptions.lengthSegments, hw = .5 * width, hl = .5 * length, positions = [], uvs = [], indices = [], minPos = new Vec3(-hw, 0, -hl), maxPos = new Vec3(hw, 0, hl), boundingRadius = Math.sqrt(width * width + length * length);
                    Vec3.set(c00, -hw, 0, hl), Vec3.set(c10, hw, 0, hl), Vec3.set(c01, -hw, 0, -hl);
                    for (var y = 0; y <= vSegments; y++) for (var x = 0; x <= uSegments; x++) {
                        var u = x / uSegments, v = y / vSegments;
                        if (Vec3.lerp(temp1$2, c00, c10, u), Vec3.lerp(temp2$2, c00, c01, v), Vec3.subtract(temp3$1, temp2$2, c00), 
                        Vec3.add(r$1, temp1$2, temp3$1), positions.push(r$1.x, r$1.y, r$1.z), normalizedOptions.includeUV && uvs.push(u, v), 
                        x < uSegments && y < vSegments) {
                            var useg1 = uSegments + 1, a = x + y * useg1, b = x + (y + 1) * useg1, c = x + 1 + (y + 1) * useg1, d = x + 1 + y * useg1;
                            indices.push(a, d, b), indices.push(d, c, b);
                        }
                    }
                    var result = {
                        positions: positions,
                        indices: indices,
                        minPos: minPos,
                        maxPos: maxPos,
                        boundingRadius: boundingRadius
                    };
                    if (normalizedOptions.includeNormal) {
                        var nVertex = (vSegments + 1) * (uSegments + 1), normals = new Array(3 * nVertex);
                        result.normals = normals;
                        for (var i = 0; i < nVertex; ++i) normals[3 * i + 0] = 0, normals[3 * i + 1] = 1, 
                        normals[3 * i + 2] = 0;
                    }
                    return normalizedOptions.includeUV && (result.uvs = uvs), result;
                },
                quad: function quad(options) {
                    var normalizedOptions = applyDefaultGeometryOptions(options), result = {
                        positions: [ -.5, -.5, 0, -.5, .5, 0, .5, .5, 0, .5, -.5, 0 ],
                        indices: [ 0, 3, 1, 3, 2, 1 ],
                        minPos: {
                            x: -.5,
                            y: -.5,
                            z: 0
                        },
                        maxPos: {
                            x: .5,
                            y: .5,
                            z: 0
                        },
                        boundingRadius: Math.sqrt(.5)
                    };
                    return !1 !== normalizedOptions.includeNormal && (result.normals = [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1 ]), 
                    !1 !== normalizedOptions.includeUV && (result.uvs = [ 0, 0, 0, 1, 1, 1, 1, 0 ]), 
                    result;
                },
                sphere: function sphere$1() {
                    for (var radius = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : .5, opts = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, segments = void 0 !== opts.segments ? opts.segments : 32, positions = [], normals = [], uvs = [], indices = [], minPos = new Vec3(-radius, -radius, -radius), maxPos = new Vec3(radius, radius, radius), boundingRadius = radius, lat = 0; lat <= segments; ++lat) for (var theta = lat * Math.PI / segments, sinTheta = Math.sin(theta), cosTheta = -Math.cos(theta), lon = 0; lon <= segments; ++lon) {
                        var phi = 2 * lon * Math.PI / segments - Math.PI / 2, x = Math.sin(phi) * sinTheta, y = cosTheta, z = Math.cos(phi) * sinTheta, u = lon / segments, v = lat / segments;
                        if (positions.push(x * radius, y * radius, z * radius), normals.push(x, y, z), uvs.push(u, v), 
                        lat < segments && lon < segments) {
                            var seg1 = segments + 1, a = seg1 * lat + lon, b = seg1 * (lat + 1) + lon, c = seg1 * (lat + 1) + lon + 1, d = seg1 * lat + lon + 1;
                            indices.push(a, d, b), indices.push(d, c, b);
                        }
                    }
                    return {
                        positions: positions,
                        indices: indices,
                        normals: normals,
                        uvs: uvs,
                        minPos: minPos,
                        maxPos: maxPos,
                        boundingRadius: boundingRadius
                    };
                },
                torus: function torus() {
                    for (var radius = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : .4, tube = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : .1, opts = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {}, radialSegments = opts.radialSegments || 32, tubularSegments = opts.tubularSegments || 32, arc = opts.arc || 2 * Math.PI, positions = [], normals = [], uvs = [], indices = [], minPos = new Vec3(-radius - tube, -tube, -radius - tube), maxPos = new Vec3(radius + tube, tube, radius + tube), boundingRadius = radius + tube, j = 0; j <= radialSegments; j++) for (var i = 0; i <= tubularSegments; i++) {
                        var u = i / tubularSegments, v = j / radialSegments, u1 = u * arc, v1 = v * Math.PI * 2, x = (radius + tube * Math.cos(v1)) * Math.sin(u1), y = tube * Math.sin(v1), z = (radius + tube * Math.cos(v1)) * Math.cos(u1), nx = Math.sin(u1) * Math.cos(v1), ny = Math.sin(v1), nz = Math.cos(u1) * Math.cos(v1);
                        if (positions.push(x, y, z), normals.push(nx, ny, nz), uvs.push(u, v), i < tubularSegments && j < radialSegments) {
                            var seg1 = tubularSegments + 1, a = seg1 * j + i, b = seg1 * (j + 1) + i, c = seg1 * (j + 1) + i + 1, d = seg1 * j + i + 1;
                            indices.push(a, d, b), indices.push(d, c, b);
                        }
                    }
                    return {
                        positions: positions,
                        normals: normals,
                        uvs: uvs,
                        indices: indices,
                        minPos: minPos,
                        maxPos: maxPos,
                        boundingRadius: boundingRadius
                    };
                },
                capsule: function capsule() {
                    var radiusTop = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : .5, radiusBottom = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : .5, height = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 2, opts = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : {}, torsoHeight = height - radiusTop - radiusBottom, sides = opts.sides || 32, heightSegments = opts.heightSegments || 32, bottomProp = radiusBottom / height, torProp = torsoHeight / height, topProp = radiusTop / height, bottomSegments = Math.floor(heightSegments * bottomProp), topSegments = Math.floor(heightSegments * topProp), torSegments = Math.floor(heightSegments * torProp), topOffset = torsoHeight + radiusBottom - height / 2, torOffset = radiusBottom - height / 2, bottomOffset = radiusBottom - height / 2, arc = opts.arc || 2 * Math.PI, positions = [], normals = [], uvs = [], indices = [], maxRadius = Math.max(radiusTop, radiusBottom), minPos = new Vec3(-maxRadius, -height / 2, -maxRadius), maxPos = new Vec3(maxRadius, height / 2, maxRadius), boundingRadius = height / 2, index = 0, indexArray = [];
                    return function generateBottom() {
                        for (var lat = 0; lat <= bottomSegments; ++lat) for (var theta = lat * Math.PI / bottomSegments / 2, sinTheta = Math.sin(theta), cosTheta = -Math.cos(theta), lon = 0; lon <= sides; ++lon) {
                            var phi = 2 * lon * Math.PI / sides - Math.PI / 2, sinPhi = Math.sin(phi), cosPhi = Math.cos(phi), x = sinPhi * sinTheta, y = cosTheta, z = cosPhi * sinTheta, u = lon / sides, v = lat / heightSegments;
                            if (positions.push(x * radiusBottom, y * radiusBottom + bottomOffset, z * radiusBottom), 
                            normals.push(x, y, z), uvs.push(u, v), lat < bottomSegments && lon < sides) {
                                var seg1 = sides + 1, a = seg1 * lat + lon, b = seg1 * (lat + 1) + lon, c = seg1 * (lat + 1) + lon + 1, d = seg1 * lat + lon + 1;
                                indices.push(a, d, b), indices.push(d, c, b);
                            }
                            ++index;
                        }
                    }(), function generateTorso() {
                        for (var slope = (radiusTop - radiusBottom) / torsoHeight, y = 0; y <= torSegments; y++) {
                            for (var indexRow = [], lat = y / torSegments, radius = lat * (radiusTop - radiusBottom) + radiusBottom, x = 0; x <= sides; ++x) {
                                var u = x / sides, v = lat * torProp + bottomProp, theta = u * arc - arc / 4, sinTheta = Math.sin(theta), cosTheta = Math.cos(theta);
                                positions.push(radius * sinTheta), positions.push(lat * torsoHeight + torOffset), 
                                positions.push(radius * cosTheta), Vec3.normalize(temp1$3, Vec3.set(temp2$3, sinTheta, -slope, cosTheta)), 
                                normals.push(temp1$3.x), normals.push(temp1$3.y), normals.push(temp1$3.z), uvs.push(u, v), 
                                indexRow.push(index), ++index;
                            }
                            indexArray.push(indexRow);
                        }
                        for (var _y = 0; _y < torSegments; ++_y) for (var _x = 0; _x < sides; ++_x) {
                            var i1 = indexArray[_y][_x], i2 = indexArray[_y + 1][_x], i3 = indexArray[_y + 1][_x + 1], i4 = indexArray[_y][_x + 1];
                            indices.push(i1), indices.push(i4), indices.push(i2), indices.push(i4), indices.push(i3), 
                            indices.push(i2);
                        }
                    }(), function generateTop() {
                        for (var lat = 0; lat <= topSegments; ++lat) for (var theta = lat * Math.PI / topSegments / 2 + Math.PI / 2, sinTheta = Math.sin(theta), cosTheta = -Math.cos(theta), lon = 0; lon <= sides; ++lon) {
                            var phi = 2 * lon * Math.PI / sides - Math.PI / 2, sinPhi = Math.sin(phi), cosPhi = Math.cos(phi), x = sinPhi * sinTheta, y = cosTheta, z = cosPhi * sinTheta, u = lon / sides, v = lat / heightSegments + (1 - topProp);
                            if (positions.push(x * radiusTop, y * radiusTop + topOffset, z * radiusTop), normals.push(x, y, z), 
                            uvs.push(u, v), lat < topSegments && lon < sides) {
                                var seg1 = sides + 1, a = seg1 * lat + lon + indexArray[torSegments][sides] + 1, b = seg1 * (lat + 1) + lon + indexArray[torSegments][sides] + 1, c = seg1 * (lat + 1) + lon + 1 + indexArray[torSegments][sides] + 1, d = seg1 * lat + lon + 1 + indexArray[torSegments][sides] + 1;
                                indices.push(a, d, b), indices.push(d, c, b);
                            }
                        }
                    }(), {
                        positions: positions,
                        normals: normals,
                        uvs: uvs,
                        indices: indices,
                        minPos: minPos,
                        maxPos: maxPos,
                        boundingRadius: boundingRadius
                    };
                },
                circle: function circle(options) {
                    var segments = function applyDefaultCircleOptions(options) {
                        return (options = applyDefaultGeometryOptions(options)).segments = 64, options;
                    }(options).segments, positions = new Array(3 * (segments + 1));
                    positions[0] = 0, positions[1] = 0, positions[2] = 0;
                    var indices = new Array(1 + 2 * segments);
                    indices[0] = 0;
                    for (var step = 2 * Math.PI / segments, iSegment = 0; iSegment < segments; ++iSegment) {
                        var angle = step * iSegment, x = Math.cos(angle), y = Math.sin(angle), p = 3 * (iSegment + 1);
                        positions[0 + p] = x, positions[1 + p] = y, positions[2 + p] = 0;
                        var i = 2 * iSegment;
                        indices[1 + i] = iSegment + 1, indices[1 + i + 1] = iSegment + 2;
                    }
                    return 0 < segments && (indices[indices.length - 1] = 1), {
                        positions: positions,
                        indices: indices,
                        minPos: {
                            x: 1,
                            y: 1,
                            z: 0
                        },
                        maxPos: {
                            x: -1,
                            y: -1,
                            z: 0
                        },
                        boundingRadius: 1,
                        primitiveMode: GFXPrimitiveMode.TRIANGLE_FAN
                    };
                },
                translate: function translate(geometry, offset) {
                    for (var x = offset.x || 0, y = offset.y || 0, z = offset.z || 0, nVertex = Math.floor(geometry.positions.length / 3), iVertex = 0; iVertex < nVertex; ++iVertex) {
                        var iX = 3 * iVertex, iY = 3 * iVertex + 1, iZ = 3 * iVertex + 2;
                        geometry.positions[iX] = geometry.positions[iX] + x, geometry.positions[iY] = geometry.positions[iY] + y, 
                        geometry.positions[iZ] = geometry.positions[iZ] + z;
                    }
                    return geometry.minPos && (geometry.minPos.x += x, geometry.minPos.y += y, geometry.minPos.z += z), 
                    geometry.maxPos && (geometry.maxPos.x += x, geometry.maxPos.y += y, geometry.maxPos.z += z), 
                    geometry;
                },
                scale: function scale(geometry, value) {
                    for (var x = value.x || 0, y = value.y || 0, z = value.z || 0, nVertex = Math.floor(geometry.positions.length / 3), iVertex = 0; iVertex < nVertex; ++iVertex) {
                        var iX = 3 * iVertex, iY = 3 * iVertex + 1, iZ = 3 * iVertex + 2;
                        geometry.positions[iX] *= x, geometry.positions[iY] *= y, geometry.positions[iZ] *= z;
                    }
                    return geometry.minPos && (geometry.minPos.x *= x, geometry.minPos.y *= y, geometry.minPos.z *= z), 
                    geometry.maxPos && (geometry.maxPos.x *= x, geometry.maxPos.y *= y, geometry.maxPos.z *= z), 
                    geometry.boundingRadius = Math.max(Math.max(x, y), z), geometry;
                },
                wireframed: function wireframed(geometry) {
                    var indices = geometry.indices;
                    if (!indices) return geometry;
                    if (geometry.primitiveMode && geometry.primitiveMode !== GFXPrimitiveMode.TRIANGLE_LIST) return geometry;
                    for (var offsets = [ [ 0, 1 ], [ 1, 2 ], [ 2, 0 ] ], lines = [], lineIDs = {}, i = 0; i < indices.length; i += 3) for (var k = 0; k < 3; ++k) {
                        var i1 = indices[i + offsets[k][0]], i2 = indices[i + offsets[k][1]], id = i2 < i1 ? i2 << 16 | i1 : i1 << 16 | i2;
                        void 0 === lineIDs[id] && (lineIDs[id] = 0, lines.push(i1, i2));
                    }
                    return geometry.indices = lines, geometry.primitiveMode = GFXPrimitiveMode.LINE_LIST, 
                    geometry;
                },
                wireframe: function wireframe(indices) {
                    for (var offsets = [ [ 0, 1 ], [ 1, 2 ], [ 2, 0 ] ], lines = [], lineIDs = {}, i = 0; i < indices.length; i += 3) for (var k = 0; k < 3; ++k) {
                        var i1 = indices[i + offsets[k][0]], i2 = indices[i + offsets[k][1]], id = i2 < i1 ? i2 << 16 | i1 : i1 << 16 | i2;
                        void 0 === lineIDs[id] && (lineIDs[id] = 0, lines.push(i1, i2));
                    }
                    return lines;
                },
                invWinding: function invWinding(indices) {
                    for (var newIB = [], i = 0; i < indices.length; i += 3) newIB.push(indices[i], indices[i + 2], indices[i + 1]);
                    return newIB;
                },
                toWavefrontOBJ: function toWavefrontOBJ(primitive) {
                    var scale = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1;
                    if (!primitive.indices || !primitive.uvs || !primitive.normals || void 0 !== primitive.primitiveMode && primitive.primitiveMode !== GFXPrimitiveMode.TRIANGLE_LIST) return "";
                    for (var v = primitive.positions, t = primitive.uvs, n = primitive.normals, IB = primitive.indices, V = function V(i) {
                        return "".concat(IB[i] + 1, "/").concat(IB[i] + 1, "/").concat(IB[i] + 1);
                    }, content = "", i = 0; i < v.length; i += 3) content += "v ".concat(v[i] * scale, " ").concat(v[i + 1] * scale, " ").concat(v[i + 2] * scale, "\n");
                    for (var _i = 0; _i < t.length; _i += 2) content += "vt ".concat(t[_i], " ").concat(t[_i + 1], "\n");
                    for (var _i2 = 0; _i2 < n.length; _i2 += 3) content += "vn ".concat(n[_i2], " ").concat(n[_i2 + 1], " ").concat(n[_i2 + 2], "\n");
                    for (var _i3 = 0; _i3 < IB.length; _i3 += 3) content += "f ".concat(V(_i3), " ").concat(V(_i3 + 1), " ").concat(V(_i3 + 2), "\n");
                    return content;
                },
                normals: function normals(positions, normals) {
                    for (var length = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 1, verts = new Array(2 * positions.length), i = 0; i < positions.length / 3; ++i) {
                        var i3 = 3 * i, i6 = 6 * i;
                        verts[0 + i6] = positions[0 + i3], verts[1 + i6] = positions[1 + i3], verts[2 + i6] = positions[2 + i3], 
                        verts[3 + i6] = positions[0 + i3] + normals[0 + i3] * length, verts[4 + i6] = positions[1 + i3] + normals[1 + i3] * length, 
                        verts[5 + i6] = positions[2 + i3] + normals[2 + i3] * length;
                    }
                    return verts;
                },
                applyDefaultGeometryOptions: applyDefaultGeometryOptions
            });
            exports("primitives", primitives);
            var Stage, Skybox = function() {
                function Skybox(scene) {
                    var _this;
                    _classCallCheck(this, Skybox), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Skybox).call(this, scene, null)))._default = builtinResMgr.get("default-cube-texture"), 
                    _this._envmap = _this._default, _this._isRGBE = !1, _this._useIBL = !1, _this._material = new Material(), 
                    _this._globalBinding = void 0, _this._scene = scene, _this._material.initialize({
                        effectName: "pipeline/skybox",
                        defines: {
                            USE_RGBE_CUBEMAP: _this._isRGBE
                        }
                    }), _this._globalBinding = _this._scene.root.pipeline.globalBindings.get(UNIFORM_ENVIRONMENT.name);
                    var subMeshData = createMesh(box({
                        width: 2,
                        height: 2,
                        length: 2
                    })).renderingMesh.getSubmesh(0);
                    return _this.initSubModel(0, subMeshData, _this._material), _this;
                }
                return _inherits(Skybox, Model), _createClass(Skybox, [ {
                    key: "useIBL",
                    set: function set(val) {
                        this._useIBL = val, this._updatePipeline();
                    },
                    get: function get() {
                        return this._useIBL;
                    }
                }, {
                    key: "isRGBE",
                    set: function set(val) {
                        this._isRGBE = val, this._material.recompileShaders({
                            USE_RGBE_CUBEMAP: this._isRGBE
                        }), this.setSubModelMaterial(0, this._material), this._updateGlobalBinding(), this._updatePipeline();
                    },
                    get: function get() {
                        return this._isRGBE;
                    }
                }, {
                    key: "envmap",
                    set: function set(val) {
                        var newEnvmap = val || this._default;
                        this._envmap = newEnvmap, this._scene.ambient.groundAlbedo[3] = this._envmap.mipmapLevel, 
                        this._updateGlobalBinding();
                    },
                    get: function get() {
                        return this._envmap;
                    }
                } ]), _createClass(Skybox, [ {
                    key: "_updatePipeline",
                    value: function _updatePipeline() {
                        var value = this._useIBL ? this._isRGBE ? 2 : 1 : 0, pipeline = this._scene.root.pipeline;
                        pipeline.macros.CC_USE_IBL !== value && (pipeline.macros.CC_USE_IBL = value, this._scene.onPipelineChange());
                    }
                }, {
                    key: "_updateGlobalBinding",
                    value: function _updateGlobalBinding() {
                        var textureView = this._envmap.getGFXTextureView(), sampler = samplerLib.getSampler(this._device, this._envmap.getSamplerHash());
                        this._globalBinding.sampler = sampler, this._globalBinding.textureView = textureView;
                        var mat = this._material;
                        mat.passes[0].bindSampler(UNIFORM_ENVIRONMENT.binding, sampler), mat.passes[0].bindTextureView(UNIFORM_ENVIRONMENT.binding, textureView);
                        var _iterator = this._matPSORecord.get(mat), _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            _ref.pipelineLayout.layouts[0].update();
                        }
                    }
                } ]), Skybox;
            }(), SphereLight = function() {
                function SphereLight(scene, name, node) {
                    var _this;
                    return _classCallCheck(this, SphereLight), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SphereLight).call(this, scene, name, node)))._size = .15, 
                    _this._range = 1, _this._luminance = 1700 / nt2lm(_this._size), _this._pos = void 0, 
                    _this._aabb = void 0, _this._type = LightType.SPHERE, _this._aabb = aabb.create(), 
                    _this._pos = new Vec3(), _this;
                }
                return _inherits(SphereLight, Light), _createClass(SphereLight, [ {
                    key: "position",
                    get: function get() {
                        return this._pos;
                    }
                }, {
                    key: "size",
                    set: function set(size) {
                        this._size = size;
                    },
                    get: function get() {
                        return this._size;
                    }
                }, {
                    key: "range",
                    set: function set(range) {
                        this._range = range;
                    },
                    get: function get() {
                        return this._range;
                    }
                }, {
                    key: "luminance",
                    set: function set(lum) {
                        this._luminance = lum;
                    },
                    get: function get() {
                        return this._luminance;
                    }
                }, {
                    key: "aabb",
                    get: function get() {
                        return this._aabb;
                    }
                } ]), _createClass(SphereLight, [ {
                    key: "update",
                    value: function update() {
                        this._node && (this._node.getWorldPosition(this._pos), aabb.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, this._range, this._range, this._range));
                    }
                } ]), SphereLight;
            }(), _forward$2 = new Vec3(0, 0, -1), _v3$3 = new Vec3(), _qt$3 = new Quat(), _matView = new Mat4(), _matProj = new Mat4(), _matViewProj = new Mat4(), _matViewProjInv = new Mat4(), SpotLight = function() {
                function SpotLight(scene, name, node) {
                    var _this;
                    return _classCallCheck(this, SpotLight), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SpotLight).call(this, scene, name, node)))._dir = new Vec3(1, -1, -1), 
                    _this._size = .15, _this._range = 5, _this._luminance = 1700 / nt2lm(_this._size), 
                    _this._spotAngle = Math.cos(Math.PI / 6), _this._pos = void 0, _this._aabb = void 0, 
                    _this._frustum = void 0, _this._angle = 0, _this._type = LightType.SPOT, _this._aabb = aabb.create(), 
                    _this._frustum = frustum.create(), _this._pos = new Vec3(), _this;
                }
                return _inherits(SpotLight, Light), _createClass(SpotLight, [ {
                    key: "position",
                    get: function get() {
                        return this._pos;
                    }
                }, {
                    key: "size",
                    set: function set(size) {
                        this._size = size;
                    },
                    get: function get() {
                        return this._size;
                    }
                }, {
                    key: "range",
                    set: function set(range) {
                        this._range = range;
                    },
                    get: function get() {
                        return this._range;
                    }
                }, {
                    key: "luminance",
                    set: function set(lum) {
                        this._luminance = lum;
                    },
                    get: function get() {
                        return this._luminance;
                    }
                }, {
                    key: "direction",
                    get: function get() {
                        return this._dir;
                    }
                }, {
                    key: "spotAngle",
                    get: function get() {
                        return this._spotAngle;
                    },
                    set: function set(val) {
                        this._angle = .5 * val, this._spotAngle = Math.cos(.5 * val);
                    }
                }, {
                    key: "aabb",
                    get: function get() {
                        return this._aabb;
                    }
                }, {
                    key: "frustum",
                    get: function get() {
                        return this._frustum;
                    }
                } ]), _createClass(SpotLight, [ {
                    key: "update",
                    value: function update() {
                        this._node && (this._node.getWorldPosition(this._pos), this._dir = Vec3.transformQuat(_v3$3, _forward$2, this._node.getWorldRotation(_qt$3)), 
                        Vec3.normalize(this._dir, this._dir), aabb.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, this._range, this._range, this._range), 
                        this._node.getWorldRT(_matView), Mat4.invert(_matView, _matView), Mat4.perspective(_matProj, this._angle, 1, .001, this._range), 
                        Mat4.multiply(_matViewProj, _matProj, _matView), Mat4.invert(_matViewProjInv, _matViewProj), 
                        this._frustum.update(_matViewProj, _matViewProjInv));
                    }
                } ]), SpotLight;
            }(), RenderScene = function() {
                function RenderScene(root) {
                    _classCallCheck(this, RenderScene), this._root = void 0, this._name = "", this._cameras = [], 
                    this._ambient = void 0, this._skybox = void 0, this._planarShadows = void 0, this._mainLight = void 0, 
                    this._defaultMainLightNode = void 0, this._sphereLights = [], this._spotLights = [], 
                    this._models = [], this._modelId = 0, this._texturePool = void 0, this._root = root, 
                    this._ambient = new Ambient(this), this._defaultMainLightNode = new Node$1("Main Light"), 
                    this._mainLight = new DirectionalLight(this, "Main Light", this._defaultMainLightNode), 
                    this._mainLight.illuminance = Ambient.SUN_ILLUM, this._mainLight.enabled = !1, this._ambient = new Ambient(this), 
                    this._skybox = new Skybox(this), this._planarShadows = new PlanarShadows(this), 
                    this._texturePool = new JointsTexturePool(root.device);
                }
                return _createClass(RenderScene, [ {
                    key: "root",
                    get: function get() {
                        return this._root;
                    }
                }, {
                    key: "name",
                    get: function get() {
                        return this._name;
                    }
                }, {
                    key: "cameras",
                    get: function get() {
                        return this._cameras;
                    }
                }, {
                    key: "ambient",
                    get: function get() {
                        return this._ambient;
                    }
                }, {
                    key: "skybox",
                    get: function get() {
                        return this._skybox;
                    }
                }, {
                    key: "planarShadows",
                    get: function get() {
                        return this._planarShadows;
                    }
                }, {
                    key: "defaultMainLightNode",
                    get: function get() {
                        return this._defaultMainLightNode;
                    }
                }, {
                    key: "mainLight",
                    get: function get() {
                        return this._mainLight;
                    }
                }, {
                    key: "sphereLights",
                    get: function get() {
                        return this._sphereLights;
                    }
                }, {
                    key: "spotLights",
                    get: function get() {
                        return this._spotLights;
                    }
                }, {
                    key: "models",
                    get: function get() {
                        return this._models;
                    }
                }, {
                    key: "texturePool",
                    get: function get() {
                        return this._texturePool;
                    }
                } ], [ {
                    key: "registerCreateFunc",
                    value: function registerCreateFunc(root) {
                        root._createSceneFun = function(_root) {
                            return new RenderScene(_root);
                        };
                    }
                } ]), _createClass(RenderScene, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return this._name = info.name, this._texturePool.initialize(), !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.destroyCameras(), this.destroyPointLights(), this.destroySpotLights(), this.destroyModels(), 
                        this._planarShadows.destroy(), this._texturePool.destroy();
                    }
                }, {
                    key: "createCamera",
                    value: function createCamera(info) {
                        var camera = new Camera(this, info);
                        return this._cameras.push(camera), camera;
                    }
                }, {
                    key: "destroyCamera",
                    value: function destroyCamera(camera) {
                        for (var i = 0; i < this._cameras.length; ++i) if (this._cameras[i] === camera) return camera.destroy(), 
                        void this._cameras.splice(i, 1);
                    }
                }, {
                    key: "destroyCameras",
                    value: function destroyCameras() {
                        var _iterator = this._cameras, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            _ref.destroy();
                        }
                        this._cameras.splice(0);
                    }
                }, {
                    key: "createSphereLight",
                    value: function createSphereLight(name, node) {
                        var light = new SphereLight(this, name, node);
                        return this._sphereLights.push(light), light;
                    }
                }, {
                    key: "destroySphereLight",
                    value: function destroySphereLight(light) {
                        for (var i = 0; i < this._sphereLights.length; ++i) if (this._sphereLights[i] === light) return void this._sphereLights.splice(i, 1);
                    }
                }, {
                    key: "createSpotLight",
                    value: function createSpotLight(name, node) {
                        var light = new SpotLight(this, name, node);
                        return this._spotLights.push(light), light;
                    }
                }, {
                    key: "destroySpotLight",
                    value: function destroySpotLight(light) {
                        for (var i = 0; i < this._spotLights.length; ++i) if (this._spotLights[i] === light) return void this._spotLights.splice(i, 1);
                    }
                }, {
                    key: "destroyPointLights",
                    value: function destroyPointLights() {
                        this._sphereLights = [];
                    }
                }, {
                    key: "destroySpotLights",
                    value: function destroySpotLights() {
                        this._spotLights = [];
                    }
                }, {
                    key: "createModel",
                    value: function createModel(clazz, node) {
                        var model = new clazz(this, node);
                        return this._models.push(model), model;
                    }
                }, {
                    key: "destroyModel",
                    value: function destroyModel(model) {
                        for (var i = 0; i < this._models.length; ++i) if (this._models[i] === model) return void this._models.splice(i, 1)[0].destroy();
                    }
                }, {
                    key: "destroyModels",
                    value: function destroyModels() {
                        var _iterator2 = this._models, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            _ref2.destroy();
                        }
                        this._models = [];
                    }
                }, {
                    key: "onPipelineChange",
                    value: function onPipelineChange() {
                        var _iterator3 = this._models, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i3 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i3++];
                            } else {
                                if ((_i3 = _iterator3.next()).done) break;
                                _ref3 = _i3.value;
                            }
                            _ref3.onPipelineChange();
                        }
                        this._skybox.onPipelineChange(), this._planarShadows.onPipelineChange();
                    }
                }, {
                    key: "generateModelId",
                    value: function generateModelId() {
                        return this._modelId++;
                    }
                }, {
                    key: "raycastModels",
                    value: function raycastModels(worldRay, argument_1, argument_2) {
                        var mask = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : Layers.Enum.DEFAULT, distance = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 1 / 0;
                        pool.reset();
                        var _iterator4 = this._models, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                        for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                            var _ref4;
                            if (_isArray4) {
                                if (_i4 >= _iterator4.length) break;
                                _ref4 = _iterator4[_i4++];
                            } else {
                                if ((_i4 = _iterator4.next()).done) break;
                                _ref4 = _i4.value;
                            }
                            var m = _ref4, transform = m.transform;
                            if (transform && m.enabled && !(m.node.layer & Layers.Enum.IGNORE_RAYCAST) && m.node.layer & mask && m.modelBounds) {
                                Mat4.invert(m4, transform.getWorldMatrix(m4)), Vec3.transformMat4(modelRay.o, worldRay.o, m4), 
                                Vec3.normalize(modelRay.d, Vec3.transformMat4Normal(modelRay.d, worldRay.d, m4));
                                var d = intersect.ray_aabb(modelRay, m.modelBounds);
                                if (!(d <= 0 || distance < d)) for (var i = 0; i < m.subModelNum; ++i) {
                                    var subModel = m.getSubModel(i).subMeshData;
                                    if (subModel && subModel.geometricInfo) {
                                        var _subModel$geometricIn = subModel.geometricInfo, vb = _subModel$geometricIn.positions, ib = _subModel$geometricIn.indices, sides = _subModel$geometricIn.doubleSided;
                                        narrowphase(vb, ib, subModel.primitiveMode, sides, distance);
                                    }
                                    if (narrowDis < distance) {
                                        var r = pool.add();
                                        r.node = m.node, r.distance = narrowDis * Vec3.multiply(v3$1, modelRay.d, transform.worldScale).length(), 
                                        results[pool.length - 1] = r;
                                    }
                                }
                            }
                        }
                        return results.length = pool.length, results;
                    }
                }, {
                    key: "raycastModel",
                    value: function raycastModel(worldRay, model, argument_2, argument_3) {
                        var mask = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : Layers.Enum.DEFAULT, distance = 3 < arguments.length && void 0 !== argument_3 ? argument_3 : 1 / 0;
                        pool.reset(), results.length = 0;
                        var m = model, transform = m.transform;
                        if (!transform || !m.enabled || m.node.layer & Layers.Enum.IGNORE_RAYCAST || !(m.node.layer & mask) || !m.modelBounds) return results;
                        Mat4.invert(m4, transform.getWorldMatrix(m4)), Vec3.transformMat4(modelRay.o, worldRay.o, m4), 
                        Vec3.normalize(modelRay.d, Vec3.transformMat4Normal(modelRay.d, worldRay.d, m4));
                        var d = intersect.ray_aabb(modelRay, m.modelBounds);
                        if (d <= 0 || distance < d) return results;
                        for (var i = 0; i < m.subModelNum; ++i) {
                            var subModel = m.getSubModel(i).subMeshData;
                            if (subModel && subModel.geometricInfo) {
                                var _subModel$geometricIn2 = subModel.geometricInfo, vb = _subModel$geometricIn2.positions, ib = _subModel$geometricIn2.indices, sides = _subModel$geometricIn2.doubleSided;
                                narrowphase(vb, ib, subModel.primitiveMode, sides, distance);
                            }
                            if (narrowDis < distance) {
                                var r = pool.add();
                                r.node = m.node, r.distance = narrowDis * Vec3.multiply(v3$1, modelRay.d, transform.worldScale).length(), 
                                results[pool.length - 1] = r;
                            }
                        }
                        return results;
                    }
                }, {
                    key: "raycastUI2D",
                    value: function raycastUI2D(worldRay, argument_1, argument_2) {
                        var mask = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : Layers.Enum.UI_2D, distance = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : 1 / 0;
                        poolUI.reset();
                        var canvasComs = cc.director.getScene().getComponentsInChildren(cc.CanvasComponent);
                        if (null != canvasComs && 0 < canvasComs.length) for (var i = 0; i < canvasComs.length; i++) {
                            var canvasNode = canvasComs[i].node;
                            null != canvasNode && canvasNode.active && this._raycastUI2DNodeRecursiveChildren(worldRay, canvasNode, mask, distance);
                        }
                        return resultUIs.length = poolUI.length, resultUIs;
                    }
                }, {
                    key: "raycastUI2DNode",
                    value: function raycastUI2DNode(worldRay, ui2dNode, argument_2, argument_3) {
                        var mask = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : Layers.Enum.UI_2D, distance = 3 < arguments.length && void 0 !== argument_3 ? argument_3 : 1 / 0;
                        var uiTransfrom = ui2dNode.uiTransfromComp;
                        if (!(null == uiTransfrom || ui2dNode.layer & Layers.Enum.IGNORE_RAYCAST) && ui2dNode.layer & mask) {
                            uiTransfrom.getComputeAABB(aabbUI);
                            var d = intersect.ray_aabb(worldRay, aabbUI);
                            if (!(d <= 0) && d < distance) {
                                var r = poolUI.add();
                                return r.node = ui2dNode, r.distance = d, r;
                            }
                        }
                    }
                }, {
                    key: "_raycastUI2DNodeRecursiveChildren",
                    value: function _raycastUI2DNodeRecursiveChildren(worldRay, parent, argument_2, argument_3) {
                        var mask = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : Layers.Enum.UI_2D, distance = 3 < arguments.length && void 0 !== argument_3 ? argument_3 : 1 / 0, result = this.raycastUI2DNode(worldRay, parent, mask, distance);
                        null != result && (resultUIs[poolUI.length - 1] = result);
                        var _iterator5 = parent.children, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                            var _ref5;
                            if (_isArray5) {
                                if (_i5 >= _iterator5.length) break;
                                _ref5 = _iterator5[_i5++];
                            } else {
                                if ((_i5 = _iterator5.next()).done) break;
                                _ref5 = _i5.value;
                            }
                            var node = _ref5;
                            null != node && node.active && this._raycastUI2DNodeRecursiveChildren(worldRay, node, mask, distance);
                        }
                    }
                } ]), RenderScene;
            }(), modelRay = ray.create(), v3$1 = new Vec3(), m4 = new Mat4(), narrowDis = 1 / 0, tri = triangle.create(), pool = new RecyclePool(function() {
                return {
                    node: null,
                    distance: 1 / 0
                };
            }, 8), results = [], aabbUI = new aabb(), poolUI = new RecyclePool(function() {
                return {
                    node: null,
                    distance: 1 / 0
                };
            }, 8), resultUIs = [], narrowphase = function narrowphase(vb, ib, pm, sides, argument_4) {
                if (narrowDis = 4 < arguments.length && void 0 !== argument_4 ? argument_4 : 1 / 0, 
                pm === GFXPrimitiveMode.TRIANGLE_LIST) for (var cnt = ib.length, j = 0; j < cnt; j += 3) {
                    var i0 = 3 * ib[j], i1 = 3 * ib[j + 1], i2 = 3 * ib[j + 2];
                    Vec3.set(tri.a, vb[i0], vb[1 + i0], vb[2 + i0]), Vec3.set(tri.b, vb[i1], vb[1 + i1], vb[2 + i1]), 
                    Vec3.set(tri.c, vb[i2], vb[1 + i2], vb[2 + i2]);
                    var dist = intersect.ray_triangle(modelRay, tri, sides);
                    dist <= 0 || narrowDis < dist || (narrowDis = dist);
                } else if (pm === GFXPrimitiveMode.TRIANGLE_STRIP) for (var _cnt = ib.length - 2, rev = 0, _j = 0; _j < _cnt; _j += 1) {
                    var _i6 = 3 * ib[_j - rev], _i7 = 3 * ib[_j + rev + 1], _i8 = 3 * ib[_j + 2];
                    Vec3.set(tri.a, vb[_i6], vb[1 + _i6], vb[2 + _i6]), Vec3.set(tri.b, vb[_i7], vb[1 + _i7], vb[2 + _i7]), 
                    Vec3.set(tri.c, vb[_i8], vb[1 + _i8], vb[2 + _i8]), rev = ~rev;
                    var _dist = intersect.ray_triangle(modelRay, tri, sides);
                    _dist <= 0 || narrowDis < _dist || (narrowDis = _dist);
                } else if (pm === GFXPrimitiveMode.TRIANGLE_FAN) {
                    var _cnt2 = ib.length - 1, _i9 = 3 * ib[0];
                    Vec3.set(tri.a, vb[_i9], vb[1 + _i9], vb[2 + _i9]);
                    for (var _j2 = 1; _j2 < _cnt2; _j2 += 1) {
                        var _i10 = 3 * ib[_j2], _i11 = 3 * ib[_j2 + 1];
                        Vec3.set(tri.b, vb[_i10], vb[1 + _i10], vb[2 + _i10]), Vec3.set(tri.c, vb[_i11], vb[1 + _i11], vb[2 + _i11]);
                        var _dist2 = intersect.ray_triangle(modelRay, tri, sides);
                        _dist2 <= 0 || narrowDis < _dist2 || (narrowDis = _dist2);
                    }
                }
            }, MeshBuffer = exports("MeshBuffer", function() {
                function MeshBuffer(batcher) {
                    _classCallCheck(this, MeshBuffer), this.batcher = void 0, this.vData = null, this.iData = null, 
                    this.vb = null, this.ib = null, this.ia = null, this.byteStart = 0, this.byteOffset = 0, 
                    this.indiceStart = 0, this.indiceOffset = 0, this.vertexStart = 0, this.vertexOffset = 0, 
                    this.dirty = !1, this._vertexFormatBytes = 9 * Float32Array.BYTES_PER_ELEMENT, this._initVDataCount = 256 * this._vertexFormatBytes, 
                    this._initIDataCount = 1536, this._outofCallback = null, this.batcher = batcher;
                }
                return _createClass(MeshBuffer, [ {
                    key: "initialize",
                    value: function initialize(attrs, outofCallback) {
                        this._outofCallback = outofCallback;
                        var vbStride = 9 * Float32Array.BYTES_PER_ELEMENT;
                        this.vb = this.vb || this.batcher.device.createBuffer({
                            usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                            size: 0,
                            stride: vbStride
                        });
                        var ibStride = Uint16Array.BYTES_PER_ELEMENT;
                        this.ib = this.ib || this.batcher.device.createBuffer({
                            usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                            size: 0,
                            stride: ibStride
                        }), this.ia = this.ia || this.batcher.device.createInputAssembler({
                            attributes: attrs,
                            vertexBuffers: [ this.vb ],
                            indexBuffer: this.ib
                        }), this._reallocBuffer();
                    }
                }, {
                    key: "request",
                    value: function request(argument_0, argument_1) {
                        var vertexCount = 0 < arguments.length && void 0 !== argument_0 ? argument_0 : 4, indiceCount = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : 6, byteOffset = this.byteOffset + vertexCount * this._vertexFormatBytes, indiceOffset = this.indiceOffset + indiceCount;
                        if (65535 < vertexCount + this.vertexOffset) return this.batcher.autoMergeBatches(), 
                        this._outofCallback && this._outofCallback.call(this.batcher, vertexCount, indiceCount), 
                        !1;
                        var byteLength = this.vData.byteLength, indiceLength = this.iData.length;
                        if (byteLength < byteOffset || indiceLength < indiceOffset) {
                            for (;byteLength < byteOffset || indiceLength < indiceOffset; ) this._initVDataCount *= 2, 
                            this._initIDataCount *= 2, byteLength = 4 * this._initVDataCount, indiceLength = this._initIDataCount;
                            this._reallocBuffer();
                        }
                        return this.vertexOffset += vertexCount, this.indiceOffset += indiceCount, this.byteOffset = byteOffset, 
                        this.dirty = !0;
                    }
                }, {
                    key: "reset",
                    value: function reset() {
                        this.byteStart = 0, this.byteOffset = 0, this.indiceStart = 0, this.indiceOffset = 0, 
                        this.vertexStart = 0, this.vertexOffset = 0, this.dirty = !1;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.ib.destroy(), this.vb.destroy(), this.ia.destroy(), this.ib = null, this.vb = null, 
                        this.ia = null;
                    }
                }, {
                    key: "uploadData",
                    value: function uploadData() {
                        if (0 !== this.byteOffset && this.dirty) {
                            var vertexsData = new Float32Array(this.vData.buffer, 0, this.byteOffset >> 2), indicesData = new Uint16Array(this.iData.buffer, 0, this.indiceOffset);
                            this.byteOffset > this.vb.size && this.vb.resize(this.byteOffset), this.vb.update(vertexsData), 
                            2 * this.indiceOffset > this.ib.size && this.ib.resize(2 * this.indiceOffset), this.ib.update(indicesData);
                        }
                    }
                }, {
                    key: "_reallocBuffer",
                    value: function _reallocBuffer() {
                        this._reallocVData(!0), this._reallocIData(!0);
                    }
                }, {
                    key: "_reallocVData",
                    value: function _reallocVData(copyOldData) {
                        var oldVData;
                        if (this.vData && (oldVData = new Uint8Array(this.vData.buffer)), this.vData = new Float32Array(this._initVDataCount), 
                        oldVData && copyOldData) for (var newData = new Uint8Array(this.vData.buffer), i = 0, l = oldVData.length; i < l; i++) newData[i] = oldVData[i];
                    }
                }, {
                    key: "_reallocIData",
                    value: function _reallocIData(copyOldData) {
                        var oldIData = this.iData;
                        if (this.iData = new Uint16Array(this._initIDataCount), oldIData && copyOldData) for (var iData = this.iData, i = 0, l = oldIData.length; i < l; i++) iData[i] = oldIData[i];
                    }
                } ]), MeshBuffer;
            }());
            !function(Stage) {
                Stage[Stage.DISABLED = 0] = "DISABLED", Stage[Stage.CLEAR = 1] = "CLEAR", Stage[Stage.ENTER_LEVEL = 2] = "ENTER_LEVEL", 
                Stage[Stage.ENABLED = 3] = "ENABLED", Stage[Stage.EXIT_LEVEL = 4] = "EXIT_LEVEL";
            }(Stage = Stage || {});
            var StencilManager = exports("StencilManager", function() {
                function StencilManager() {
                    _classCallCheck(this, StencilManager), this.stage = Stage.DISABLED, this._maskStack = [], 
                    this._stencilPattern = {
                        stencilTest: !0,
                        func: GFXComparisonFunc.ALWAYS,
                        stencilMask: 4294967295,
                        writeMask: 4294967295,
                        failOp: GFXStencilOp.KEEP,
                        zFailOp: GFXStencilOp.KEEP,
                        passOp: GFXStencilOp.KEEP,
                        ref: 1
                    }, this._defaultPipelineState = {
                        depthStencilState: {},
                        rasterizerState: {},
                        blendState: {}
                    };
                }
                return _createClass(StencilManager, [ {
                    key: "pushMask",
                    value: function pushMask(mask) {
                        this._maskStack.push(mask);
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        this.stage = Stage.CLEAR;
                    }
                }, {
                    key: "enterLevel",
                    value: function enterLevel() {
                        this.stage = Stage.ENTER_LEVEL;
                    }
                }, {
                    key: "enableMask",
                    value: function enableMask() {
                        this.stage = Stage.ENABLED;
                    }
                }, {
                    key: "exitMask",
                    value: function exitMask() {
                        0 !== this._maskStack.length && (this._maskStack.pop(), 0 === this._maskStack.length ? this.stage = Stage.DISABLED : this.stage = Stage.ENABLED);
                    }
                }, {
                    key: "handleMaterial",
                    value: function handleMaterial(mat) {
                        var pattern = this._stencilPattern;
                        this.stage === Stage.DISABLED ? (pattern.stencilTest = !1, pattern.func = GFXComparisonFunc.ALWAYS, 
                        pattern.failOp = GFXStencilOp.KEEP, pattern.stencilMask = pattern.writeMask = 4294967295, 
                        pattern.ref = 1) : (pattern.stencilTest = !0, this.stage === Stage.ENABLED ? (pattern.func = GFXComparisonFunc.EQUAL, 
                        pattern.failOp = GFXStencilOp.KEEP, pattern.stencilMask = pattern.ref = this.getStencilRef(), 
                        pattern.writeMask = this.getWriteMask()) : this.stage === Stage.CLEAR ? (pattern.func = GFXComparisonFunc.NEVER, 
                        pattern.failOp = GFXStencilOp.ZERO, pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask()) : this.stage === Stage.ENTER_LEVEL && (pattern.func = GFXComparisonFunc.NEVER, 
                        pattern.failOp = GFXStencilOp.REPLACE, pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask()));
                        var pass = mat.passes[0];
                        if (this._changed(pass)) {
                            var state = this._stencilPattern;
                            return this._defaultPipelineState.depthStencilState = {
                                stencilTestFront: state.stencilTest,
                                stencilFuncFront: state.func,
                                stencilReadMaskFront: state.stencilMask,
                                stencilWriteMaskFront: state.writeMask,
                                stencilFailOpFront: state.failOp,
                                stencilZFailOpFront: state.zFailOp,
                                stencilPassOpFront: state.passOp,
                                stencilRefFront: state.ref,
                                stencilTestBack: state.stencilTest,
                                stencilFuncBack: state.func,
                                stencilReadMaskBack: state.stencilMask,
                                stencilWriteMaskBack: state.writeMask,
                                stencilFailOpBack: state.failOp,
                                stencilZFailOpBack: state.zFailOp,
                                stencilPassOpBack: state.passOp,
                                stencilRefBack: state.ref
                            }, this._defaultPipelineState.blendState = pass.blendState, this._defaultPipelineState.rasterizerState = pass.rasterizerState, 
                            mat.overridePipelineStates(this._defaultPipelineState), !0;
                        }
                        return !1;
                    }
                }, {
                    key: "getWriteMask",
                    value: function getWriteMask() {
                        return 1 << this._maskStack.length - 1;
                    }
                }, {
                    key: "getExitWriteMask",
                    value: function getExitWriteMask() {
                        return 1 << this._maskStack.length;
                    }
                }, {
                    key: "getStencilRef",
                    value: function getStencilRef() {
                        for (var result = 0, i = 0; i < this._maskStack.length; ++i) result += 1 << i;
                        return result;
                    }
                }, {
                    key: "getInvertedRef",
                    value: function getInvertedRef() {
                        for (var result = 0, i = 0; i < this._maskStack.length - 1; ++i) result += 1 << i;
                        return result;
                    }
                }, {
                    key: "reset",
                    value: function reset() {
                        this._maskStack.length = 0, this.stage = Stage.DISABLED;
                    }
                }, {
                    key: "_changed",
                    value: function _changed(pass) {
                        var stencilState = pass.depthStencilState, pattern = this._stencilPattern;
                        return pattern.stencilTest !== stencilState.stencilTestFront || pattern.func !== stencilState.stencilFuncFront || pattern.failOp !== stencilState.stencilFailOpFront || pattern.zFailOp !== stencilState.stencilZFailOpFront || pattern.passOp !== stencilState.stencilPassOpFront || pattern.stencilMask !== stencilState.stencilReadMaskFront || pattern.writeMask !== stencilState.stencilWriteMaskFront || pattern.ref !== stencilState.stencilRefFront;
                    }
                } ]), StencilManager;
            }());
            StencilManager.sharedManager = null, StencilManager.sharedManager = new StencilManager();
            var UIBatchModel = function() {
                function UIBatchModel(scene) {
                    var _this;
                    return _classCallCheck(this, UIBatchModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(UIBatchModel).call(this, scene, null)))._subModel = void 0, 
                    _this._subModel = new UISubModel(), _this;
                }
                return _inherits(UIBatchModel, Model), _createClass(UIBatchModel, [ {
                    key: "updateTransform",
                    value: function updateTransform() {}
                }, {
                    key: "updateUBOs",
                    value: function updateUBOs() {
                        return !1;
                    }
                }, {
                    key: "initialize",
                    value: function initialize(ia, batch) {
                        this._subModel.directInitialize(ia, batch.material, batch.pipelineState), this._subModels[0] = this._subModel;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._subModel.destroy();
                    }
                } ]), UIBatchModel;
            }(), UISubModel = function() {
                function UISubModel() {
                    var _this2;
                    return _classCallCheck(this, UISubModel), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(UISubModel).call(this))).psos = [], 
                    _this2;
                }
                return _inherits(UISubModel, SubModel), _createClass(UISubModel, [ {
                    key: "directInitialize",
                    value: function directInitialize(ia, mat, pso) {
                        this._inputAssembler = ia, this.psos[0] = pso, this.material = mat;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        0 < this.commandBuffers.length && this.commandBuffers[0].destroy();
                    }
                } ]), UISubModel;
            }(), UIMaterial = function() {
                function UIMaterial() {
                    _classCallCheck(this, UIMaterial), this._material = null, this._pass = null, this._psos = void 0, 
                    this._refCount = 0, this._psos = null;
                }
                return _createClass(UIMaterial, [ {
                    key: "material",
                    get: function get() {
                        return this._material;
                    }
                }, {
                    key: "pass",
                    get: function get() {
                        return this._pass;
                    }
                } ]), _createClass(UIMaterial, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        var _this = this;
                        return !!info.material && (this._material = new Material(), this._material.copy(info.material), 
                        this._pass = this._material.passes[0], this._pass.update(), this._psos = new Pool$1(function() {
                            return _this._pass.createPipelineState();
                        }, 1), !0);
                    }
                }, {
                    key: "increase",
                    value: function increase() {
                        return this._refCount++, this._refCount;
                    }
                }, {
                    key: "decrease",
                    value: function decrease() {
                        return this._refCount--, 0 === this._refCount && this.destroy(), this._refCount;
                    }
                }, {
                    key: "getPipelineState",
                    value: function getPipelineState() {
                        return this._psos.alloc();
                    }
                }, {
                    key: "revertPipelineState",
                    value: function revertPipelineState(pso) {
                        this._psos.free(pso);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        var _this2 = this;
                        this._psos && this._psos.clear(function(obj) {
                            _this2._pass.destroyPipelineState(obj);
                        }), this._material && (this._material.destroy(), this._material = null), this._refCount = 0;
                    }
                } ]), UIMaterial;
            }(), vfmt = [ {
                name: GFXAttributeName.ATTR_POSITION,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_TEX_COORD,
                format: GFXFormat.RG32F
            }, {
                name: GFXAttributeName.ATTR_COLOR,
                format: GFXFormat.RGBA32F
            } ], UIVertexFormat = Object.freeze({
                vfmt: vfmt
            });
            exports("UIVertexFormat", UIVertexFormat);
            var UIDrawBatch = function() {
                function UIDrawBatch() {
                    _classCallCheck(this, UIDrawBatch), this.camera = null, this.bufferBatch = null, 
                    this.model = null, this.material = null, this.texView = null, this.firstIdx = 0, 
                    this.idxCount = 0, this.pipelineState = null, this.bindingLayout = null, this.useLocalData = null;
                }
                return _createClass(UIDrawBatch, [ {
                    key: "destroy",
                    value: function destroy(ui) {
                        this.pipelineState && (ui._getUIMaterial(this.material).revertPipelineState(this.pipelineState), 
                        this.pipelineState = null), this.bindingLayout && (this.bindingLayout = null);
                    }
                }, {
                    key: "clear",
                    value: function clear(ui) {
                        this.pipelineState && (ui._getUIMaterial(this.material).revertPipelineState(this.pipelineState), 
                        this.pipelineState = null), this.camera = null, this.bufferBatch = null, this.material = null, 
                        this.texView = null, this.firstIdx = 0, this.idxCount = 0, this.model = null;
                    }
                } ]), UIDrawBatch;
            }(), UI = function() {
                function UI(_root) {
                    var _this = this;
                    _classCallCheck(this, UI), this._root = _root, this.device = void 0, this._screens = [], 
                    this._bufferBatchPool = new RecyclePool(function() {
                        return new MeshBuffer(_this);
                    }, 128), this._drawBatchPool = new Pool$1(function() {
                        return new UIDrawBatch();
                    }, 128), this._cmdBuff = null, this._scene = void 0, this._attributes = [], this._meshBuffers = [], 
                    this._meshBufferUseCount = 0, this._uiMaterials = new Map(), this._canvasMaterials = new Map(), 
                    this._batches = void 0, this._uiModelPool = null, this._modelInUse = void 0, this._emptyMaterial = new Material(), 
                    this._currMeshBuffer = null, this._currMaterial = this._emptyMaterial, this._currTexView = null, 
                    this._currCanvas = -1, this.device = _root.device, this._scene = this._root.createScene({
                        name: "GUIScene"
                    }), this._uiModelPool = new Pool$1(function() {
                        var model = _this._scene.createModel(UIBatchModel, null);
                        return model.visFlags |= Layers.Enum.UI_3D, model;
                    }, 2), this._modelInUse = new CachedArray(10), this._batches = new CachedArray(64), 
                    cc.director.on(cc.Director.EVENT_BEFORE_DRAW, this.update, this);
                }
                return _createClass(UI, [ {
                    key: "renderScene",
                    get: function get() {
                        return this._scene;
                    }
                }, {
                    key: "currBufferBatch",
                    get: function get() {
                        return this._currMeshBuffer;
                    }
                } ]), _createClass(UI, [ {
                    key: "initialize",
                    value: function initialize() {
                        return this._attributes = vfmt, this._requireBufferBatch(), this._cmdBuff = this.device.createCommandBuffer({
                            allocator: this.device.commandAllocator,
                            type: GFXCommandBufferType.PRIMARY
                        }), !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._destroyUIMaterials();
                        var _iterator = this._batches.array, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            _ref.destroy(this);
                        }
                        var _iterator2 = this._meshBuffers, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            _ref2.destroy();
                        }
                        this._meshBuffers.splice(0);
                        for (var matIter = this._uiMaterials.values(), result = matIter.next(); !result.done; ) {
                            result.value.destroy(), result = matIter.next();
                        }
                        this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
                    }
                }, {
                    key: "getRenderSceneGetter",
                    value: function getRenderSceneGetter() {
                        return Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), "renderScene").get.bind(this);
                    }
                }, {
                    key: "_getUIMaterial",
                    value: function _getUIMaterial(mat) {
                        if (this._uiMaterials.has(mat.hash)) return this._uiMaterials.get(mat.hash);
                        var uiMat = new UIMaterial();
                        return uiMat.initialize({
                            material: mat
                        }), this._uiMaterials.set(mat.hash, uiMat), uiMat;
                    }
                }, {
                    key: "_removeUIMaterial",
                    value: function _removeUIMaterial(hash) {
                        this._uiMaterials.has(hash) && 0 === this._uiMaterials.get(hash).decrease() && this._uiMaterials.delete(hash);
                    }
                }, {
                    key: "addScreen",
                    value: function addScreen(comp) {
                        this._screens.push(comp), comp.camera && (comp.camera.view.visibility = Layers.BitMask.UI_2D | this._screens.length, 
                        this._canvasMaterials.set(comp.camera.view.visibility, new Map())), this._screens.sort(this._screenSort);
                    }
                }, {
                    key: "getScreen",
                    value: function getScreen(visibility) {
                        for (var screens = this._screens, i = 0; i < screens.length; ++i) {
                            var screen = screens[i];
                            if (screen.camera && screen.camera.view.visibility === visibility) return screen;
                        }
                        return null;
                    }
                }, {
                    key: "removeScreen",
                    value: function removeScreen(comp) {
                        var idx = this._screens.indexOf(comp);
                        if (-1 !== idx) {
                            if (this._screens.splice(idx, 1), comp.camera) for (var matHashInter = this._canvasMaterials.get(comp.camera.view.visibility).keys(), matHash = matHashInter.next(); !matHash.done; ) this._removeUIMaterial(matHash.value), 
                            matHash = matHashInter.next();
                            for (var camera, i = idx; i < this._screens.length; i++) if (camera = this._screens[i].camera) {
                                var matRecord = this._canvasMaterials.get(camera.view.visibility);
                                camera.view.visibility -= 1, this._canvasMaterials.set(camera.view.visibility, matRecord);
                            }
                        }
                    }
                }, {
                    key: "update",
                    value: function update() {
                        if (this._renderScreens(), 0 < this._batches.length) for (var buffers = this._meshBuffers, i = 0; i < buffers.length; ++i) {
                            var bufferBatch = buffers[i];
                            bufferBatch.uploadData(), bufferBatch.reset();
                        }
                        this.render(), this._reset();
                    }
                }, {
                    key: "render",
                    value: function render() {
                        for (var batchPriority = 0, i = 0; i < this._modelInUse.length; i++) this._modelInUse.get(i).enabled = !1, 
                        this._uiModelPool.free(this._modelInUse.get(i));
                        if (this._modelInUse.clear(), this._batches.length) for (var _i3 = 0; _i3 < this._batches.length; ++_i3) {
                            var batch = this._batches.array[_i3];
                            if (batch.model) {
                                if (batch.camera) {
                                    var visFlags = batch.camera.view.visibility;
                                    batch.model.visFlags = visFlags, batch.model.node.layer = visFlags;
                                }
                                for (var j = 0; j < batch.model.subModelNum; j++) batch.model.getSubModel(j).priority = batchPriority++;
                            } else {
                                var bindingLayout = batch.bindingLayout;
                                bindingLayout.bindTextureView(UniformBinding.CUSTOM_SAMPLER_BINDING_START_POINT, batch.texView), 
                                bindingLayout.update();
                                var ia = batch.bufferBatch.ia;
                                ia.firstIndex = batch.firstIdx, ia.indexCount = batch.idxCount;
                                var uiModel = this._uiModelPool.alloc();
                                uiModel.initialize(ia, batch), uiModel.enabled = !0, uiModel.getSubModel(0).priority = batchPriority++, 
                                batch.camera && (uiModel.visFlags = batch.camera.view.visibility, null == this._canvasMaterials.get(batch.camera.view.visibility).get(batch.material.hash) && (this._uiMaterials.get(batch.material.hash).increase(), 
                                this._canvasMaterials.get(batch.camera.view.visibility).set(batch.material.hash, 1))), 
                                this._modelInUse.push(uiModel);
                            }
                        }
                    }
                }, {
                    key: "commitComp",
                    value: function commitComp(comp, argument_1, argument_2) {
                        var assembler = 2 < arguments.length ? argument_2 : void 0, renderComp = comp, texView = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : null;
                        this._currMaterial.hash === renderComp.material.hash && this._currTexView === texView && this._currCanvas === renderComp.visibility || (this.autoMergeBatches(), 
                        this._currMaterial = renderComp.material, this._currTexView = texView, this._currCanvas = renderComp.visibility), 
                        assembler && assembler.fillBuffers(renderComp, this);
                    }
                }, {
                    key: "commitModel",
                    value: function commitModel(comp, model, mat) {
                        if ((this._currMaterial !== this._emptyMaterial && this.autoMergeBatches(), mat) && (StencilManager.sharedManager.handleMaterial(mat) && model)) for (var i = 0; i < model.subModelNum; i++) model.setSubModelMaterial(i, mat);
                        var uiCanvas = this.getScreen(comp.visibility), curDrawBatch = this._drawBatchPool.alloc();
                        curDrawBatch.camera = uiCanvas && uiCanvas.camera, curDrawBatch.model = model, curDrawBatch.bufferBatch = null, 
                        curDrawBatch.material = mat, curDrawBatch.texView = null, curDrawBatch.firstIdx = 0, 
                        curDrawBatch.idxCount = 0, curDrawBatch.pipelineState = null, curDrawBatch.bindingLayout = null, 
                        this._currMaterial = this._emptyMaterial, this._currTexView = null, this._currCanvas = comp.visibility, 
                        this._batches.push(curDrawBatch);
                    }
                }, {
                    key: "autoMergeBatches",
                    value: function autoMergeBatches() {
                        var mat = this._currMaterial, buffer = this._currMeshBuffer, indicsStart = buffer.indiceStart, vCount = buffer.indiceOffset - indicsStart;
                        if (vCount && mat) {
                            var uiCanvas = this.getScreen(this._currCanvas);
                            StencilManager.sharedManager.handleMaterial(mat);
                            var curDrawBatch = this._drawBatchPool.alloc();
                            curDrawBatch.camera = uiCanvas && uiCanvas.camera, curDrawBatch.bufferBatch = this._currMeshBuffer, 
                            curDrawBatch.material = mat, curDrawBatch.texView = this._currTexView, curDrawBatch.firstIdx = indicsStart, 
                            curDrawBatch.idxCount = vCount, curDrawBatch.pipelineState = this._getUIMaterial(mat).getPipelineState(), 
                            curDrawBatch.bindingLayout = curDrawBatch.pipelineState.pipelineLayout.layouts[0], 
                            this._batches.push(curDrawBatch), buffer.vertexStart = buffer.vertexOffset, buffer.indiceStart = buffer.indiceOffset, 
                            buffer.byteStart = buffer.byteOffset;
                        }
                    }
                }, {
                    key: "forceMergeBatches",
                    value: function forceMergeBatches(material, sprite) {
                        this._currMaterial = material, this._currTexView = sprite, this.autoMergeBatches();
                    }
                }, {
                    key: "_deleteUIMaterial",
                    value: function _deleteUIMaterial(mat) {
                        this._uiMaterials.has(mat.hash) && (this._uiMaterials.get(mat.hash).destroy(), this._uiMaterials.delete(mat.hash));
                    }
                }, {
                    key: "_destroyUIMaterials",
                    value: function _destroyUIMaterials() {
                        for (var matIter = this._uiMaterials.values(), result = matIter.next(); !result.done; ) {
                            result.value.destroy(), result = matIter.next();
                        }
                        this._uiMaterials.clear();
                    }
                }, {
                    key: "_walk",
                    value: function _walk(node, argument_1) {
                        var level = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : 0, len = node.children.length;
                        if (this._preprocess(node), 0 < len) for (var children = node.children, i = 0; i < children.length; ++i) {
                            var child = children[i];
                            this._walk(child, level);
                        }
                        this._postprocess(node), level += 1;
                    }
                }, {
                    key: "_renderScreens",
                    value: function _renderScreens() {
                        for (var screens = this._screens, i = 0; i < screens.length; ++i) {
                            var screen = screens[i];
                            screen.enabledInHierarchy && this._recursiveScreenNode(screen.node);
                        }
                    }
                }, {
                    key: "_preprocess",
                    value: function _preprocess(c) {
                        var render = c._uiComp;
                        render && render.enabledInHierarchy && render.updateAssembler(this);
                    }
                }, {
                    key: "_postprocess",
                    value: function _postprocess(c) {
                        var render = c._uiComp;
                        render && render.enabledInHierarchy && render.postUpdateAssembler(this);
                    }
                }, {
                    key: "_recursiveScreenNode",
                    value: function _recursiveScreenNode(screen) {
                        this._walk(screen), this.autoMergeBatches();
                    }
                }, {
                    key: "_reset",
                    value: function _reset() {
                        for (var i = 0; i < this._batches.length; ++i) {
                            var batch = this._batches.array[i];
                            batch.clear(this), this._drawBatchPool.free(batch);
                        }
                        this._batches.clear(), this._currMaterial = this._emptyMaterial, this._currCanvas = -1, 
                        this._currTexView = null, this._meshBufferUseCount = 0, this._requireBufferBatch(), 
                        StencilManager.sharedManager.reset();
                    }
                }, {
                    key: "_createMeshBuffer",
                    value: function _createMeshBuffer() {
                        var batch = this._bufferBatchPool.add();
                        return batch.initialize(this._attributes, this._requireBufferBatch.bind(this)), 
                        this._meshBuffers.push(batch), batch;
                    }
                }, {
                    key: "_requireBufferBatch",
                    value: function _requireBufferBatch(argument_0, argument_1) {
                        this._meshBufferUseCount >= this._meshBuffers.length ? this._currMeshBuffer = this._createMeshBuffer() : this._currMeshBuffer = this._meshBuffers[this._meshBufferUseCount], 
                        this._meshBufferUseCount++, 2 === arguments.length && this._currMeshBuffer.request(argument_0, argument_1);
                    }
                }, {
                    key: "_screenSort",
                    value: function _screenSort(a, b) {
                        return a.priority - b.priority;
                    }
                } ]), UI;
            }(), Root = function() {
                function Root(device) {
                    _classCallCheck(this, Root), this._createSceneFun = void 0, this._createViewFun = void 0, 
                    this._device = void 0, this._windows = [], this._mainWindow = null, this._curWindow = null, 
                    this._tempWindow = null, this._pipeline = null, this._ui = null, this._scenes = [], 
                    this._views = [], this._time = 0, this._frameTime = 0, this._fpsTime = 0, this._frameCount = 0, 
                    this._fps = 0, this._fixedFPS = 0, this._fixedFPSFrameTime = 0, this._device = device, 
                    RenderScene.registerCreateFunc(this), RenderView.registerCreateFunc(this);
                }
                return _createClass(Root, [ {
                    key: "device",
                    get: function get() {
                        return this._device;
                    }
                }, {
                    key: "mainWindow",
                    get: function get() {
                        return this._mainWindow;
                    }
                }, {
                    key: "curWindow",
                    set: function set(window) {
                        this._curWindow = window;
                    },
                    get: function get() {
                        return this._curWindow;
                    }
                }, {
                    key: "tempWindow",
                    set: function set(window) {
                        this._tempWindow = window;
                    },
                    get: function get() {
                        return this._tempWindow;
                    }
                }, {
                    key: "windows",
                    get: function get() {
                        return this._windows;
                    }
                }, {
                    key: "pipeline",
                    get: function get() {
                        return this._pipeline;
                    }
                }, {
                    key: "ui",
                    get: function get() {
                        return this._ui;
                    }
                }, {
                    key: "scenes",
                    get: function get() {
                        return this._scenes;
                    }
                }, {
                    key: "views",
                    get: function get() {
                        return this._views;
                    }
                }, {
                    key: "cumulativeTime",
                    get: function get() {
                        return this._time;
                    }
                }, {
                    key: "frameTime",
                    get: function get() {
                        return this._frameTime;
                    }
                }, {
                    key: "frameCount",
                    get: function get() {
                        return this._frameCount;
                    }
                }, {
                    key: "fps",
                    get: function get() {
                        return this._fps;
                    }
                }, {
                    key: "fixedFPS",
                    set: function set(fps) {
                        0 < fps ? (this._fixedFPS = fps, this._fixedFPSFrameTime = 1e3 / fps) : this._fixedFPSFrameTime = 0;
                    },
                    get: function get() {
                        return this._fixedFPS;
                    }
                } ]), _createClass(Root, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        var _this = this;
                        return !!this._device.mainWindow && (this._mainWindow = this._device.mainWindow, 
                        this._curWindow = this._mainWindow, builtinResMgr.initBuiltinRes(this._device), 
                        this._pipeline = new ForwardPipeline(this), this._pipeline.initialize(info) ? (this._ui = new UI(this), 
                        this._ui.initialize() ? (cc.view.on("design-resolution-changed", function() {
                            var width = cc.game.canvas.width, height = cc.game.canvas.height;
                            _this.resize(width, height);
                        }, this), !0) : (this.destroy(), !1)) : (this.destroy(), !1));
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.destroyViews(), this.destroyScenes(), this._pipeline && (this._pipeline.destroy(), 
                        this._pipeline = null), this._ui && (this._ui.destroy(), this._ui = null), this._curWindow = null, 
                        this._mainWindow = null;
                    }
                }, {
                    key: "resize",
                    value: function resize(width, height) {
                        this._device.resize(width, height), this._mainWindow.resize(width, height);
                        var _iterator = this._windows, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var window = _ref;
                            window.isOffscreen || window.resize(width, height);
                        }
                        this._pipeline && this._pipeline.resize(width, height);
                        var _iterator2 = this._views, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            var view = _ref2;
                            view.camera.isWindowSize && view.camera.resize(width, height);
                        }
                    }
                }, {
                    key: "activeWindow",
                    value: function activeWindow(window) {
                        this._curWindow = window;
                    }
                }, {
                    key: "resetCumulativeTime",
                    value: function resetCumulativeTime() {
                        this._time = 0;
                    }
                }, {
                    key: "frameMove",
                    value: function frameMove(deltaTime) {
                        this._frameTime = deltaTime, ++this._frameCount, this._time += this._frameTime, 
                        this._fpsTime += this._frameTime, 1 < this._fpsTime && (this._fps = this._frameCount, 
                        this._frameCount = 0, this._fpsTime = 0), this._views.sort(function(a, b) {
                            return a.priority - b.priority;
                        });
                        var _iterator3 = this._views, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i3 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i3++];
                            } else {
                                if ((_i3 = _iterator3.next()).done) break;
                                _ref3 = _i3.value;
                            }
                            var view = _ref3;
                            view.isEnable && view.window && (view.window.isOffscreen || !view.window.isOffscreen && view.window === this._curWindow) && this._pipeline.render(view);
                        }
                    }
                }, {
                    key: "createWindow",
                    value: function createWindow(info) {
                        if (this._device) {
                            var window = this._device.createWindow(info);
                            if (window) return this._windows.push(window), window;
                        }
                        return null;
                    }
                }, {
                    key: "destroyWindow",
                    value: function destroyWindow(window) {
                        for (var i = 0; i < this._windows.length; ++i) if (this._windows[i] === window) return window.destroy(), 
                        void this._windows.splice(i, 1);
                    }
                }, {
                    key: "destroyWindows",
                    value: function destroyWindows() {
                        var _iterator4 = this._windows, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                        for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                            var _ref4;
                            if (_isArray4) {
                                if (_i4 >= _iterator4.length) break;
                                _ref4 = _iterator4[_i4++];
                            } else {
                                if ((_i4 = _iterator4.next()).done) break;
                                _ref4 = _i4.value;
                            }
                            _ref4.destroy();
                        }
                        this._windows = [];
                    }
                }, {
                    key: "createScene",
                    value: function createScene(info) {
                        var scene = this._createSceneFun(this);
                        return scene.initialize(info), this._scenes.push(scene), scene;
                    }
                }, {
                    key: "destroyScene",
                    value: function destroyScene(scene) {
                        for (var i = 0; i < this._scenes.length; ++i) if (this._scenes[i] === scene) return scene.destroy(), 
                        void this._scenes.splice(i, 1);
                    }
                }, {
                    key: "destroyScenes",
                    value: function destroyScenes() {
                        var _iterator5 = this._scenes, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                            var _ref5;
                            if (_isArray5) {
                                if (_i5 >= _iterator5.length) break;
                                _ref5 = _iterator5[_i5++];
                            } else {
                                if ((_i5 = _iterator5.next()).done) break;
                                _ref5 = _i5.value;
                            }
                            _ref5.destroy();
                        }
                        this._scenes = [];
                    }
                }, {
                    key: "createView",
                    value: function createView(info) {
                        var view = this._createViewFun(this, info.camera);
                        return view.initialize(info), this._views.push(view), view;
                    }
                }, {
                    key: "destroyView",
                    value: function destroyView(view) {
                        for (var i = 0; i < this._views.length; ++i) if (this._views[i] === view) return this._views.splice(i, 1), 
                        void view.destroy();
                    }
                }, {
                    key: "destroyViews",
                    value: function destroyViews() {
                        var _iterator6 = this._views, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                        for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                            var _ref6;
                            if (_isArray6) {
                                if (_i6 >= _iterator6.length) break;
                                _ref6 = _iterator6[_i6++];
                            } else {
                                if ((_i6 = _iterator6.next()).done) break;
                                _ref6 = _i6.value;
                            }
                            _ref6.destroy();
                        }
                        this._views = [];
                    }
                } ]), Root;
            }(), Director = exports("Director", function() {
                function Director() {
                    var _this;
                    _classCallCheck(this, Director), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Director).call(this)))._compScheduler = void 0, 
                    _this._nodeActivator = void 0, _this.invalid = void 0, _this._paused = void 0, _this._purgeDirectorInNextLoop = void 0, 
                    _this._root = void 0, _this._loadingScene = void 0, _this._scene = void 0, _this._totalFrames = void 0, 
                    _this._lastUpdate = void 0, _this._deltaTime = void 0, _this._scheduler = void 0, 
                    _this._systems = void 0, _this.invalid = !1, _this._paused = !1, _this._purgeDirectorInNextLoop = !1, 
                    _this._root = null, _this._loadingScene = "", _this._scene = null, _this._totalFrames = 0, 
                    _this._lastUpdate = 0, _this._deltaTime = 0, _this._scheduler = new Scheduler(), 
                    _this._compScheduler = new ComponentScheduler(), _this._nodeActivator = new NodeActivator(), 
                    _this._systems = [];
                    var self = _assertThisInitialized(_this);
                    return cc.game.on(Game.EVENT_SHOW, function() {
                        self._lastUpdate = performance.now();
                    }), cc.game.once(Game.EVENT_RENDERER_INITED, _this.initOnRenererInited, _assertThisInitialized(_this)), 
                    cc.game.once(Game.EVENT_ENGINE_INITED, _this.initOnEngineInited, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(Director, EventTarget), _createClass(Director, [ {
                    key: "initOnRenererInited",
                    value: function initOnRenererInited() {
                        this._root = new Root(cc.game._gfxDevice);
                        return !!this._root.initialize({});
                    }
                }, {
                    key: "initOnEngineInited",
                    value: function initOnEngineInited() {
                        this._totalFrames = 0, this._lastUpdate = performance.now(), this._paused = !1, 
                        this._purgeDirectorInNextLoop = !1, cc.loader.init(this), eventManager && eventManager.setEnabled(!0), 
                        this.registerSystem(Scheduler.ID, this._scheduler, 200), this.emit(Director.EVENT_INIT);
                    }
                }, {
                    key: "calculateDeltaTime",
                    value: function calculateDeltaTime() {
                        var now = performance.now();
                        this._deltaTime = (now - this._lastUpdate) / 1e3, 1 < this._deltaTime && (this._deltaTime = 1 / 60), 
                        this._lastUpdate = now;
                    }
                }, {
                    key: "convertToGL",
                    value: function convertToGL(uiPoint) {
                        var container = cc.game.container, view = cc.view, box = container.getBoundingClientRect(), left = box.left + window.pageXOffset - container.clientLeft, top = box.top + window.pageYOffset - container.clientTop, x = view._devicePixelRatio * (uiPoint.x - left), y = view._devicePixelRatio * (top + box.height - uiPoint.y);
                        return view._isRotated ? cc.v2(view._viewportRect.width - y, x) : cc.v2(x, y);
                    }
                }, {
                    key: "convertToUI",
                    value: function convertToUI(glPoint) {
                        var container = cc.game.container, view = cc.view, box = container.getBoundingClientRect(), left = box.left + window.pageXOffset - container.clientLeft, top = box.top + window.pageYOffset - container.clientTop, uiPoint = cc.v2(0, 0);
                        return view._isRotated ? (uiPoint.x = left + glPoint.y / view._devicePixelRatio, 
                        uiPoint.y = top + box.height - (view._viewportRect.width - glPoint.x) / view._devicePixelRatio) : (uiPoint.x = left + glPoint.x * view._devicePixelRatio, 
                        uiPoint.y = top + box.height - glPoint.y * view._devicePixelRatio), uiPoint;
                    }
                }, {
                    key: "end",
                    value: function end() {
                        this._purgeDirectorInNextLoop = !0;
                    }
                }, {
                    key: "getWinSize",
                    value: function getWinSize() {
                        return cc.size(cc.winSize);
                    }
                }, {
                    key: "getWinSizeInPixels",
                    value: function getWinSizeInPixels() {
                        return cc.size(cc.winSize);
                    }
                }, {
                    key: "pause",
                    value: function pause() {
                        this._paused || (this._paused = !0);
                    }
                }, {
                    key: "purgeCachedData",
                    value: function purgeCachedData() {
                        cc.loader.releaseAll();
                    }
                }, {
                    key: "purgeDirector",
                    value: function purgeDirector() {
                        this._scheduler.unscheduleAll(), this._compScheduler.unscheduleAll(), this._nodeActivator.reset(), 
                        eventManager && eventManager.setEnabled(!1), cc.isValid(this._scene) && this._scene.destroy(), 
                        this._scene = null, this.stopAnimation(), null != this._root && this._root.destroy(), 
                        this._root = null, cc.loader.releaseAll();
                    }
                }, {
                    key: "reset",
                    value: function reset() {
                        this.purgeDirector(), this.emit(Director.EVENT_RESET), eventManager && eventManager.setEnabled(!0), 
                        this.startAnimation();
                    }
                }, {
                    key: "runSceneImmediate",
                    value: function runSceneImmediate(scene, onBeforeLoadScene, onLaunched) {
                        cc.assertID(scene instanceof cc.Scene, 1216);
                        var uuid = cc.loader._getReferenceKey(scene.uuid);
                        cc.loader.removeItem(uuid), console.time("InitScene"), scene._load(), console.timeEnd("InitScene"), 
                        console.time("AttachPersist");
                        for (var persistNodeList = Object.keys(cc.game._persistRootNodes).map(function(x) {
                            return cc.game._persistRootNodes[x];
                        }), i = 0; i < persistNodeList.length; i++) {
                            var node = persistNodeList[i];
                            node.emit(cc.Node.SCENE_CHANGED_FOR_PERSISTS, scene.renderScene);
                            var existNode = scene.getChildByUuid(node.uuid);
                            if (existNode) {
                                var index = existNode.getSiblingIndex();
                                existNode._destroyImmediate(), scene.insertChild(node, index);
                            } else node.parent = scene;
                        }
                        console.timeEnd("AttachPersist");
                        var oldScene = this._scene;
                        console.time("AutoRelease"), function autoRelease(oldSceneAssets, nextSceneAssets, persistNodes) {
                            var releaseSettings = cc.loader._autoReleaseSetting, excludeMap = createMap();
                            if (nextSceneAssets) for (var i = 0; i < nextSceneAssets.length; i++) excludeMap[nextSceneAssets[i]] = !0;
                            for (var _i2 = 0; _i2 < persistNodes.length; _i2++) visitNode(persistNodes[_i2], excludeMap);
                            if (oldSceneAssets) for (var _i3 = 0; _i3 < oldSceneAssets.length; _i3++) {
                                var key = oldSceneAssets[_i3];
                                !1 === releaseSettings[key] || excludeMap[key] || cc.loader.release(key);
                            }
                            for (var keys = Object.keys(releaseSettings), _i4 = 0; _i4 < keys.length; _i4++) {
                                var _key = keys[_i4];
                                !0 !== releaseSettings[_key] || excludeMap[_key] || cc.loader.release(_key);
                            }
                        }(oldScene && oldScene.autoReleaseAssets && oldScene.dependAssets, scene.dependAssets, persistNodeList), 
                        console.timeEnd("AutoRelease"), console.time("Destroy"), cc.isValid(oldScene) && oldScene.destroy(), 
                        this._scene = null, CCObject._deferredDestroy(), console.timeEnd("Destroy"), onBeforeLoadScene && onBeforeLoadScene(), 
                        this.emit(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, scene), this._scene = scene, console.time("Activate"), 
                        scene._activate(), console.timeEnd("Activate"), this._root && this._root.resetCumulativeTime(), 
                        this.startAnimation(), onLaunched && onLaunched(null, scene), this.emit(cc.Director.EVENT_AFTER_SCENE_LAUNCH, scene);
                    }
                }, {
                    key: "runScene",
                    value: function runScene(scene, onBeforeLoadScene, onLaunched) {
                        var _this2 = this;
                        cc.assertID(scene, 1205), cc.assertID(scene instanceof cc.Scene, 1216), scene._load(), 
                        this.once(cc.Director.EVENT_AFTER_UPDATE, function() {
                            _this2.runSceneImmediate(scene, onBeforeLoadScene, onLaunched);
                        });
                    }
                }, {
                    key: "_getSceneUuid",
                    value: function _getSceneUuid(key) {
                        var scenes = cc.game._sceneInfos;
                        if ("string" == typeof key) {
                            key.endsWith(".scene") || (key += ".scene"), "/" === key[0] || key.startsWith("db://") || (key = "/" + key);
                            for (var i = 0; i < scenes.length; i++) {
                                var info = scenes[i];
                                if (info.url.endsWith(key)) return info;
                            }
                        } else if ("number" == typeof key) {
                            if (0 <= key && key < scenes.length) return scenes[key];
                            cc.errorID(1206, key);
                        } else cc.errorID(1207, key);
                        return null;
                    }
                }, {
                    key: "loadScene",
                    value: function loadScene(sceneName, onLaunched, _onUnloaded) {
                        if (this._loadingScene) return cc.errorID(1208, sceneName, this._loadingScene), 
                        !1;
                        var info = this._getSceneUuid(sceneName);
                        if (info) {
                            var uuid = info.uuid;
                            return this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName), this._loadingScene = sceneName, 
                            this._loadSceneByUuid(uuid, onLaunched, _onUnloaded), !0;
                        }
                        return cc.errorID(1209, sceneName), !1;
                    }
                }, {
                    key: "preloadScene",
                    value: function preloadScene(sceneName, onProgress, onLoaded) {
                        void 0 === onLoaded && (onLoaded = onProgress, onProgress = null);
                        var info = this._getSceneUuid(sceneName);
                        if (info) this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName), cc.loader.load({
                            uuid: info.uuid,
                            type: "uuid"
                        }, onProgress, function(error, asset) {
                            error && cc.errorID(1210, sceneName, error.message), onLoaded && onLoaded(error, asset);
                        }); else {
                            var error = 'Can not preload the scene "' + sceneName + '" because it is not in the build settings.';
                            onLoaded(new Error(error)), cc.error("preloadScene: " + error);
                        }
                    }
                }, {
                    key: "_loadSceneByUuid",
                    value: function _loadSceneByUuid(uuid, argument_1, argument_2, argument_3) {
                        var onLaunched = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : null, onUnloaded = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : null;
                        console.time("LoadScene " + uuid), cc.AssetLibrary.loadAsset(uuid, function(error, sceneAsset) {
                            console.timeEnd("LoadScene " + uuid);
                            var self = director;
                            if (self._loadingScene = "", error) error = "Failed to load scene: " + error, cc.error(error); else {
                                if (sceneAsset instanceof cc.SceneAsset) {
                                    var scene = sceneAsset.scene;
                                    return scene._id = sceneAsset._uuid, scene._name = sceneAsset._name, void self.runSceneImmediate(scene, onUnloaded, onLaunched);
                                }
                                error = "The asset " + uuid + " is not a scene", cc.error(error);
                            }
                            onLaunched && onLaunched(error);
                        });
                    }
                }, {
                    key: "resume",
                    value: function resume() {
                        this._paused && (this._lastUpdate = performance.now(), this._lastUpdate || cc.logID(1200), 
                        this._paused = !1, this._deltaTime = 0);
                    }
                }, {
                    key: "setDepthTest",
                    value: function setDepthTest(value) {
                        cc.Camera.main && (cc.Camera.main.depth = !!value);
                    }
                }, {
                    key: "setClearColor",
                    value: function setClearColor(clearColor) {
                        cc.Camera.main && (cc.Camera.main.backgroundColor = clearColor);
                    }
                }, {
                    key: "getRunningScene",
                    value: function getRunningScene() {
                        return this._scene;
                    }
                }, {
                    key: "getScene",
                    value: function getScene() {
                        return this._scene;
                    }
                }, {
                    key: "getAnimationInterval",
                    value: function getAnimationInterval() {
                        return 1e3 / cc.game.getFrameRate();
                    }
                }, {
                    key: "setAnimationInterval",
                    value: function setAnimationInterval(value) {
                        cc.game.setFrameRate(Math.round(1e3 / value));
                    }
                }, {
                    key: "getDeltaTime",
                    value: function getDeltaTime() {
                        return this._deltaTime;
                    }
                }, {
                    key: "getCurrentTime",
                    value: function getCurrentTime() {
                        return this._lastUpdate;
                    }
                }, {
                    key: "getTotalFrames",
                    value: function getTotalFrames() {
                        return this._totalFrames;
                    }
                }, {
                    key: "isPaused",
                    value: function isPaused() {
                        return this._paused;
                    }
                }, {
                    key: "getScheduler",
                    value: function getScheduler() {
                        return this._scheduler;
                    }
                }, {
                    key: "setScheduler",
                    value: function setScheduler(scheduler) {
                        this._scheduler !== scheduler && (this.unregisterSystem(this._scheduler), this._scheduler = scheduler, 
                        this.registerSystem(Scheduler.ID, scheduler, 200));
                    }
                }, {
                    key: "registerSystem",
                    value: function registerSystem(name, sys, priority) {
                        sys.id = name, sys.priority = priority, sys.init(), this._systems.push(sys), this._systems.sort(System.sortByPriority);
                    }
                }, {
                    key: "unregisterSystem",
                    value: function unregisterSystem(sys) {
                        array.fastRemove(this._systems, sys), this._systems.sort(System.sortByPriority);
                    }
                }, {
                    key: "getSystem",
                    value: function getSystem(name) {
                        return this._systems.find(function(sys) {
                            return sys.id === name;
                        });
                    }
                }, {
                    key: "getAnimationManager",
                    value: function getAnimationManager() {
                        return this.getSystem(cc.AnimationManager.ID);
                    }
                }, {
                    key: "startAnimation",
                    value: function startAnimation() {
                        this.invalid = !1, this._lastUpdate = performance.now();
                    }
                }, {
                    key: "stopAnimation",
                    value: function stopAnimation() {
                        this.invalid = !0;
                    }
                }, {
                    key: "mainLoop",
                    value: function mainLoop() {
                        if (this._purgeDirectorInNextLoop) this._purgeDirectorInNextLoop = !1, this.purgeDirector(); else if (!this.invalid) {
                            this.calculateDeltaTime();
                            var dt = this._deltaTime;
                            if (!this._paused) {
                                this.emit(Director.EVENT_BEFORE_UPDATE), this._compScheduler.startPhase(), this._compScheduler.updatePhase(dt);
                                for (var i = 0; i < this._systems.length; ++i) this._systems[i].update(dt);
                                this._compScheduler.lateUpdatePhase(dt), this.emit(Director.EVENT_AFTER_UPDATE), 
                                CCObject._deferredDestroy();
                                for (var _i = 0; _i < this._systems.length; ++_i) this._systems[_i].postUpdate(dt);
                            }
                            this.emit(Director.EVENT_BEFORE_DRAW), this._root.frameMove(this._deltaTime), this._root.device.present(), 
                            this.emit(Director.EVENT_AFTER_DRAW), eventManager.frameUpdateListeners(), Node$1.bookOfChange.clear(), 
                            this._totalFrames++;
                        }
                    }
                }, {
                    key: "root",
                    get: function get() {
                        return this._root;
                    }
                } ]), Director;
            }());
            Director.EVENT_INIT = "director_init", Director.EVENT_RESET = "director_reset", 
            Director.EVENT_BEFORE_SCENE_LOADING = "director_before_scene_loading", Director.EVENT_BEFORE_SCENE_LAUNCH = "director_before_scene_launch", 
            Director.EVENT_AFTER_SCENE_LAUNCH = "director_after_scene_launch", Director.EVENT_BEFORE_UPDATE = "director_before_update", 
            Director.EVENT_AFTER_UPDATE = "director_after_update", Director.EVENT_BEFORE_DRAW = "director_before_draw", 
            Director.EVENT_AFTER_DRAW = "director_after_draw", Director.EVENT_BEFORE_PHYSICS = "director_before_physics", 
            Director.EVENT_AFTER_PHYSICS = "director_after_physics", Director.instance = void 0, 
            cc.Director = Director;
            var director = exports("director", Director.instance = cc.director = new Director());
            function flattenCodeArray(array) {
                var strList = [];
                return function deepFlatten(strList, array) {
                    var _iterator = array, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var item = _ref;
                        Array.isArray(item) ? deepFlatten(strList, item) : strList.push(item);
                    }
                }(strList, array), strList.join("");
            }
            cc.RenderPassStage = RenderPassStage;
            var Destroyed$2 = CCObject.Flags.Destroyed, PersistentMask$2 = CCObject.Flags.PersistentMask, DEFAULT = DELIMETER + "default", IDENTIFIER_RE$1 = CCClass.IDENTIFIER_RE, DEFAULT_MODULE_CACHE = {
                "cc.Node": "cc.Node",
                "cc.Sprite": "cc.Sprite",
                "cc.Label": "cc.Label",
                "cc.Button": "cc.Button",
                "cc.Widget": "cc.Widget",
                "cc.Animation": "cc.Animation",
                "cc.ClickEvent": !1,
                "cc.PrefabInfo": !1
            }, escapeForJS$1 = CCClass.escapeForJS, Declaration = function() {
                function Declaration(varName, expression) {
                    _classCallCheck(this, Declaration), this.varName = void 0, this.expression = void 0, 
                    this.varName = varName, this.expression = expression;
                }
                return _createClass(Declaration, [ {
                    key: "toString",
                    value: function toString() {
                        return "var " + this.varName + "=" + this.expression + ";";
                    }
                } ]), Declaration;
            }();
            function mergeDeclaration(statement, expression) {
                return expression instanceof Declaration ? new Declaration(expression.varName, statement + expression.expression) : statement + expression;
            }
            function writeAssignment(codeArray, statement, expression) {
                Array.isArray(expression) ? (expression[0] = mergeDeclaration(statement, expression[0]), 
                codeArray.push(expression)) : codeArray.push(mergeDeclaration(statement, expression) + ";");
            }
            var Assignments = function() {
                function Assignments(targetExpression) {
                    _classCallCheck(this, Assignments), this._exps = void 0, this._targetExp = void 0, 
                    this._exps = [], this._targetExp = targetExpression;
                }
                return _createClass(Assignments, [ {
                    key: "append",
                    value: function append(key, expression) {
                        this._exps.push([ key, expression ]);
                    }
                }, {
                    key: "writeCode",
                    value: function writeCode(codeArray) {
                        var targetVar;
                        if (1 < this._exps.length) codeArray.push("t=" + this._targetExp + ";"), targetVar = "t"; else {
                            if (1 !== this._exps.length) return;
                            targetVar = this._targetExp;
                        }
                        for (var i = 0; i < this._exps.length; i++) {
                            var pair = this._exps[i];
                            writeAssignment(codeArray, targetVar + getPropAccessor(pair[0]) + "=", pair[1]);
                        }
                    }
                } ]), Assignments;
            }();
            function getPropAccessor(key) {
                return IDENTIFIER_RE$1.test(key) ? "." + key : "[" + escapeForJS$1(key) + "]";
            }
            Assignments.pool = void 0, Assignments.pool = new Pool(function(obj) {
                obj._exps.length = 0, obj._targetExp = null;
            }, 1), Assignments.pool.get = function(targetExpression) {
                var cache = this._get() || new Assignments();
                return cache._targetExp = targetExpression, cache;
            };
            var _class$k, _class2$g, _descriptor$e, _descriptor2$a, _descriptor3$7, _class3$a, _temp$i, Parser = function() {
                function Parser(obj, parent) {
                    var globalVariablesDeclaration;
                    _classCallCheck(this, Parser), this.parent = void 0, this.objsToClear_iN$t = void 0, 
                    this.codeArray = void 0, this.objs = void 0, this.funcs = void 0, this.funcModuleCache = void 0, 
                    this.globalVariables = void 0, this.globalVariableId = void 0, this.localVariableId = void 0, 
                    this.result = void 0, this.parent = parent, this.objsToClear_iN$t = [], this.codeArray = [], 
                    this.objs = [], this.funcs = [], this.funcModuleCache = createMap(), mixin(this.funcModuleCache, DEFAULT_MODULE_CACHE), 
                    this.globalVariables = [], this.globalVariableId = 0, this.localVariableId = 0, 
                    this.codeArray.push("var o,t;", "if(R){", "o=R;", "}else{", "o=R=new " + this.getFuncModule(obj.constructor, !0) + "();", "}"), 
                    obj._iN$t = {
                        globalVar: "R"
                    }, this.objsToClear_iN$t.push(obj), this.enumerateObject(this.codeArray, obj), 0 < this.globalVariables.length && (globalVariablesDeclaration = "var " + this.globalVariables.join(",") + ";");
                    var code = flattenCodeArray([ "return (function(R){", globalVariablesDeclaration || [], this.codeArray, "return o;", "})" ]);
                    this.result = Function("O", "F", code)(this.objs, this.funcs);
                    for (var i = 0, len = this.objsToClear_iN$t.length; i < len; ++i) this.objsToClear_iN$t[i]._iN$t = null;
                    this.objsToClear_iN$t.length = 0;
                }
                return _createClass(Parser, [ {
                    key: "getFuncModule",
                    value: function getFuncModule(func, usedInNew) {
                        var clsName = getClassName(func);
                        if (clsName) {
                            var cache = this.funcModuleCache[clsName];
                            if (cache) return cache;
                            if (void 0 === cache) {
                                var clsNameIsModule = -1 !== clsName.indexOf(".");
                                if (clsNameIsModule) try {
                                    if (clsNameIsModule = func === Function("return " + clsName)()) return this.funcModuleCache[clsName] = clsName;
                                } catch (e) {}
                            }
                        }
                        var index = this.funcs.indexOf(func);
                        index < 0 && (index = this.funcs.length, this.funcs.push(func));
                        var res = "F[" + index + "]";
                        return usedInNew && (res = "(" + res + ")"), this.funcModuleCache[clsName] = res;
                    }
                }, {
                    key: "getObjRef",
                    value: function getObjRef(obj) {
                        var index = this.objs.indexOf(obj);
                        return index < 0 && (index = this.objs.length, this.objs.push(obj)), "O[" + index + "]";
                    }
                }, {
                    key: "setValueType",
                    value: function setValueType(codeArray, defaultValue, srcValue, targetExpression) {
                        var assignments = Assignments.pool.get(targetExpression), fastDefinedProps = defaultValue.constructor.__props__;
                        fastDefinedProps = fastDefinedProps || Object.keys(defaultValue);
                        for (var i = 0; i < fastDefinedProps.length; i++) {
                            var propName = fastDefinedProps[i], prop = srcValue[propName];
                            if (defaultValue[propName] !== prop) {
                                var expression = this.enumerateField(srcValue, propName, prop);
                                assignments.append(propName, expression);
                            }
                        }
                        assignments.writeCode(codeArray), Assignments.pool.put(assignments);
                    }
                }, {
                    key: "enumerateCCClass",
                    value: function enumerateCCClass(codeArray, obj, klass) {
                        for (var props = klass.__values__, attrs = getClassAttrs(klass), p = 0; p < props.length; p++) {
                            var key = props[p], val = obj[key], defaultValue = attrs[key + DEFAULT];
                            if (!equalsToDefault(defaultValue, val)) if ("object" === _typeof(val) && val instanceof cc.ValueType && (defaultValue = CCClass.getDefault(defaultValue)) && defaultValue.constructor === val.constructor) {
                                var targetExpression = "o" + getPropAccessor(key);
                                this.setValueType(codeArray, defaultValue, val, targetExpression);
                            } else this.setObjProp(codeArray, obj, key, val);
                        }
                    }
                }, {
                    key: "instantiateArray",
                    value: function instantiateArray(value) {
                        if (0 === value.length) return "[]";
                        var arrayVar = "a" + ++this.localVariableId, codeArray = [ new Declaration(arrayVar, "new Array(" + value.length + ")") ];
                        value._iN$t = {
                            globalVar: "",
                            source: codeArray
                        }, this.objsToClear_iN$t.push(value);
                        for (var i = 0; i < value.length; ++i) {
                            writeAssignment(codeArray, arrayVar + "[" + i + "]=", this.enumerateField(value, i, value[i]));
                        }
                        return codeArray;
                    }
                }, {
                    key: "enumerateField",
                    value: function enumerateField(obj, key, value) {
                        if ("object" === _typeof(value) && value) {
                            var _iN$t = value._iN$t;
                            if (_iN$t) {
                                var globalVar = _iN$t.globalVar;
                                if (!globalVar) {
                                    globalVar = _iN$t.globalVar = "v" + ++this.globalVariableId, this.globalVariables.push(globalVar);
                                    var line = _iN$t.source[0];
                                    _iN$t.source[0] = mergeDeclaration(globalVar + "=", line);
                                }
                                return globalVar;
                            }
                            return Array.isArray(value) ? this.instantiateArray(value) : this.instantiateObj(value);
                        }
                        return "function" == typeof value ? this.getFuncModule(value) : "string" == typeof value ? escapeForJS$1(value) : ("_objFlags" === key && obj instanceof CCObject && (value &= PersistentMask$2), 
                        value);
                    }
                }, {
                    key: "setObjProp",
                    value: function setObjProp(codeArray, obj, key, value) {
                        writeAssignment(codeArray, "o" + getPropAccessor(key) + "=", this.enumerateField(obj, key, value));
                    }
                }, {
                    key: "enumerateObject",
                    value: function enumerateObject(codeArray, obj) {
                        var klass = obj.constructor;
                        if (cc.Class._isCCClass(klass)) this.enumerateCCClass(codeArray, obj, klass); else for (var key in obj) if (obj.hasOwnProperty(key) && (95 !== key.charCodeAt(0) || 95 !== key.charCodeAt(1) || "__type__" === key)) {
                            var value = obj[key];
                            "object" === _typeof(value) && value && value === obj._iN$t || this.setObjProp(codeArray, obj, key, value);
                        }
                    }
                }, {
                    key: "instantiateObj",
                    value: function instantiateObj(obj) {
                        if (obj instanceof cc.ValueType) return CCClass.getNewValueTypeCode(obj);
                        if (obj instanceof cc.Asset) return this.getObjRef(obj);
                        if (obj._objFlags & Destroyed$2) return null;
                        var createCode, ctor = obj.constructor;
                        if (cc.Class._isCCClass(ctor)) {
                            if (this.parent) if (this.parent instanceof cc.Component) {
                                if (obj instanceof cc._BaseNode || obj instanceof cc.Component) return this.getObjRef(obj);
                            } else if (this.parent instanceof cc._BaseNode) if (obj instanceof cc._BaseNode) {
                                if (!obj.isChildOf(this.parent)) return this.getObjRef(obj);
                            } else if (obj instanceof cc.Component && !obj.node.isChildOf(this.parent)) return this.getObjRef(obj);
                            createCode = new Declaration("o", "new " + this.getFuncModule(ctor, !0) + "()");
                        } else if (ctor === Object) createCode = new Declaration("o", "{}"); else {
                            if (ctor) return this.getObjRef(obj);
                            createCode = new Declaration("o", "Object.create(null)");
                        }
                        var codeArray = [ createCode ];
                        return obj._iN$t = {
                            globalVar: "",
                            source: codeArray
                        }, this.objsToClear_iN$t.push(obj), this.enumerateObject(codeArray, obj), [ "(function(){", codeArray, "return o;})();" ];
                    }
                } ]), Parser;
            }();
            function equalsToDefault(def, value) {
                if ("function" == typeof def) try {
                    def = def();
                } catch (e) {
                    return !1;
                }
                if (def === value) return !0;
                if (def && value) {
                    if (def instanceof cc.ValueType && def.equals(value)) return !0;
                    if (Array.isArray(def) && Array.isArray(value) || def.constructor === Object && value.constructor === Object) try {
                        return Array.isArray(def) && Array.isArray(value) && 0 === def.length && 0 === value.length;
                    } catch (e) {}
                }
                return !1;
            }
            function compile(node) {
                var root = node instanceof cc._BaseNode && node;
                return new Parser(node, root).result;
            }
            var _class$l, _class2$h, _descriptor$f, _descriptor2$b, OptimizationPolicy = Enum({
                AUTO: 0,
                SINGLE_INSTANCE: 1,
                MULTI_INSTANCE: 2
            }), Prefab = exports("Prefab", ccclass("cc.Prefab")((_temp$i = _class3$a = function() {
                function Prefab() {
                    var _this;
                    return _classCallCheck(this, Prefab), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Prefab).call(this)), "data", _descriptor$e, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "optimizationPolicy", _descriptor2$a, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "asyncLoadAssets", _descriptor3$7, _assertThisInitialized(_this)), 
                    _this._createFunction = void 0, _this._instantiatedTimes = void 0, _this._createFunction = null, 
                    _this._instantiatedTimes = 0, _this;
                }
                return _inherits(Prefab, Asset), _createClass(Prefab, [ {
                    key: "createNode",
                    value: function createNode(cb) {
                        var node = cc.instantiate(this);
                        node.name = this.name, cb(null, node);
                    }
                }, {
                    key: "compileCreateFunction",
                    value: function compileCreateFunction() {
                        this._createFunction = compile(this.data);
                    }
                }, {
                    key: "_doInstantiate",
                    value: function _doInstantiate(rootToRedirect) {
                        return this.data._prefab ? this.data._prefab._synced = !0 : cc.warnID(3700), this._createFunction || this.compileCreateFunction(), 
                        this._createFunction(rootToRedirect);
                    }
                }, {
                    key: "_instantiate",
                    value: function _instantiate() {
                        var node;
                        return this.optimizationPolicy !== OptimizationPolicy.SINGLE_INSTANCE && (this.optimizationPolicy === OptimizationPolicy.MULTI_INSTANCE || this._instantiatedTimes + 1 >= Prefab.OptimizationPolicyThreshold) ? (node = this._doInstantiate(), 
                        this.data._instantiate(node)) : (this.data._prefab._synced = !0, node = this.data._instantiate()), 
                        ++this._instantiatedTimes, node;
                    }
                } ]), Prefab;
            }(), _class3$a.OptimizationPolicy = OptimizationPolicy, _class3$a.OptimizationPolicyThreshold = 3, 
            _descriptor$e = _applyDecoratedDescriptor((_class2$g = _temp$i).prototype, "data", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor2$a = _applyDecoratedDescriptor(_class2$g.prototype, "optimizationPolicy", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return OptimizationPolicy.AUTO;
                }
            }), _descriptor3$7 = _applyDecoratedDescriptor(_class2$g.prototype, "asyncLoadAssets", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _class$k = _class2$g)) || _class$k);
            cc.Prefab = Prefab, obsolete(cc, "cc._Prefab", "Prefab");
            var _class$m, _class2$i, _descriptor$g, SceneAsset = exports("SceneAsset", ccclass("cc.SceneAsset")((_descriptor$f = _applyDecoratedDescriptor((_class2$h = function() {
                function SceneAsset() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, SceneAsset);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SceneAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "scene", _descriptor$f, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "asyncLoadAssets", _descriptor2$b, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(SceneAsset, Asset), SceneAsset;
            }()).prototype, "scene", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor2$b = _applyDecoratedDescriptor(_class2$h.prototype, "asyncLoadAssets", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _class$l = _class2$h)) || _class$l);
            cc.SceneAsset = SceneAsset;
            var _class$n, _class2$j, _descriptor$h, SpriteAtlas = exports("SpriteAtlas", ccclass("cc.SpriteAtlas")((_descriptor$g = _applyDecoratedDescriptor((_class2$i = function() {
                function SpriteAtlas() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, SpriteAtlas);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SpriteAtlas)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "spriteFrames", _descriptor$g, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(SpriteAtlas, Asset), _createClass(SpriteAtlas, [ {
                    key: "getTexture",
                    value: function getTexture() {
                        var keys = Object.keys(this.spriteFrames);
                        if (0 < keys.length) {
                            var spriteFrame = this.spriteFrames[keys[0]];
                            return spriteFrame && spriteFrame._image;
                        }
                        return null;
                    }
                }, {
                    key: "getSpriteFrame",
                    value: function getSpriteFrame(key) {
                        var sf = this.spriteFrames[key];
                        return sf ? (sf.name || (sf.name = key), sf) : null;
                    }
                }, {
                    key: "getSpriteFrames",
                    value: function getSpriteFrames() {
                        for (var frames = [], spriteFrames = this.spriteFrames, _i = 0, _Object$keys = Object.keys(spriteFrames); _i < _Object$keys.length; _i++) {
                            var _key2 = _Object$keys[_i];
                            frames.push(spriteFrames[_key2]);
                        }
                        return frames;
                    }
                }, {
                    key: "_serialize",
                    value: function _serialize(exporting) {
                        for (var frames = [], _i2 = 0, _Object$keys2 = Object.keys(this.spriteFrames); _i2 < _Object$keys2.length; _i2++) {
                            var _key3 = _Object$keys2[_i2], spriteFrame = this.spriteFrames[_key3], id = spriteFrame ? spriteFrame._uuid : "";
                            id && exporting && (id = Editor.Utils.UuidUtils.compressUuid(id, !0)), frames.push(_key3), 
                            frames.push(id);
                        }
                        return {
                            name: this._name,
                            spriteFrames: frames
                        };
                    }
                }, {
                    key: "_deserialize",
                    value: function _deserialize(serializeData, handle) {
                        var data = serializeData;
                        this._name = data.name;
                        var frames = data.spriteFrames;
                        this.spriteFrames = createMap();
                        for (var i = 0; i < frames.length; i += 2) handle.result.push(this.spriteFrames, frames[i], frames[i + 1]);
                    }
                } ]), SpriteAtlas;
            }()).prototype, "spriteFrames", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return createMap();
                }
            }), _class$m = _class2$i)) || _class$m);
            cc.SpriteAtlas = SpriteAtlas;
            var _class$o, _class2$k, _descriptor$i, TextAsset = exports("TextAsset", ccclass("cc.TextAsset")((_descriptor$h = _applyDecoratedDescriptor((_class2$j = function() {
                function TextAsset() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, TextAsset);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TextAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "text", _descriptor$h, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(TextAsset, Asset), _createClass(TextAsset, [ {
                    key: "toString",
                    value: function toString() {
                        return this.text;
                    }
                } ]), TextAsset;
            }()).prototype, "text", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return "";
                }
            }), _class$n = _class2$j)) || _class$n);
            cc.TextAsset = TextAsset;
            var JsonAsset = exports("JsonAsset", ccclass("cc.JsonAsset")((_descriptor$i = _applyDecoratedDescriptor((_class2$k = function() {
                function JsonAsset() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, JsonAsset);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(JsonAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "json", _descriptor$i, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(JsonAsset, Asset), JsonAsset;
            }()).prototype, "json", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _class$o = _class2$k)) || _class$o);
            cc.JsonAsset = JsonAsset;
            var HexChars = "0123456789abcdef".split(""), _t = [ "", "", "", "" ], UuidTemplate = _t.concat(_t, "-", _t, "-", _t, "-", _t, "-", _t, _t, _t), Indices = UuidTemplate.map(function(x, i) {
                return "-" === x ? NaN : i;
            }).filter(isFinite);
            function decodeUuid(base64) {
                var uuid = base64.split("@")[0];
                if (22 !== uuid.length) return base64;
                UuidTemplate[0] = base64[0], UuidTemplate[1] = base64[1];
                for (var i = 2, j = 2; i < 22; i += 2) {
                    var lhs = BASE64_VALUES[base64.charCodeAt(i)], rhs = BASE64_VALUES[base64.charCodeAt(i + 1)];
                    UuidTemplate[Indices[j++]] = HexChars[lhs >> 2], UuidTemplate[Indices[j++]] = HexChars[(3 & lhs) << 2 | rhs >> 4], 
                    UuidTemplate[Indices[j++]] = HexChars[15 & rhs];
                }
                return base64.replace(uuid, UuidTemplate.join(""));
            }
            var url = {
                _rawAssets: "",
                normalize: function normalize(url) {
                    return url && (46 === url.charCodeAt(0) && 47 === url.charCodeAt(1) ? url = url.slice(2) : 47 === url.charCodeAt(0) && (url = url.slice(1))), 
                    url;
                },
                raw: function raw(url) {
                    if ((url = this.normalize(url)).startsWith("resources/")) {
                        var uuid = cc.loader._getResUuid(url.slice(10), cc.Asset, null, !0);
                        if (uuid) return cc.AssetLibrary.getLibUrlNoExt(uuid, !0) + cc.path.extname(url);
                    } else cc.errorID(7002, url);
                    return this._rawAssets + url;
                },
                _init: function _init(assets) {
                    this._rawAssets = cc.path.stripSep(assets) + "/";
                }
            };
            cc.url = url, exports("url", url);
            function Entry(uuid, type) {
                _classCallCheck(this, Entry), this.uuid = void 0, this.type = void 0, this.uuid = uuid, 
                this.type = type;
            }
            function isMatchByWord(path, test) {
                return !(path.length > test.length) || 47 === path.charCodeAt(test.length);
            }
            var ItemState, AssetTable = function() {
                function AssetTable() {
                    _classCallCheck(this, AssetTable), this._pathToUuid = void 0, this._pathToUuid = createMap(!0);
                }
                return _createClass(AssetTable, [ {
                    key: "getUuid",
                    value: function getUuid(path, type) {
                        path = url.normalize(path);
                        var item = this._pathToUuid[path];
                        if (item) if (Array.isArray(item)) {
                            if (!type) return item[0].uuid;
                            for (var i = 0; i < item.length; i++) {
                                var entry = item[i];
                                if (isChildClassOf(entry.type, type)) return entry.uuid;
                            }
                            if (isChildClassOf(type, SpriteFrame)) for (var _i = 0; _i < item.length; _i++) {
                                if (isChildClassOf(item[_i].type, SpriteAtlas)) {
                                    errorID(4932, path);
                                    break;
                                }
                            }
                        } else {
                            if (!type || isChildClassOf(item.type, type)) return item.uuid;
                            isChildClassOf(type, SpriteFrame) && isChildClassOf(item.type, SpriteAtlas) && errorID(4932, path);
                        }
                        return "";
                    }
                }, {
                    key: "getUuidArray",
                    value: function getUuidArray(path, type, out_urls) {
                        "/" === (path = url.normalize(path))[path.length - 1] && (path = path.slice(0, -1));
                        var _foundAtlasUrl, path2uuid = this._pathToUuid, uuids = [];
                        for (var p in path2uuid) if (p.startsWith(path) && isMatchByWord(p, path) || !path) {
                            var item = path2uuid[p];
                            if (Array.isArray(item)) for (var i = 0; i < item.length; i++) {
                                var entry = item[i];
                                !type || isChildClassOf(entry.type, type) ? (uuids.push(entry.uuid), out_urls && out_urls.push(p)) : entry.type === SpriteAtlas && (_foundAtlasUrl = p);
                            } else !type || isChildClassOf(item.type, type) ? (uuids.push(item.uuid), out_urls && out_urls.push(p)) : item.type === SpriteAtlas && (_foundAtlasUrl = p);
                        }
                        return 0 === uuids.length && _foundAtlasUrl && isChildClassOf(type, SpriteFrame) && errorID(4932, _foundAtlasUrl), 
                        uuids;
                    }
                }, {
                    key: "add",
                    value: function add(path, uuid, type, isMainAsset) {
                        isMainAsset && (path = path.substring(0, path.length - extname(path).length));
                        var newEntry = new Entry(uuid, type);
                        pushToMap(this._pathToUuid, path, newEntry, isMainAsset);
                    }
                }, {
                    key: "_getInfo_DEBUG",
                    value: function _getInfo_DEBUG(uuid, out_info) {
                        for (var path2uuid = this._pathToUuid, paths = Object.keys(path2uuid), p = 0; p < paths.length; ++p) {
                            var path = paths[p], item = path2uuid[path];
                            if (Array.isArray(item)) for (var i = 0; i < item.length; i++) {
                                var entry = item[i];
                                if (entry.uuid === uuid) return out_info.path = path, out_info.type = entry.type, 
                                !0;
                            } else if (item.uuid === uuid) return out_info.path = path, out_info.type = item.type, 
                            !0;
                        }
                        return !1;
                    }
                }, {
                    key: "reset",
                    value: function reset() {
                        this._pathToUuid = createMap(!0);
                    }
                } ]), AssetTable;
            }(), _qid = 0 | 998 * Math.random(), _queues = createMap(!0), _pool = [];
            !function(ItemState) {
                ItemState[ItemState.WORKING = 0] = "WORKING", ItemState[ItemState.COMPLETE = 1] = "COMPLETE", 
                ItemState[ItemState.ERROR = 2] = "ERROR";
            }(ItemState = ItemState || {});
            var _queueDeps = createMap(!0);
            function createItem(id, queueId) {
                var url = "object" === _typeof(id) ? id.url : id, result = {
                    queueId: queueId,
                    id: url,
                    url: url,
                    rawUrl: void 0,
                    urlParam: function _parseUrlParam(url) {
                        if (url) {
                            var split = url.split("?");
                            if (split && split[0] && split[1]) {
                                var urlParam = {};
                                return split[1].split("&").forEach(function(item) {
                                    var itemSplit = item.split("=");
                                    urlParam[itemSplit[0]] = itemSplit[1];
                                }), urlParam;
                            }
                        }
                    }(url),
                    type: "",
                    error: null,
                    content: null,
                    complete: !1,
                    states: {},
                    deps: null,
                    isScene: id.uuid && cc.game._sceneInfos.find(function(info) {
                        return info.uuid === id.uuid;
                    })
                };
                if ("object" === _typeof(id) && (mixin(result, id), id.skips)) for (var i = 0; i < id.skips.length; i++) {
                    var skip = id.skips[i];
                    result.states[skip] = ItemState.COMPLETE;
                }
                return result.rawUrl = result.url, url && !result.type && (result.type = extname(url).toLowerCase().substr(1)), 
                result;
            }
            var _checkedIds = [];
            function checkCircleReference(owner, item, recursiveCall) {
                if (!owner || !item) return !1;
                var result = !1;
                if (_checkedIds.push(item.id), item.deps) {
                    var i, subDep, deps = item.deps;
                    for (i = 0; i < deps.length; i++) {
                        if ((subDep = deps[i]).id === owner.id) {
                            result = !0;
                            break;
                        }
                        if (!(0 <= _checkedIds.indexOf(subDep.id)) && (subDep.deps && checkCircleReference(owner, subDep, !0))) {
                            result = !0;
                            break;
                        }
                    }
                }
                return recursiveCall || (_checkedIds.length = 0), result;
            }
            var LoadingItems = exports("LoadingItems", function() {
                function LoadingItems(pipeline, urlList, onProgress, onComplete) {
                    var _this;
                    return _classCallCheck(this, LoadingItems), (_this = _possibleConstructorReturn(this, _getPrototypeOf(LoadingItems).call(this))).onProgress = void 0, 
                    _this.onComplete = void 0, _this.map = createMap(!0), _this.completed = {}, _this.totalCount = 0, 
                    _this.completedCount = 0, _this.active = void 0, _this._id = void 0, _this._pipeline = void 0, 
                    _this._errorUrls = [], _this._appending = !1, _this._ownerQueue = null, _this._id = ++_qid, 
                    _queues[_this._id] = _assertThisInitialized(_this), _this._pipeline = pipeline, 
                    _this.onProgress = onProgress, _this.onComplete = onComplete, _this._pipeline ? _this.active = !0 : _this.active = !1, 
                    urlList && (0 < urlList.length ? _this.append(urlList) : _this.allComplete()), _this;
                }
                return _inherits(LoadingItems, CallbacksInvoker), _createClass(LoadingItems, [ {
                    key: "append",
                    value: function append(urlList, owner) {
                        var _this2 = this;
                        if (!this.active) return [];
                        owner && !owner.deps && (owner.deps = []), this._appending = !0;
                        var i, url, item, id, accepted = [];
                        for (i = 0; i < urlList.length; ++i) {
                            if ((url = urlList[i]).queueId && !this.map[url.id]) {
                                if (this.map[url.id] = url, owner && owner.deps.push(url), url.complete || checkCircleReference(owner, url)) {
                                    this.totalCount++, this.itemComplete(url.id);
                                    continue;
                                }
                                if ("continue" === function() {
                                    var self = _this2, queue = _queues[url.queueId];
                                    return queue && (_this2.totalCount++, LoadingItems.registerQueueDep(owner || _this2._id, url.id), 
                                    queue.addListener(url.id, function(item) {
                                        self.itemComplete(item.id);
                                    })), "continue";
                                }()) continue;
                            }
                            if ("string" == typeof ((id = url).url || id)) {
                                var key = (item = createItem(url, this._id)).id;
                                this.map[key] || (this.map[key] = item, this.totalCount++, owner && owner.deps.push(item), 
                                LoadingItems.registerQueueDep(owner || this._id, key), accepted.push(item));
                            }
                        }
                        return this._appending = !1, this.completedCount === this.totalCount ? this.allComplete() : this._pipeline.flowIn(accepted), 
                        accepted;
                    }
                }, {
                    key: "_childOnProgress",
                    value: function _childOnProgress(item) {
                        if (this.onProgress) {
                            var dep = _queueDeps[this._id];
                            this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
                        }
                    }
                }, {
                    key: "allComplete",
                    value: function allComplete() {
                        var errors = 0 === this._errorUrls.length ? null : this._errorUrls;
                        this.onComplete && this.onComplete(errors, this);
                    }
                }, {
                    key: "isCompleted",
                    value: function isCompleted() {
                        return this.completedCount >= this.totalCount;
                    }
                }, {
                    key: "isItemCompleted",
                    value: function isItemCompleted(id) {
                        return !!this.completed[id];
                    }
                }, {
                    key: "exists",
                    value: function exists(id) {
                        return !!this.map[id];
                    }
                }, {
                    key: "getContent",
                    value: function getContent(id) {
                        var item = this.map[id], ret = null;
                        return item && (item.content ? ret = item.content : item.alias && (ret = item.alias.content)), 
                        ret;
                    }
                }, {
                    key: "getError",
                    value: function getError(id) {
                        var item = this.map[id], ret = null;
                        return item && (item.error ? ret = item.error : item.alias && (ret = item.alias.error)), 
                        ret;
                    }
                }, {
                    key: "removeItem",
                    value: function removeItem(url) {
                        var item = this.map[url];
                        item && this.completed[item.alias || url] && (delete this.completed[url], delete this.map[url], 
                        item.alias && (delete this.completed[item.alias.id], delete this.map[item.alias.id]), 
                        this.completedCount--, this.totalCount--);
                    }
                }, {
                    key: "itemComplete",
                    value: function itemComplete(id) {
                        var item = this.map[id];
                        if (item) {
                            var errorListId = this._errorUrls.indexOf(id);
                            if (item.error && -1 === errorListId ? this._errorUrls.push(id) : item.error || -1 === errorListId || this._errorUrls.splice(errorListId, 1), 
                            this.completed[id] = item, this.completedCount++, LoadingItems.finishDep(item.id), 
                            this.onProgress) {
                                var dep = _queueDeps[this._id];
                                this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
                            }
                            this.emit(id, item), this.removeAll(id), !this._appending && this.completedCount >= this.totalCount && this.allComplete();
                        }
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.active = !1, this._appending = !1, this._pipeline = null, this._ownerQueue = null, 
                        this._errorUrls.length = 0, this.onProgress = void 0, this.onComplete = void 0, 
                        this.map = createMap(!0), this.completed = {}, this.totalCount = 0, this.completedCount = 0, 
                        CallbacksInvoker.call(this), _queues[this._id] = null, _queueDeps[this._id] && (_queueDeps[this._id].completed.length = 0, 
                        _queueDeps[this._id].deps.length = 0), -1 === _pool.indexOf(this) && _pool.length < 10 && _pool.push(this);
                    }
                }, {
                    key: "addListener",
                    value: function addListener(key, callback, target) {
                        return _get(_getPrototypeOf(LoadingItems.prototype), "on", this).call(this, key, callback, target);
                    }
                }, {
                    key: "hasListener",
                    value: function hasListener(key, callback, target) {
                        return _get(_getPrototypeOf(LoadingItems.prototype), "hasEventListener", this).call(this, key, callback, target);
                    }
                }, {
                    key: "removeListener",
                    value: function removeListener(key, callback, target) {
                        return _get(_getPrototypeOf(LoadingItems.prototype), "off", this).call(this, key, callback, target);
                    }
                }, {
                    key: "removeAllListeners",
                    value: function removeAllListeners(key) {
                        _get(_getPrototypeOf(LoadingItems.prototype), "removeAll", this).call(this, key);
                    }
                } ], [ {
                    key: "create",
                    value: function create(pipeline, urlList, onProgress, onComplete) {
                        void 0 === onProgress ? "function" == typeof urlList && (onComplete = urlList, urlList = onProgress = null) : void 0 === onComplete && ("function" == typeof urlList ? (onComplete = onProgress, 
                        onProgress = urlList, urlList = null) : (onComplete = onProgress, onProgress = null));
                        var queue = _pool.pop();
                        return queue ? (queue._pipeline = pipeline, queue.onProgress = onProgress, queue.onComplete = onComplete, 
                        (_queues[queue._id] = queue)._pipeline && (queue.active = !0), urlList && queue.append(urlList)) : queue = new LoadingItems(pipeline, urlList, onProgress, onComplete), 
                        queue;
                    }
                }, {
                    key: "getQueue",
                    value: function getQueue(item) {
                        return item.queueId ? _queues[item.queueId] : null;
                    }
                }, {
                    key: "itemComplete",
                    value: function itemComplete(item) {
                        var queue = _queues[item.queueId];
                        queue && queue.itemComplete(item.id);
                    }
                }, {
                    key: "initQueueDeps",
                    value: function initQueueDeps(queue) {
                        var dep = _queueDeps[queue._id];
                        dep ? (dep.completed.length = 0, dep.deps.length = 0) : dep = _queueDeps[queue._id] = {
                            completed: [],
                            deps: []
                        };
                    }
                }, {
                    key: "registerQueueDep",
                    value: function registerQueueDep(owner, depId) {
                        var queueId = owner.queueId || owner;
                        if (!queueId) return !1;
                        var queueDepList = _queueDeps[queueId];
                        if (queueDepList) -1 === queueDepList.deps.indexOf(depId) && queueDepList.deps.push(depId); else if (owner.id) for (var id in _queueDeps) {
                            var queue = _queueDeps[id];
                            -1 !== queue.deps.indexOf(owner.id) && -1 === queue.deps.indexOf(depId) && queue.deps.push(depId);
                        }
                    }
                }, {
                    key: "finishDep",
                    value: function finishDep(depId) {
                        for (var id in _queueDeps) {
                            var queue = _queueDeps[id];
                            -1 !== queue.deps.indexOf(depId) && -1 === queue.completed.indexOf(depId) && queue.completed.push(depId);
                        }
                    }
                } ]), LoadingItems;
            }());
            LoadingItems.ItemState = new cc.Enum(ItemState);
            var ItemState$1 = (cc.LoadingItems = LoadingItems).ItemState;
            function flow(pipe, item) {
                var pipeId = pipe.id, itemState = item.states[pipeId], next = pipe.next, pipeline = pipe.pipeline;
                if (!item.error && itemState !== ItemState$1.WORKING && itemState !== ItemState$1.ERROR) if (itemState === ItemState$1.COMPLETE) next ? flow(next, item) : pipeline.flowOut(item); else {
                    item.states[pipeId] = ItemState$1.WORKING;
                    var result = pipe.handle(item, function(err, result) {
                        err ? (item.error = err, item.states[pipeId] = ItemState$1.ERROR, pipeline.flowOut(item)) : (result && (item.content = result), 
                        item.states[pipeId] = ItemState$1.COMPLETE, next ? flow(next, item) : pipeline.flowOut(item));
                    });
                    result instanceof Error ? (item.error = result, item.states[pipeId] = ItemState$1.ERROR, 
                    pipeline.flowOut(item)) : void 0 !== result && (null !== result && (item.content = result), 
                    item.states[pipeId] = ItemState$1.COMPLETE, next ? flow(next, item) : pipeline.flowOut(item));
                }
            }
            var Pipeline = exports("Pipeline", function() {
                function Pipeline(pipes) {
                    _classCallCheck(this, Pipeline), this._pipes = void 0, this._cache = createMap(!0), 
                    this._pipes = pipes;
                    for (var i = 0; i < pipes.length; ++i) {
                        var pipe = pipes[i];
                        pipe.handle && pipe.id && (pipe.pipeline = this, pipe.next = i < pipes.length - 1 ? pipes[i + 1] : null);
                    }
                }
                return _createClass(Pipeline, [ {
                    key: "insertPipe",
                    value: function insertPipe(pipe, index) {
                        if (!pipe.handle || !pipe.id || index > this._pipes.length) cc.warnID(4921); else if (0 < this._pipes.indexOf(pipe)) cc.warnID(4922); else {
                            var nextPipe = null;
                            index < (pipe.pipeline = this)._pipes.length && (nextPipe = this._pipes[index]);
                            var previousPipe = null;
                            0 < index && (previousPipe = this._pipes[index - 1]), previousPipe && (previousPipe.next = pipe), 
                            pipe.next = nextPipe, this._pipes.splice(index, 0, pipe);
                        }
                    }
                }, {
                    key: "insertPipeAfter",
                    value: function insertPipeAfter(refPipe, newPipe) {
                        var index = this._pipes.indexOf(refPipe);
                        index < 0 || this.insertPipe(newPipe, index + 1);
                    }
                }, {
                    key: "appendPipe",
                    value: function appendPipe(pipe) {
                        pipe.handle && pipe.id && (pipe.pipeline = this, pipe.next = null, 0 < this._pipes.length && (this._pipes[this._pipes.length - 1].next = pipe), 
                        this._pipes.push(pipe));
                    }
                }, {
                    key: "flowIn",
                    value: function flowIn(items) {
                        var i, item, pipe = this._pipes[0];
                        if (pipe) {
                            for (i = 0; i < items.length; i++) (item = items[i]).isScene || (this._cache[item.id] = item);
                            for (i = 0; i < items.length; i++) flow(pipe, item = items[i]);
                        } else for (i = 0; i < items.length; i++) this.flowOut(items[i]);
                    }
                }, {
                    key: "flowInDeps",
                    value: function flowInDeps(owner, urlList, callback) {
                        return LoadingItems.create(this, function(errors, items) {
                            callback(errors, items), items.destroy();
                        }).append(urlList, owner);
                    }
                }, {
                    key: "flowOut",
                    value: function flowOut(item) {
                        item.error ? delete this._cache[item.id] : this._cache[item.id] || item.isScene || (this._cache[item.id] = item), 
                        item.complete = !0, LoadingItems.itemComplete(item);
                    }
                }, {
                    key: "copyItemStates",
                    value: function copyItemStates(srcItem, dstItems) {
                        if (dstItems instanceof Array) for (var i = 0; i < dstItems.length; ++i) dstItems[i].states = srcItem.states; else dstItems.states = srcItem.states;
                    }
                }, {
                    key: "getItem",
                    value: function getItem(id) {
                        var item = this._cache[id];
                        return item && item.alias && (item = item.alias), item;
                    }
                }, {
                    key: "removeItem",
                    value: function removeItem(id) {
                        var removed = this._cache[id];
                        removed && removed.complete && delete this._cache[id];
                        return removed;
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        for (var id in this._cache) {
                            var _item = this._cache[id];
                            delete this._cache[id], _item.complete || (_item.error = new Error("Canceled manually"), 
                            this.flowOut(_item));
                        }
                    }
                } ]), Pipeline;
            }());
            Pipeline.ItemState = ItemState$1, cc.Pipeline = Pipeline;
            var ID = "MD5Pipe", ExtnameRegex = /(\.[^.\n\\/]*)$/, UuidRegex = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/;
            var MD5Pipe = function() {
                function MD5Pipe(md5AssetsMap, md5NativeAssetsMap, libraryBase) {
                    _classCallCheck(this, MD5Pipe), this.id = ID, this.async = !1, this.pipeline = null, 
                    this.md5AssetsMap = void 0, this.md5NativeAssetsMap = void 0, this.libraryBase = void 0, 
                    this.id = ID, this.async = !1, this.pipeline = null, this.md5AssetsMap = md5AssetsMap, 
                    this.md5NativeAssetsMap = md5NativeAssetsMap, this.libraryBase = libraryBase;
                }
                return _createClass(MD5Pipe, [ {
                    key: "handle",
                    value: function handle(item) {
                        var hashPatchInFolder = !1;
                        return "ttf" === item.type && (hashPatchInFolder = !0), item.url = this.transformURL(item.url, hashPatchInFolder), 
                        item;
                    }
                }, {
                    key: "transformURL",
                    value: function transformURL(url, hashPatchInFolder) {
                        var uuid = function getUuidFromURL(url) {
                            var matches = url.match(UuidRegex);
                            return matches ? matches[1] : "";
                        }(url);
                        if (uuid) {
                            var hashValue = (!url.match(this.libraryBase) ? this.md5NativeAssetsMap : this.md5AssetsMap)[uuid];
                            if (hashValue) if (hashPatchInFolder) {
                                var dirname = cc.path.dirname(url), basename = cc.path.basename(url);
                                url = "".concat(dirname, ".").concat(hashValue, "/").concat(basename);
                            } else {
                                var matched = !1;
                                url = url.replace(ExtnameRegex, function(match, p1) {
                                    return matched = !0, "." + hashValue + p1;
                                }), matched || (url = url + "." + hashValue);
                            }
                        }
                        return url;
                    }
                } ]), MD5Pipe;
            }();
            MD5Pipe.ID = ID, Pipeline.MD5Pipe = MD5Pipe;
            var PackState, JsonUnpacker = function() {
                function JsonUnpacker() {
                    _classCallCheck(this, JsonUnpacker), this.jsons = {};
                }
                return _createClass(JsonUnpacker, [ {
                    key: "load",
                    value: function load(indices, packedJson) {
                        packedJson.length !== indices.length && cc.errorID(4915);
                        for (var i = 0; i < indices.length; i++) {
                            var key = indices[i], json = packedJson[i];
                            this.jsons[key] = json;
                        }
                    }
                }, {
                    key: "retrieve",
                    value: function retrieve(key) {
                        return this.jsons[key] || null;
                    }
                } ]), JsonUnpacker;
            }(), TextureUnpacker = function() {
                function TextureUnpacker() {
                    _classCallCheck(this, TextureUnpacker), this.contents = {};
                }
                return _createClass(TextureUnpacker, [ {
                    key: "load",
                    value: function load(indices, packedJson) {
                        var datas = packedJson.data;
                        datas.length !== indices.length && cc.errorID(4915);
                        for (var i = 0; i < indices.length; i++) this.contents[indices[i]] = {
                            base: datas[i][0],
                            mipmaps: datas[i][1]
                        };
                    }
                }, {
                    key: "retrieve",
                    value: function retrieve(key) {
                        var content = this.contents[key];
                        return content ? {
                            __type__: cc.js._getClassId(cc.Texture2D),
                            content: content
                        } : null;
                    }
                } ]), TextureUnpacker;
            }(), _noCacheRex = /\?/;
            function urlAppendTimestamp(url) {
                return cc.game.config.noCache && "string" == typeof url && (_noCacheRex.test(url) ? url += "&_t=" + (new Date() - 0) : url += "?_t=" + (new Date() - 0)), 
                url;
            }
            !function(PackState) {
                PackState[PackState.Invalid = 0] = "Invalid", PackState[PackState.Removed = 1] = "Removed", 
                PackState[PackState.Downloading = 2] = "Downloading", PackState[PackState.Loaded = 3] = "Loaded";
            }(PackState = PackState || {});
            var UnpackerData = function UnpackerData() {
                _classCallCheck(this, UnpackerData), this.unpacker = void 0, this.state = void 0, 
                this.unpacker = null, this.state = PackState.Invalid;
            }, uuidToPack = {}, packIndices = {}, globalUnpackers = {};
            function error$1(uuid, packUuid) {
                return new Error("Can not retrieve " + uuid + " from packer " + packUuid);
            }
            function initPacks(packs) {
                for (var packUuid in packIndices = packs) for (var uuids = packs[packUuid], i = 0; i < uuids.length; i++) {
                    var uuid = uuids[i], pushFront = 1 === uuids.length;
                    pushToMap(uuidToPack, uuid, packUuid, pushFront);
                }
            }
            function _loadNewPack(uuid, packUuid, callback) {
                var packUrl = cc.AssetLibrary.getLibUrlNoExt(packUuid) + ".json";
                cc.loader.load({
                    url: packUrl,
                    ignoreMaxConcurrency: !0
                }, function(err, packJson) {
                    if (err) return errorID(4916, uuid), callback(err);
                    var res = _doLoadNewPack(uuid, packUuid, packJson);
                    res ? callback(null, res) : callback(error$1(uuid, packUuid));
                });
            }
            function _doPreload(packUuid, packJson) {
                var unpackerData = globalUnpackers[packUuid];
                unpackerData || ((unpackerData = globalUnpackers[packUuid] = new UnpackerData()).state = PackState.Downloading), 
                unpackerData.state !== PackState.Loaded && (unpackerData.unpacker = new JsonUnpacker(), 
                unpackerData.unpacker.load(packIndices[packUuid], packJson), unpackerData.state = PackState.Loaded);
            }
            function _doLoadNewPack(uuid, packUuid, packedJson) {
                var unpackerData = globalUnpackers[packUuid];
                unpackerData.state !== PackState.Loaded && ("string" == typeof packedJson && (packedJson = JSON.parse(packedJson)), 
                Array.isArray(packedJson) ? unpackerData.unpacker = new JsonUnpacker() : packedJson.type === _getClassId(Texture2D) && (unpackerData.unpacker = new TextureUnpacker()), 
                unpackerData.unpacker.load(packIndices[packUuid], packedJson), unpackerData.state = PackState.Loaded);
                return unpackerData.unpacker.retrieve(uuid);
            }
            function _selectLoadedPack(packUuids) {
                for (var existsPackState = PackState.Invalid, existsPackUuid = "", i = 0; i < packUuids.length; i++) {
                    var packUuid = packUuids[i], unpackerData = globalUnpackers[packUuid];
                    if (unpackerData) {
                        var state = unpackerData.state;
                        if (state === PackState.Loaded) return packUuid;
                        existsPackState < state && (existsPackState = state, existsPackUuid = packUuid);
                    }
                }
                return existsPackState !== PackState.Invalid ? existsPackUuid : packUuids[0];
            }
            function load(item, callback) {
                var uuid = item.uuid, packUuid = uuidToPack[uuid];
                if (packUuid) {
                    Array.isArray(packUuid) && (packUuid = _selectLoadedPack(packUuid));
                    var unpackerData = globalUnpackers[packUuid];
                    if (unpackerData && unpackerData.state === PackState.Loaded) {
                        var json = unpackerData.unpacker.retrieve(uuid);
                        return json || error$1(uuid, packUuid);
                    }
                    return unpackerData || (console.log("Create unpacker %s for %s", packUuid, uuid), 
                    (unpackerData = globalUnpackers[packUuid] = new UnpackerData()).state = PackState.Downloading), 
                    _loadNewPack(uuid, packUuid, callback), null;
                }
            }
            var PackDownloader = Object.freeze({
                initPacks: initPacks,
                _loadNewPack: _loadNewPack,
                _doPreload: _doPreload,
                _doLoadNewPack: _doLoadNewPack,
                _selectLoadedPack: _selectLoadedPack,
                load: load
            }), UuidRegex$1 = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/;
            var _uuidToSubPack = Object.create(null), SubPackPipe = function() {
                function SubPackPipe(subpackage) {
                    _classCallCheck(this, SubPackPipe), this.id = "SubPackPipe", this.async = !1, this.pipeline = null;
                    function _loop(packName) {
                        var pack = subpackage[packName];
                        pack.uuids && pack.uuids.forEach(function(val) {
                            var uuid = decodeUuid(val);
                            uuid = uuid.split("@").map(function(name) {
                                return encodeURIComponent(name);
                            }).join("@"), _uuidToSubPack[uuid] = pack.path;
                        });
                    }
                    for (var packName in subpackage) _loop(packName);
                }
                return _createClass(SubPackPipe, [ {
                    key: "handle",
                    value: function handle(item) {
                        return item.url = this.transformURL(item.url), null;
                    }
                }, {
                    key: "transformURL",
                    value: function transformURL(url) {
                        var uuid = function getUuidFromURL$1(url) {
                            var matches = url.match(UuidRegex$1);
                            return matches ? matches[1] : "";
                        }(url);
                        if (uuid) {
                            var subpackage = _uuidToSubPack[uuid];
                            if (subpackage) return url.replace("res/raw-assets/", subpackage + "raw-assets/");
                        }
                        return url;
                    }
                } ]), SubPackPipe;
            }();
            SubPackPipe.ID = "SubPackPipe", Pipeline.SubPackPipe = SubPackPipe;
            var _libraryBase = "", _rawAssetsBase = "", _uuidToRawAsset = createMap(!0);
            function RawAssetEntry(url, type) {
                this.url = url, this.type = type;
            }
            var _class$p, AssetLibrary = {
                _uuidToAsset: {},
                loadAsset: function loadAsset(uuid, callback, options) {
                    if ("string" != typeof uuid) return callInNextTick(callback, new Error("[AssetLibrary] uuid must be string"), null);
                    var item = {
                        uuid: uuid,
                        type: "uuid"
                    };
                    options && options.existingAsset && (item.existingAsset = options.existingAsset), 
                    cc.loader.load(item, function(error$1, asset) {
                        if (error$1 || !asset) error$1 = new Error("[AssetLibrary] loading JSON or dependencies failed: " + (error$1 ? error$1.message : "Unknown error")); else if (asset.constructor === cc.SceneAsset) {
                            var key = cc.loader._getReferenceKey(uuid);
                            asset.scene.dependAssets = getDependsRecursively(key);
                        }
                        callback && callback(error$1, asset);
                    });
                },
                getLibUrlNoExt: function getLibUrlNoExt(uuid, inRawAssetsDir) {
                    return uuid = (uuid = decodeUuid(uuid)).split("@").map(function(name) {
                        return encodeURIComponent(name);
                    }).join("@"), (inRawAssetsDir ? _rawAssetsBase + "assets/" : _libraryBase) + uuid.slice(0, 2) + "/" + uuid;
                },
                _queryAssetInfoInEditor: function _queryAssetInfoInEditor(uuid, callback) {
                    callback(new Error("Unable to load resource: EditorExtends is not defined."));
                },
                _getAssetInfoInRuntime: function _getAssetInfoInRuntime(uuid, result) {
                    result = result || {
                        url: null,
                        raw: !1
                    };
                    var info = _uuidToRawAsset[uuid];
                    return info && !isChildClassOf(info.type, cc.Asset) ? (result.url = _rawAssetsBase + info.url, 
                    result.raw = !0) : (result.url = this.getLibUrlNoExt(uuid) + ".json", result.raw = !1), 
                    result;
                },
                _uuidInSettings: function _uuidInSettings(uuid) {
                    return uuid in _uuidToRawAsset;
                },
                queryAssetInfo: function queryAssetInfo(uuid, callback) {
                    var info = this._getAssetInfoInRuntime(uuid);
                    callback(null, info.url, info.raw);
                },
                parseUuidInEditor: function parseUuidInEditor() {},
                loadJson: function loadJson(json, callback) {
                    var randomUuid = "" + (new Date().getTime() + Math.random()), item = {
                        uuid: randomUuid,
                        type: "uuid",
                        content: json,
                        skips: [ cc.loader.assetLoader.id, cc.loader.downloader.id ]
                    };
                    cc.loader.load(item, function(error, asset) {
                        if (error) error = new Error("[AssetLibrary] loading JSON or dependencies failed: " + error.message); else {
                            if (asset.constructor === cc.SceneAsset) {
                                var key = cc.loader._getReferenceKey(randomUuid);
                                asset.scene.dependAssets = getDependsRecursively(key);
                            }
                            if (function isScene(asset) {
                                return asset && (asset.constructor === cc.SceneAsset || asset instanceof cc.Scene);
                            }(asset)) {
                                var id = cc.loader._getReferenceKey(randomUuid);
                                cc.loader.removeItem(id);
                            }
                        }
                        asset._uuid = "", callback && callback(error, asset);
                    });
                },
                getAssetByUuid: function getAssetByUuid(uuid) {
                    return AssetLibrary._uuidToAsset[uuid] || null;
                },
                init: function init(options) {
                    var libraryPath = options.libraryPath;
                    libraryPath = libraryPath.replace(/\\/g, "/"), _libraryBase = cc.path.stripSep(libraryPath) + "/", 
                    _rawAssetsBase = options.rawAssetsBase;
                    var md5AssetsMap = options.md5AssetsMap;
                    if (md5AssetsMap && md5AssetsMap.import) {
                        var i = 0, md5ImportMap = createMap(!0), md5Entries = md5AssetsMap.import;
                        for (i = 0; i < md5Entries.length; i += 2) {
                            md5ImportMap[decodeUuid(md5Entries[i]).split("@").map(function(name) {
                                return encodeURIComponent(name);
                            }).join("@")] = md5Entries[i + 1];
                        }
                        var md5RawAssetsMap = createMap(!0);
                        for (md5Entries = md5AssetsMap["raw-assets"], i = 0; i < md5Entries.length; i += 2) {
                            md5RawAssetsMap[decodeUuid(md5Entries[i]).split("@").map(function(name) {
                                return encodeURIComponent(name);
                            }).join("@")] = md5Entries[i + 1];
                        }
                        var md5Pipe = new MD5Pipe(md5ImportMap, md5RawAssetsMap, _libraryBase);
                        cc.loader.insertPipeAfter(cc.loader.assetLoader, md5Pipe), cc.loader.md5Pipe = md5Pipe;
                    }
                    if (options.subpackages) {
                        var subPackPipe = new SubPackPipe(options.subpackages);
                        cc.loader.insertPipeAfter(cc.loader.assetLoader, subPackPipe), cc.loader.subPackPipe = subPackPipe;
                    }
                    var assetTables = cc.loader._assetTables;
                    for (var mount in assetTables) assetTables[mount].reset();
                    var rawAssets = options.rawAssets;
                    if (rawAssets) for (var mountPoint in rawAssets) {
                        var assets = rawAssets[mountPoint];
                        for (var _uuid in assets) {
                            var info = assets[_uuid], url = info[0], typeId = info[1], type = _getClassById(typeId);
                            if (type) {
                                _uuidToRawAsset[_uuid] = new RawAssetEntry(mountPoint + "/" + url, type);
                                var isSubAsset = 1 === info[2];
                                assetTables[mountPoint] || (assetTables[mountPoint] = new AssetTable()), assetTables[mountPoint].add(url, _uuid, type, !isSubAsset);
                            } else cc.error("Cannot get", typeId);
                        }
                    }
                    options.packedAssets && initPacks(options.packedAssets), cc.url._init(options.mountPaths && options.mountPaths.assets || _rawAssetsBase + "assets");
                }
            };
            cc.AssetLibrary = AssetLibrary, exports("AssetLibrary", AssetLibrary);
            var _dec$q, _dec2$8, _class$q, _class2$l, _descriptor$j, Font = exports("Font", ccclass("cc.Font")(_class$p = function() {
                function Font() {
                    return _classCallCheck(this, Font), _possibleConstructorReturn(this, _getPrototypeOf(Font).apply(this, arguments));
                }
                return _inherits(Font, Asset), Font;
            }()) || _class$p);
            cc.Font = Font;
            var _dec$r, _dec2$9, _class$r, _class2$m, _descriptor$k, _descriptor2$c, _descriptor3$8, _descriptor4$6, TTFFont = exports("TTFFont", (_dec$q = ccclass("cc.TTFFont"), 
            _dec2$8 = property({
                type: cc.String,
                override: !0
            }), _dec$q((_descriptor$j = _applyDecoratedDescriptor((_class2$l = function() {
                function TTFFont() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, TTFFont);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TTFFont)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_fontFamily", _descriptor$j, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(TTFFont, Font), _createClass(TTFFont, [ {
                    key: "_nativeAsset",
                    get: function get() {
                        return this._fontFamily;
                    },
                    set: function set(value) {
                        this._fontFamily = value || "Arial";
                    }
                } ]), TTFFont;
            }()).prototype, "_fontFamily", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _applyDecoratedDescriptor(_class2$l.prototype, "_nativeAsset", [ _dec2$8 ], Object.getOwnPropertyDescriptor(_class2$l.prototype, "_nativeAsset"), _class2$l.prototype), 
            _class$q = _class2$l)) || _class$q));
            cc.TTFFont = TTFFont;
            var _class$s, BitmapFont = exports("BitmapFont", (_dec$r = ccclass("cc.BitmapFont"), 
            _dec2$9 = property({
                type: SpriteFrame
            }), _dec$r((_descriptor$k = _applyDecoratedDescriptor((_class2$m = function() {
                function BitmapFont() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, BitmapFont);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(BitmapFont)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "fntDataStr", _descriptor$k, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "spriteFrame", _descriptor2$c, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "fontSize", _descriptor3$8, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "fntConfig", _descriptor4$6, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(BitmapFont, Font), BitmapFont;
            }()).prototype, "fntDataStr", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return "";
                }
            }), _descriptor2$c = _applyDecoratedDescriptor(_class2$m.prototype, "spriteFrame", [ _dec2$9 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor3$8 = _applyDecoratedDescriptor(_class2$m.prototype, "fontSize", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return -1;
                }
            }), _descriptor4$6 = _applyDecoratedDescriptor(_class2$m.prototype, "fntConfig", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _class$r = _class2$m)) || _class$r));
            cc.BitmapFont = BitmapFont;
            var LabelAtlas = exports("LabelAtlas", ccclass("cc.LabelAtlas")(_class$s = function() {
                function LabelAtlas() {
                    return _classCallCheck(this, LabelAtlas), _possibleConstructorReturn(this, _getPrototypeOf(LabelAtlas).apply(this, arguments));
                }
                return _inherits(LabelAtlas, BitmapFont), LabelAtlas;
            }()) || _class$s);
            cc.LabelAtlas = LabelAtlas;
            var reusedArray = [], AssetLoader = function() {
                function AssetLoader() {
                    _classCallCheck(this, AssetLoader), this.id = "AssetLoader", this.async = !0, this.pipeline = null;
                }
                return _createClass(AssetLoader, [ {
                    key: "handle",
                    value: function handle(item, callback) {
                        var uuid = item.uuid;
                        if (!uuid) return item.content || null;
                        cc.AssetLibrary.queryAssetInfo(uuid, function(error, url, isRawAsset) {
                            if (error) callback(error); else if (item.url = item.rawUrl = url, item.isRawAsset = isRawAsset) {
                                var ext = extname(url).toLowerCase();
                                if (!ext) return void callback(new Error(getError(4931, uuid, url)));
                                ext = ext.substr(1);
                                var queue = LoadingItems.getQueue(item);
                                reusedArray[0] = {
                                    queueId: item.queueId,
                                    id: url,
                                    url: url,
                                    type: ext,
                                    error: null,
                                    alias: item,
                                    complete: !0
                                }, queue.append(reusedArray), item.type = ext, callback(null, item.content);
                            } else item.type = "uuid", callback(null, item.content);
                        });
                    }
                } ]), AssetLoader;
            }();
            function downloadBinary(item, callback) {
                var url = item.url, xhr = cc.loader.getXMLHttpRequest(), errInfo = "Load binary data failed: " + url;
                xhr.open("GET", url, !0), xhr.responseType = "arraybuffer", xhr.onload = function() {
                    var arrayBuffer = xhr.response;
                    arrayBuffer ? callback(null, arrayBuffer) : callback({
                        status: xhr.status,
                        errorMessage: errInfo + "(no response)"
                    });
                }, xhr.onerror = function() {
                    callback({
                        status: xhr.status,
                        errorMessage: errInfo + "(error)"
                    });
                }, xhr.ontimeout = function() {
                    callback({
                        status: xhr.status,
                        errorMessage: errInfo + "(time out)"
                    });
                }, xhr.send(null);
            }
            function downloadText(item, callback) {
                var url = item.url;
                url = urlAppendTimestamp(url);
                var xhr = cc.loader.getXMLHttpRequest(), errInfo = "Load text file failed: " + url;
                xhr.open("GET", url, !0), xhr.overrideMimeType && xhr.overrideMimeType("text/plain; charset=utf-8"), 
                xhr.onload = function() {
                    4 === xhr.readyState ? 200 === xhr.status || 0 === xhr.status ? callback(null, xhr.responseText) : callback({
                        status: xhr.status,
                        errorMessage: errInfo + "(wrong status)"
                    }) : callback({
                        status: xhr.status,
                        errorMessage: errInfo + "(wrong readyState)"
                    });
                }, xhr.onerror = function() {
                    callback({
                        status: xhr.status,
                        errorMessage: errInfo + "(error)"
                    });
                }, xhr.ontimeout = function() {
                    callback({
                        status: xhr.status,
                        errorMessage: errInfo + "(time out)"
                    });
                }, xhr.send(null);
            }
            function skip() {
                return null;
            }
            function downloadScript(item, callback, isAsync) {
                var url = item.url, d = document, s = document.createElement("script");
                function loadHandler() {
                    s.parentNode && s.parentNode.removeChild(s), s.removeEventListener("load", loadHandler, !1), 
                    s.removeEventListener("error", errorHandler, !1), callback(null, url);
                }
                function errorHandler() {
                    s.parentNode && s.parentNode.removeChild(s), s.removeEventListener("load", loadHandler, !1), 
                    s.removeEventListener("error", errorHandler, !1), callback(new Error(getError(4928, url)));
                }
                s.async = !!isAsync, s.src = urlAppendTimestamp(url), s.addEventListener("load", loadHandler, !1), 
                s.addEventListener("error", errorHandler, !1), d.body.appendChild(s);
            }
            function downloadImage(item, callback, isCrossOrigin, img) {
                void 0 === isCrossOrigin && (isCrossOrigin = !0);
                var url = urlAppendTimestamp(item.url);
                function loadCallback() {
                    img.removeEventListener("load", loadCallback), img.removeEventListener("error", errorCallback), 
                    img.id = item.id, callback(null, img);
                }
                function errorCallback() {
                    img.removeEventListener("load", loadCallback), img.removeEventListener("error", errorCallback), 
                    "https:" !== window.location.protocol && img.crossOrigin && "anonymous" === img.crossOrigin.toLowerCase() ? downloadImage(item, callback, !1, img) : callback(new Error(getError(4930, url)));
                }
                if (img = img || new Image(), isCrossOrigin && "file:" !== window.location.protocol ? img.crossOrigin = "anonymous" : img.crossOrigin = null, 
                img.complete && 0 < img.naturalWidth && img.src === url) return img;
                img.addEventListener("load", loadCallback), img.addEventListener("error", errorCallback), 
                img.src = url;
            }
            AssetLoader.ID = "AssetLoader", Pipeline.AssetLoader = AssetLoader;
            var defaultMap = {
                js: downloadScript,
                png: downloadImage,
                jpg: downloadImage,
                bmp: downloadImage,
                jpeg: downloadImage,
                gif: downloadImage,
                ico: downloadImage,
                tiff: downloadImage,
                webp: function downloadWebp(item, callback, isCrossOrigin, img) {
                    return cc.sys.capabilities.webp ? downloadImage(item, callback, isCrossOrigin, img) : new Error(getError(4929, item.url));
                },
                image: downloadImage,
                pvr: downloadBinary,
                pkm: downloadBinary,
                txt: downloadText,
                xml: downloadText,
                vsh: downloadText,
                fsh: downloadText,
                atlas: downloadText,
                tmx: downloadText,
                tsx: downloadText,
                json: downloadText,
                ExportJson: downloadText,
                plist: downloadText,
                fnt: downloadText,
                font: skip,
                eot: skip,
                ttf: skip,
                woff: skip,
                svg: skip,
                ttc: skip,
                uuid: function downloadUuid(item, callback) {
                    var result = load(item, callback);
                    return void 0 === result ? this.extMap.json(item, callback) : result || void 0;
                },
                binary: downloadBinary,
                bin: downloadBinary,
                default: downloadText
            }, Downloader = exports("Downloader", function() {
                function Downloader(extMap) {
                    _classCallCheck(this, Downloader), this.id = "Downloader", this.async = !0, this.pipeline = null, 
                    this.extMap = void 0, this._curConcurrent = 0, this._loadQueue = [], this._subpackages = {}, 
                    this.extMap = mixin(extMap, defaultMap);
                }
                return _createClass(Downloader, [ {
                    key: "addHandlers",
                    value: function addHandlers(extMap) {
                        mixin(this.extMap, extMap);
                    }
                }, {
                    key: "_handleLoadQueue",
                    value: function _handleLoadQueue() {
                        for (;this._curConcurrent < cc.macro.DOWNLOAD_MAX_CONCURRENT; ) {
                            var nextOne = this._loadQueue.shift();
                            if (!nextOne) break;
                            var syncRet = this.handle(nextOne.item, nextOne.callback);
                            void 0 !== syncRet && (syncRet instanceof Error ? nextOne.callback(syncRet) : nextOne.callback(null, syncRet));
                        }
                    }
                }, {
                    key: "handle",
                    value: function handle(item, callback) {
                        var self = this, downloadFunc = this.extMap[item.type] || this.extMap.default, syncRet = void 0;
                        if (this._curConcurrent < cc.macro.DOWNLOAD_MAX_CONCURRENT) {
                            if (this._curConcurrent++, void 0 !== (syncRet = downloadFunc.call(this, item, function(err, result) {
                                self._curConcurrent = Math.max(0, self._curConcurrent - 1), self._handleLoadQueue(), 
                                callback && callback(err, result);
                            }))) return this._curConcurrent = Math.max(0, this._curConcurrent - 1), this._handleLoadQueue(), 
                            syncRet;
                        } else if (item.ignoreMaxConcurrency) {
                            if (void 0 !== (syncRet = downloadFunc.call(this, item, callback))) return syncRet;
                        } else this._loadQueue.push({
                            item: item,
                            callback: callback
                        });
                    }
                }, {
                    key: "loadSubpackage",
                    value: function loadSubpackage(name, completeCallback) {
                        var pac = this._subpackages[name];
                        pac ? pac.loaded ? completeCallback && completeCallback() : downloadScript({
                            url: pac.path
                        }, function(err) {
                            err || (pac.loaded = !0), completeCallback && completeCallback(err);
                        }) : completeCallback && completeCallback(new Error("Can't find subpackage ".concat(name)));
                    }
                } ]), Downloader;
            }());
            Downloader.ID = "Downloader", Downloader.PackDownloader = PackDownloader, Pipeline.Downloader = Downloader;
            var SAXParser = function() {
                function SAXParser() {
                    _classCallCheck(this, SAXParser), this._isSupportDOMParser = void 0, this._parser = void 0, 
                    window.DOMParser ? (this._isSupportDOMParser = !0, this._parser = new DOMParser()) : (this._isSupportDOMParser = !1, 
                    this._parser = null);
                }
                return _createClass(SAXParser, [ {
                    key: "parse",
                    value: function parse(xmlTxt) {
                        return this._parseXML(xmlTxt);
                    }
                }, {
                    key: "_parseXML",
                    value: function _parseXML(textxml) {
                        var xmlDoc;
                        return this._isSupportDOMParser ? xmlDoc = this._parser.parseFromString(textxml, "text/xml") : ((xmlDoc = new ActiveXObject("Microsoft.XMLDOM")).async = "false", 
                        xmlDoc.loadXML(textxml)), xmlDoc;
                    }
                } ]), SAXParser;
            }(), plistParser = new (function() {
                function PlistParser() {
                    return _classCallCheck(this, PlistParser), _possibleConstructorReturn(this, _getPrototypeOf(PlistParser).apply(this, arguments));
                }
                return _inherits(PlistParser, SAXParser), _createClass(PlistParser, [ {
                    key: "parse",
                    value: function parse(xmlTxt) {
                        var xmlDoc = this._parseXML(xmlTxt), plist = xmlDoc.documentElement;
                        if ("plist" !== plist.tagName) return cc.warnID(5100), {};
                        for (var node = null, i = 0, len = plist.childNodes.length; i < len && 1 !== (node = plist.childNodes[i]).nodeType; i++) ;
                        return xmlDoc = null, this._parseNode(node);
                    }
                }, {
                    key: "_parseNode",
                    value: function _parseNode(node) {
                        var data = null, tagName = node.tagName;
                        if ("dict" === tagName) data = this._parseDict(node); else if ("array" === tagName) data = this._parseArray(node); else if ("string" === tagName) if (1 === node.childNodes.length) data = node.firstChild.nodeValue; else {
                            data = "";
                            for (var i = 0; i < node.childNodes.length; i++) data += node.childNodes[i].nodeValue;
                        } else "false" === tagName ? data = !1 : "true" === tagName ? data = !0 : "real" === tagName ? data = parseFloat(node.firstChild.nodeValue) : "integer" === tagName && (data = parseInt(node.firstChild.nodeValue, 10));
                        return data;
                    }
                }, {
                    key: "_parseArray",
                    value: function _parseArray(node) {
                        for (var data = [], i = 0, len = node.childNodes.length; i < len; i++) {
                            var child = node.childNodes[i];
                            1 === child.nodeType && data.push(this._parseNode(child));
                        }
                        return data;
                    }
                }, {
                    key: "_parseDict",
                    value: function _parseDict(node) {
                        for (var data = {}, key = null, i = 0, len = node.childNodes.length; i < len; i++) {
                            var child = node.childNodes[i];
                            1 === child.nodeType && ("key" === child.tagName ? key = child.firstChild.nodeValue : data[key] = this._parseNode(child));
                        }
                        return data;
                    }
                } ]), PlistParser;
            }())();
            function isSceneObj(json) {
                return json && (json[0] && "cc.Scene" === json[0].__type__ || json[1] && "cc.Scene" === json[1].__type__ || json[0] && "cc.Prefab" === json[0].__type__);
            }
            function loadUuid(item, callback) {
                var json, classFinder;
                if ("string" == typeof item.content) try {
                    json = JSON.parse(item.content);
                } catch (e) {
                    return new Error(getError(4923, item.id, e.stack));
                } else {
                    if ("object" !== _typeof(item.content)) return new Error(getError(4924));
                    json = item.content;
                }
                if (null == json) return new Error(getError(4923, item.id));
                var isScene = isSceneObj(json);
                classFinder = isScene ? cc._MissingScript.safeFindClass : function classFinder(id) {
                    var cls = _getClassById(id);
                    return cls || (cc.warnID(4903, id), Object);
                };
                var asset, tdInfo = cc.deserialize.Details.pool.get();
                try {
                    asset = cc.deserialize(json, tdInfo, {
                        classFinder: classFinder,
                        target: item.existingAsset,
                        customEnv: item
                    });
                } catch (e) {
                    return cc.deserialize.Details.pool.put(tdInfo), console.error(e), new Error("Failed to load asset ".concat(item.id, ", exception occurs during deserialization: ").concat(e.stack, "."));
                }
                asset._uuid = item.uuid;
                var deferredLoad = function canDeferredLoad(asset, item, isScene) {
                    var res = item.deferredLoadRaw;
                    return res ? asset instanceof cc.Asset && asset.constructor.preventDeferredLoadDependents && (res = !1) : isScene && (asset instanceof cc.SceneAsset || asset instanceof cc.Prefab) && (res = asset.asyncLoadAssets), 
                    res;
                }(asset, item, isScene), depends = function parseDepends$1(item, asset, tdInfo, deferredLoadRawAssetsInRuntime) {
                    var depends, i, dependUuid, uuidList = tdInfo.uuidList, objList = tdInfo.uuidObjList, propList = tdInfo.uuidPropList, stillUseUrl = tdInfo._stillUseUrl, dependKeys = item.dependKeys = [];
                    if (deferredLoadRawAssetsInRuntime) for (depends = [], i = 0; i < uuidList.length; i++) {
                        dependUuid = uuidList[i];
                        var obj = objList[i], prop = propList[i], info = cc.AssetLibrary._getAssetInfoInRuntime(dependUuid);
                        if (info.raw) {
                            var url = info.url;
                            obj[prop] = url, dependKeys.push(url);
                        } else depends.push({
                            type: "uuid",
                            uuid: dependUuid,
                            deferredLoadRaw: !0,
                            _owner: obj,
                            _ownerProp: prop,
                            _stillUseUrl: stillUseUrl[i]
                        });
                    } else {
                        for (depends = new Array(uuidList.length), i = 0; i < uuidList.length; i++) dependUuid = uuidList[i], 
                        depends[i] = {
                            type: "uuid",
                            uuid: dependUuid,
                            _owner: objList[i],
                            _ownerProp: propList[i],
                            _stillUseUrl: stillUseUrl[i]
                        };
                        asset._native && !asset.constructor.preventPreloadNativeObject && depends.push({
                            url: asset.nativeUrl,
                            _owner: asset,
                            _ownerProp: "_nativeAsset"
                        });
                    }
                    return depends;
                }(item, asset, tdInfo, deferredLoad);
                cc.deserialize.Details.pool.put(tdInfo);
                function wrappedCallback(err, asset) {
                    if (!err && asset.onLoaded) try {
                        asset.onLoaded();
                    } catch (error) {
                        err = error;
                    }
                    callback(err, asset);
                }
                if (0 === depends.length) return wrappedCallback(null, asset);
                !function loadDepends(pipeline, item, asset, depends, callback) {
                    item.content = asset;
                    var dependKeys = item.dependKeys;
                    pipeline.flowInDeps(item, depends, function(errors, items) {
                        var item, itemsMap = items.map;
                        for (var src in itemsMap) (item = itemsMap[src]).uuid && item.content && (item.content._uuid = item.uuid);
                        for (var i = 0; i < depends.length; i++) {
                            var loadCallback = function loadCallback(item) {
                                var value = item.content;
                                this._stillUseUrl && (value = value ? value.nativeUrl : item.rawUrl), this._owner[this._ownerProp] = value, 
                                item.uuid !== asset._uuid && dependKeys.indexOf(item.id) < 0 && dependKeys.push(item.id);
                            }, dep = depends[i], dependSrc = dep.uuid, dependUrl = dep.url;
                            dep._owner, dep._ownerProp;
                            if (item = itemsMap[dependUrl]) {
                                var loadCallbackCtx = dep;
                                if (item.complete || item.content) {
                                    if (item.error) cc._throw(item.error); else loadCallback.call(loadCallbackCtx, item);
                                } else {
                                    var queue = LoadingItems.getQueue(item), list = queue._callbackTable[dependSrc];
                                    list ? list.unshift(loadCallback, loadCallbackCtx) : queue.addListener(dependSrc, loadCallback, loadCallbackCtx);
                                }
                            }
                        }
                        callback(errors, asset);
                    });
                }(this.pipeline, item, asset, depends, wrappedCallback);
            }
            loadUuid.isSceneObj = isSceneObj;
            var _canvasContext = null, _testString = "BES bswy:->@", _fontFaces = {}, _intervalId = -1, _loadingFonts = [], _timeout = 6e4;
            function _checkFontLoaded() {
                for (var allFontsLoaded = !0, now = Date.now(), i = _loadingFonts.length - 1; 0 <= i; i--) {
                    var fontLoadHandle = _loadingFonts[i], fontFamily = fontLoadHandle.fontFamilyName;
                    if (now - fontLoadHandle.startTime > _timeout) cc.warnID(4933, fontFamily), fontLoadHandle.callback(null, fontFamily), 
                    _loadingFonts.splice(i, 1); else {
                        var oldWidth = fontLoadHandle.refWidth;
                        _canvasContext.font = "40px " + fontFamily, oldWidth !== safeMeasureText(_canvasContext, _testString) ? (_loadingFonts.splice(i, 1), 
                        fontLoadHandle.callback(null, fontFamily)) : allFontsLoaded = !1;
                    }
                }
                allFontsLoaded && (clearInterval(_intervalId), _intervalId = -1);
            }
            function loadFont(item, callback) {
                var url = item.url, fontFamilyName = function _getFontFamily(fontHandle) {
                    var ttfIndex = fontHandle.lastIndexOf(".ttf");
                    if (-1 === ttfIndex) return fontHandle;
                    var fontFamilyName, slashPos = fontHandle.lastIndexOf("/");
                    fontFamilyName = -1 === slashPos ? fontHandle.substring(0, ttfIndex) + "_LABEL" : fontHandle.substring(slashPos + 1, ttfIndex) + "_LABEL";
                    -1 !== fontFamilyName.indexOf(" ") && (fontFamilyName = '"' + fontFamilyName + '"');
                    return fontFamilyName;
                }(url);
                if (_fontFaces[fontFamilyName]) return fontFamilyName;
                if (!_canvasContext) {
                    var labelCanvas = document.createElement("canvas");
                    labelCanvas.width = 100, labelCanvas.height = 100, _canvasContext = labelCanvas.getContext("2d");
                }
                var fontDesc = "40px " + fontFamilyName;
                _canvasContext.font = fontDesc;
                var refWidth = safeMeasureText(_canvasContext, _testString), fontStyle = document.createElement("style");
                fontStyle.type = "text/css";
                var fontStr = "";
                isNaN(fontFamilyName - 0) ? fontStr += "@font-face { font-family:" + fontFamilyName + "; src:" : fontStr += "@font-face { font-family:'" + fontFamilyName + "'; src:", 
                fontStr += "url('" + url + "');", fontStyle.textContent = fontStr + "}", document.body.appendChild(fontStyle);
                var preloadDiv = document.createElement("div"), divStyle = preloadDiv.style;
                divStyle.fontFamily = fontFamilyName, preloadDiv.innerHTML = ".", divStyle.position = "absolute", 
                divStyle.left = "-100px", divStyle.top = "-100px", document.body.appendChild(preloadDiv);
                var fontLoadHandle = {
                    fontFamilyName: fontFamilyName,
                    refWidth: refWidth,
                    callback: callback,
                    startTime: Date.now()
                };
                _loadingFonts.push(fontLoadHandle), _fontFaces[fontFamilyName] = fontStyle, -1 === _intervalId && (_intervalId = setInterval(_checkFontLoaded, 100));
            }
            function loadJSON(item) {
                if ("string" != typeof item.content) return new Error("JSON Loader: Input item doesn't contain string content");
                try {
                    return JSON.parse(item.content);
                } catch (e) {
                    return new Error("JSON Loader: Parse json [" + item.id + "] failed : " + e);
                }
            }
            function loadImage(item) {
                if (item._owner instanceof cc.Asset) return null;
                var image = item.content;
                if (!(image instanceof Image)) return new Error("Image Loader: Input item doesn't contain Image content");
                var rawUrl = item.rawUrl, imageAsset = item.imageAsset || new ImageAsset();
                return imageAsset._uuid = item.uuid, imageAsset._url = rawUrl, imageAsset._setRawAsset(rawUrl, !1), 
                imageAsset._nativeAsset = image, imageAsset;
            }
            function loadAudioAsAsset(item, callback) {
                if (item._owner instanceof cc.Asset) return null;
                var audioClip = new cc.AudioClip();
                return audioClip._setRawAsset(item.rawUrl, !1), audioClip._nativeAsset = item.content, 
                audioClip;
            }
            function loadBinary(item) {
                return item.load ? item.load(item.content) : item.content;
            }
            function readBEUint16(header, offset) {
                return header[offset] << 8 | header[offset + 1];
            }
            var defaultMap$1 = {
                png: loadImage,
                jpg: loadImage,
                bmp: loadImage,
                jpeg: loadImage,
                gif: loadImage,
                ico: loadImage,
                tiff: loadImage,
                webp: loadImage,
                image: loadImage,
                pvr: function loadPVRTex(item) {
                    var buffer = item.content instanceof ArrayBuffer ? item.content : item.content.buffer, header = new Int32Array(buffer, 0, 13);
                    if (55727696 === header[0]) {
                        var width = header[7], height = header[6], dataOffset = header[12] + 52;
                        return buffer = buffer.slice(dataOffset, buffer.byteLength), {
                            _data: new Uint8Array(buffer),
                            _compressed: !0,
                            width: width,
                            height: height
                        };
                    }
                    if (559044176 !== header[11]) return new Error("Invalid magic number in PVR header");
                    var headerLength = header[0], _height = header[1], _width = header[2];
                    return buffer = buffer.slice(headerLength, buffer.byteLength), {
                        _data: new Uint8Array(buffer),
                        _compressed: !0,
                        width: _width,
                        height: _height
                    };
                },
                pkm: function loadPKMTex(item) {
                    var buffer = item.content instanceof ArrayBuffer ? item.content : item.content.buffer, header = new Uint8Array(buffer), format = readBEUint16(header, 6);
                    if (0 !== format && 1 !== format && 3 !== format) return new Error("Invalid magic number in ETC header");
                    var width = readBEUint16(header, 12), height = readBEUint16(header, 14);
                    return readBEUint16(header, 8), readBEUint16(header, 10), buffer = buffer.slice(16, buffer.byteLength), 
                    {
                        _data: new Uint8Array(buffer),
                        _compressed: !0,
                        width: width,
                        height: height
                    };
                },
                mp3: loadAudioAsAsset,
                ogg: loadAudioAsAsset,
                wav: loadAudioAsAsset,
                m4a: loadAudioAsAsset,
                json: loadJSON,
                ExportJson: loadJSON,
                plist: function loadPlist(item) {
                    if ("string" != typeof item.content) return new Error("Plist Loader: Input item doesn't contain string content");
                    var result = plistParser.parse(item.content);
                    return result || new Error("Plist Loader: Parse [" + item.id + "] failed");
                },
                uuid: loadUuid,
                prefab: loadUuid,
                fire: loadUuid,
                scene: loadUuid,
                binary: loadBinary,
                bin: loadBinary,
                font: loadFont,
                eot: loadFont,
                ttf: loadFont,
                woff: loadFont,
                svg: loadFont,
                ttc: loadFont,
                default: function loadNothing() {
                    return null;
                }
            }, Loader = exports("Loader", function() {
                function Loader(extMap) {
                    _classCallCheck(this, Loader), this.id = "Loader", this.async = !0, this.pipeline = null, 
                    this.extMap = void 0, this.extMap = mixin(extMap, defaultMap$1);
                }
                return _createClass(Loader, [ {
                    key: "addHandlers",
                    value: function addHandlers(extMap) {
                        this.extMap = mixin(this.extMap, extMap);
                    }
                }, {
                    key: "handle",
                    value: function handle(item, callback) {
                        return (this.extMap[item.type] || this.extMap.default).call(this, item, callback);
                    }
                } ]), Loader;
            }());
            Loader.ID = "Loader", Pipeline.Loader = Loader;
            var _tmpInfo = null;
            function doCheckCouldRelease(releasedKey, refOwnerItem, caches) {
                caches[releasedKey] || cc.log('"'.concat(releasedKey, '" was released but maybe still referenced by ').concat(function getItemDesc(item) {
                    return item.uuid ? (_tmpInfo = _tmpInfo || {
                        path: "",
                        type: null
                    }, cc.loader._assetTables.assets._getInfo_DEBUG(item.uuid, _tmpInfo) ? (_tmpInfo.path = "resources/" + _tmpInfo.path, 
                    '"'.concat(_tmpInfo.path, '" (type: ').concat(getClassName(_tmpInfo.type), ", uuid: ").concat(item.uuid, ")")) : '"'.concat(item.rawUrl, '" (').concat(item.uuid, ")")) : '"'.concat(item.rawUrl, '"');
                }(refOwnerItem)));
            }
            var ReleasedAssetChecker = function() {
                function ReleasedAssetChecker() {
                    _classCallCheck(this, ReleasedAssetChecker), this._releasedKeys = void 0, this._dirty = void 0, 
                    this._releasedKeys = createMap(!0), this._dirty = !1;
                }
                return _createClass(ReleasedAssetChecker, [ {
                    key: "setReleased",
                    value: function setReleased(item, releasedKey) {
                        this._releasedKeys[releasedKey] = !0, this._dirty = !0;
                    }
                }, {
                    key: "checkCouldRelease",
                    value: function checkCouldRelease(caches) {
                        if (this._dirty) {
                            this._dirty = !1;
                            var released = this._releasedKeys;
                            for (var id in caches) {
                                var item = caches[id];
                                item.alias && (item = item.alias);
                                var depends = item.dependKeys;
                                if (depends) for (var i = 0; i < depends.length; ++i) {
                                    var depend = depends[i];
                                    released[depend] && (doCheckCouldRelease(depend, item, caches), delete released[depend]);
                                }
                            }
                            clear(released);
                        }
                    }
                } ]), ReleasedAssetChecker;
            }(), assetTables = Object.create(null);
            function getXMLHttpRequest() {
                return window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject("MSXML2.XMLHTTP");
            }
            assetTables.assets = new AssetTable(), assetTables.internal = new AssetTable();
            var _info = {
                url: null,
                raw: !1
            };
            function getResWithUrl(res) {
                var id, result, isUuid;
                if ("object" === _typeof(res)) {
                    if ((result = res).url) return result;
                    id = res.uuid;
                } else result = {}, id = res;
                return isUuid = result.type ? "uuid" === result.type : cc.AssetLibrary._uuidInSettings(id), 
                cc.AssetLibrary._getAssetInfoInRuntime(id, _info), result.url = isUuid ? _info.url : id, 
                _info.url && "uuid" === result.type && _info.raw ? (result.type = null, result.isRawAsset = !0) : isUuid || (result.isRawAsset = !0), 
                result;
            }
            var _sharedResources = [], _sharedList = [], CCLoader = function() {
                function CCLoader() {
                    var _this;
                    _classCallCheck(this, CCLoader);
                    var assetLoader = new AssetLoader(), downloader = new Downloader(), loader = new Loader();
                    return (_this = _possibleConstructorReturn(this, _getPrototypeOf(CCLoader).call(this, [ assetLoader, downloader, loader ]))).getXMLHttpRequest = void 0, 
                    _this.assetLoader = void 0, _this.md5Pipe = void 0, _this.downloader = void 0, _this.loader = void 0, 
                    _this.onProgress = void 0, _this._assetTables = void 0, _this._autoReleaseSetting = void 0, 
                    _this._releasedAssetChecker_DEBUG = void 0, _this.getXMLHttpRequest = getXMLHttpRequest, 
                    _this.assetLoader = assetLoader, _this.md5Pipe = null, _this.downloader = downloader, 
                    _this.loader = loader, _this.onProgress = null, _this._assetTables = assetTables, 
                    _this._autoReleaseSetting = createMap(!0), _this._releasedAssetChecker_DEBUG = new ReleasedAssetChecker(), 
                    _this;
                }
                return _inherits(CCLoader, Pipeline), _createClass(CCLoader, [ {
                    key: "init",
                    value: function init(director) {
                        var self = this;
                        director.on(cc.Director.EVENT_AFTER_UPDATE, function() {
                            self._releasedAssetChecker_DEBUG.checkCouldRelease(self._cache);
                        });
                    }
                }, {
                    key: "addDownloadHandlers",
                    value: function addDownloadHandlers(extMap) {
                        this.downloader.addHandlers(extMap);
                    }
                }, {
                    key: "addLoadHandlers",
                    value: function addLoadHandlers(extMap) {
                        this.loader.addHandlers(extMap);
                    }
                }, {
                    key: "load",
                    value: function load(resources, progressCallback, completeCallback) {
                        void 0 === completeCallback && (completeCallback = progressCallback, progressCallback = this.onProgress || null);
                        var res, self = this, singleRes = !1;
                        resources instanceof Array || (resources = resources ? (singleRes = !0, [ resources ]) : []);
                        for (var i = _sharedResources.length = 0; i < resources.length; ++i) {
                            var resource = resources[i];
                            if (resource && resource.id && (cc.warnID(4920, resource.id), resource.uuid || resource.url || (resource.url = resource.id)), 
                            (res = getResWithUrl(resource)).url || res.uuid) {
                                var item = this._cache[res.url];
                                _sharedResources.push(item || res);
                            }
                        }
                        var queue = LoadingItems.create(this, progressCallback, function(errors, items) {
                            callInNextTick(function() {
                                if (completeCallback) {
                                    if (singleRes) {
                                        var id = res.url;
                                        completeCallback.call(self, items.getError(id), items.getContent(id));
                                    } else completeCallback.call(self, errors, items);
                                    completeCallback = null;
                                }
                                items.destroy();
                            });
                        });
                        LoadingItems.initQueueDeps(queue), queue.append(_sharedResources), _sharedResources.length = 0;
                    }
                }, {
                    key: "flowInDeps",
                    value: function flowInDeps(owner, urlList, callback) {
                        for (var i = _sharedList.length = 0; i < urlList.length; ++i) {
                            var res = getResWithUrl(urlList[i]);
                            if (res.url || res.uuid) {
                                var item = this._cache[res.url];
                                item ? _sharedList.push(item) : _sharedList.push(res);
                            }
                        }
                        var queue = LoadingItems.create(this, owner ? function(completedCount, totalCount, item) {
                            queue._ownerQueue && queue._ownerQueue.onProgress && queue._ownerQueue._childOnProgress(item);
                        } : null, function(errors, items) {
                            callback(errors, items), owner && owner.deps && (owner.deps.length = 0), items.destroy();
                        });
                        if (owner) {
                            var ownerQueue = LoadingItems.getQueue(owner);
                            queue._ownerQueue = ownerQueue._ownerQueue || ownerQueue;
                        }
                        var accepted = queue.append(_sharedList, owner);
                        return _sharedList.length = 0, accepted;
                    }
                }, {
                    key: "loadRes",
                    value: function loadRes(url, type, mount, progressCallback, completeCallback) {
                        5 !== arguments.length && (completeCallback = progressCallback, progressCallback = mount, 
                        mount = "assets");
                        var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
                        type = args.type, progressCallback = args.onProgress, completeCallback = args.onComplete;
                        var self = this, uuid = self._getResUuid(url, type, mount, !0);
                        uuid ? this.load({
                            type: "uuid",
                            uuid: uuid
                        }, progressCallback, function(err, asset) {
                            asset && self.setAutoReleaseRecursively(uuid, !1), completeCallback && completeCallback(err, asset);
                        }) : self._urlNotFound(url, type, completeCallback);
                    }
                }, {
                    key: "loadResDir",
                    value: function loadResDir(url, type, mount, progressCallback, completeCallback) {
                        if (5 !== arguments.length && (completeCallback = progressCallback, progressCallback = mount, 
                        mount = "assets"), assetTables[mount]) {
                            var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
                            type = args.type, progressCallback = args.onProgress, completeCallback = args.onComplete;
                            var urls = [], uuids = assetTables[mount].getUuidArray(url, type, urls);
                            this._loadResUuids(uuids, progressCallback, function(errors, assetRes, urlRes) {
                                for (var assetResLength = assetRes.length, i = 0; i < assetResLength; ++i) if (assetRes[i] instanceof cc.SpriteAtlas) {
                                    var spriteFrames = assetRes[i].getSpriteFrames();
                                    for (var k in spriteFrames) {
                                        var sf = spriteFrames[k];
                                        assetRes.push(sf), urlRes && urlRes.push("".concat(urlRes[i], "/").concat(sf.name));
                                    }
                                }
                                completeCallback && completeCallback(errors, assetRes, urlRes);
                            }, urls);
                        }
                    }
                }, {
                    key: "loadResArray",
                    value: function loadResArray(urls, type, mount, progressCallback, completeCallback) {
                        5 !== arguments.length && (completeCallback = progressCallback, progressCallback = mount, 
                        mount = "assets");
                        var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
                        type = args.type, progressCallback = args.onProgress, completeCallback = args.onComplete;
                        for (var uuids = [], i = 0; i < urls.length; i++) {
                            var _url = urls[i], uuid = this._getResUuid(_url, type, mount, !0);
                            if (!uuid) return void this._urlNotFound(_url, type, completeCallback);
                            uuids.push(uuid);
                        }
                        this._loadResUuids(uuids, progressCallback, completeCallback);
                    }
                }, {
                    key: "getRes",
                    value: function getRes(url, type) {
                        var item = this._cache[url];
                        if (!item) {
                            var uuid = this._getResUuid(url, type, null, !0);
                            if (!uuid) return null;
                            var ref = this._getReferenceKey(uuid);
                            item = this._cache[ref];
                        }
                        return item && item.alias && (item = item.alias), item && item.complete ? item.content : null;
                    }
                }, {
                    key: "getResCount",
                    value: function getResCount() {
                        return Object.keys(this._cache).length;
                    }
                }, {
                    key: "getDependsRecursively",
                    value: function getDependsRecursively$1(owner) {
                        if (owner) {
                            var key = this._getReferenceKey(owner), assets = getDependsRecursively(key);
                            return assets.push(key), assets;
                        }
                        return [];
                    }
                }, {
                    key: "release",
                    value: function release(asset) {
                        if (Array.isArray(asset)) for (var i = 0; i < asset.length; i++) {
                            var key = asset[i];
                            this.release(key);
                        } else if (asset) {
                            var id = this._getReferenceKey(asset), item = this.getItem(id);
                            if (item) {
                                var removed = this.removeItem(id);
                                if ((asset = item.content) instanceof cc.Asset) {
                                    var nativeUrl = asset.nativeUrl;
                                    nativeUrl && this.release(nativeUrl), asset.destroy();
                                }
                                removed && this._releasedAssetChecker_DEBUG.setReleased(item, id);
                            }
                        }
                    }
                }, {
                    key: "releaseAsset",
                    value: function releaseAsset(asset) {
                        var uuid = asset._uuid;
                        uuid && this.release(uuid);
                    }
                }, {
                    key: "releaseRes",
                    value: function releaseRes(url, type, mount) {
                        var uuid = this._getResUuid(url, type, mount, !0);
                        uuid ? this.release(uuid) : cc.errorID(4914, url);
                    }
                }, {
                    key: "releaseResDir",
                    value: function releaseResDir(url, type, mount) {
                        if (assetTables[mount = mount || "assets"]) for (var uuids = assetTables[mount].getUuidArray(url, type), i = 0; i < uuids.length; i++) {
                            var uuid = uuids[i];
                            this.release(uuid);
                        }
                    }
                }, {
                    key: "releaseAll",
                    value: function releaseAll() {
                        for (var id in this._cache) this.release(id);
                    }
                }, {
                    key: "removeItem",
                    value: function removeItem(key) {
                        var removed = Pipeline.prototype.removeItem.call(this, key);
                        return delete this._autoReleaseSetting[key], removed;
                    }
                }, {
                    key: "setAutoRelease",
                    value: function setAutoRelease(assetOrUrlOrUuid, autoRelease) {
                        var key = this._getReferenceKey(assetOrUrlOrUuid);
                        key && (this._autoReleaseSetting[key] = !!autoRelease);
                    }
                }, {
                    key: "setAutoReleaseRecursively",
                    value: function setAutoReleaseRecursively(assetOrUrlOrUuid, autoRelease) {
                        autoRelease = !!autoRelease;
                        var key = this._getReferenceKey(assetOrUrlOrUuid);
                        if (key) {
                            this._autoReleaseSetting[key] = autoRelease;
                            for (var depends = getDependsRecursively(key), i = 0; i < depends.length; i++) {
                                var depend = depends[i];
                                this._autoReleaseSetting[depend] = autoRelease;
                            }
                        } else 0;
                    }
                }, {
                    key: "isAutoRelease",
                    value: function isAutoRelease(assetOrUrl) {
                        var key = this._getReferenceKey(assetOrUrl);
                        return !!key && !!this._autoReleaseSetting[key];
                    }
                }, {
                    key: "_getResUuid",
                    value: function _getResUuid(url, type, mount, quiet) {
                        var uuid = "", assetTable = assetTables[mount = mount || "assets"];
                        if (url && assetTable) {
                            var index = url.indexOf("?");
                            if (-1 !== index && (url = url.substr(0, index)), !(uuid = assetTable.getUuid(url, type))) {
                                var extname = cc.path.extname(url);
                                extname && (url = url.slice(0, -extname.length), (uuid = assetTable.getUuid(url, type)) && !quiet && cc.warnID(4901, url, extname));
                            }
                        }
                        return !uuid && type && (isChildClassOf(type, SpriteFrame) || isChildClassOf(type, Texture2D) || isChildClassOf(type, TextureCube)) && cc.warnID(4934), 
                        uuid;
                    }
                }, {
                    key: "_getReferenceKey",
                    value: function _getReferenceKey(assetOrUrlOrUuid) {
                        var key;
                        return "object" === _typeof(assetOrUrlOrUuid) ? key = assetOrUrlOrUuid._uuid || null : "string" == typeof assetOrUrlOrUuid && (key = this._getResUuid(assetOrUrlOrUuid, null, null, !0) || assetOrUrlOrUuid), 
                        key ? (cc.AssetLibrary._getAssetInfoInRuntime(key, _info), this._cache[_info.url] ? _info.url : key) : (cc.warnID(4800, assetOrUrlOrUuid), 
                        key);
                    }
                }, {
                    key: "_urlNotFound",
                    value: function _urlNotFound(url, type, completeCallback) {
                        callInNextTick(function() {
                            url = cc.url.normalize(url);
                            var info = "".concat(type ? getClassName(type) : "Asset", ' in "resources/').concat(url, '" does not exist.');
                            completeCallback && completeCallback(new Error(info), []);
                        });
                    }
                }, {
                    key: "_parseLoadResArgs",
                    value: function _parseLoadResArgs(type, onProgress, onComplete) {
                        if (void 0 === onComplete) {
                            var isValidType = isChildClassOf(type, cc.RawAsset);
                            onProgress ? (onComplete = onProgress, isValidType && (onProgress = this.onProgress || null)) : void 0 !== onProgress || isValidType || (onComplete = type, 
                            onProgress = this.onProgress || null, type = null), void 0 === onProgress || isValidType || (onProgress = type, 
                            type = null);
                        }
                        return {
                            type: type,
                            onProgress: onProgress,
                            onComplete: onComplete
                        };
                    }
                }, {
                    key: "_loadResUuids",
                    value: function _loadResUuids(uuids, progressCallback, completeCallback, urls) {
                        if (0 < uuids.length) {
                            var self = this, res = uuids.map(function(uuid) {
                                return {
                                    type: "uuid",
                                    uuid: uuid
                                };
                            });
                            this.load(res, progressCallback, function(errors, items) {
                                if (completeCallback) {
                                    for (var assetRes = [], urlRes = urls && [], i = 0; i < res.length; ++i) {
                                        var uuid = res[i].uuid, id = self._getReferenceKey(uuid), item = items.getContent(id);
                                        item && (self.setAutoReleaseRecursively(uuid, !1), assetRes.push(item), urlRes && urlRes.push(urls[i]));
                                    }
                                    urls ? completeCallback(errors, assetRes, urlRes) : completeCallback(errors, assetRes);
                                }
                            });
                        } else completeCallback && callInNextTick(function() {
                            urls ? completeCallback(null, [], []) : completeCallback(null, []);
                        });
                    }
                } ]), CCLoader;
            }(), loader = exports("loader", cc.loader = new CCLoader());
            var _dec$t, _dec2$a, _dec3$3, _class$t, _class2$n, _descriptor$l, _descriptor2$d, textureUtil = Object.freeze({
                loadImage: function loadImage$1(url, callback, target) {
                    assertID(!!url, 3103);
                    var imageAsset = loader.getRes(url);
                    return imageAsset ? imageAsset.loaded ? callback && callback.call(target, null, imageAsset) : imageAsset.once("load", function() {
                        callback && callback.call(target, null, imageAsset);
                    }, target) : (imageAsset = new ImageAsset(), loader.load({
                        url: url,
                        imageAsset: imageAsset
                    }, function(err, asset) {
                        if (err) return callback && callback.call(target, err || new Error("Unknown error")), 
                        imageAsset;
                        callback && callback.call(target, null, asset);
                    })), imageAsset;
                },
                cacheImage: function cacheImage(url, image) {
                    if (url && image) {
                        var imageAsset = new ImageAsset(image), item = {
                            id: url,
                            url: url,
                            error: null,
                            content: imageAsset,
                            complete: !1
                        };
                        return loader.flowOut(item), imageAsset;
                    }
                },
                postLoadImage: function postLoadImage(imageAsset, callback) {
                    imageAsset.loaded ? callback && callback() : imageAsset.nativeUrl ? loader.load({
                        url: imageAsset.nativeUrl,
                        skips: imageAsset.isCompressed ? void 0 : [ "Loader" ]
                    }, function(err, image) {
                        if (image) {
                            if (image instanceof ImageAsset) return error("internal error: loader handle pipe must be skipped");
                            imageAsset.loaded || (imageAsset._nativeAsset = image);
                        }
                        callback && callback(err);
                    }) : callback && callback();
                }
            });
            exports("textureUtil", textureUtil);
            var _dec$u, _dec2$b, _class$u, _class2$o, _descriptor$m, _descriptor2$e, _descriptor3$9, _descriptor4$7, _descriptor5$6, Skeleton = exports("Skeleton", (_dec$t = ccclass("cc.Skeleton"), 
            _dec2$a = property([ CCString ]), _dec3$3 = property([ Mat4 ]), _dec$t((_descriptor$l = _applyDecoratedDescriptor((_class2$n = function() {
                function Skeleton() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, Skeleton);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Skeleton)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_joints", _descriptor$l, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_bindposes", _descriptor2$d, _assertThisInitialized(_this)), 
                    _this._bindTRS = [], _this._hash = 0, _this;
                }
                return _inherits(Skeleton, Asset), _createClass(Skeleton, [ {
                    key: "onLoaded",
                    value: function onLoaded() {
                        this.bindposes = this._bindposes;
                    }
                }, {
                    key: "bindposes",
                    get: function get() {
                        return this._bindposes;
                    },
                    set: function set(value) {
                        this._bindposes = value, this._bindTRS = value.map(function(m) {
                            var position = new Vec3(), rotation = new Quat(), scale = new Vec3();
                            return Mat4.toRTS(m, rotation, position, scale), {
                                position: position,
                                rotation: rotation,
                                scale: scale
                            };
                        }), this._hash = murmurhash2_32_gc(this.bindposes.reduce(function(acc, cur) {
                            return acc + cur.m00.toPrecision(2) + " " + cur.m01.toPrecision(2) + " " + cur.m02.toPrecision(2) + " " + cur.m03.toPrecision(2) + " " + cur.m04.toPrecision(2) + " " + cur.m05.toPrecision(2) + " " + cur.m06.toPrecision(2) + " " + cur.m07.toPrecision(2) + " " + cur.m08.toPrecision(2) + " " + cur.m09.toPrecision(2) + " " + cur.m10.toPrecision(2) + " " + cur.m11.toPrecision(2) + " " + cur.m12.toPrecision(2) + " " + cur.m13.toPrecision(2) + " " + cur.m14.toPrecision(2) + " " + cur.m15.toPrecision(2) + "\n";
                        }, ""), 666);
                    }
                }, {
                    key: "bindTRS",
                    get: function get() {
                        return this._bindTRS;
                    }
                }, {
                    key: "joints",
                    get: function get() {
                        return this._joints;
                    },
                    set: function set(value) {
                        this._joints = value;
                    }
                }, {
                    key: "hash",
                    get: function get() {
                        return this._hash;
                    }
                } ]), Skeleton;
            }()).prototype, "_joints", [ _dec2$a ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor2$d = _applyDecoratedDescriptor(_class2$n.prototype, "_bindposes", [ _dec3$3 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _class$t = _class2$n)) || _class$t));
            cc.Skeleton = Skeleton, cc.textureUtil = textureUtil;
            var _dec$v, _dec2$c, _class$v, _class2$p, _descriptor$n, _dec3$4, _dec4$2, _dec5$2, _dec6$2, _class4$1, _class5$1, _descriptor2$f, _descriptor3$a, EventHandler = exports("EventHandler", (_dec$u = ccclass("cc.ClickEvent"), 
            _dec2$b = property(cc.Node), _dec$u((_applyDecoratedDescriptor((_class2$o = function() {
                function EventHandler() {
                    _classCallCheck(this, EventHandler), _initializerDefineProperty(this, "target", _descriptor$m, this), 
                    _initializerDefineProperty(this, "component", _descriptor2$e, this), _initializerDefineProperty(this, "_componentId", _descriptor3$9, this), 
                    _initializerDefineProperty(this, "handler", _descriptor4$7, this), _initializerDefineProperty(this, "customEventData", _descriptor5$6, this);
                }
                return _createClass(EventHandler, [ {
                    key: "emit",
                    value: function emit(params) {
                        var target = this.target;
                        if (cc.isValid(target)) {
                            this._genCompIdIfNeeded();
                            var compType = cc.js._getClassById(this._componentId), comp = target.getComponent(compType);
                            if (cc.isValid(comp)) {
                                var handler = comp[this.handler];
                                "function" == typeof handler && (null != this.customEventData && "" !== this.customEventData && (params = params.slice()).push(this.customEventData), 
                                handler.apply(comp, params));
                            }
                        }
                    }
                }, {
                    key: "_compName2Id",
                    value: function _compName2Id(compName) {
                        var comp = cc.js.getClassByName(compName);
                        return cc.js._getClassId(comp);
                    }
                }, {
                    key: "_compId2Name",
                    value: function _compId2Name(compId) {
                        var comp = cc.js._getClassById(compId);
                        return cc.js.getClassName(comp);
                    }
                }, {
                    key: "_genCompIdIfNeeded",
                    value: function _genCompIdIfNeeded() {
                        this._componentId || (this._componentName = this.component, this.component = "");
                    }
                }, {
                    key: "_componentName",
                    get: function get() {
                        return this._genCompIdIfNeeded(), this._compId2Name(this._componentId);
                    },
                    set: function set(value) {
                        this._componentId = this._compName2Id(value);
                    }
                } ], [ {
                    key: "emitEvents",
                    value: function emitEvents(events) {
                        for (var _len = arguments.length, args = new Array(1 < _len ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                        for (var i = 0, l = events.length; i < l; i++) {
                            var event = events[i];
                            event instanceof EventHandler && event.emit(args);
                        }
                    }
                } ]), EventHandler;
            }()).prototype, "_componentName", [ property ], Object.getOwnPropertyDescriptor(_class2$o.prototype, "_componentName"), _class2$o.prototype), 
            _descriptor$m = _applyDecoratedDescriptor(_class2$o.prototype, "target", [ _dec2$b ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor2$e = _applyDecoratedDescriptor(_class2$o.prototype, "component", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return "";
                }
            }), _descriptor3$9 = _applyDecoratedDescriptor(_class2$o.prototype, "_componentId", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return "";
                }
            }), _descriptor4$7 = _applyDecoratedDescriptor(_class2$o.prototype, "handler", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return "";
                }
            }), _descriptor5$6 = _applyDecoratedDescriptor(_class2$o.prototype, "customEventData", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return "";
                }
            }), _class$u = _class2$o)) || _class$u));
            cc.Component.EventHandler = EventHandler;
            var _class$w, MissingClass$1 = (_dec$v = ccclass("cc.MissingClass"), _dec2$c = property({
                visible: !1,
                editorOnly: !0
            }), _dec$v((_descriptor$n = _applyDecoratedDescriptor((_class2$p = function MissingClass() {
                _classCallCheck(this, MissingClass), _initializerDefineProperty(this, "_$erialized", _descriptor$n, this);
            }).prototype, "_$erialized", [ _dec2$c ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _class$v = _class2$p)) || _class$v), MissingScript = exports("MissingScript", (_dec3$4 = ccclass("cc.MissingScript"), 
            _dec4$2 = inspector("packages://inspector/inspectors/comps/missing-script.js"), 
            _dec5$2 = property({
                serializable: !1
            }), _dec6$2 = property({
                visible: !1,
                editorOnly: !0
            }), _dec3$4(_class4$1 = _dec4$2((_descriptor2$f = _applyDecoratedDescriptor((_class5$1 = function() {
                function MissingScript() {
                    var _this;
                    return _classCallCheck(this, MissingScript), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(MissingScript).call(this)), "compiled", _descriptor2$f, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_$erialized", _descriptor3$a, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(MissingScript, Component), _createClass(MissingScript, null, [ {
                    key: "safeFindClass",
                    value: function safeFindClass(id, data) {
                        var cls = _getClassById(id);
                        return cls || (id ? (cc.deserialize.reportMissingClass(id), MissingScript.getMissingWrapper(id, data)) : null);
                    }
                }, {
                    key: "getMissingWrapper",
                    value: function getMissingWrapper(id, data) {
                        return data.node && (/^[0-9a-zA-Z+/]{23}$/.test(id) || BUILTIN_CLASSID_RE.test(id)) ? MissingScript : MissingClass$1;
                    }
                } ]), _createClass(MissingScript, [ {
                    key: "onLoad",
                    value: function onLoad() {
                        cc.warnID(4600, this.node.name);
                    }
                } ]), MissingScript;
            }()).prototype, "compiled", [ _dec5$2 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor3$a = _applyDecoratedDescriptor(_class5$1.prototype, "_$erialized", [ _dec6$2 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _class4$1 = _class5$1)) || _class4$1) || _class4$1));
            cc._MissingScript = MissingScript;
            var BlockEvents = [ SystemEventType.TOUCH_START, SystemEventType.TOUCH_END, SystemEventType.TOUCH_MOVE, SystemEventType.MOUSE_DOWN, SystemEventType.MOUSE_MOVE, SystemEventType.MOUSE_UP, SystemEventType.MOUSE_ENTER, SystemEventType.MOUSE_LEAVE, SystemEventType.MOUSE_WHEEL ];
            function stopPropagation(event) {
                event.propagationStopped = !0;
            }
            var _dec$x, _dec2$e, _dec3$5, _dec4$3, _dec5$3, _class$x, _class2$q, _descriptor$o, _descriptor2$g, _class3$b, _temp$s, BlockInputEventsComponent = exports("BlockInputEventsComponent", ccclass("cc.BlockInputEventsComponent")(_class$w = menu("Components/BlockInputEvents")(_class$w = function() {
                function BlockInputEventsComponent() {
                    return _classCallCheck(this, BlockInputEventsComponent), _possibleConstructorReturn(this, _getPrototypeOf(BlockInputEventsComponent).apply(this, arguments));
                }
                return _inherits(BlockInputEventsComponent, Component), _createClass(BlockInputEventsComponent, [ {
                    key: "onEnable",
                    value: function onEnable() {
                        for (var i = 0; i < BlockEvents.length; i++) this.node.on(BlockEvents[i], stopPropagation, this);
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        for (var i = 0; i < BlockEvents.length; i++) this.node.off(BlockEvents[i], stopPropagation, this);
                    }
                } ]), BlockInputEventsComponent;
            }()) || _class$w) || _class$w);
            cc.BlockInputEventsComponent = BlockInputEventsComponent;
            var _dec$y, _dec2$f, _dec3$6, _dec4$4, _dec5$4, _dec6$3, _dec7$2, _class$y, _class2$r, _descriptor$p, _descriptor2$h, _descriptor3$b, _descriptor4$8, _descriptor5$7, _descriptor6$2, _descriptor7$2, _descriptor8$2, _descriptor9$2, _descriptor10$2, _descriptor11$1, _descriptor12$1, _descriptor13$1, _descriptor14$1, _class3$c, _temp$t, _vec2a = new Vec2(), _vec2b = new Vec2(), _mat4_temp = new Mat4(), _matrix = new Mat4(), _worldMatrix = new Mat4(), UITransformComponent = exports("UITransformComponent", (_dec$x = ccclass("cc.UITransformComponent"), 
            _dec2$e = executionOrder(110), _dec3$5 = menu("UI/UITransform"), _dec4$3 = property({
                displayOrder: 0
            }), _dec5$3 = property({
                displayOrder: 1
            }), _dec$x(_class$x = _dec2$e(_class$x = _dec3$5(_class$x = executeInEditMode((_temp$s = _class3$b = function() {
                function UITransformComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, UITransformComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UITransformComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_contentSize", _descriptor$o, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_anchorPoint", _descriptor2$g, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(UITransformComponent, Component), _createClass(UITransformComponent, [ {
                    key: "__preload",
                    value: function __preload() {
                        this.node.uiTransfromComp = this;
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.node.uiTransfromComp = null;
                    }
                }, {
                    key: "setContentSize",
                    value: function setContentSize(size, height) {
                        var locContentSize = this._contentSize;
                        if (void 0 === height) {
                            if ((size = size).width === locContentSize.width && size.height === locContentSize.height) return;
                            0, locContentSize.width = size.width, locContentSize.height = size.height;
                        } else {
                            if (size === locContentSize.width && height === locContentSize.height) return;
                            0, locContentSize.width = size, locContentSize.height = height;
                        }
                        this.node.emit(SystemEventType.SIZE_CHANGED);
                    }
                }, {
                    key: "setAnchorPoint",
                    value: function setAnchorPoint(point, y) {
                        var locAnchorPoint = this._anchorPoint;
                        if (void 0 === y) {
                            if ((point = point).x === locAnchorPoint.x && point.y === locAnchorPoint.y) return;
                            locAnchorPoint.x = point.x, locAnchorPoint.y = point.y;
                        } else {
                            if (point === locAnchorPoint.x && y === locAnchorPoint.y) return;
                            locAnchorPoint.x = point, locAnchorPoint.y = y;
                        }
                        this.node.emit(SystemEventType.ANCHOR_CHANGED, this._anchorPoint);
                    }
                }, {
                    key: "isHit",
                    value: function isHit(point, listener) {
                        var w = this._contentSize.width, h = this._contentSize.height, cameraPt = _vec2a, testPt = _vec2b, visibility = -1, renderComp = this.node.getComponent(cc.UIRenderComponent);
                        visibility = renderComp ? renderComp.visibility : this._getVisibility();
                        var canvas = director.root.ui.getScreen(visibility);
                        if (canvas) {
                            canvas.node.getWorldRT(_mat4_temp);
                            var m12 = _mat4_temp.m12, m13 = _mat4_temp.m13, center = cc.visibleRect.center;
                            if (_mat4_temp.m12 = center.x - (_mat4_temp.m00 * m12 + _mat4_temp.m04 * m13), _mat4_temp.m13 = center.y - (_mat4_temp.m01 * m12 + _mat4_temp.m05 * m13), 
                            Mat4.invert(_mat4_temp, _mat4_temp), Vec2.transformMat4(cameraPt, point, _mat4_temp), 
                            this.node.getWorldMatrix(_worldMatrix), Mat4.invert(_mat4_temp, _worldMatrix), Vec2.transformMat4(testPt, cameraPt, _mat4_temp), 
                            testPt.x += this._anchorPoint.x * w, testPt.y += this._anchorPoint.y * h, 0 <= testPt.x && 0 <= testPt.y && testPt.x <= w && testPt.y <= h) {
                                if (listener && listener.mask) {
                                    for (var mask = listener.mask, parent = this.node, i = 0; parent && i < mask.index; ++i, 
                                    parent = parent.parent) ;
                                    if (parent !== mask.node) return !(listener.mask = null);
                                    var comp = parent.getComponent(cc.MaskComponent);
                                    return !comp || !comp.enabledInHierarchy || comp.isHit(cameraPt);
                                }
                                return !0;
                            }
                            return !1;
                        }
                    }
                }, {
                    key: "convertToNodeSpaceAR",
                    value: function convertToNodeSpaceAR(worldPoint, out) {
                        return this.node.getWorldMatrix(_worldMatrix), Mat4.invert(_mat4_temp, _worldMatrix), 
                        out = out || new Vec3(), Vec3.transformMat4(out, worldPoint, _mat4_temp);
                    }
                }, {
                    key: "convertToWorldSpaceAR",
                    value: function convertToWorldSpaceAR(nodePoint, out) {
                        return this.node.getWorldMatrix(_worldMatrix), out = out || new Vec3(), Vec3.transformMat4(out, nodePoint, _worldMatrix);
                    }
                }, {
                    key: "getBoundingBox",
                    value: function getBoundingBox() {
                        Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
                        var width = this._contentSize.width, height = this._contentSize.height, rect = new Rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
                        return rect.transformMat4(_matrix), rect;
                    }
                }, {
                    key: "getBoundingBoxToWorld",
                    value: function getBoundingBoxToWorld() {
                        return this.node.parent ? (this.node.parent.getWorldMatrix(_worldMatrix), this.getBoundingBoxTo(_worldMatrix)) : this.getBoundingBox();
                    }
                }, {
                    key: "getBoundingBoxTo",
                    value: function getBoundingBoxTo(parentMat) {
                        Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
                        var width = this._contentSize.width, height = this._contentSize.height, rect = new Rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
                        if (Mat4.multiply(_worldMatrix, parentMat, _matrix), rect.transformMat4(_worldMatrix), 
                        !this.node.children) return rect;
                        var _iterator = this.node.children, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var child = _ref;
                            if (child && child.active) {
                                var uiTransform = child.getComponent(UITransformComponent);
                                if (uiTransform) {
                                    var childRect = uiTransform.getBoundingBoxTo(parentMat);
                                    childRect && Rect.union(rect, rect, childRect);
                                }
                            }
                        }
                        return rect;
                    }
                }, {
                    key: "getComputeAABB",
                    value: function getComputeAABB(out) {
                        var rectWorld = this.getBoundingBoxToWorld(), px = rectWorld.center.x, py = rectWorld.center.y, pz = this.node.worldPosition.z, w = rectWorld.width / 2, h = rectWorld.height / 2;
                        if (null == out) return new aabb(px, py, pz, w, h, .01);
                        aabb.set(out, px, py, pz, w, h, .01);
                    }
                }, {
                    key: "_getVisibility",
                    value: function _getVisibility() {
                        for (var visibility = -1, parent = this.node; parent; ) {
                            if (parent) {
                                var canvasComp = parent.getComponent("cc.CanvasComponent");
                                if (canvasComp) {
                                    visibility = canvasComp.visibility;
                                    break;
                                }
                            }
                            parent = parent.parent;
                        }
                        return visibility;
                    }
                }, {
                    key: "contentSize",
                    get: function get() {
                        return this._contentSize;
                    },
                    set: function set(value) {
                        this._contentSize.equals(value) || (this._contentSize.set(value), this.node.emit(SystemEventType.SIZE_CHANGED));
                    }
                }, {
                    key: "width",
                    get: function get() {
                        return this._contentSize.width;
                    },
                    set: function set(value) {
                        this._contentSize.width !== value && (this._contentSize.width = value, this.node.emit(SystemEventType.SIZE_CHANGED));
                    }
                }, {
                    key: "height",
                    get: function get() {
                        return this._contentSize.height;
                    },
                    set: function set(value) {
                        this.contentSize.height !== value && (this._contentSize.height = value, this.node.emit(SystemEventType.SIZE_CHANGED));
                    }
                }, {
                    key: "anchorPoint",
                    get: function get() {
                        return this._anchorPoint;
                    },
                    set: function set(value) {
                        this._anchorPoint.equals(value) || (this._anchorPoint.set(value), this.node.emit(SystemEventType.ANCHOR_CHANGED, this._anchorPoint));
                    }
                }, {
                    key: "anchorX",
                    get: function get() {
                        return this._anchorPoint.x;
                    },
                    set: function set(value) {
                        this._anchorPoint.x !== value && (this._anchorPoint.x = value, this.node.emit(SystemEventType.ANCHOR_CHANGED, this._anchorPoint));
                    }
                }, {
                    key: "anchorY",
                    get: function get() {
                        return this._anchorPoint.y;
                    },
                    set: function set(value) {
                        this._anchorPoint.y !== value && (this._anchorPoint.y = value, this.node.emit(SystemEventType.ANCHOR_CHANGED, this._anchorPoint));
                    }
                } ]), UITransformComponent;
            }(), _class3$b.EventType = SystemEventType, _applyDecoratedDescriptor((_class2$q = _temp$s).prototype, "contentSize", [ _dec4$3 ], Object.getOwnPropertyDescriptor(_class2$q.prototype, "contentSize"), _class2$q.prototype), 
            _applyDecoratedDescriptor(_class2$q.prototype, "anchorPoint", [ _dec5$3 ], Object.getOwnPropertyDescriptor(_class2$q.prototype, "anchorPoint"), _class2$q.prototype), 
            _descriptor$o = _applyDecoratedDescriptor(_class2$q.prototype, "_contentSize", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Size(100, 100);
                }
            }), _descriptor2$g = _applyDecoratedDescriptor(_class2$q.prototype, "_anchorPoint", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec2(.5, .5);
                }
            }), _class$x = _class2$q)) || _class$x) || _class$x) || _class$x) || _class$x));
            cc.UITransformComponent = UITransformComponent;
            var _dec$z, _dec2$g, _dec3$7, _dec4$5, _dec5$5, _dec6$4, _dec7$3, _dec8$1, _dec9$1, _dec10$1, _class$z, _class2$s, _descriptor$q, _descriptor2$i, _descriptor3$c, _descriptor4$9, _descriptor5$8, _class$A, _class2$t, _descriptor$r, ProjectionType = Enum({
                ORTHO: 0,
                PERSPECTIVE: 1
            }), CameraClearFlag = Enum({
                SKYBOX: SKYBOX_FLAG | GFXClearFlag.DEPTH_STENCIL,
                SOLID_COLOR: GFXClearFlag.ALL,
                DEPTH_ONLY: GFXClearFlag.DEPTH_STENCIL,
                DONT_CLEAR: GFXClearFlag.NONE
            }), CameraComponent = exports("CameraComponent", (_dec$y = ccclass("cc.CameraComponent"), 
            _dec2$f = menu("Components/Camera"), _dec3$6 = property({
                type: ProjectionType
            }), _dec4$4 = property({
                type: CameraClearFlag
            }), _dec5$4 = property({
                visible: !1
            }), _dec6$3 = property({
                type: Layers.BitMask
            }), _dec7$2 = property({
                type: RenderTexture
            }), _dec$y(_class$y = _dec2$f(_class$y = executeInEditMode((_temp$t = _class3$c = function() {
                function CameraComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, CameraComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(CameraComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_projection", _descriptor$p, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_priority", _descriptor2$h, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_fov", _descriptor3$b, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_orthoHeight", _descriptor4$8, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_near", _descriptor5$7, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_far", _descriptor6$2, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_color", _descriptor7$2, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_depth", _descriptor8$2, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_stencil", _descriptor9$2, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_clearFlags", _descriptor10$2, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_rect", _descriptor11$1, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_screenScale", _descriptor12$1, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_visibility", _descriptor13$1, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_targetTexture", _descriptor14$1, _assertThisInitialized(_this)), 
                    _this._camera = null, _this._inEditorMode = !1, _this;
                }
                return _inherits(CameraComponent, Component), _createClass(CameraComponent, [ {
                    key: "onLoad",
                    value: function onLoad() {
                        cc.director.on(cc.Director.EVENT_AFTER_SCENE_LAUNCH, this.onSceneChanged, this);
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        this._camera || this._createCamera(), this._camera.enabled = !0;
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this._camera && (this._camera.enabled = !1);
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this._camera && (this._getRenderScene().destroyCamera(this._camera), this._camera = null), 
                        this._targetTexture && this._targetTexture.off("resize");
                    }
                }, {
                    key: "screenPointToRay",
                    value: function screenPointToRay(x, y, out) {
                        return out = out || ray.create(), this._camera && this._camera.screenPointToRay(out, x, y), 
                        out;
                    }
                }, {
                    key: "worldToScreen",
                    value: function worldToScreen(worldPos, out) {
                        return out = out || new Vec3(), this._camera && this._camera.worldToScreen(out, worldPos), 
                        out;
                    }
                }, {
                    key: "screenToWorld",
                    value: function screenToWorld(screenPos, out) {
                        return out = out || this.node.getWorldPosition(), this._camera && this._camera.screenToWorld(out, screenPos), 
                        out;
                    }
                }, {
                    key: "_createCamera",
                    value: function _createCamera() {
                        var _this2 = this;
                        if (this.node.scene) {
                            var scene = this._getRenderScene();
                            if (!this._camera || !scene.cameras.find(function(c) {
                                return c === _this2._camera;
                            })) {
                                if (this._camera = scene.createCamera({
                                    name: this.node.name,
                                    node: this.node,
                                    projection: this._projection,
                                    window: this._inEditorMode ? cc.director.root && cc.director.root.mainWindow : cc.director.root && cc.director.root.tempWindow,
                                    priority: this._priority
                                }), this._camera) {
                                    this._camera.viewport = this._rect, this._camera.fov = toRadian(this._fov), this._camera.orthoHeight = this._orthoHeight, 
                                    this._camera.nearClip = this._near, this._camera.farClip = this._far;
                                    var r = this._color.x, g = this._color.y, b = this._color.z, a = this._color.w;
                                    this._camera.clearColor = {
                                        r: r,
                                        g: g,
                                        b: b,
                                        a: a
                                    }, this._camera.clearDepth = this._depth, this._camera.clearStencil = this._stencil, 
                                    this._camera.clearFlag = this._clearFlags, this._camera.visibility = this._visibility;
                                }
                                this._updateTargetTexture();
                            }
                        }
                    }
                }, {
                    key: "onSceneChanged",
                    value: function onSceneChanged(scene) {
                        this._camera && this._camera.scene !== scene.renderScene && (this._createCamera(), 
                        this._camera.enabled = !0);
                    }
                }, {
                    key: "_chechTargetTextureEvent",
                    value: function _chechTargetTextureEvent(old) {
                        var _this3 = this;
                        old && old.off("resize"), this._targetTexture && this._targetTexture.on("resize", function resizeFunc(window) {
                            _this3._camera && _this3._camera.setFixedSize(window.width, window.height);
                        }, this);
                    }
                }, {
                    key: "_updateTargetTexture",
                    value: function _updateTargetTexture() {
                        if (this._camera && this._targetTexture) {
                            var window = this._targetTexture.getGFXWindow();
                            this._camera.changeTargetWindow(window), this._camera.setFixedSize(window.width, window.height);
                        }
                    }
                }, {
                    key: "projection",
                    get: function get() {
                        return this._projection;
                    },
                    set: function set(val) {
                        this._projection = val, this._camera && (this._camera.projectionType = val);
                    }
                }, {
                    key: "priority",
                    get: function get() {
                        return this._priority;
                    },
                    set: function set(val) {
                        this._priority = val, this._camera && (this._camera.priority = val);
                    }
                }, {
                    key: "fov",
                    get: function get() {
                        return this._fov;
                    },
                    set: function set(val) {
                        this._fov = val, this._camera && (this._camera.fov = toRadian(val));
                    }
                }, {
                    key: "orthoHeight",
                    get: function get() {
                        return this._orthoHeight;
                    },
                    set: function set(val) {
                        this._orthoHeight = val, this._camera && (this._camera.orthoHeight = val);
                    }
                }, {
                    key: "near",
                    get: function get() {
                        return this._near;
                    },
                    set: function set(val) {
                        this._near = val, this._camera && (this._camera.nearClip = val);
                    }
                }, {
                    key: "far",
                    get: function get() {
                        return this._far;
                    },
                    set: function set(val) {
                        this._far = val, this._camera && (this._camera.farClip = val);
                    }
                }, {
                    key: "color",
                    get: function get() {
                        return this._color;
                    },
                    set: function set(val) {
                        this._color.set(val), this._camera && (this._camera.clearColor.r = val.x, this._camera.clearColor.g = val.y, 
                        this._camera.clearColor.b = val.z, this._camera.clearColor.a = val.w);
                    }
                }, {
                    key: "depth",
                    get: function get() {
                        return this._depth;
                    },
                    set: function set(val) {
                        this._depth = val, this._camera && (this._camera.clearDepth = val);
                    }
                }, {
                    key: "stencil",
                    get: function get() {
                        return this._stencil;
                    },
                    set: function set(val) {
                        this._stencil = val, this._camera && (this._camera.clearStencil = val);
                    }
                }, {
                    key: "clearFlags",
                    get: function get() {
                        return this._clearFlags;
                    },
                    set: function set(val) {
                        this._clearFlags = val, this._camera && (this._camera.clearFlag = val);
                    }
                }, {
                    key: "rect",
                    get: function get() {
                        return this._rect;
                    },
                    set: function set(val) {
                        this._rect = val, this._camera && (this._camera.viewport = val);
                    }
                }, {
                    key: "screenScale",
                    get: function get() {
                        return this._screenScale;
                    },
                    set: function set(val) {
                        this._screenScale = val, this._camera && (this._camera.screenScale = val);
                    }
                }, {
                    key: "visibility",
                    get: function get() {
                        return this._visibility;
                    },
                    set: function set(val) {
                        this._visibility = val, this._camera && (this._camera.visibility = val);
                    }
                }, {
                    key: "targetTexture",
                    get: function get() {
                        return this._targetTexture;
                    },
                    set: function set(value) {
                        if (this._targetTexture !== value) {
                            var old = this._targetTexture;
                            this._targetTexture = value, this._chechTargetTextureEvent(old), this._updateTargetTexture(), 
                            !value && this._camera && (this._camera.changeTargetWindow(null), this._camera.isWindowSize = !0);
                        }
                    }
                }, {
                    key: "inEditorMode",
                    get: function get() {
                        return this._inEditorMode;
                    },
                    set: function set(value) {
                        this._inEditorMode = value, this._camera && this._camera.changeTargetWindow(value ? cc.director.root && cc.director.root.mainWindow : cc.director.root && cc.director.root.tempWindow);
                    }
                } ]), CameraComponent;
            }(), _class3$c.ProjectionType = ProjectionType, _class3$c.CameraClearFlag = CameraClearFlag, 
            _descriptor$p = _applyDecoratedDescriptor((_class2$r = _temp$t).prototype, "_projection", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return ProjectionType.PERSPECTIVE;
                }
            }), _descriptor2$h = _applyDecoratedDescriptor(_class2$r.prototype, "_priority", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor3$b = _applyDecoratedDescriptor(_class2$r.prototype, "_fov", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 45;
                }
            }), _descriptor4$8 = _applyDecoratedDescriptor(_class2$r.prototype, "_orthoHeight", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 10;
                }
            }), _descriptor5$7 = _applyDecoratedDescriptor(_class2$r.prototype, "_near", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _descriptor6$2 = _applyDecoratedDescriptor(_class2$r.prototype, "_far", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1e3;
                }
            }), _descriptor7$2 = _applyDecoratedDescriptor(_class2$r.prototype, "_color", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Color("#334C78");
                }
            }), _descriptor8$2 = _applyDecoratedDescriptor(_class2$r.prototype, "_depth", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _descriptor9$2 = _applyDecoratedDescriptor(_class2$r.prototype, "_stencil", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor10$2 = _applyDecoratedDescriptor(_class2$r.prototype, "_clearFlags", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return CameraClearFlag.SOLID_COLOR;
                }
            }), _descriptor11$1 = _applyDecoratedDescriptor(_class2$r.prototype, "_rect", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Rect(0, 0, 1, 1);
                }
            }), _descriptor12$1 = _applyDecoratedDescriptor(_class2$r.prototype, "_screenScale", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _descriptor13$1 = _applyDecoratedDescriptor(_class2$r.prototype, "_visibility", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return CameraDefaultMask;
                }
            }), _descriptor14$1 = _applyDecoratedDescriptor(_class2$r.prototype, "_targetTexture", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _applyDecoratedDescriptor(_class2$r.prototype, "projection", [ _dec3$6 ], Object.getOwnPropertyDescriptor(_class2$r.prototype, "projection"), _class2$r.prototype), 
            _applyDecoratedDescriptor(_class2$r.prototype, "priority", [ property ], Object.getOwnPropertyDescriptor(_class2$r.prototype, "priority"), _class2$r.prototype), 
            _applyDecoratedDescriptor(_class2$r.prototype, "fov", [ property ], Object.getOwnPropertyDescriptor(_class2$r.prototype, "fov"), _class2$r.prototype), 
            _applyDecoratedDescriptor(_class2$r.prototype, "orthoHeight", [ property ], Object.getOwnPropertyDescriptor(_class2$r.prototype, "orthoHeight"), _class2$r.prototype), 
            _applyDecoratedDescriptor(_class2$r.prototype, "near", [ property ], Object.getOwnPropertyDescriptor(_class2$r.prototype, "near"), _class2$r.prototype), 
            _applyDecoratedDescriptor(_class2$r.prototype, "far", [ property ], Object.getOwnPropertyDescriptor(_class2$r.prototype, "far"), _class2$r.prototype), 
            _applyDecoratedDescriptor(_class2$r.prototype, "color", [ property ], Object.getOwnPropertyDescriptor(_class2$r.prototype, "color"), _class2$r.prototype), 
            _applyDecoratedDescriptor(_class2$r.prototype, "depth", [ property ], Object.getOwnPropertyDescriptor(_class2$r.prototype, "depth"), _class2$r.prototype), 
            _applyDecoratedDescriptor(_class2$r.prototype, "stencil", [ property ], Object.getOwnPropertyDescriptor(_class2$r.prototype, "stencil"), _class2$r.prototype), 
            _applyDecoratedDescriptor(_class2$r.prototype, "clearFlags", [ _dec4$4 ], Object.getOwnPropertyDescriptor(_class2$r.prototype, "clearFlags"), _class2$r.prototype), 
            _applyDecoratedDescriptor(_class2$r.prototype, "rect", [ property ], Object.getOwnPropertyDescriptor(_class2$r.prototype, "rect"), _class2$r.prototype), 
            _applyDecoratedDescriptor(_class2$r.prototype, "screenScale", [ _dec5$4 ], Object.getOwnPropertyDescriptor(_class2$r.prototype, "screenScale"), _class2$r.prototype), 
            _applyDecoratedDescriptor(_class2$r.prototype, "visibility", [ _dec6$3 ], Object.getOwnPropertyDescriptor(_class2$r.prototype, "visibility"), _class2$r.prototype), 
            _applyDecoratedDescriptor(_class2$r.prototype, "targetTexture", [ _dec7$2 ], Object.getOwnPropertyDescriptor(_class2$r.prototype, "targetTexture"), _class2$r.prototype), 
            _class$y = _class2$r)) || _class$y) || _class$y) || _class$y)), _worldPos = new Vec3(), CanvasClearFlag = Enum({
                SOLID_COLOR: GFXClearFlag.ALL,
                DEPTH_STENCIL: GFXClearFlag.DEPTH_STENCIL,
                NONE: GFXClearFlag.NONE
            }), RenderMode = Enum({
                OVERLAY: 0,
                INTERSPERSE: 1
            }), CanvasComponent = exports("CanvasComponent", (_dec$z = ccclass("cc.CanvasComponent"), 
            _dec2$g = executionOrder(100), _dec3$7 = requireComponent(UITransformComponent), 
            _dec4$5 = menu("UI/Canvas"), _dec5$5 = property({
                type: CanvasClearFlag
            }), _dec6$4 = property({
                type: RenderMode
            }), _dec7$3 = property(), _dec8$1 = property({
                type: RenderTexture
            }), _dec9$1 = property({
                type: CanvasClearFlag
            }), _dec10$1 = property({
                type: RenderMode
            }), _dec$z(_class$z = _dec2$g(_class$z = _dec3$7(_class$z = _dec4$5(_class$z = executeInEditMode(_class$z = disallowMultiple((_applyDecoratedDescriptor((_class2$s = function() {
                function CanvasComponent() {
                    var _this;
                    return _classCallCheck(this, CanvasComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(CanvasComponent).call(this)), "_priority", _descriptor$q, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_targetTexture", _descriptor2$i, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_clearFlag", _descriptor3$c, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_color", _descriptor4$9, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_renderMode", _descriptor5$8, _assertThisInitialized(_this)), 
                    _this._thisOnResized = void 0, _this._camera = null, _this._pos = new Vec3(), _this._thisOnResized = _this.alignWithScreen.bind(_assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(CanvasComponent, Component), _createClass(CanvasComponent, [ {
                    key: "clearFlag",
                    get: function get() {
                        return this._clearFlag;
                    },
                    set: function set(val) {
                        this._clearFlag = val, this._camera && (this._camera.clearFlag = this._clearFlag);
                    }
                }, {
                    key: "color",
                    get: function get() {
                        return this._color;
                    },
                    set: function set(val) {
                        Color.copy(this._color, val), this._camera && (this._camera.clearColor.r = val.r / 255, 
                        this._camera.clearColor.g = val.g / 255, this._camera.clearColor.b = val.b / 255, 
                        this._camera.clearColor.a = val.a / 255);
                    }
                }, {
                    key: "renderMode",
                    get: function get() {
                        return this._renderMode;
                    },
                    set: function set(val) {
                        this._renderMode = val, this._camera && (this._camera.priority = this._getViewPriority());
                    }
                }, {
                    key: "priority",
                    get: function get() {
                        return this._priority;
                    },
                    set: function set(val) {
                        this._priority = val, this._camera && (this._camera.priority = this._getViewPriority());
                    }
                }, {
                    key: "targetTexture",
                    get: function get() {
                        return this._targetTexture;
                    },
                    set: function set(value) {
                        if (this._targetTexture !== value) {
                            var old = this._targetTexture;
                            this._targetTexture = value, this._chechTargetTextureEvent(old), this._updateTargetTexture();
                        }
                    }
                }, {
                    key: "visibility",
                    get: function get() {
                        return this._camera ? this._camera.view.visibility : -1;
                    }
                }, {
                    key: "camera",
                    get: function get() {
                        return this._camera;
                    }
                } ]), _createClass(CanvasComponent, [ {
                    key: "__preload",
                    value: function __preload() {
                        var cameraNode = new Node$1("UICamera_" + this.node.name);
                        cameraNode.setPosition(0, 0, 1e3), this._camera = director.root.ui.renderScene.createCamera({
                            name: "ui_" + this.node.name,
                            node: cameraNode,
                            projection: CameraComponent.ProjectionType.ORTHO,
                            priority: this._getViewPriority(),
                            flows: [ "UIFlow" ]
                        }), this._camera.fov = 45, this._camera.clearFlag = this.clearFlag, this._camera.farClip = 2e3, 
                        this.color = this._color;
                        var device = director.root.device;
                        if (this._camera.resize(device.width, device.height), this._targetTexture) {
                            var window = this._targetTexture.getGFXWindow();
                            this._camera.changeTargetWindow(window), this._camera.setFixedSize(window.width, window.height);
                        }
                        view.on("design-resolution-changed", this._thisOnResized), this.alignWithScreen(), 
                        director.root.ui.addScreen(this);
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this._camera && director.root.ui.renderScene.destroyCamera(this._camera), this._targetTexture && this._targetTexture.off("resize"), 
                        view.off("design-resolution-changed", this._thisOnResized), director.root.ui.removeScreen(this);
                    }
                }, {
                    key: "alignWithScreen",
                    value: function alignWithScreen() {
                        var nodeSize, designSize;
                        this.node.getPosition(this._pos);
                        var canvasSize = visibleRect;
                        nodeSize = canvasSize, designSize = view.getDesignResolutionSize();
                        var offsetX = 0, offsetY = 0;
                        if (view.getResolutionPolicy() === ResolutionPolicy.NO_BORDER && (offsetX = .5 * (designSize.width - canvasSize.width), 
                        offsetY = .5 * (designSize.height - canvasSize.height)), Vec3.set(_worldPos, .5 * canvasSize.width + offsetX, .5 * canvasSize.height + offsetY, 0), 
                        this._pos.equals(_worldPos) || this.node.setPosition(_worldPos), this.node.width !== nodeSize.width && (this.node.width = nodeSize.width), 
                        this.node.height !== nodeSize.height && (this.node.height = nodeSize.height), this.node.getWorldPosition(_worldPos), 
                        this._camera) {
                            var size = game.canvas;
                            this._camera.resize(size.width, size.height), this._camera.orthoHeight = game.canvas.height / view.getScaleY() / 2, 
                            this._camera.node.setPosition(_worldPos.x, _worldPos.y, 1e3), this._camera.update();
                        }
                    }
                }, {
                    key: "_chechTargetTextureEvent",
                    value: function _chechTargetTextureEvent(old) {
                        var _this2 = this;
                        old && old.off("resize"), this._targetTexture && this._targetTexture.on("resize", function resizeFunc(window) {
                            _this2._camera && _this2._camera.setFixedSize(window.width, window.height);
                        }, this);
                    }
                }, {
                    key: "_updateTargetTexture",
                    value: function _updateTargetTexture() {
                        if (this._camera) if (this._targetTexture) {
                            var window = this._targetTexture.getGFXWindow();
                            this._camera.changeTargetWindow(window), this._camera.setFixedSize(window.width, window.height);
                        } else this._camera.changeTargetWindow(), this._camera.isWindowSize = !0;
                    }
                }, {
                    key: "_getViewPriority",
                    value: function _getViewPriority() {
                        return this._renderMode === RenderMode.OVERLAY ? this._priority | 1 << 30 : this._priority;
                    }
                } ]), CanvasComponent;
            }()).prototype, "clearFlag", [ _dec5$5 ], Object.getOwnPropertyDescriptor(_class2$s.prototype, "clearFlag"), _class2$s.prototype), 
            _applyDecoratedDescriptor(_class2$s.prototype, "color", [ property ], Object.getOwnPropertyDescriptor(_class2$s.prototype, "color"), _class2$s.prototype), 
            _applyDecoratedDescriptor(_class2$s.prototype, "renderMode", [ _dec6$4 ], Object.getOwnPropertyDescriptor(_class2$s.prototype, "renderMode"), _class2$s.prototype), 
            _applyDecoratedDescriptor(_class2$s.prototype, "priority", [ _dec7$3 ], Object.getOwnPropertyDescriptor(_class2$s.prototype, "priority"), _class2$s.prototype), 
            _applyDecoratedDescriptor(_class2$s.prototype, "targetTexture", [ _dec8$1 ], Object.getOwnPropertyDescriptor(_class2$s.prototype, "targetTexture"), _class2$s.prototype), 
            _descriptor$q = _applyDecoratedDescriptor(_class2$s.prototype, "_priority", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor2$i = _applyDecoratedDescriptor(_class2$s.prototype, "_targetTexture", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor3$c = _applyDecoratedDescriptor(_class2$s.prototype, "_clearFlag", [ _dec9$1 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return CanvasClearFlag.NONE;
                }
            }), _descriptor4$9 = _applyDecoratedDescriptor(_class2$s.prototype, "_color", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Color(0, 0, 0, 0);
                }
            }), _descriptor5$8 = _applyDecoratedDescriptor(_class2$s.prototype, "_renderMode", [ _dec10$1 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return RenderMode.OVERLAY;
                }
            }), _class$z = _class2$s)) || _class$z) || _class$z) || _class$z) || _class$z) || _class$z) || _class$z));
            cc.CanvasComponent = CanvasComponent;
            function BaseRenderData() {
                _classCallCheck(this, BaseRenderData), this.material = null, this.vertexCount = 0, 
                this.indiceCount = 0;
            }
            var _dec$B, _dec2$i, _dec3$8, _dec4$6, _class$B, _class2$u, _descriptor$s, _descriptor2$j, _dec$C, _dec2$j, _dec3$9, _dec4$7, _dec5$6, _dec6$5, _dec7$4, _class$C, _class2$v, _descriptor$t, _descriptor2$k, _descriptor3$d, _descriptor4$a, _class3$d, _temp$x, InstanceMaterialType, UIComponent = exports("UIComponent", ccclass("cc.UIComponent")(_class$A = executionOrder(110)(_class$A = disallowMultiple(_class$A = executeInEditMode((_applyDecoratedDescriptor((_class2$t = function() {
                function UIComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, UIComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_priority", _descriptor$r, _assertThisInitialized(_this)), 
                    _this._followScreen = null, _this._lastParent = null, _this;
                }
                return _inherits(UIComponent, Component), _createClass(UIComponent, [ {
                    key: "__preload",
                    value: function __preload() {
                        this.node._uiComp = this;
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        this._lastParent = this.node.parent, this._updateVisibility(), this._lastParent && this.node.on(SystemEventType.CHILD_REMOVED, this._parentChanged, this), 
                        this._sortSiblings();
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this._cancelEventFromParent();
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.node._uiComp === this && (this.node._uiComp = null);
                    }
                }, {
                    key: "updateAssembler",
                    value: function updateAssembler() {}
                }, {
                    key: "postUpdateAssembler",
                    value: function postUpdateAssembler() {}
                }, {
                    key: "_setScreen",
                    value: function _setScreen(value) {
                        this._followScreen = value;
                    }
                }, {
                    key: "_parentChanged",
                    value: function _parentChanged(node) {
                        return node === this.node && (this._updateVisibility(), this._cancelEventFromParent(), 
                        this._lastParent = this.node.parent, this._sortSiblings(), !0);
                    }
                }, {
                    key: "_sortSiblings",
                    value: function _sortSiblings() {
                        var siblings = this.node.parent && this.node.parent.children;
                        siblings && siblings.sort(function(a, b) {
                            var aComp = a._uiComp, bComp = b._uiComp;
                            return (aComp ? aComp.priority : 0) - (bComp ? bComp.priority : 0);
                        });
                    }
                }, {
                    key: "_updateVisibility",
                    value: function _updateVisibility() {
                        for (var parent = this.node; parent; ) {
                            if (parent) {
                                var canvasComp = parent.getComponent(CanvasComponent);
                                if (canvasComp) {
                                    this._followScreen = canvasComp;
                                    break;
                                }
                            }
                            parent = parent.parent;
                        }
                    }
                }, {
                    key: "_cancelEventFromParent",
                    value: function _cancelEventFromParent() {
                        this._lastParent && (this._lastParent.off(SystemEventType.CHILD_REMOVED, this._parentChanged, this), 
                        this._lastParent = null), this._followScreen = null;
                    }
                }, {
                    key: "priority",
                    get: function get() {
                        return this._priority;
                    },
                    set: function set(value) {
                        this._priority !== value && (this._priority = value, this._sortSiblings());
                    }
                }, {
                    key: "visibility",
                    get: function get() {
                        return this._screen ? this._screen.visibility : -1;
                    }
                }, {
                    key: "_screen",
                    get: function get() {
                        return this._followScreen;
                    }
                } ]), UIComponent;
            }()).prototype, "priority", [ property ], Object.getOwnPropertyDescriptor(_class2$t.prototype, "priority"), _class2$t.prototype), 
            _descriptor$r = _applyDecoratedDescriptor(_class2$t.prototype, "_priority", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _class$A = _class2$t)) || _class$A) || _class$A) || _class$A) || _class$A), RenderData = function() {
                function RenderData() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, RenderData);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RenderData)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).vData = null, 
                    _this.uvDirty = !0, _this.vertDirty = !0, _this._datas = [], _this._indices = [], 
                    _this._pivotX = 0, _this._pivotY = 0, _this._width = 0, _this._height = 0, _this;
                }
                return _inherits(RenderData, BaseRenderData), _createClass(RenderData, [ {
                    key: "updateSizeNPivot",
                    value: function updateSizeNPivot(width, height, pivotX, pivotY) {
                        width === this._width && height === this._height && pivotX === this._pivotX && pivotY === this._pivotY || (this._width = width, 
                        this._height = height, this._pivotX = pivotX, this._pivotY = pivotY, this.vertDirty = !0);
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        this._datas.length = 0, this._indices.length = 0, this._pivotX = 0, this._pivotY = 0, 
                        this._width = 0, this._height = 0, this.uvDirty = !0, this.vertDirty = !0, this.material = null, 
                        this.vertexCount = 0, this.indiceCount = 0;
                    }
                }, {
                    key: "dataLength",
                    get: function get() {
                        return this._datas.length;
                    },
                    set: function set(length) {
                        var data = this._datas;
                        if (data.length !== length) {
                            var value = data.length, i = 0;
                            for (i = length; i < value; i++) _dataPool.free(data[i]);
                            for (i = value; i < length; i++) data[i] = _dataPool.alloc();
                            data.length = length;
                        }
                    }
                }, {
                    key: "datas",
                    get: function get() {
                        return this._datas;
                    }
                } ], [ {
                    key: "add",
                    value: function add() {
                        return _pool$1.add();
                    }
                }, {
                    key: "remove",
                    value: function remove(data) {
                        var idx = _pool$1.data.indexOf(data);
                        -1 !== idx && (_pool$1.data[idx].clear(), _pool$1.removeAt(idx));
                    }
                } ]), RenderData;
            }(), IARenderData = function() {
                function IARenderData() {
                    var _getPrototypeOf3, _this2;
                    _classCallCheck(this, IARenderData);
                    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
                    return (_this2 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(IARenderData)).call.apply(_getPrototypeOf3, [ this ].concat(args)))).vData = new Float32Array(2304 * Float32Array.BYTES_PER_ELEMENT), 
                    _this2.iData = new Uint16Array(1536), _this2.vertexStart = 0, _this2.indiceStart = 0, 
                    _this2.byteStart = 0, _this2.byteCount = 0, _this2._formatByte = 9 * Float32Array.BYTES_PER_ELEMENT, 
                    _this2;
                }
                return _inherits(IARenderData, BaseRenderData), _createClass(IARenderData, [ {
                    key: "request",
                    value: function request(vertexCount, indiceCount) {
                        var byteOffset = this.byteCount + vertexCount * this._formatByte, indiceOffset = this.indiceCount + indiceCount;
                        if (65535 < vertexCount + this.vertexCount) return !1;
                        var byteLength = this.vData.byteLength, indiceLength = this.iData.length, vCount = this.vData.length, iCount = this.iData.length;
                        if (byteLength < byteOffset || indiceLength < indiceOffset) {
                            for (;byteLength < byteOffset || indiceLength < indiceOffset; ) byteLength = 4 * (vCount *= 2), 
                            indiceLength = iCount *= 2;
                            var oldvData = new Float32Array(this.vData.buffer);
                            this.vData = new Float32Array(vCount), this.vData.set(oldvData, 0);
                            var oldiData = new Uint16Array(this.iData.buffer);
                            this.iData = new Uint16Array(iCount), this.iData.set(oldiData, 0);
                        }
                        return this.vertexCount += vertexCount, this.indiceCount += indiceCount, this.byteCount = byteOffset, 
                        !0;
                    }
                }, {
                    key: "reset",
                    value: function reset() {
                        this.vertexCount = 0, this.indiceCount = 0, this.byteCount = 0, this.vertexStart = 0, 
                        this.indiceStart = 0, this.byteStart = 0;
                    }
                } ]), IARenderData;
            }(), _dataPool = new Pool$1(function() {
                return {
                    x: 0,
                    y: 0,
                    z: 0,
                    u: 0,
                    v: 0,
                    color: Color.WHITE.clone()
                };
            }, 128), _pool$1 = new RecyclePool(function() {
                return new RenderData();
            }, 32), property$1 = property, RenderableComponent = exports("RenderableComponent", (_dec$B = ccclass("cc.RenderableComponent"), 
            _dec2$i = property$1({
                type: [ Material ]
            }), _dec3$8 = property$1({
                type: Material,
                displayName: "Materials"
            }), _dec4$6 = property$1({
                visible: !1
            }), _dec$B((_descriptor$s = _applyDecoratedDescriptor((_class2$u = function() {
                function RenderableComponent() {
                    var _this;
                    return _classCallCheck(this, RenderableComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(RenderableComponent).call(this)), "_materials", _descriptor$s, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_visFlags", _descriptor2$j, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(RenderableComponent, Component), _createClass(RenderableComponent, [ {
                    key: "getMaterial",
                    value: function getMaterial(idx, argument_1, argument_2) {
                        var inEditor = 1 < arguments.length && void 0 !== argument_1 && argument_1, autoUpdate = 2 < arguments.length && void 0 !== argument_2 && argument_2, mat = this._materials[idx];
                        if (!mat) return null;
                        var instantiated = Material.getInstantiatedMaterial(mat, this, inEditor);
                        return instantiated !== this._materials[idx] && this.setMaterial(instantiated, idx, autoUpdate || !inEditor), 
                        this._materials[idx];
                    }
                }, {
                    key: "getSharedMaterial",
                    value: function getSharedMaterial(idx) {
                        return idx < 0 || idx >= this._materials.length ? null : this._materials[idx];
                    }
                }, {
                    key: "setMaterial",
                    value: function setMaterial(material, index, argument_2) {
                        var notify = !(2 < arguments.length && void 0 !== argument_2) || argument_2;
                        this._materials[index] = material, notify && this._onMaterialModified(index, material);
                    }
                }, {
                    key: "_getModel",
                    value: function _getModel() {
                        return null;
                    }
                }, {
                    key: "recreateModel",
                    value: function recreateModel() {}
                }, {
                    key: "_onMaterialModified",
                    value: function _onMaterialModified() {}
                }, {
                    key: "_onRebuildPSO",
                    value: function _onRebuildPSO() {}
                }, {
                    key: "_clearMaterials",
                    value: function _clearMaterials() {}
                }, {
                    key: "_onVisiblityChange",
                    value: function _onVisiblityChange() {}
                }, {
                    key: "sharedMaterials",
                    get: function get() {
                        return this._materials.slice();
                    },
                    set: function set(val) {
                        for (var i = 0; i < val.length; i++) val[i] !== this._materials[i] && this.setMaterial(val[i], i);
                        if (val.length < this._materials.length) {
                            for (var _i = val.length; _i < this._materials.length; _i++) this.setMaterial(null, _i);
                            this._materials.splice(val.length);
                        }
                    }
                }, {
                    key: "materials",
                    get: function get() {
                        for (var i = 0; i < this._materials.length; i++) this._materials[i] = this.getMaterial(i);
                        return this._materials;
                    },
                    set: function set(val) {
                        var dLen = val.length - this._materials.length;
                        if (0 < dLen) this._materials = this._materials.concat(new Array(dLen).fill(null)); else if (dLen < 0) {
                            for (var i = -dLen; i < this._materials.length; ++i) this.setMaterial(null, i);
                            this._materials = this._materials.splice(-dLen);
                        }
                    }
                }, {
                    key: "material",
                    get: function get() {
                        return this.getMaterial(0);
                    },
                    set: function set(val) {
                        1 === this._materials.length && this._materials[0] === val || this.setMaterial(val, 0);
                    }
                }, {
                    key: "sharedMaterial",
                    get: function get() {
                        return this.getSharedMaterial(0);
                    }
                }, {
                    key: "visibility",
                    get: function get() {
                        return this._visFlags;
                    },
                    set: function set(val) {
                        this._visFlags = val, this._onVisiblityChange(val);
                    }
                } ]), RenderableComponent;
            }()).prototype, "_materials", [ _dec2$i ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor2$j = _applyDecoratedDescriptor(_class2$u.prototype, "_visFlags", [ property$1 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Layers.Enum.NONE;
                }
            }), _applyDecoratedDescriptor(_class2$u.prototype, "sharedMaterials", [ _dec3$8 ], Object.getOwnPropertyDescriptor(_class2$u.prototype, "sharedMaterials"), _class2$u.prototype), 
            _applyDecoratedDescriptor(_class2$u.prototype, "visibility", [ _dec4$6 ], Object.getOwnPropertyDescriptor(_class2$u.prototype, "visibility"), _class2$u.prototype), 
            _class$B = _class2$u)) || _class$B));
            ccenum(GFXBlendFactor), function(InstanceMaterialType) {
                InstanceMaterialType[InstanceMaterialType.ADDCOLOR = 0] = "ADDCOLOR", InstanceMaterialType[InstanceMaterialType.ADDCOLORANDTEXTURE = 1] = "ADDCOLORANDTEXTURE";
            }(InstanceMaterialType = InstanceMaterialType || exports("InstanceMaterialType", {}));
            var _dec$D, _dec2$k, _dec3$a, _dec4$8, _dec5$7, _class$D, _class2$w, _descriptor$u, _descriptor2$l, _descriptor3$e, _descriptor4$b, _class3$e, _temp$y, UIRenderComponent = exports("UIRenderComponent", (_dec$C = ccclass("cc.UIRenderComponent"), 
            _dec2$j = executionOrder(110), _dec3$9 = requireComponent(UITransformComponent), 
            _dec4$7 = property({
                type: GFXBlendFactor,
                displayOrder: 0
            }), _dec5$6 = property({
                type: GFXBlendFactor,
                displayOrder: 1
            }), _dec6$5 = property({
                displayOrder: 2
            }), _dec7$4 = property({
                type: Material,
                displayOrder: 3
            }), _dec$C(_class$C = _dec2$j(_class$C = _dec3$9(_class$C = executeInEditMode((_temp$x = _class3$d = function() {
                function UIRenderComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, UIRenderComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIRenderComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_srcBlendFactor", _descriptor$t, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_dstBlendFactor", _descriptor2$k, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_color", _descriptor3$d, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_sharedMaterial", _descriptor4$a, _assertThisInitialized(_this)), 
                    _this._assembler = null, _this._postAssembler = null, _this._renderData = null, 
                    _this._renderDataFlag = !0, _this._renderFlag = !0, _this._material = null, _this._instanceMaterialType = InstanceMaterialType.ADDCOLORANDTEXTURE, 
                    _this._blendTemplate = {
                        blendState: {
                            targets: [ {
                                blendSrc: GFXBlendFactor.SRC_ALPHA,
                                blendDst: GFXBlendFactor.ONE_MINUS_SRC_ALPHA
                            } ]
                        },
                        depthStencilState: {},
                        rasterizerState: {}
                    }, _this._simulate = !1, _this;
                }
                return _inherits(UIRenderComponent, UIComponent), _createClass(UIRenderComponent, [ {
                    key: "__preload",
                    value: function __preload() {
                        _get(_getPrototypeOf(UIRenderComponent.prototype), "__preload", this).call(this), 
                        this._instanceMaterial(), this._flushAssembler && this._flushAssembler();
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        _get(_getPrototypeOf(UIRenderComponent.prototype), "onEnable", this).call(this), 
                        this.node.on(SystemEventType.ANCHOR_CHANGED, this._nodeStateChange, this), this.node.on(SystemEventType.SIZE_CHANGED, this._nodeStateChange, this), 
                        this._renderFlag = this._canRender();
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        _get(_getPrototypeOf(UIRenderComponent.prototype), "onDisable", this).call(this), 
                        this.node.off(SystemEventType.ANCHOR_CHANGED, this._nodeStateChange, this), this.node.off(SystemEventType.SIZE_CHANGED, this._nodeStateChange, this), 
                        this._renderFlag = !1;
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        _get(_getPrototypeOf(UIRenderComponent.prototype), "onDestroy", this).call(this), 
                        this.destroyRenderData(), this._material && this._material.destroy(), this._updateMaterial(null), 
                        this._renderData = null;
                    }
                }, {
                    key: "markForUpdateRenderData",
                    value: function markForUpdateRenderData(argument_0) {
                        var enable = !(0 < arguments.length && void 0 !== argument_0) || argument_0;
                        if (this._renderFlag = this._canRender(), enable && this._renderFlag) {
                            var renderData = this._renderData;
                            renderData && (renderData.vertDirty = !0), this._renderDataFlag = enable;
                        } else enable || (this._renderDataFlag = enable);
                    }
                }, {
                    key: "requestRenderData",
                    value: function requestRenderData() {
                        var data = RenderData.add();
                        return this._renderData = data;
                    }
                }, {
                    key: "destroyRenderData",
                    value: function destroyRenderData() {
                        this._renderData && (RenderData.remove(this._renderData), this._renderData = null);
                    }
                }, {
                    key: "updateAssembler",
                    value: function updateAssembler(render) {
                        _get(_getPrototypeOf(UIRenderComponent.prototype), "updateAssembler", this).call(this, render), 
                        this._renderFlag && (this._checkAndUpdateRenderData(), this._render(render));
                    }
                }, {
                    key: "postUpdateAssembler",
                    value: function postUpdateAssembler(render) {
                        _get(_getPrototypeOf(UIRenderComponent.prototype), "postUpdateAssembler", this).call(this, render), 
                        this._renderFlag && this._postRender(render);
                    }
                }, {
                    key: "_render",
                    value: function _render() {}
                }, {
                    key: "_postRender",
                    value: function _postRender() {}
                }, {
                    key: "_checkAndUpdateRenderData",
                    value: function _checkAndUpdateRenderData() {
                        this._renderDataFlag && (this._assembler.updateRenderData(this), this._renderDataFlag = !1);
                    }
                }, {
                    key: "_canRender",
                    value: function _canRender() {
                        return null !== this.material && this.enabled && (!!this._simulate || this.enabledInHierarchy);
                    }
                }, {
                    key: "_postCanRender",
                    value: function _postCanRender() {}
                }, {
                    key: "_updateColor",
                    value: function _updateColor() {
                        this._assembler && this._assembler.updateColor && this._assembler.updateColor(this);
                    }
                }, {
                    key: "_updateMaterial",
                    value: function _updateMaterial(material) {
                        this._material = material, this._updateBlendFunc();
                    }
                }, {
                    key: "_updateBlendFunc",
                    value: function _updateBlendFunc() {
                        if (this._material) {
                            var target = this._blendTemplate.blendState.targets[0];
                            target.blendDst === this._dstBlendFactor && target.blendSrc === this._srcBlendFactor || (target.blendDst = this._dstBlendFactor, 
                            target.blendSrc = this._srcBlendFactor, this._blendTemplate.depthStencilState = this._material.passes[0].depthStencilState, 
                            this._blendTemplate.rasterizerState = this._material.passes[0].rasterizerState, 
                            this._material.overridePipelineStates(this._blendTemplate, 0));
                        }
                    }
                }, {
                    key: "_nodeStateChange",
                    value: function _nodeStateChange() {
                        this._renderData && this.markForUpdateRenderData();
                        var _iterator = this.node.children, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var renderComp = _ref.getComponent(UIRenderComponent);
                            renderComp && renderComp.markForUpdateRenderData();
                        }
                    }
                }, {
                    key: "_instanceMaterial",
                    value: function _instanceMaterial() {
                        var mat = null;
                        if (this._sharedMaterial) mat = Material.getInstantiatedMaterial(this._sharedMaterial, new RenderableComponent(), !1); else switch (this._instanceMaterialType) {
                          case InstanceMaterialType.ADDCOLOR:
                            mat = Material.getInstantiatedMaterial(cc.builtinResMgr.get("ui-base-material"), new RenderableComponent(), !1);
                            break;

                          case InstanceMaterialType.ADDCOLORANDTEXTURE:
                            mat = Material.getInstantiatedMaterial(cc.builtinResMgr.get("ui-sprite-material"), new RenderableComponent(), !1);
                        }
                        this._updateMaterial(mat);
                    }
                }, {
                    key: "srcBlendFactor",
                    get: function get() {
                        return this._srcBlendFactor;
                    },
                    set: function set(value) {
                        this._srcBlendFactor !== value && (this._srcBlendFactor = value, this._updateBlendFunc());
                    }
                }, {
                    key: "dstBlendFactor",
                    get: function get() {
                        return this._dstBlendFactor;
                    },
                    set: function set(value) {
                        this._dstBlendFactor !== value && (this._dstBlendFactor = value, this._updateBlendFunc());
                    }
                }, {
                    key: "color",
                    get: function get() {
                        return this._color;
                    },
                    set: function set(value) {
                        this._color !== value && (this._color.set(value), this._updateColor(), this.markForUpdateRenderData());
                    }
                }, {
                    key: "sharedMaterial",
                    get: function get() {
                        return this._sharedMaterial;
                    },
                    set: function set(value) {
                        this._sharedMaterial !== value && (this._sharedMaterial = value, this._instanceMaterial && this._instanceMaterial());
                    }
                }, {
                    key: "material",
                    get: function get() {
                        return this._material || this._instanceMaterial && this._instanceMaterial(), this._material;
                    }
                }, {
                    key: "renderData",
                    get: function get() {
                        return this._renderData;
                    }
                }, {
                    key: "simulate",
                    set: function set(value) {
                        this._simulate = value;
                    }
                } ]), UIRenderComponent;
            }(), _class3$d.BlendState = GFXBlendFactor, _class3$d.Assembler = null, _class3$d.PostAssembler = null, 
            _applyDecoratedDescriptor((_class2$v = _temp$x).prototype, "srcBlendFactor", [ _dec4$7 ], Object.getOwnPropertyDescriptor(_class2$v.prototype, "srcBlendFactor"), _class2$v.prototype), 
            _applyDecoratedDescriptor(_class2$v.prototype, "dstBlendFactor", [ _dec5$6 ], Object.getOwnPropertyDescriptor(_class2$v.prototype, "dstBlendFactor"), _class2$v.prototype), 
            _applyDecoratedDescriptor(_class2$v.prototype, "color", [ _dec6$5 ], Object.getOwnPropertyDescriptor(_class2$v.prototype, "color"), _class2$v.prototype), 
            _applyDecoratedDescriptor(_class2$v.prototype, "sharedMaterial", [ _dec7$4 ], Object.getOwnPropertyDescriptor(_class2$v.prototype, "sharedMaterial"), _class2$v.prototype), 
            _descriptor$t = _applyDecoratedDescriptor(_class2$v.prototype, "_srcBlendFactor", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return GFXBlendFactor.SRC_ALPHA;
                }
            }), _descriptor2$k = _applyDecoratedDescriptor(_class2$v.prototype, "_dstBlendFactor", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return GFXBlendFactor.ONE_MINUS_SRC_ALPHA;
                }
            }), _descriptor3$d = _applyDecoratedDescriptor(_class2$v.prototype, "_color", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Color.WHITE.clone();
                }
            }), _descriptor4$a = _applyDecoratedDescriptor(_class2$v.prototype, "_sharedMaterial", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _class$C = _class2$v)) || _class$C) || _class$C) || _class$C) || _class$C));
            cc.UIRenderComponent = UIRenderComponent, removeProperty(UIComponent.prototype, "UIComponent", [ {
                name: "_visibility"
            }, {
                name: "setVisibility"
            } ]);
            var _dec$E, _dec2$l, _dec3$b, _dec4$9, _dec5$8, _dec6$6, _dec7$5, _class$E, _class2$x, _descriptor$v, _descriptor2$m, _dec$F, _dec2$m, _dec3$c, _dec4$a, _dec5$9, _class$F, _class2$y, _descriptor$w, _descriptor2$n, _descriptor3$f, _descriptor4$c, _descriptor5$9, _dec6$7, _dec7$6, _dec8$2, _dec9$2, _dec10$2, _dec11$1, _dec12$1, _class4$2, _class5$2, _descriptor6$3, _descriptor7$3, _descriptor8$3, _dec$G, _dec2$n, _class$G, _class2$z, _descriptor$x, _descriptor2$o, _descriptor3$g, _class3$f, _temp$B, _dec$H, _dec2$o, _dec3$d, _class$H, _class2$A, _descriptor$y, _class$I, _dec$J, _dec2$p, _dec3$e, _dec4$b, _dec5$a, _class$J, _class2$B, _descriptor$z, _descriptor2$p, _descriptor3$h, _descriptor4$d, _dec$K, _dec2$q, _dec3$f, _dec4$c, _dec5$b, _dec6$8, _class$K, _class2$C, _descriptor$A, _descriptor2$q, _descriptor3$i, _descriptor4$e, _descriptor5$a, ModelShadowCastingMode = Enum({
                OFF: 0,
                ON: 1
            }), ModelComponent = exports("ModelComponent", (_dec$D = ccclass("cc.ModelComponent"), 
            _dec2$k = executionOrder(100), _dec3$a = menu("Components/Model"), _dec4$8 = property({
                type: Mesh
            }), _dec5$7 = property({
                type: ModelShadowCastingMode
            }), _dec$D(_class$D = _dec2$k(_class$D = _dec3$a(_class$D = executeInEditMode((_temp$y = _class3$e = function() {
                function ModelComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, ModelComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ModelComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._model = null, 
                    _initializerDefineProperty(_this, "_enableDynamicBatching", _descriptor$u, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_mesh", _descriptor2$l, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_shadowCastingMode", _descriptor3$e, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_receiveShadows", _descriptor4$b, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(ModelComponent, RenderableComponent), _createClass(ModelComponent, [ {
                    key: "onLoad",
                    value: function onLoad() {
                        this._updateModels(), this._updateCastShadow(), this._updateReceiveShadow();
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        this._model && (this._model.inited || this._updateModels(), this._model.enabled = !0);
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this._model && (this._model.enabled = !1);
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this._model && (this._model.scene.destroyModel(this._model), this._model = null);
                    }
                }, {
                    key: "_getModel",
                    value: function _getModel() {
                        return this._model;
                    }
                }, {
                    key: "recreateModel",
                    value: function recreateModel() {
                        this.isValid && (this._model && (this._model.destroy(), this._model.scene.destroyModel(this._model), 
                        this._model = null), this._updateModels());
                    }
                }, {
                    key: "_updateModels",
                    value: function _updateModels() {
                        if (this.enabledInHierarchy && this._mesh && (this._model && this._model.inited ? this._model.destroy() : this._createModel(), 
                        this._model.createBoundingShape(this._mesh.minPosition, this._mesh.maxPosition), 
                        this._updateModelParams(), this._model && (this._model.enabled = !0, this._model.isDynamicBatching = this._enableDynamicBatching, 
                        this._enableDynamicBatching))) {
                            this._mesh.hasFlatBuffers || this._mesh.createFlatBuffers();
                            for (var i = 0; i < this._model.subModels.length; ++i) for (var subModel = this._model.subModels[i], p = 0; p < subModel.passes.length; ++p) {
                                var pass = subModel.passes[p];
                                pass.batchedBuffer || pass.createBatchedBuffer();
                            }
                        }
                    }
                }, {
                    key: "_createModel",
                    value: function _createModel() {
                        if (this.node.scene) {
                            var scene = this._getRenderScene();
                            this._model = scene.createModel(this._getModelConstructor(), this.node), this._model.visFlags = this.visibility;
                        }
                    }
                }, {
                    key: "_getModelConstructor",
                    value: function _getModelConstructor() {
                        return Model;
                    }
                }, {
                    key: "_updateModelParams",
                    value: function _updateModelParams() {
                        if (this._mesh && this._model) {
                            this.node.hasChangedFlags = this._model.transform.hasChangedFlags = TransformDirtyBit.POSITION;
                            for (var meshCount = this._mesh ? this._mesh.subMeshCount : 0, i = 0; i < meshCount; ++i) {
                                var material = this.getSharedMaterial(i), renderingMesh = this._mesh.renderingMesh;
                                if (renderingMesh) {
                                    var subMeshData = renderingMesh.getSubmesh(i);
                                    subMeshData && this._model.initSubModel(i, subMeshData, material || this._getBuiltinMaterial());
                                }
                            }
                        }
                    }
                }, {
                    key: "_onMaterialModified",
                    value: function _onMaterialModified(idx, material) {
                        if (null != this._model && (this._onRebuildPSO(idx, material || this._getBuiltinMaterial()), 
                        this._enableDynamicBatching && material)) for (var p = 0; p < material.passes.length; ++p) {
                            var pass = material.passes[p];
                            pass.batchedBuffer || pass.createBatchedBuffer();
                        }
                    }
                }, {
                    key: "_onRebuildPSO",
                    value: function _onRebuildPSO(idx, material) {
                        this._model && this._model.setSubModelMaterial(idx, material);
                    }
                }, {
                    key: "_onMeshChanged",
                    value: function _onMeshChanged() {}
                }, {
                    key: "_clearMaterials",
                    value: function _clearMaterials() {
                        if (null != this._model) for (var i = 0; i < this._model.subModelNum; ++i) this._onMaterialModified(i, null);
                    }
                }, {
                    key: "_getBuiltinMaterial",
                    value: function _getBuiltinMaterial() {
                        return builtinResMgr.get("missing-material");
                    }
                }, {
                    key: "_onVisiblityChange",
                    value: function _onVisiblityChange(val) {
                        this._model && (this._model.visFlags = val);
                    }
                }, {
                    key: "_updateCastShadow",
                    value: function _updateCastShadow() {
                        this._model && (this._shadowCastingMode === ModelShadowCastingMode.OFF ? this._model.castShadow = !1 : this._shadowCastingMode === ModelShadowCastingMode.ON ? this._model.castShadow = !0 : console.warn("ShadowCastingMode ".concat(this._shadowCastingMode, " is not supported.")));
                    }
                }, {
                    key: "_updateReceiveShadow",
                    value: function _updateReceiveShadow() {
                        this.enabledInHierarchy && this._model;
                    }
                }, {
                    key: "mesh",
                    get: function get() {
                        return this._mesh;
                    },
                    set: function set(val) {
                        var old = this._mesh;
                        this._mesh = val, this._onMeshChanged(old), this._updateModels();
                    }
                }, {
                    key: "shadowCastingMode",
                    get: function get() {
                        return this._shadowCastingMode;
                    },
                    set: function set(val) {
                        this._shadowCastingMode = val, this._updateCastShadow();
                    }
                }, {
                    key: "receiveShadows",
                    get: function get() {
                        return this._receiveShadows;
                    },
                    set: function set(val) {
                        this._receiveShadows = val, this._updateReceiveShadow();
                    }
                }, {
                    key: "model",
                    get: function get() {
                        return this._model;
                    }
                }, {
                    key: "enableDynamicBatching",
                    set: function set(enable) {
                        if (this._enableDynamicBatching = enable, this._mesh && (enable ? this._mesh.createFlatBuffers() : this._mesh.destroyFlatBuffers()), 
                        this._model) if (this._model.isDynamicBatching = enable, this._model.isDynamicBatching) for (var i = 0; i < this._model.subModels.length; ++i) for (var subModel = this._model.subModels[i], p = 0; p < subModel.passes.length; ++p) {
                            var pass = subModel.passes[p];
                            pass.batchedBuffer || pass.createBatchedBuffer();
                        } else for (var _i = 0; _i < this._model.subModels.length; ++_i) for (var _subModel = this._model.subModels[_i], _p = 0; _p < _subModel.passes.length; ++_p) {
                            var _pass = _subModel.passes[_p];
                            _pass.batchedBuffer && _pass.clearBatchedBuffer();
                        }
                    },
                    get: function get() {
                        return this._enableDynamicBatching;
                    }
                } ]), ModelComponent;
            }(), _class3$e.ShadowCastingMode = ModelShadowCastingMode, _applyDecoratedDescriptor((_class2$w = _temp$y).prototype, "mesh", [ _dec4$8 ], Object.getOwnPropertyDescriptor(_class2$w.prototype, "mesh"), _class2$w.prototype), 
            _applyDecoratedDescriptor(_class2$w.prototype, "shadowCastingMode", [ _dec5$7 ], Object.getOwnPropertyDescriptor(_class2$w.prototype, "shadowCastingMode"), _class2$w.prototype), 
            _applyDecoratedDescriptor(_class2$w.prototype, "enableDynamicBatching", [ property ], Object.getOwnPropertyDescriptor(_class2$w.prototype, "enableDynamicBatching"), _class2$w.prototype), 
            _descriptor$u = _applyDecoratedDescriptor(_class2$w.prototype, "_enableDynamicBatching", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor2$l = _applyDecoratedDescriptor(_class2$w.prototype, "_mesh", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor3$e = _applyDecoratedDescriptor(_class2$w.prototype, "_shadowCastingMode", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return ModelShadowCastingMode.OFF;
                }
            }), _descriptor4$b = _applyDecoratedDescriptor(_class2$w.prototype, "_receiveShadows", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _class$D = _class2$w)) || _class$D) || _class$D) || _class$D) || _class$D)), SkinningModelComponent = exports("SkinningModelComponent", (_dec$E = ccclass("cc.SkinningModelComponent"), 
            _dec2$l = executionOrder(100), _dec3$b = menu("Components/SkinningModel"), _dec4$9 = property(Skeleton), 
            _dec5$8 = property(Node$1), _dec6$6 = property({
                type: Skeleton
            }), _dec7$5 = property({
                type: Node$1
            }), _dec$E(_class$E = _dec2$l(_class$E = executeInEditMode(_class$E = _dec3$b((_descriptor$v = _applyDecoratedDescriptor((_class2$x = function() {
                function SkinningModelComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, SkinningModelComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SkinningModelComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_skeleton", _descriptor$v, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_skinningRoot", _descriptor2$m, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(SkinningModelComponent, ModelComponent), _createClass(SkinningModelComponent, [ {
                    key: "uploadAnimation",
                    value: function uploadAnimation(clip) {
                        this._model && this._model.uploadAnimation(clip);
                    }
                }, {
                    key: "_updateModelParams",
                    value: function _updateModelParams() {
                        this._update(), _get(_getPrototypeOf(SkinningModelComponent.prototype), "_updateModelParams", this).call(this);
                    }
                }, {
                    key: "_onMaterialModified",
                    value: function _onMaterialModified(index) {
                        var type = selectJointsMediumType(director.root.device), mat = this.getMaterial(index) || this._getBuiltinMaterial();
                        mat.recompileShaders({
                            CC_USE_SKINNING: type
                        }), _get(_getPrototypeOf(SkinningModelComponent.prototype), "_onMaterialModified", this).call(this, index, mat);
                    }
                }, {
                    key: "_getModelConstructor",
                    value: function _getModelConstructor() {
                        return SkinningModel;
                    }
                }, {
                    key: "_getBuiltinMaterial",
                    value: function _getBuiltinMaterial() {
                        return builtinResMgr.get("missing-skinning-material");
                    }
                }, {
                    key: "_update",
                    value: function _update() {
                        var _this2 = this;
                        this._model && this._model.bindSkeleton(this._skeleton, this._skinningRoot), this._materials.forEach(function(material, index) {
                            return material && _this2._onMaterialModified(index, material);
                        });
                    }
                }, {
                    key: "skeleton",
                    get: function get() {
                        return this._skeleton;
                    },
                    set: function set(val) {
                        this._skeleton = val, this._update();
                    }
                }, {
                    key: "skinningRoot",
                    get: function get() {
                        return this._skinningRoot;
                    },
                    set: function set(value) {
                        this._skinningRoot = value, this._update();
                    }
                }, {
                    key: "model",
                    get: function get() {
                        return this._model;
                    }
                } ]), SkinningModelComponent;
            }()).prototype, "_skeleton", [ _dec4$9 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor2$m = _applyDecoratedDescriptor(_class2$x.prototype, "_skinningRoot", [ _dec5$8 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _applyDecoratedDescriptor(_class2$x.prototype, "skeleton", [ _dec6$6 ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "skeleton"), _class2$x.prototype), 
            _applyDecoratedDescriptor(_class2$x.prototype, "skinningRoot", [ _dec7$5 ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "skinningRoot"), _class2$x.prototype), 
            _class$E = _class2$x)) || _class$E) || _class$E) || _class$E) || _class$E)), batch_id = {
                name: GFXAttributeName.ATTR_BATCH_ID,
                format: GFXFormat.R32F,
                isNormalized: !1
            }, batch_uv = {
                name: GFXAttributeName.ATTR_BATCH_UV,
                format: GFXFormat.RG32F,
                isNormalized: !1
            }, batch_extras_size = GFXFormatInfos[batch_id.format].size + GFXFormatInfos[batch_uv.format].size, SkinningModelUnit = exports("SkinningModelUnit", (_dec$F = ccclass("cc.SkinningModelUnit"), 
            _dec2$m = property(Mesh), _dec3$c = property(Skeleton), _dec4$a = property(Material), 
            _dec5$9 = property({
                type: SkinningModelComponent
            }), _dec$F((_descriptor$w = _applyDecoratedDescriptor((_class2$y = function() {
                function SkinningModelUnit() {
                    _classCallCheck(this, SkinningModelUnit), _initializerDefineProperty(this, "mesh", _descriptor$w, this), 
                    _initializerDefineProperty(this, "skeleton", _descriptor2$n, this), _initializerDefineProperty(this, "material", _descriptor3$f, this), 
                    _initializerDefineProperty(this, "_offset", _descriptor4$c, this), _initializerDefineProperty(this, "_size", _descriptor5$9, this);
                }
                return _createClass(SkinningModelUnit, [ {
                    key: "offset",
                    set: function set(offset) {
                        Vec2.copy(this._offset, offset);
                    },
                    get: function get() {
                        return this._offset;
                    }
                }, {
                    key: "size",
                    set: function set(size) {
                        Vec2.copy(this._size, size);
                    },
                    get: function get() {
                        return this._size;
                    }
                }, {
                    key: "copyFrom",
                    set: function set(comp) {
                        comp && (this.mesh = comp.mesh, this.skeleton = comp.skeleton, this.material = comp.getSharedMaterial(0));
                    },
                    get: function get() {
                        return null;
                    }
                } ]), SkinningModelUnit;
            }()).prototype, "mesh", [ _dec2$m ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor2$n = _applyDecoratedDescriptor(_class2$y.prototype, "skeleton", [ _dec3$c ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor3$f = _applyDecoratedDescriptor(_class2$y.prototype, "material", [ _dec4$a ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor4$c = _applyDecoratedDescriptor(_class2$y.prototype, "_offset", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec2(0, 0);
                }
            }), _descriptor5$9 = _applyDecoratedDescriptor(_class2$y.prototype, "_size", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec2(1, 1);
                }
            }), _applyDecoratedDescriptor(_class2$y.prototype, "offset", [ property ], Object.getOwnPropertyDescriptor(_class2$y.prototype, "offset"), _class2$y.prototype), 
            _applyDecoratedDescriptor(_class2$y.prototype, "size", [ property ], Object.getOwnPropertyDescriptor(_class2$y.prototype, "size"), _class2$y.prototype), 
            _applyDecoratedDescriptor(_class2$y.prototype, "copyFrom", [ _dec5$9 ], Object.getOwnPropertyDescriptor(_class2$y.prototype, "copyFrom"), _class2$y.prototype), 
            _class$F = _class2$y)) || _class$F)), BatchedSkinningModelComponent = exports("BatchedSkinningModelComponent", (_dec6$7 = ccclass("cc.BatchedSkinningModelComponent"), 
            _dec7$6 = executionOrder(100), _dec8$2 = menu("Components/BatchedSkinningModel"), 
            _dec9$2 = property({
                type: [ CCString ]
            }), _dec10$2 = property({
                type: [ SkinningModelUnit ]
            }), _dec11$1 = property({
                override: !0,
                visible: !1
            }), _dec12$1 = property({
                override: !0,
                visible: !1
            }), _dec6$7(_class4$2 = _dec7$6(_class4$2 = executeInEditMode(_class4$2 = _dec8$2((_descriptor6$3 = _applyDecoratedDescriptor((_class5$2 = function() {
                function BatchedSkinningModelComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, BatchedSkinningModelComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(BatchedSkinningModelComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "atlasSize", _descriptor6$3, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "batchableTextureNames", _descriptor7$3, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "units", _descriptor8$3, _assertThisInitialized(_this)), 
                    _this._textures = {}, _this._batchMaterial = null, _this;
                }
                return _inherits(BatchedSkinningModelComponent, SkinningModelComponent), _createClass(BatchedSkinningModelComponent, [ {
                    key: "onLoad",
                    value: function onLoad() {
                        _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "onLoad", this).call(this), 
                        this.cook();
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        for (var _i = 0, _Object$keys = Object.keys(this._textures); _i < _Object$keys.length; _i++) {
                            var tex = _Object$keys[_i];
                            this._textures[tex].destroy();
                        }
                        this._textures = {}, this._mesh && (this._mesh.destroy(), this._mesh = null), _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "onDestroy", this).call(this);
                    }
                }, {
                    key: "cook",
                    value: function cook() {
                        this.cookMaterials(), this.cookSkeletons(), this.cookMeshes();
                    }
                }, {
                    key: "cookMaterials",
                    value: function cookMaterials() {
                        var _this2 = this;
                        this._batchMaterial || (this._batchMaterial = this.getSharedMaterial(0));
                        var mat = this.getMaterial(0);
                        if (mat && this._batchMaterial && this._batchMaterial.effectAsset) {
                            mat.copy(this._batchMaterial), this.resizeAtlases();
                            for (var tech = mat.effectAsset.techniques[mat.technique], _loop = function _loop(i) {
                                var pass = tech.passes[i];
                                if (!pass.properties) return "continue";
                                for (var _loop2 = function _loop2() {
                                    var prop = _Object$keys2[_i2];
                                    if (pass.properties[prop].type >= GFXType.SAMPLER1D) {
                                        var tex = null;
                                        _this2.batchableTextureNames.find(function(n) {
                                            return n === prop;
                                        }) ? (tex = (tex = _this2._textures[prop]) || _this2.createTexture(prop), _this2.cookTextures(tex, prop, i)) : _this2.units.some(function(u) {
                                            return tex = u.material && u.material.getProperty(prop, i);
                                        }), tex && mat.setProperty(prop, tex, i);
                                    } else {
                                        var value = [], _iterator = _this2.units, _isArray = Array.isArray(_iterator), _i3 = 0;
                                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                            var _ref;
                                            if (_isArray) {
                                                if (_i3 >= _iterator.length) break;
                                                _ref = _iterator[_i3++];
                                            } else {
                                                if ((_i3 = _iterator.next()).done) break;
                                                _ref = _i3.value;
                                            }
                                            var unit = _ref;
                                            unit.material && value.push(unit.material.getProperty(prop.slice(0, -3), i));
                                        }
                                        mat.setProperty(prop, value, i);
                                    }
                                }, _i2 = 0, _Object$keys2 = Object.keys(pass.properties); _i2 < _Object$keys2.length; _i2++) _loop2();
                            }, i = 0; i < tech.passes.length; i++) _loop(i);
                        } else console.warn("incomplete batch material!");
                    }
                }, {
                    key: "cookSkeletons",
                    value: function cookSkeletons() {
                        if (this._skinningRoot) {
                            var skeleton = new Skeleton(), bindposes = [], _iterator2 = this.units, _isArray2 = Array.isArray(_iterator2), _i4 = 0;
                            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                                var _ref2;
                                if (_isArray2) {
                                    if (_i4 >= _iterator2.length) break;
                                    _ref2 = _iterator2[_i4++];
                                } else {
                                    if ((_i4 = _iterator2.next()).done) break;
                                    _ref2 = _i4.value;
                                }
                                var unit = _ref2;
                                if (unit && unit.skeleton) for (var partial = unit.skeleton, _loop3 = function _loop3(i) {
                                    var path = partial.joints[i];
                                    if (0 <= skeleton.joints.findIndex(function(p) {
                                        return p === path;
                                    })) return "continue";
                                    skeleton.joints.push(path), bindposes.push(partial.bindposes[i] || new Mat4());
                                }, i = 0; i < partial.joints.length; i++) _loop3(i);
                            }
                            var idxMap = Array.from(Array(skeleton.joints.length).keys()).sort(function(a, b) {
                                return skeleton.joints[a] > skeleton.joints[b] ? 1 : skeleton.joints[a] < skeleton.joints[b] ? -1 : 0;
                            });
                            skeleton.joints = skeleton.joints.map(function(_, idx, arr) {
                                return arr[idxMap[idx]];
                            }), skeleton.bindposes = bindposes.map(function(_, idx, arr) {
                                return arr[idxMap[idx]];
                            }), this._skeleton && this._skeleton.destroy(), this.skeleton = skeleton;
                        } else console.warn("no skinning root specified!");
                    }
                }, {
                    key: "cookMeshes",
                    value: function cookMeshes() {
                        var _this3 = this, isValid = !1, _iterator3 = this.units, _isArray3 = Array.isArray(_iterator3), _i5 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i5 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i5++];
                            } else {
                                if ((_i5 = _iterator3.next()).done) break;
                                _ref3 = _i5.value;
                            }
                            if (_ref3.mesh) {
                                isValid = !0;
                                break;
                            }
                        }
                        if (this._mesh ? this._mesh.destroyRenderingMesh() : this._mesh = new Mesh(), isValid && this._skinningRoot) {
                            for (var dataView, uvOffset = 0, uvFormat = GFXFormat.UNKNOWN, jointOffset = 0, jointFormat = GFXFormat.UNKNOWN, jointIndexMap = new Array(this.units.length), unitLen = this.units.length, i = 0; i < unitLen; i++) {
                                var unit = this.units[i];
                                unit && unit.skeleton && (jointIndexMap[i] = unit.skeleton.joints.map(function(j) {
                                    return _this3._skeleton.joints.findIndex(function(ref) {
                                        return j === ref;
                                    });
                                }));
                            }
                            for (var _loop4 = function _loop4(_i6) {
                                var unit = _this3.units[_i6];
                                if (!unit || !unit.mesh || !unit.mesh.data) return "continue";
                                var newMeshStruct = JSON.parse(JSON.stringify(unit.mesh.struct)), newOffset = 0, _iterator4 = newMeshStruct.vertexBundles, _isArray4 = Array.isArray(_iterator4), _i7 = 0;
                                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                                    var _ref4;
                                    if (_isArray4) {
                                        if (_i7 >= _iterator4.length) break;
                                        _ref4 = _iterator4[_i7++];
                                    } else {
                                        if ((_i7 = _iterator4.next()).done) break;
                                        _ref4 = _i7.value;
                                    }
                                    var vb = _ref4;
                                    vb.attributes.push(batch_id), vb.attributes.push(batch_uv), vb.view.offset = newOffset, 
                                    vb.view.length += vb.view.count * batch_extras_size, vb.view.stride += batch_extras_size, 
                                    newOffset += vb.view.length;
                                }
                                var _iterator5 = newMeshStruct.primitives, _isArray5 = Array.isArray(_iterator5), _i8 = 0;
                                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                                    var _ref5;
                                    if (_isArray5) {
                                        if (_i8 >= _iterator5.length) break;
                                        _ref5 = _iterator5[_i8++];
                                    } else {
                                        if ((_i8 = _iterator5.next()).done) break;
                                        _ref5 = _i8.value;
                                    }
                                    var pm = _ref5;
                                    pm.indexView && (pm.indexView.offset = newOffset, newOffset += pm.indexView.length), 
                                    pm.geometricInfo && (newOffset = 4 * Math.ceil(newOffset / 4), pm.geometricInfo.view.offset = newOffset, 
                                    newOffset += pm.geometricInfo.view.length);
                                }
                                var src = unit.mesh.data, oldOffset = 0, newMeshData = new Uint8Array(newOffset);
                                dataView = new DataView(newMeshData.buffer);
                                for (var k = 0; k < newMeshStruct.vertexBundles.length; k++) {
                                    var uvs = unit.mesh.readAttribute(k, GFXAttributeName.ATTR_TEX_COORD), oldView = unit.mesh.struct.vertexBundles[k].view, newView = newMeshStruct.vertexBundles[k].view, oldStride = oldView.stride, newStride = newView.stride;
                                    oldOffset = oldView.offset, newOffset = newView.offset;
                                    for (var j = 0; j < newView.count; j++) {
                                        var srcVertex = src.subarray(oldOffset, oldOffset + oldStride);
                                        newMeshData.set(srcVertex, newOffset), dataView.setFloat32(newOffset + oldStride, _i6, cc.sys.isLittleEndian), 
                                        dataView.setFloat32(newOffset + oldStride + 4, uvs[2 * j], cc.sys.isLittleEndian), 
                                        dataView.setFloat32(newOffset + oldStride + 8, uvs[2 * j + 1], cc.sys.isLittleEndian), 
                                        newOffset += newStride, oldOffset += oldStride;
                                    }
                                }
                                for (var _k = 0; _k < newMeshStruct.primitives.length; _k++) {
                                    var oldPrimitive = unit.mesh.struct.primitives[_k], newPrimitive = newMeshStruct.primitives[_k];
                                    if (oldPrimitive.indexView && newPrimitive.indexView) {
                                        var _oldStride = oldPrimitive.indexView.stride, _newStride = newPrimitive.indexView.stride;
                                        oldOffset = oldPrimitive.indexView.offset, newOffset = newPrimitive.indexView.offset;
                                        for (var _j = 0; _j < newPrimitive.indexView.count; _j++) {
                                            var srcIndices = src.subarray(oldOffset, oldOffset + _oldStride);
                                            newMeshData.set(srcIndices, newOffset), newOffset += _newStride, oldOffset += _oldStride;
                                        }
                                    }
                                    if (oldPrimitive.geometricInfo && newPrimitive.geometricInfo) {
                                        var _oldStride2 = oldPrimitive.geometricInfo.view.stride, _newStride2 = newPrimitive.geometricInfo.view.stride;
                                        oldOffset = oldPrimitive.geometricInfo.view.offset, newOffset = newPrimitive.geometricInfo.view.offset;
                                        for (var _j2 = 0; _j2 < newPrimitive.geometricInfo.view.count; _j2++) {
                                            var srcPositions = src.subarray(oldOffset, oldOffset + _oldStride2);
                                            newMeshData.set(srcPositions, newOffset), newOffset += _newStride2, oldOffset += _oldStride2;
                                        }
                                    }
                                }
                                var newMesh = new Mesh();
                                newMesh.reset({
                                    struct: newMeshStruct,
                                    data: newMeshData
                                });
                                function _loop6() {
                                    if (_isArray6) {
                                        if (_i9 >= _iterator6.length) return "break";
                                        _ref6 = _iterator6[_i9++];
                                    } else {
                                        if ((_i9 = _iterator6.next()).done) return "break";
                                        _ref6 = _i9.value;
                                    }
                                    var bundle = _ref6;
                                    uvOffset = bundle.view.offset, uvFormat = GFXFormat.UNKNOWN;
                                    var _iterator7 = bundle.attributes, _isArray7 = Array.isArray(_iterator7), _i10 = 0;
                                    for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                                        var _ref7;
                                        if (_isArray7) {
                                            if (_i10 >= _iterator7.length) break;
                                            _ref7 = _iterator7[_i10++];
                                        } else {
                                            if ((_i10 = _iterator7.next()).done) break;
                                            _ref7 = _i10.value;
                                        }
                                        var attr = _ref7;
                                        if (attr.name === GFXAttributeName.ATTR_BATCH_UV) {
                                            uvFormat = attr.format;
                                            break;
                                        }
                                        uvOffset += GFXFormatInfos[attr.format].size;
                                    }
                                    uvFormat && mapBuffer(dataView, function(cur, idx) {
                                        var comp = 0 === idx ? "x" : "y";
                                        return (cur = function repeat(n) {
                                            return n - Math.floor(n);
                                        }(cur)) * size[comp] + offset[comp];
                                    }, uvFormat, uvOffset, bundle.view.length, bundle.view.stride, dataView);
                                    var idxMap = jointIndexMap[_i6];
                                    if (!idxMap) return "continue";
                                    jointOffset = bundle.view.offset, jointFormat = GFXFormat.UNKNOWN;
                                    var _iterator8 = bundle.attributes, _isArray8 = Array.isArray(_iterator8), _i11 = 0;
                                    for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                                        var _ref8;
                                        if (_isArray8) {
                                            if (_i11 >= _iterator8.length) break;
                                            _ref8 = _iterator8[_i11++];
                                        } else {
                                            if ((_i11 = _iterator8.next()).done) break;
                                            _ref8 = _i11.value;
                                        }
                                        var _attr = _ref8;
                                        if (_attr.name === GFXAttributeName.ATTR_JOINTS) {
                                            jointFormat = _attr.format;
                                            break;
                                        }
                                        jointOffset += GFXFormatInfos[_attr.format].size;
                                    }
                                    jointFormat && mapBuffer(dataView, function(cur) {
                                        return idxMap[cur];
                                    }, jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
                                }
                                var offset = unit.offset, size = unit.size;
                                var _iterator6 = newMeshStruct.vertexBundles, _isArray6 = Array.isArray(_iterator6), _i9 = 0;
                                _loop5: for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                                    var _ref6;
                                    switch (_loop6()) {
                                      case "break":
                                        break _loop5;

                                      case "continue":
                                        continue;
                                    }
                                }
                                _this3._mesh.merge(newMesh);
                            }, _i6 = 0; _i6 < unitLen; _i6++) _loop4(_i6);
                            this._onMeshChanged(this._mesh), this._updateModels();
                        }
                    }
                }, {
                    key: "cookTextures",
                    value: function cookTextures(target, prop, passIdx) {
                        var texImages = [], texImageRegions = [], texBuffers = [], texBufferRegions = [], _iterator9 = this.units, _isArray9 = Array.isArray(_iterator9), _i12 = 0;
                        for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                            var _ref9;
                            if (_isArray9) {
                                if (_i12 >= _iterator9.length) break;
                                _ref9 = _iterator9[_i12++];
                            } else {
                                if ((_i12 = _iterator9.next()).done) break;
                                _ref9 = _i12.value;
                            }
                            var unit = _ref9;
                            if (unit.material) {
                                var partial = unit.material.getProperty(prop, passIdx);
                                if (partial && partial.image && partial.image.data) {
                                    var region = new GFXBufferTextureCopy();
                                    region.texOffset.x = unit.offset.x * this.atlasSize, region.texOffset.y = unit.offset.y * this.atlasSize, 
                                    region.texExtent.width = unit.size.x * this.atlasSize, region.texExtent.height = unit.size.y * this.atlasSize;
                                    var data = partial.image.data;
                                    data instanceof HTMLCanvasElement || data instanceof HTMLImageElement ? (texImages.push(data), 
                                    texImageRegions.push(region)) : (texBuffers.push(data.buffer), texBufferRegions.push(region));
                                }
                            }
                        }
                        var gfxTex = target.getGFXTexture(), device = cc.director.root.device;
                        0 < texBuffers.length && device.copyBuffersToTexture(texBuffers, gfxTex, texBufferRegions), 
                        0 < texImages.length && device.copyTexImagesToTexture(texImages, gfxTex, texImageRegions);
                    }
                }, {
                    key: "createTexture",
                    value: function createTexture(prop) {
                        var tex = new Texture2D();
                        return tex.setFilters(Filter.LINEAR, Filter.LINEAR), tex.reset({
                            width: this.atlasSize,
                            height: this.atlasSize,
                            format: PixelFormat.RGBA8888
                        }), tex.loaded = !0, this._textures[prop] = tex;
                    }
                }, {
                    key: "resizeAtlases",
                    value: function resizeAtlases() {
                        for (var _i13 = 0, _Object$keys3 = Object.keys(this._textures); _i13 < _Object$keys3.length; _i13++) {
                            var prop = _Object$keys3[_i13];
                            this._textures[prop].reset({
                                width: this.atlasSize,
                                height: this.atlasSize,
                                format: PixelFormat.RGBA8888
                            });
                        }
                    }
                }, {
                    key: "mesh",
                    get: function get() {
                        return this._mesh;
                    },
                    set: function set(val) {
                        _set(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "mesh", val, this, !0);
                    }
                }, {
                    key: "skeleton",
                    get: function get() {
                        return this._skeleton;
                    },
                    set: function set(val) {
                        _set(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "skeleton", val, this, !0);
                    }
                } ]), BatchedSkinningModelComponent;
            }()).prototype, "atlasSize", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1024;
                }
            }), _descriptor7$3 = _applyDecoratedDescriptor(_class5$2.prototype, "batchableTextureNames", [ _dec9$2 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor8$3 = _applyDecoratedDescriptor(_class5$2.prototype, "units", [ _dec10$2 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _applyDecoratedDescriptor(_class5$2.prototype, "mesh", [ _dec11$1 ], Object.getOwnPropertyDescriptor(_class5$2.prototype, "mesh"), _class5$2.prototype), 
            _applyDecoratedDescriptor(_class5$2.prototype, "skeleton", [ _dec12$1 ], Object.getOwnPropertyDescriptor(_class5$2.prototype, "skeleton"), _class5$2.prototype), 
            _class4$2 = _class5$2)) || _class4$2) || _class4$2) || _class4$2) || _class4$2)), PhotometricTerm = Enum({
                LUMINOUS_POWER: 0,
                LUMINANCE: 1
            }), LightComponent = exports("LightComponent", (_dec$G = ccclass("cc.LightComponent"), 
            _dec2$n = property({
                slide: !0,
                range: [ 1e3, 15e3, 1 ]
            }), _dec$G((_temp$B = _class3$f = function() {
                function LightComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, LightComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(LightComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_color", _descriptor$x, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_useColorTemperature", _descriptor2$o, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_colorTemperature", _descriptor3$g, _assertThisInitialized(_this)), 
                    _this._type = LightType.UNKNOWN, _this._light = null, _this;
                }
                return _inherits(LightComponent, Component), _createClass(LightComponent, [ {
                    key: "onEnable",
                    value: function onEnable() {
                        this._light ? this._light.enabled = !0 : this._createLight();
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this._light && (this._light.enabled = !1);
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this._destroyLight();
                    }
                }, {
                    key: "_createLight",
                    value: function _createLight() {
                        this._light && (this.color = this._color, this.useColorTemperature = this._useColorTemperature, 
                        this.colorTemperature = this._colorTemperature, this._light.node = this.node, this._light.enabled = this.enabledInHierarchy);
                    }
                }, {
                    key: "_destroyLight",
                    value: function _destroyLight() {
                        this._light = null;
                    }
                }, {
                    key: "color",
                    get: function get() {
                        return this._color;
                    },
                    set: function set(val) {
                        this._color = val, this._light && (this._light.color.x = val.r / 255, this._light.color.y = val.g / 255, 
                        this._light.color.z = val.b / 255);
                    }
                }, {
                    key: "useColorTemperature",
                    get: function get() {
                        return this._useColorTemperature;
                    },
                    set: function set(enable) {
                        this._useColorTemperature = enable, this._light && (this._light.useColorTemperature = enable);
                    }
                }, {
                    key: "colorTemperature",
                    get: function get() {
                        return this._colorTemperature;
                    },
                    set: function set(val) {
                        this._colorTemperature = val, this._light && (this._light.colorTemperature = val);
                    }
                }, {
                    key: "type",
                    get: function get() {
                        return this._type;
                    }
                } ]), LightComponent;
            }(), _class3$f.Type = LightType, _class3$f.PhotometricTerm = PhotometricTerm, _descriptor$x = _applyDecoratedDescriptor((_class2$z = _temp$B).prototype, "_color", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Color.WHITE.clone();
                }
            }), _descriptor2$o = _applyDecoratedDescriptor(_class2$z.prototype, "_useColorTemperature", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor3$g = _applyDecoratedDescriptor(_class2$z.prototype, "_colorTemperature", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 6550;
                }
            }), _applyDecoratedDescriptor(_class2$z.prototype, "color", [ property ], Object.getOwnPropertyDescriptor(_class2$z.prototype, "color"), _class2$z.prototype), 
            _applyDecoratedDescriptor(_class2$z.prototype, "useColorTemperature", [ property ], Object.getOwnPropertyDescriptor(_class2$z.prototype, "useColorTemperature"), _class2$z.prototype), 
            _applyDecoratedDescriptor(_class2$z.prototype, "colorTemperature", [ _dec2$n ], Object.getOwnPropertyDescriptor(_class2$z.prototype, "colorTemperature"), _class2$z.prototype), 
            _class$G = _class2$z)) || _class$G)), DirectionalLightComponent = exports("DirectionalLightComponent", (_dec$H = ccclass("cc.DirectionalLightComponent"), 
            _dec2$o = menu("Components/DirectionalLight"), _dec3$d = property({
                unit: "lx"
            }), _dec$H(_class$H = _dec2$o(_class$H = executeInEditMode((_descriptor$y = _applyDecoratedDescriptor((_class2$A = function() {
                function DirectionalLightComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, DirectionalLightComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(DirectionalLightComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_illuminance", _descriptor$y, _assertThisInitialized(_this)), 
                    _this._type = LightType.DIRECTIONAL, _this._light = null, _this;
                }
                return _inherits(DirectionalLightComponent, LightComponent), _createClass(DirectionalLightComponent, [ {
                    key: "_createLight",
                    value: function _createLight(scene) {
                        this.node.scene && ((scene = scene || this._getRenderScene()).mainLight.node.activeInHierarchy ? console.warn("there can be only one directional(main) light.") : (this._light = scene.mainLight, 
                        this.illuminance = this._illuminance, _get(_getPrototypeOf(DirectionalLightComponent.prototype), "_createLight", this).call(this, scene)));
                    }
                }, {
                    key: "_destroyLight",
                    value: function _destroyLight(scene) {
                        this.node.scene && this._light && (this._light.enabled = !1, scene = scene || this._getRenderScene(), 
                        this._light.node = scene.defaultMainLightNode, _get(_getPrototypeOf(DirectionalLightComponent.prototype), "_destroyLight", this).call(this, scene));
                    }
                }, {
                    key: "illuminance",
                    get: function get() {
                        return this._illuminance;
                    },
                    set: function set(val) {
                        this._illuminance = val, this._light && (this._light.illuminance = this._illuminance);
                    }
                } ]), DirectionalLightComponent;
            }()).prototype, "_illuminance", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 65e3;
                }
            }), _applyDecoratedDescriptor(_class2$A.prototype, "illuminance", [ _dec3$d ], Object.getOwnPropertyDescriptor(_class2$A.prototype, "illuminance"), _class2$A.prototype), 
            _class$H = _class2$A)) || _class$H) || _class$H) || _class$H)), EditorCameraComponent = ccclass("cc.EditorCameraComponent")(_class$I = function() {
                function EditorCameraComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, EditorCameraComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EditorCameraComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._uiEditorCamera = null, 
                    _this;
                }
                return _inherits(EditorCameraComponent, CameraComponent), _createClass(EditorCameraComponent, [ {
                    key: "onLoad",
                    value: function onLoad() {
                        _get(_getPrototypeOf(EditorCameraComponent.prototype), "onLoad", this).call(this), 
                        this._inEditorMode = !0;
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        _get(_getPrototypeOf(EditorCameraComponent.prototype), "onEnable", this).call(this);
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        _get(_getPrototypeOf(EditorCameraComponent.prototype), "onDisable", this).call(this);
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        _get(_getPrototypeOf(EditorCameraComponent.prototype), "onDestroy", this).call(this), 
                        this._uiEditorCamera && (cc.director.root.ui.renderScene.destroyCamera(this._uiEditorCamera), 
                        this._uiEditorCamera = null);
                    }
                }, {
                    key: "_createCamera",
                    value: function _createCamera() {
                        var priorCamera = this._camera;
                        _get(_getPrototypeOf(EditorCameraComponent.prototype), "_createCamera", this).call(this), 
                        this._camera !== priorCamera && this._camera && (this._uiEditorCamera && (cc.director.root.ui.renderScene.destroyCamera(this._uiEditorCamera), 
                        this._uiEditorCamera = null), this._uiEditorCamera = cc.director.root.ui.renderScene.createCamera({
                            name: "Editor UICamera",
                            node: this._camera.node,
                            projection: this._projection,
                            window: cc.director.root.mainWindow,
                            priority: this._priority + 1,
                            flows: [ "UIFlow" ]
                        }), this._uiEditorCamera.visibility = CameraEditorMask, this._uiEditorCamera.viewport = this._camera.viewport, 
                        this._uiEditorCamera.fov = this._camera.fov, this._uiEditorCamera.nearClip = this._camera.nearClip, 
                        this._uiEditorCamera.farClip = this._camera.farClip, this._uiEditorCamera.clearColor = this._camera.clearColor, 
                        this._uiEditorCamera.clearDepth = this._camera.clearDepth, this._uiEditorCamera.clearStencil = this._camera.clearStencil, 
                        this._uiEditorCamera.clearFlag = GFXClearFlag.DEPTH_STENCIL);
                    }
                }, {
                    key: "projection",
                    set: function set(val) {
                        _set(_getPrototypeOf(EditorCameraComponent.prototype), "projection", val, this, !0), 
                        this._uiEditorCamera && (this._uiEditorCamera.projectionType = val);
                    }
                }, {
                    key: "fov",
                    set: function set(val) {
                        _set(_getPrototypeOf(EditorCameraComponent.prototype), "fov", val, this, !0), this._uiEditorCamera && (this._uiEditorCamera.fov = toRadian(val));
                    }
                }, {
                    key: "orthoHeight",
                    set: function set(val) {
                        _set(_getPrototypeOf(EditorCameraComponent.prototype), "orthoHeight", val, this, !0), 
                        this._uiEditorCamera && (this._uiEditorCamera.orthoHeight = val);
                    }
                }, {
                    key: "near",
                    set: function set(val) {
                        _set(_getPrototypeOf(EditorCameraComponent.prototype), "near", val, this, !0), this._uiEditorCamera && (this._uiEditorCamera.nearClip = val);
                    }
                }, {
                    key: "far",
                    set: function set(val) {
                        _set(_getPrototypeOf(EditorCameraComponent.prototype), "far", val, this, !0), this._uiEditorCamera && (this._uiEditorCamera.farClip = val);
                    }
                }, {
                    key: "color",
                    set: function set(val) {
                        _set(_getPrototypeOf(EditorCameraComponent.prototype), "color", val, this, !0), 
                        this._uiEditorCamera && (this._uiEditorCamera.clearColor = val);
                    }
                }, {
                    key: "depth",
                    set: function set(val) {
                        _set(_getPrototypeOf(EditorCameraComponent.prototype), "depth", val, this, !0), 
                        this._uiEditorCamera && (this._uiEditorCamera.clearDepth = val);
                    }
                }, {
                    key: "stencil",
                    set: function set(val) {
                        _set(_getPrototypeOf(EditorCameraComponent.prototype), "stencil", val, this, !0), 
                        this._uiEditorCamera && (this._uiEditorCamera.clearStencil = val);
                    }
                }, {
                    key: "clearFlags",
                    set: function set(val) {
                        _set(_getPrototypeOf(EditorCameraComponent.prototype), "clearFlags", val, this, !0), 
                        this._uiEditorCamera && (this._uiEditorCamera.clearFlag = val);
                    }
                }, {
                    key: "rect",
                    set: function set(val) {
                        _set(_getPrototypeOf(EditorCameraComponent.prototype), "rect", val, this, !0), this._uiEditorCamera && (this._uiEditorCamera.viewport = val);
                    }
                }, {
                    key: "screenScale",
                    set: function set(val) {
                        _set(_getPrototypeOf(EditorCameraComponent.prototype), "screenScale", val, this, !0), 
                        this._uiEditorCamera && (this._uiEditorCamera.screenScale = val);
                    }
                } ]), EditorCameraComponent;
            }()) || _class$I, SphereLightComponent = exports("SphereLightComponent", (_dec$J = ccclass("cc.SphereLightComponent"), 
            _dec2$p = menu("Components/SphereLight"), _dec3$e = property({
                unit: "lm"
            }), _dec4$b = property({
                unit: "cd/m²"
            }), _dec5$a = property({
                type: PhotometricTerm
            }), _dec$J(_class$J = _dec2$p(_class$J = executeInEditMode((_descriptor$z = _applyDecoratedDescriptor((_class2$B = function() {
                function SphereLightComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, SphereLightComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SphereLightComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_size", _descriptor$z, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_luminance", _descriptor2$p, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_term", _descriptor3$h, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_range", _descriptor4$d, _assertThisInitialized(_this)), 
                    _this._type = LightType.SPHERE, _this._light = null, _this;
                }
                return _inherits(SphereLightComponent, LightComponent), _createClass(SphereLightComponent, [ {
                    key: "_createLight",
                    value: function _createLight(scene) {
                        var _this2 = this;
                        this.node.scene && (scene = scene || this._getRenderScene(), this._light && scene.sphereLights.find(function(c) {
                            return c === _this2._light;
                        }) || (this._light = scene.createSphereLight(this.name, this.node), this._light ? (this._light.luminance = this._luminance, 
                        this.size = this._size, this.range = this._range, _get(_getPrototypeOf(SphereLightComponent.prototype), "_createLight", this).call(this, scene)) : console.warn("we don't support this many lights in forward pipeline.")));
                    }
                }, {
                    key: "_destroyLight",
                    value: function _destroyLight(scene) {
                        this.node.scene && this._light && ((scene = scene || this._getRenderScene()).destroySphereLight(this._light), 
                        _get(_getPrototypeOf(SphereLightComponent.prototype), "_destroyLight", this).call(this, scene));
                    }
                }, {
                    key: "luminousPower",
                    get: function get() {
                        return this._luminance * nt2lm(this._size);
                    },
                    set: function set(val) {
                        this._luminance = val / nt2lm(this._size), this._light && (this._light.luminance = this._luminance);
                    }
                }, {
                    key: "luminance",
                    get: function get() {
                        return this._luminance;
                    },
                    set: function set(val) {
                        this._luminance = val, this._light && (this._light.luminance = val);
                    }
                }, {
                    key: "term",
                    get: function get() {
                        return this._term;
                    },
                    set: function set(val) {
                        this._term = val;
                    }
                }, {
                    key: "size",
                    get: function get() {
                        return this._size;
                    },
                    set: function set(val) {
                        this._size = val, this._light && (this._light.size = val);
                    }
                }, {
                    key: "range",
                    get: function get() {
                        return this._range;
                    },
                    set: function set(val) {
                        this._range = val, this._light && (this._light.range = val);
                    }
                } ]), SphereLightComponent;
            }()).prototype, "_size", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return .15;
                }
            }), _descriptor2$p = _applyDecoratedDescriptor(_class2$B.prototype, "_luminance", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1700 / nt2lm(.15);
                }
            }), _descriptor3$h = _applyDecoratedDescriptor(_class2$B.prototype, "_term", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return PhotometricTerm.LUMINOUS_POWER;
                }
            }), _descriptor4$d = _applyDecoratedDescriptor(_class2$B.prototype, "_range", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _applyDecoratedDescriptor(_class2$B.prototype, "luminousPower", [ _dec3$e ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "luminousPower"), _class2$B.prototype), 
            _applyDecoratedDescriptor(_class2$B.prototype, "luminance", [ _dec4$b ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "luminance"), _class2$B.prototype), 
            _applyDecoratedDescriptor(_class2$B.prototype, "term", [ _dec5$a ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "term"), _class2$B.prototype), 
            _applyDecoratedDescriptor(_class2$B.prototype, "size", [ property ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "size"), _class2$B.prototype), 
            _applyDecoratedDescriptor(_class2$B.prototype, "range", [ property ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "range"), _class2$B.prototype), 
            _class$J = _class2$B)) || _class$J) || _class$J) || _class$J)), SpotLightComponent = exports("SpotLightComponent", (_dec$K = ccclass("cc.SpotLightComponent"), 
            _dec2$q = menu("Components/SpotLight"), _dec3$f = property({
                unit: "lm"
            }), _dec4$c = property({
                unit: "cd/m²"
            }), _dec5$b = property({
                type: PhotometricTerm
            }), _dec6$8 = property({
                slide: !0,
                range: [ 2, 180, 1 ]
            }), _dec$K(_class$K = _dec2$q(_class$K = executeInEditMode((_descriptor$A = _applyDecoratedDescriptor((_class2$C = function() {
                function SpotLightComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, SpotLightComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SpotLightComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_size", _descriptor$A, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_luminance", _descriptor2$q, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_term", _descriptor3$i, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_range", _descriptor4$e, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_spotAngle", _descriptor5$a, _assertThisInitialized(_this)), 
                    _this._type = LightType.SPOT, _this._light = null, _this;
                }
                return _inherits(SpotLightComponent, LightComponent), _createClass(SpotLightComponent, [ {
                    key: "_createLight",
                    value: function _createLight(scene) {
                        var _this2 = this;
                        this.node.scene && (scene = scene || this._getRenderScene(), this._light && scene.spotLights.find(function(c) {
                            return c === _this2._light;
                        }) || (this._light = scene.createSpotLight(this.name, this.node), this._light ? (this._light.luminance = this._luminance, 
                        this.size = this._size, this.range = this._range, this.spotAngle = this._spotAngle, 
                        _get(_getPrototypeOf(SpotLightComponent.prototype), "_createLight", this).call(this, scene)) : console.warn("we don't support this many lights in forward pipeline.")));
                    }
                }, {
                    key: "_destroyLight",
                    value: function _destroyLight(scene) {
                        this.node.scene && this._light && ((scene = scene || this._getRenderScene()).destroySpotLight(this._light), 
                        _get(_getPrototypeOf(SpotLightComponent.prototype), "_destroyLight", this).call(this, scene));
                    }
                }, {
                    key: "luminousPower",
                    get: function get() {
                        return this._luminance * nt2lm(this._size);
                    },
                    set: function set(val) {
                        this._luminance = val / nt2lm(this._size), this._light && (this._light.luminance = this._luminance);
                    }
                }, {
                    key: "luminance",
                    get: function get() {
                        return this._luminance;
                    },
                    set: function set(val) {
                        this._luminance = val, this._light && (this._light.luminance = val);
                    }
                }, {
                    key: "term",
                    get: function get() {
                        return this._term;
                    },
                    set: function set(val) {
                        this._term = val;
                    }
                }, {
                    key: "size",
                    get: function get() {
                        return this._size;
                    },
                    set: function set(val) {
                        this._size = val, this._light && (this._light.size = val);
                    }
                }, {
                    key: "range",
                    get: function get() {
                        return this._range;
                    },
                    set: function set(val) {
                        this._range = val, this._light && (this._light.range = val);
                    }
                }, {
                    key: "spotAngle",
                    get: function get() {
                        return this._spotAngle;
                    },
                    set: function set(val) {
                        this._spotAngle = val, this._light && (this._light.spotAngle = toRadian(val));
                    }
                } ]), SpotLightComponent;
            }()).prototype, "_size", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return .15;
                }
            }), _descriptor2$q = _applyDecoratedDescriptor(_class2$C.prototype, "_luminance", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1700 / nt2lm(.15);
                }
            }), _descriptor3$i = _applyDecoratedDescriptor(_class2$C.prototype, "_term", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return PhotometricTerm.LUMINOUS_POWER;
                }
            }), _descriptor4$e = _applyDecoratedDescriptor(_class2$C.prototype, "_range", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _descriptor5$a = _applyDecoratedDescriptor(_class2$C.prototype, "_spotAngle", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 60;
                }
            }), _applyDecoratedDescriptor(_class2$C.prototype, "luminousPower", [ _dec3$f ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "luminousPower"), _class2$C.prototype), 
            _applyDecoratedDescriptor(_class2$C.prototype, "luminance", [ _dec4$c ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "luminance"), _class2$C.prototype), 
            _applyDecoratedDescriptor(_class2$C.prototype, "term", [ _dec5$b ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "term"), _class2$C.prototype), 
            _applyDecoratedDescriptor(_class2$C.prototype, "size", [ property ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "size"), _class2$C.prototype), 
            _applyDecoratedDescriptor(_class2$C.prototype, "range", [ property ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "range"), _class2$C.prototype), 
            _applyDecoratedDescriptor(_class2$C.prototype, "spotAngle", [ _dec6$8 ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "spotAngle"), _class2$C.prototype), 
            _class$K = _class2$C)) || _class$K) || _class$K) || _class$K));
            function bezier(C1, C2, C3, C4, t) {
                var t1 = 1 - t;
                return C1 * t1 * t1 * t1 + 3 * C2 * t1 * t1 * t + 3 * C3 * t1 * t * t + C4 * t * t * t;
            }
            cc.CameraComponent = CameraComponent, cc.EditorComponent = EditorCameraComponent, 
            cc.RenderableComponent = RenderableComponent, cc.ModelComponent = ModelComponent, 
            cc.SkinningModelComponent = SkinningModelComponent, cc.BatchedSkinningModelComponent = BatchedSkinningModelComponent, 
            cc.SkinningModelUnit = SkinningModelUnit, cc.LightComponent = LightComponent, cc.DirectionalLightComponent = DirectionalLightComponent, 
            cc.SphereLightComponent = SphereLightComponent, cc.SpotLightComponent = SpotLightComponent, 
            cc.utils = utils, cc.bezier = bezier;
            var cos = Math.cos, acos = Math.acos, max$2 = Math.max, tau = 2 * Math.PI, sqrt = Math.sqrt;
            function crt(v) {
                return v < 0 ? -Math.pow(-v, 1 / 3) : Math.pow(v, 1 / 3);
            }
            function bezierByTime(controlPoints, x) {
                var percent = function cardano(curve, x) {
                    var u1, x1, x2, x3, pa = x - 0, pb = x - curve[0], pa3 = 3 * pa, pb3 = 3 * pb, pc3 = 3 * (x - curve[2]), rd = 1 / (pb3 - pa - pc3 + (x - 1)), a = (pa3 - 6 * pb + pc3) * rd, a3 = 1 / 3 * a, b = (pb3 - pa3) * rd, p = 1 / 3 * (3 * b - a * a), p3 = 1 / 3 * p, q = (2 * a * a * a - 9 * a * b + 27 * (pa * rd)) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3;
                    if (discriminant < 0) {
                        var mp3 = 1 / 3 * -p, r = sqrt(mp3 * mp3 * mp3), t = -q / (2 * r), phi = acos(t < -1 ? -1 : 1 < t ? 1 : t), t1 = 2 * crt(r);
                        return x1 = t1 * cos(phi * (1 / 3)) - a3, x2 = t1 * cos((phi + tau) * (1 / 3)) - a3, 
                        x3 = t1 * cos((phi + 2 * tau) * (1 / 3)) - a3, 0 <= x1 && x1 <= 1 ? 0 <= x2 && x2 <= 1 ? 0 <= x3 && x3 <= 1 ? max$2(x1, x2, x3) : max$2(x1, x2) : 0 <= x3 && x3 <= 1 ? max$2(x1, x3) : x1 : 0 <= x2 && x2 <= 1 ? 0 <= x3 && x3 <= 1 ? max$2(x2, x3) : x2 : x3;
                    }
                    if (0 == discriminant) return x2 = -(u1 = q2 < 0 ? crt(-q2) : -crt(q2)) - a3, 0 <= (x1 = 2 * u1 - a3) && x1 <= 1 ? 0 <= x2 && x2 <= 1 ? max$2(x1, x2) : x1 : x2;
                    var sd = sqrt(discriminant);
                    return x1 = (u1 = crt(-q2 + sd)) - crt(q2 + sd) - a3;
                }(controlPoints, x), t1 = 1 - percent;
                return 0 * t1 * t1 * t1 + 3 * controlPoints[1] * percent * t1 * t1 + 3 * controlPoints[3] * percent * percent * t1 + 1 * percent * percent * percent;
            }
            cc.bezierByTime = bezierByTime;
            var WrapModeMask, WrapMode$2, EPSILON$1 = 1e-6;
            function binarySearchEpsilon(array, value) {
                for (var low = 0, high = array.length - 1, middle = high >>> 1; low <= high; middle = low + high >>> 1) {
                    var middleValue = array[middle];
                    if (value + EPSILON$1 < middleValue) high = middle - 1; else {
                        if (!(middleValue < value - EPSILON$1)) return middle;
                        low = middle + 1;
                    }
                }
                return ~low;
            }
            !function(WrapModeMask) {
                WrapModeMask[WrapModeMask.Loop = 2] = "Loop", WrapModeMask[WrapModeMask.ShouldWrap = 4] = "ShouldWrap", 
                WrapModeMask[WrapModeMask.PingPong = 22] = "PingPong", WrapModeMask[WrapModeMask.Reverse = 36] = "Reverse";
            }(WrapModeMask = WrapModeMask || {}), function(WrapMode) {
                WrapMode[WrapMode.Default = 0] = "Default", WrapMode[WrapMode.Normal = 1] = "Normal", 
                WrapMode[WrapMode.Reverse = WrapModeMask.Reverse] = "Reverse", WrapMode[WrapMode.Loop = WrapModeMask.Loop] = "Loop", 
                WrapMode[WrapMode.LoopReverse = WrapModeMask.Loop | WrapModeMask.Reverse] = "LoopReverse", 
                WrapMode[WrapMode.PingPong = WrapModeMask.PingPong] = "PingPong", WrapMode[WrapMode.PingPongReverse = WrapModeMask.PingPong | WrapModeMask.Reverse] = "PingPongReverse";
            }(WrapMode$2 = WrapMode$2 || {}), ccenum(WrapMode$2);
            var _class$L, WrappedInfo = function() {
                function WrappedInfo(info) {
                    _classCallCheck(this, WrappedInfo), this.ratio = 0, this.time = 0, this.direction = 1, 
                    this.stopped = !0, this.iterations = 0, this.frameIndex = void 0, info && this.set(info);
                }
                return _createClass(WrappedInfo, [ {
                    key: "set",
                    value: function set(info) {
                        this.ratio = info.ratio, this.time = info.time, this.direction = info.direction, 
                        this.stopped = info.stopped, this.iterations = info.iterations, this.frameIndex = info.frameIndex;
                    }
                } ]), WrappedInfo;
            }();
            var RatioSampler = exports("RatioSampler", function() {
                function RatioSampler(ratios) {
                    var currRatioDif, lastRatioDif;
                    _classCallCheck(this, RatioSampler), this.ratios = void 0;
                    for (var canOptimize = !(this._findRatio = void 0), i = 1, l = (this.ratios = ratios).length; i < l; i++) if (currRatioDif = ratios[i] - ratios[i - 1], 
                    1 === i) lastRatioDif = currRatioDif; else if (1e-6 < Math.abs(currRatioDif - lastRatioDif)) {
                        canOptimize = !1;
                        break;
                    }
                    this._findRatio = canOptimize ? quickFindIndex : binarySearchEpsilon;
                }
                return _createClass(RatioSampler, [ {
                    key: "sample",
                    value: function sample(ratio) {
                        return this._findRatio(this.ratios, ratio);
                    }
                } ]), RatioSampler;
            }());
            cc.RatioSampler = RatioSampler;
            var AnimCurve = exports("AnimCurve", function() {
                function AnimCurve(propertyCurveData, duration) {
                    _classCallCheck(this, AnimCurve), this.types = void 0, this.type = null, this._values = [], 
                    this._lerp = void 0, this._stepfiedValues = void 0, this._duration = void 0, this._duration = duration, 
                    this._values = propertyCurveData.values;
                    function getCurveType(easingMethod) {
                        return "string" == typeof easingMethod ? easingMethod : Array.isArray(easingMethod) ? easingMethod[0] === easingMethod[1] && easingMethod[2] === easingMethod[3] ? AnimCurve.Linear : AnimCurve.Bezier(easingMethod) : AnimCurve.Linear;
                    }
                    void 0 !== propertyCurveData.easingMethod ? this.type = getCurveType(propertyCurveData.easingMethod) : void 0 !== propertyCurveData.easingMethods ? this.types = propertyCurveData.easingMethods.map(getCurveType) : this.type = null;
                    var firstValue = propertyCurveData.values[0];
                    void 0 !== propertyCurveData.interpolate && !propertyCurveData.interpolate || (this._lerp = selectLerpFx(firstValue));
                }
                return _createClass(AnimCurve, null, [ {
                    key: "Bezier",
                    value: function Bezier(controlPoints) {
                        return controlPoints;
                    }
                } ]), _createClass(AnimCurve, [ {
                    key: "hasLerp",
                    value: function hasLerp() {
                        return !!this._lerp;
                    }
                }, {
                    key: "valueAt",
                    value: function valueAt(index) {
                        var value = this._values[index];
                        return value && value.getNoLerp ? value.getNoLerp() : value;
                    }
                }, {
                    key: "valueBetween",
                    value: function valueBetween(ratio, from, fromRatio, to, toRatio) {
                        if (this._lerp) {
                            var type = this.types ? this.types[from] : this.type, dRatio = toRatio - fromRatio, ratioBetweenFrames = (ratio - fromRatio) / dRatio;
                            type && (ratioBetweenFrames = computeRatioByType(ratioBetweenFrames, type));
                            var fromVal = this._values[from], toVal = this._values[to];
                            return this._lerp(fromVal, toVal, ratioBetweenFrames, dRatio * this._duration);
                        }
                        return this.valueAt(from);
                    }
                }, {
                    key: "empty",
                    value: function empty() {
                        return 0 === this._values.length;
                    }
                } ]), AnimCurve;
            }());
            AnimCurve.Linear = null, cc.AnimCurve = AnimCurve;
            exports("EventInfo", function() {
                function EventInfo() {
                    _classCallCheck(this, EventInfo), this.events = [];
                }
                return _createClass(EventInfo, [ {
                    key: "add",
                    value: function add(func, params) {
                        this.events.push({
                            func: func || "",
                            params: params || []
                        });
                    }
                } ]), EventInfo;
            }());
            var CurveValueAdapter = exports("CurveValueAdapter", ccclass("cc.CurveValueAdapter")(_class$L = function() {
                function CurveValueAdapter() {
                    _classCallCheck(this, CurveValueAdapter);
                }
                return _createClass(CurveValueAdapter, [ {
                    key: "forTarget",
                    value: function forTarget() {
                        return {
                            set: function set() {}
                        };
                    }
                } ]), CurveValueAdapter;
            }()) || _class$L);
            function sampleAnimationCurve(curve, sampler, ratio) {
                var index = sampler.sample(ratio);
                if (index < 0) if ((index = ~index) <= 0) index = 0; else {
                    if (!(index >= sampler.ratios.length)) return curve.valueBetween(ratio, index - 1, sampler.ratios[index - 1], index, sampler.ratios[index]);
                    index = sampler.ratios.length - 1;
                }
                return curve.valueAt(index);
            }
            function computeRatioByType(ratio, type) {
                if ("string" == typeof type) {
                    var func = easing[type];
                    func ? ratio = func(ratio) : errorID(3906, type);
                } else Array.isArray(type) && (ratio = bezierByTime(type, ratio));
                return ratio;
            }
            function quickFindIndex(ratios, ratio) {
                var length = ratios.length - 1;
                if (0 == length) return 0;
                var start = ratios[0];
                if (ratio < start) return 0;
                var end = ratios[length];
                if (end < ratio) return length;
                var index = (ratio = (ratio - start) / (end - start)) / (1 / length), floorIndex = 0 | index;
                return index - floorIndex < 1e-6 ? floorIndex : 1 + floorIndex - index < 1e-6 ? 1 + floorIndex : ~(1 + floorIndex);
            }
            cc.CurveValueAdapter = CurveValueAdapter, cc.sampleAnimationCurve = sampleAnimationCurve;
            var selectLerpFx = function(value) {
                if (null !== value) {
                    if ("number" == typeof value) return lerp;
                    if ("object" === _typeof(value) && value.constructor) {
                        if (value instanceof Quat) return function makeQuatSlerpFx() {
                            var tempValue = new Quat();
                            return function(from, to, t, dt) {
                                return Quat.slerp(tempValue, from, to, t);
                            };
                        }();
                        if (value instanceof ValueType) return function makeValueTypeLerpFx(constructor) {
                            var tempValue = new constructor();
                            return function(from, to, ratio) {
                                return constructor.lerp(tempValue, from, to, ratio), tempValue;
                            };
                        }(value.constructor);
                        if (value.constructor === Number) return lerp;
                        if (function isLerpable(object) {
                            return "function" == typeof object.lerp;
                        }(value)) return callLerpable;
                    }
                }
            };
            function callLerpable(from, to, t, dt) {
                return from.lerp(to, t, dt);
            }
            var _class$M, _class2$D, _descriptor$B, _class4$3, _class5$3, _descriptor2$r;
            function isPropertyModifier(modifier) {
                return "string" == typeof modifier;
            }
            function isElementModifier(modifier) {
                return "number" == typeof modifier;
            }
            function isCustomTargetModifier(modifier, constructor) {
                return modifier instanceof constructor;
            }
            cc.isPropertyModifier = isPropertyModifier, cc.isElementModifier = isElementModifier, 
            cc.isCustomTargetModifier = isCustomTargetModifier;
            var HierachyModifier = exports("HierachyModifier", ccclass("cc.HierachyModifier")((_descriptor$B = _applyDecoratedDescriptor((_class2$D = function() {
                function HierachyModifier(path) {
                    _classCallCheck(this, HierachyModifier), _initializerDefineProperty(this, "path", _descriptor$B, this), 
                    this.path = path || "";
                }
                return _createClass(HierachyModifier, [ {
                    key: "get",
                    value: function get(target) {
                        if (!(target instanceof Node$1)) throw new Error("Target of hierachy modifier shall be Node.");
                        var result = target.getChildByPath(this.path);
                        if (!result) throw new Error('Node "'.concat(target.name, '" has no path "').concat(this.path, '"'));
                        return result;
                    }
                } ]), HierachyModifier;
            }()).prototype, "path", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return "";
                }
            }), _class$M = _class2$D)) || _class$M);
            cc.HierachyModifier = HierachyModifier;
            var ComponentModifier = exports("ComponentModifier", ccclass("cc.ComponentModifier")((_descriptor2$r = _applyDecoratedDescriptor((_class5$3 = function() {
                function ComponentModifier(component) {
                    _classCallCheck(this, ComponentModifier), _initializerDefineProperty(this, "component", _descriptor2$r, this), 
                    this.component = component || "";
                }
                return _createClass(ComponentModifier, [ {
                    key: "get",
                    value: function get(target) {
                        if (!(target instanceof Node$1)) throw new Error("Target of hierachy modifier shall be Node.");
                        var result = target.getComponent(this.component);
                        if (!result) throw new Error('Node "'.concat(target.name, '" has no component "').concat(this.component, '"'));
                        return result;
                    }
                } ]), ComponentModifier;
            }()).prototype, "component", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return "";
                }
            }), _class4$3 = _class5$3)) || _class4$3);
            cc.ComponentModifier = ComponentModifier;
            var _dec$N, _dec2$s, _class$N, _class2$E, _descriptor$C, _descriptor2$s, _descriptor3$j, _descriptor4$f, _descriptor5$b, _descriptor6$4, _descriptor7$4, _descriptor8$4, _descriptor9$3, _class3$g, _temp$H, BoundTarget = function() {
                function BoundTarget(target, modifiers, valueAdapter) {
                    var assignmentModifier;
                    _classCallCheck(this, BoundTarget), this._isProxy = void 0, this._assignmentOrProxy = void 0;
                    for (var iModifier = 0; iModifier < modifiers.length; ++iModifier) {
                        var modifier = modifiers[iModifier];
                        if (isElementModifier(modifier) || isPropertyModifier(modifier)) if (iModifier !== modifiers.length - 1 || valueAdapter) {
                            if (!(modifier in target)) throw new Error('Target object has no property "'.concat(modifier, '"'));
                            target = target[modifier];
                        } else assignmentModifier = modifier; else target = modifier.get(target);
                    }
                    if (void 0 !== assignmentModifier) this._assignmentOrProxy = {
                        object: target,
                        propertyOrElement: assignmentModifier
                    }, this._isProxy = !1; else {
                        if (!valueAdapter) throw new Error("Bad animation curve.");
                        this._assignmentOrProxy = valueAdapter.forTarget(target), this._isProxy = !0;
                    }
                }
                return _createClass(BoundTarget, [ {
                    key: "setValue",
                    value: function setValue(value) {
                        this._isProxy ? this._assignmentOrProxy.set(value) : this._assignmentOrProxy.object[this._assignmentOrProxy.propertyOrElement] = value;
                    }
                } ]), BoundTarget;
            }(), AnimationClip = exports("AnimationClip", (_dec$N = ccclass("cc.AnimationClip"), 
            _dec2$s = property({
                visible: !1
            }), _dec$N((_temp$H = _class3$g = function() {
                function AnimationClip() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, AnimationClip);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AnimationClip)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "sample", _descriptor$C, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "speed", _descriptor2$s, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "wrapMode", _descriptor3$j, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "curveDatas", _descriptor4$f, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_curves", _descriptor5$b, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "events", _descriptor6$4, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_duration", _descriptor7$4, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_keys", _descriptor8$4, _assertThisInitialized(_this)), 
                    _this._ratioSamplers = [], _this._runtimeCurves = void 0, _this._runtimeEvents = void 0, 
                    _this.frameRate = 0, _initializerDefineProperty(_this, "_stepness", _descriptor9$3, _assertThisInitialized(_this)), 
                    _this._hash = 0, _this;
                }
                return _inherits(AnimationClip, Asset), _createClass(AnimationClip, [ {
                    key: "onLoaded",
                    value: function onLoaded() {
                        this.frameRate = this.sample, this._migrateCurveDatas();
                    }
                }, {
                    key: "getPropertyCurves",
                    value: function getPropertyCurves() {
                        return this._runtimeCurves || this._createPropertyCurves(), this._runtimeCurves;
                    }
                }, {
                    key: "updateCurveDatas",
                    value: function updateCurveDatas() {
                        this._migrateCurveDatas(), delete this._runtimeCurves;
                    }
                }, {
                    key: "updateEventDatas",
                    value: function updateEventDatas() {
                        delete this._runtimeEvents;
                    }
                }, {
                    key: "getEventGroupIndexAtRatio",
                    value: function getEventGroupIndexAtRatio(ratio) {
                        return this._runtimeEvents || this._createRuntimeEvents(), function binarySearchEpsilon$1(array, value) {
                            for (var l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
                                var test = array[m];
                                if (value + 1e-6 < test) h = m - 1; else {
                                    if (!(test < value - 1e-6)) return m;
                                    l = m + 1;
                                }
                            }
                            return ~l;
                        }(this._runtimeEvents.ratios, ratio);
                    }
                }, {
                    key: "hasEvents",
                    value: function hasEvents() {
                        return 0 !== this.events.length;
                    }
                }, {
                    key: "_createPropertyCurves",
                    value: function _createPropertyCurves() {
                        var _this2 = this;
                        this._ratioSamplers = this._keys.map(function(keys) {
                            return new RatioSampler(keys.map(function(key) {
                                return key / _this2._duration;
                            }));
                        }), this._runtimeCurves = this._curves.map(function(targetCurve) {
                            return {
                                curve: new AnimCurve(targetCurve.data, _this2._duration),
                                modifiers: targetCurve.modifiers,
                                valueAdapter: targetCurve.valueAdapter,
                                sampler: _this2._ratioSamplers[targetCurve.data.keys]
                            };
                        }), this._applyStepness();
                    }
                }, {
                    key: "_createRuntimeEvents",
                    value: function _createRuntimeEvents() {
                        var _this3 = this;
                        var ratios = [], eventGroups = [], _loop = function _loop() {
                            if (_isArray) {
                                if (_i >= _iterator.length) return "break";
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) return "break";
                                _ref = _i.value;
                            }
                            var eventData = _ref, ratio = eventData.frame / _this3._duration, i = ratios.findIndex(function(r) {
                                return r === ratio;
                            });
                            i < 0 && (i = ratios.length, ratios.push(ratio), eventGroups.push({
                                events: []
                            })), eventGroups[i].events.push({
                                functionName: eventData.func,
                                parameters: eventData.params
                            });
                        }, _iterator = this.events.sort(function(a, b) {
                            return a.frame - b.frame;
                        }), _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if ("break" === _loop()) break;
                        }
                        this._runtimeEvents = {
                            ratios: ratios,
                            eventGroups: eventGroups
                        };
                    }
                }, {
                    key: "_applyStepness",
                    value: function _applyStepness() {
                        this._runtimeCurves;
                    }
                }, {
                    key: "_migrateCurveDatas",
                    value: function _migrateCurveDatas() {
                        if (this.curveDatas) {
                            for (var _i2 = 0, _Object$keys = Object.keys(this.curveDatas); _i2 < _Object$keys.length; _i2++) {
                                var curveTargetPath = _Object$keys[_i2], hierachyModifier = new HierachyModifier();
                                hierachyModifier.path = curveTargetPath;
                                var nodeData = this.curveDatas[curveTargetPath];
                                if (nodeData.props) for (var _i3 = 0, _Object$keys2 = Object.keys(nodeData.props); _i3 < _Object$keys2.length; _i3++) {
                                    var nodePropertyName = _Object$keys2[_i3], propertyCurveData = nodeData.props[nodePropertyName];
                                    this._curves.push({
                                        modifiers: [ hierachyModifier, nodePropertyName ],
                                        data: propertyCurveData
                                    });
                                }
                                if (nodeData.comps) for (var _i4 = 0, _Object$keys3 = Object.keys(nodeData.comps); _i4 < _Object$keys3.length; _i4++) {
                                    var _componentName = _Object$keys3[_i4], componentModifier = new ComponentModifier();
                                    componentModifier.component = _componentName;
                                    for (var componentData = nodeData.comps[_componentName], _i5 = 0, _Object$keys4 = Object.keys(componentData); _i5 < _Object$keys4.length; _i5++) {
                                        var componentPropertyName = _Object$keys4[_i5], _propertyCurveData = componentData[componentPropertyName];
                                        this._curves.push({
                                            modifiers: [ hierachyModifier, componentModifier, componentPropertyName ],
                                            data: _propertyCurveData
                                        });
                                    }
                                }
                            }
                            delete this.curveDatas;
                        }
                    }
                }, {
                    key: "_getDeprecatedCurveDatas",
                    value: function _getDeprecatedCurveDatas() {
                        var result = {}, _iterator2 = this._curves, _isArray2 = Array.isArray(_iterator2), _i6 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i6 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i6++];
                            } else {
                                if ((_i6 = _iterator2.next()).done) break;
                                _ref2 = _i6.value;
                            }
                            var curve = _ref2;
                            if (0 !== curve.modifiers.length && isCustomTargetModifier(curve.modifiers[0], HierachyModifier)) {
                                var _componentName2 = null, _propertyName = void 0;
                                if (2 === curve.modifiers.length && isPropertyModifier(curve.modifiers[1])) _propertyName = curve.modifiers[1]; else {
                                    if (3 !== curve.modifiers.length || !isCustomTargetModifier(curve.modifiers[1], ComponentModifier) || !isPropertyModifier(curve.modifiers[2])) continue;
                                    _componentName2 = curve.modifiers[1].component, _propertyName = curve.modifiers[2];
                                }
                                var _path = curve.modifiers[0].path;
                                _path in result || (result[_path] = {});
                                var nodeCurveData = result[_path], objectCurveData = void 0;
                                if (_componentName2) {
                                    "comps" in nodeCurveData || (nodeCurveData.comps = {});
                                    var componentCurveData = nodeCurveData.comps;
                                    _componentName2 in componentCurveData || (componentCurveData[_componentName2] = {}), 
                                    objectCurveData = componentCurveData[_componentName2];
                                } else "props" in nodeCurveData || (nodeCurveData.props = {}), objectCurveData = nodeCurveData.props;
                                objectCurveData[_propertyName] = curve.data;
                            }
                        }
                        return result;
                    }
                }, {
                    key: "duration",
                    get: function get() {
                        return this._duration;
                    },
                    set: function set(value) {
                        this._duration = value;
                    }
                }, {
                    key: "keys",
                    get: function get() {
                        return this._keys;
                    },
                    set: function set(value) {
                        this._keys = value;
                    }
                }, {
                    key: "eventGroups",
                    get: function get() {
                        return this._runtimeEvents || this._createRuntimeEvents(), this._runtimeEvents.eventGroups;
                    }
                }, {
                    key: "stepness",
                    get: function get() {
                        return this._stepness;
                    },
                    set: function set(value) {
                        this._stepness = value, this._applyStepness();
                    }
                }, {
                    key: "hash",
                    get: function get() {
                        return this._hash || (this._hash = murmurhash2_32_gc(JSON.stringify(this._getDeprecatedCurveDatas()), 666)), 
                        this._hash;
                    }
                }, {
                    key: "curves",
                    get: function get() {
                        return this._curves;
                    },
                    set: function set(value) {
                        this._curves = value, delete this._runtimeCurves;
                    }
                } ], [ {
                    key: "createWithSpriteFrames",
                    value: function createWithSpriteFrames(spriteFrames, sample) {
                        if (!Array.isArray(spriteFrames)) return errorID(3905), null;
                        var clip = new AnimationClip();
                        clip.sample = sample || clip.sample, clip.duration = spriteFrames.length / clip.sample;
                        for (var step = 1 / clip.sample, keys = new Array(spriteFrames.length), values = new Array(keys.length), i = 0; i < spriteFrames.length; i++) keys[i] = i * step, 
                        values[i] = spriteFrames[i];
                        return clip.keys = [ keys ], clip.curves = [ {
                            modifiers: [ new ComponentModifier("cc.SpriteComponent"), "spriteFrame" ],
                            data: {
                                keys: 0,
                                values: values
                            }
                        } ], clip;
                    }
                } ]), AnimationClip;
            }(), _class3$g.WrapMode = WrapMode$2, _descriptor$C = _applyDecoratedDescriptor((_class2$E = _temp$H).prototype, "sample", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 60;
                }
            }), _descriptor2$s = _applyDecoratedDescriptor(_class2$E.prototype, "speed", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _descriptor3$j = _applyDecoratedDescriptor(_class2$E.prototype, "wrapMode", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return WrapMode$2.Normal;
                }
            }), _descriptor4$f = _applyDecoratedDescriptor(_class2$E.prototype, "curveDatas", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return {};
                }
            }), _descriptor5$b = _applyDecoratedDescriptor(_class2$E.prototype, "_curves", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor6$4 = _applyDecoratedDescriptor(_class2$E.prototype, "events", [ _dec2$s ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor7$4 = _applyDecoratedDescriptor(_class2$E.prototype, "_duration", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor8$4 = _applyDecoratedDescriptor(_class2$E.prototype, "_keys", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor9$3 = _applyDecoratedDescriptor(_class2$E.prototype, "_stepness", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _class$N = _class2$E)) || _class$N));
            cc.AnimationClip = AnimationClip;
            var _class$O, _class2$F, _temp$I, AnimationBlendState = function() {
                function AnimationBlendState() {
                    _classCallCheck(this, AnimationBlendState), this._blendTargets = [];
                }
                return _createClass(AnimationBlendState, [ {
                    key: "refPropertyBlendTarget",
                    value: function refPropertyBlendTarget(target, property) {
                        var targetState = this._blendTargets.find(function(x) {
                            return x.target === target;
                        });
                        targetState || (targetState = {
                            target: target,
                            properties: []
                        }, this._blendTargets.push(targetState));
                        var propertyStates = targetState.properties, propertyState = propertyStates.find(function(p) {
                            return p.name === property;
                        });
                        return propertyState || (propertyState = {
                            name: property,
                            weight: 0,
                            value: void 0,
                            refCount: 0
                        }, propertyStates.push(propertyState)), ++propertyState.refCount, propertyState;
                    }
                }, {
                    key: "derefPropertyBlendTarget",
                    value: function derefPropertyBlendTarget(target, property) {
                        var iTargetState = this._blendTargets.findIndex(function(x) {
                            return x.target === target;
                        });
                        if (!(iTargetState < 0)) {
                            var propertyStates = this._blendTargets[iTargetState].properties, iPropertyState = propertyStates.findIndex(function(p) {
                                return p.name === property;
                            });
                            if (!(iPropertyState < 0)) {
                                var propertyState = propertyStates[iPropertyState];
                                --propertyState.refCount, 0 < propertyState.refCount || (2 <= propertyStates.length ? propertyStates.splice(iPropertyState, 1) : this._blendTargets.splice(iTargetState, 1));
                            }
                        }
                    }
                }, {
                    key: "apply",
                    value: function apply() {
                        var _iterator = this._blendTargets, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var targetState = _ref, target = targetState.target, _iterator2 = targetState.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                                var _ref2;
                                if (_isArray2) {
                                    if (_i2 >= _iterator2.length) break;
                                    _ref2 = _iterator2[_i2++];
                                } else {
                                    if ((_i2 = _iterator2.next()).done) break;
                                    _ref2 = _i2.value;
                                }
                                var p = _ref2;
                                0 !== p.weight && (target instanceof Node$1 ? "position" === p.name ? target.setPosition(p.value) : "rotation" === p.name ? target.setRotation(p.value) : target.setScale(p.value) : target[p.name] = p.value);
                            }
                        }
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        var _iterator3 = this._blendTargets, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i3 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i3++];
                            } else {
                                if ((_i3 = _iterator3.next()).done) break;
                                _ref3 = _i3.value;
                            }
                            var _iterator4 = _ref3.properties, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                            for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                                var _ref4;
                                if (_isArray4) {
                                    if (_i4 >= _iterator4.length) break;
                                    _ref4 = _iterator4[_i4++];
                                } else {
                                    if ((_i4 = _iterator4.next()).done) break;
                                    _ref4 = _i4.value;
                                }
                                _ref4.weight = 0;
                            }
                        }
                    }
                } ]), AnimationBlendState;
            }(), AnimationManager = exports("AnimationManager", ccclass((_temp$I = _class2$F = function() {
                function AnimationManager() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, AnimationManager);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AnimationManager)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._anims = new MutableForwardIterator([]), 
                    _this._delayEvents = [], _this._blendState = new AnimationBlendState(), _this._crossFades = [], 
                    _this;
                }
                return _inherits(AnimationManager, System), _createClass(AnimationManager, [ {
                    key: "addCrossFade",
                    value: function addCrossFade(crossFade) {
                        this._crossFades.push(crossFade);
                    }
                }, {
                    key: "removeCrossFade",
                    value: function removeCrossFade(crossFade) {
                        remove(this._crossFades, crossFade);
                    }
                }, {
                    key: "update",
                    value: function update(dt) {
                        var _iterator = this._crossFades, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            _ref.update(dt);
                        }
                        this._blendState.clear();
                        var iterator = this._anims, array = iterator.array;
                        for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                            var anim = array[iterator.i];
                            anim.isPlaying && !anim.isPaused && anim.update(dt);
                        }
                        this._blendState.apply();
                        for (var events = this._delayEvents, i = 0, l = events.length; i < l; i++) {
                            var event = events[i];
                            event.target[event.func].apply(event.target, event.args);
                        }
                        events.length = 0;
                    }
                }, {
                    key: "destruct",
                    value: function destruct() {}
                }, {
                    key: "addAnimation",
                    value: function addAnimation(anim) {
                        -1 === this._anims.array.indexOf(anim) && (anim.attachToBlendState(this._blendState), 
                        this._anims.push(anim));
                    }
                }, {
                    key: "removeAnimation",
                    value: function removeAnimation(anim) {
                        var index = this._anims.array.indexOf(anim);
                        0 <= index ? (anim.detachFromBlendState(this._blendState), this._anims.fastRemoveAt(index)) : errorID(3907);
                    }
                }, {
                    key: "pushDelayEvent",
                    value: function pushDelayEvent(target, func, args) {
                        this._delayEvents.push({
                            target: target,
                            func: func,
                            args: args
                        });
                    }
                }, {
                    key: "blendState",
                    get: function get() {
                        return this._blendState;
                    }
                } ]), AnimationManager;
            }(), _class2$F.ID = "animation", _class$O = _temp$I)) || _class$O);
            director.on(Director.EVENT_INIT, function() {
                var animationManager = new AnimationManager();
                director.registerSystem(AnimationManager.ID, animationManager, Scheduler.PRIORITY_SYSTEM);
            }), cc.AnimationManager = AnimationManager;
            var PropertySpecialization, Playable = function() {
                function Playable() {
                    _classCallCheck(this, Playable), this._isPlaying = !1, this._isPaused = !1, this._stepOnce = !1;
                }
                return _createClass(Playable, [ {
                    key: "play",
                    value: function play() {
                        this._isPlaying ? this._isPaused ? (this._isPaused = !1, this.onResume()) : this.onError(getError(3912)) : (this._isPlaying = !0, 
                        this.onPlay());
                    }
                }, {
                    key: "stop",
                    value: function stop() {
                        this._isPlaying && (this._isPlaying = !1, this.onStop(), this._isPaused = !1);
                    }
                }, {
                    key: "pause",
                    value: function pause() {
                        this._isPlaying && !this._isPaused && (this._isPaused = !0, this.onPause());
                    }
                }, {
                    key: "resume",
                    value: function resume() {
                        this._isPlaying && this._isPaused && (this._isPaused = !1, this.onResume());
                    }
                }, {
                    key: "step",
                    value: function step() {
                        this.pause(), this._stepOnce = !0, this._isPlaying || this.play();
                    }
                }, {
                    key: "update",
                    value: function update() {}
                }, {
                    key: "onPlay",
                    value: function onPlay() {}
                }, {
                    key: "onPause",
                    value: function onPause() {}
                }, {
                    key: "onResume",
                    value: function onResume() {}
                }, {
                    key: "onStop",
                    value: function onStop() {}
                }, {
                    key: "onError",
                    value: function onError() {}
                }, {
                    key: "isPlaying",
                    get: function get() {
                        return this._isPlaying;
                    }
                }, {
                    key: "isPaused",
                    get: function get() {
                        return this._isPaused;
                    }
                } ]), Playable;
            }();
            function additive3D(value, weight, propertyBlendState) {
                return propertyBlendState.value || (propertyBlendState.value = new Vec3()), 0 === propertyBlendState.weight && Vec3.zero(propertyBlendState.value), 
                0 === weight ? propertyBlendState.value : 1 === weight ? Vec3.copy(propertyBlendState.value, value) : Vec3.scaleAndAdd(propertyBlendState.value, propertyBlendState.value, value, weight);
            }
            function additiveQuat(value, weight, propertyBlendState) {
                if (propertyBlendState.value || (propertyBlendState.value = new Quat()), 0 === propertyBlendState.weight && Quat.identity(propertyBlendState.value), 
                0 === weight) return propertyBlendState.value;
                if (1 === weight) return Quat.copy(propertyBlendState.value, value);
                var t = weight / (propertyBlendState.weight + weight);
                return Quat.slerp(propertyBlendState.value, propertyBlendState.value, value, t);
            }
            !function(PropertySpecialization) {
                PropertySpecialization[PropertySpecialization.NodePosition = 0] = "NodePosition", 
                PropertySpecialization[PropertySpecialization.NodeScale = 1] = "NodeScale", PropertySpecialization[PropertySpecialization.NodeRotation = 2] = "NodeRotation", 
                PropertySpecialization[PropertySpecialization.None = 3] = "None";
            }(PropertySpecialization = PropertySpecialization || {});
            var ICurveInstance = function() {
                function ICurveInstance(runtimeCurve, target) {
                    var blendTarget = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
                    if (_classCallCheck(this, ICurveInstance), this._curve = void 0, this._boundTarget = void 0, 
                    this._curveValueProxy = void 0, this._rootTarget = void 0, this._rootTargetProperty = void 0, 
                    this._isNodeTarget = void 0, this._propertySpecialization = void 0, this._blendTarget = void 0, 
                    this._blendFunction = void 0, this._cached = void 0, this._curveDetail = void 0, 
                    this._curve = runtimeCurve.curve, this._curveDetail = runtimeCurve, this._boundTarget = new BoundTarget(target, runtimeCurve.modifiers, runtimeCurve.valueAdapter), 
                    this._rootTarget = target, this._isNodeTarget = target instanceof Node$1, this._propertySpecialization = PropertySpecialization.None, 
                    this._blendFunction = null, this._isNodeTarget && 1 === runtimeCurve.modifiers.length) switch (runtimeCurve.modifiers[0]) {
                      case "position":
                        this._propertySpecialization = PropertySpecialization.NodePosition, this._blendFunction = additive3D;
                        break;

                      case "rotation":
                        this._propertySpecialization = PropertySpecialization.NodeRotation, this._blendFunction = additiveQuat;
                        break;

                      case "scale":
                        this._propertySpecialization = PropertySpecialization.NodeScale, this._blendFunction = additive3D;
                    }
                    this._blendTarget = blendTarget;
                }
                return _createClass(ICurveInstance, [ {
                    key: "attachToBlendState",
                    value: function attachToBlendState(blendState) {
                        this._rootTargetProperty && (this._blendTarget = blendState.refPropertyBlendTarget(this._rootTarget, this._rootTargetProperty));
                    }
                }, {
                    key: "dettachFromBlendState",
                    value: function dettachFromBlendState(blendState) {
                        this._rootTargetProperty && (this._blendTarget = null, blendState.derefPropertyBlendTarget(this._rootTarget, this._rootTargetProperty));
                    }
                }, {
                    key: "applySample",
                    value: function applySample(ratio, index, lerpRequired, samplerResultCache, weight) {
                        var value;
                        this._curve.empty() || (value = lerpRequired ? this._curve.valueBetween(ratio, samplerResultCache.from, samplerResultCache.fromRatio, samplerResultCache.to, samplerResultCache.toRatio) : this._curve.valueAt(index), 
                        this._setValue(value, weight));
                    }
                }, {
                    key: "_setValue",
                    value: function _setValue(value, weight) {
                        if (!this._blendFunction || !this._blendTarget || this._blendTarget.refCount <= 1) switch (this._propertySpecialization) {
                          case PropertySpecialization.NodePosition:
                            this._rootTarget.setPosition(value);
                            break;

                          case PropertySpecialization.NodeRotation:
                            this._rootTarget.setRotation(value);
                            break;

                          case PropertySpecialization.NodeScale:
                            this._rootTarget.setScale(value);
                            break;

                          default:
                            this._boundTarget.setValue(value);
                        } else this._blendTarget.value = this._blendFunction(value, weight, this._blendTarget), 
                        this._blendTarget.weight += weight;
                    }
                }, {
                    key: "propertyName",
                    get: function get() {
                        return this._rootTargetProperty || "";
                    }
                }, {
                    key: "curveDetail",
                    get: function get() {
                        return this._curveDetail;
                    }
                } ]), ICurveInstance;
            }();
            var _class4$4, _class5$4, _descriptor4$g, _descriptor5$c, _descriptor6$5, AnimationState = exports("AnimationState", function() {
                function AnimationState(clip, name) {
                    var _this;
                    return _classCallCheck(this, AnimationState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(AnimationState).call(this))).duration = 1, 
                    _this.speed = 1, _this.time = 0, _this.weight = 0, _this.frameRate = 0, _this._lastframeEventOn = !1, 
                    _this._wrapMode = WrapMode$2.Normal, _this._repeatCount = 1, _this._currentFramePlayed = !1, 
                    _this._delay = 0, _this._delayTime = 0, _this._wrappedInfo = new WrappedInfo(), 
                    _this._lastWrapInfo = null, _this._lastWrapInfoEvent = null, _this._process = _this.process, 
                    _this._target = null, _this._targetNode = null, _this._clip = void 0, _this._name = void 0, 
                    _this._lastIterations = void 0, _this._samplerSharedGroups = [], _this._curveLoaded = !1, 
                    _this._ignoreIndex = -1, _this._clip = clip, _this._name = name || clip && clip.name, 
                    _this;
                }
                return _inherits(AnimationState, Playable), _createClass(AnimationState, [ {
                    key: "clip",
                    get: function get() {
                        return this._clip;
                    }
                }, {
                    key: "name",
                    get: function get() {
                        return this._name;
                    }
                }, {
                    key: "length",
                    get: function get() {
                        return this.duration;
                    }
                }, {
                    key: "wrapMode",
                    get: function get() {
                        return this._wrapMode;
                    },
                    set: function set(value) {
                        this._wrapMode = value, this.time = 0, value & WrapModeMask.Loop ? this.repeatCount = 1 / 0 : this.repeatCount = 1;
                    }
                }, {
                    key: "repeatCount",
                    get: function get() {
                        return this._repeatCount;
                    },
                    set: function set(value) {
                        this._repeatCount = value;
                        var shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap, reverse = (this.wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse;
                        this._process = value !== 1 / 0 || shouldWrap || reverse ? this.process : this.simpleProcess;
                    }
                }, {
                    key: "delay",
                    get: function get() {
                        return this._delay;
                    },
                    set: function set(value) {
                        this._delayTime = this._delay = value;
                    }
                } ]), _createClass(AnimationState, [ {
                    key: "initialize",
                    value: function initialize(root) {
                        var _this2 = this;
                        if (!this._curveLoaded) {
                            this._curveLoaded = !0, this._samplerSharedGroups.length = 0, this._targetNode = root;
                            var clip = this._clip;
                            this.duration = clip.duration, this.speed = clip.speed, this.wrapMode = clip.wrapMode, 
                            this.frameRate = clip.sample, (this.wrapMode & WrapModeMask.Loop) === WrapModeMask.Loop ? this.repeatCount = 1 / 0 : this.repeatCount = 1;
                            for (var propertyCurves = clip.getPropertyCurves(root), _loop = function _loop(iPropertyCurve) {
                                var propertyCurve = propertyCurves[iPropertyCurve], samplerSharedGroup = _this2._samplerSharedGroups.find(function(value) {
                                    return value.sampler === propertyCurve.sampler;
                                });
                                samplerSharedGroup || (samplerSharedGroup = function makeSamplerSharedGroup(sampler) {
                                    return {
                                        sampler: sampler,
                                        curves: [],
                                        samplerResultCache: {
                                            from: 0,
                                            fromRatio: 0,
                                            to: 0,
                                            toRatio: 0
                                        }
                                    };
                                }(propertyCurve.sampler), _this2._samplerSharedGroups.push(samplerSharedGroup));
                                try {
                                    samplerSharedGroup.curves.push(new ICurveInstance(propertyCurve, root));
                                } catch (err) {}
                            }, iPropertyCurve = 0; iPropertyCurve < propertyCurves.length; ++iPropertyCurve) _loop(iPropertyCurve);
                        }
                    }
                }, {
                    key: "_emit",
                    value: function _emit(type, state) {
                        this._target && this._target.isValid && this._target.emit(type, type, state);
                    }
                }, {
                    key: "emit",
                    value: function emit() {
                        for (var args = new Array(arguments.length), i = 0, l = args.length; i < l; i++) args[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                        director.getAnimationManager().pushDelayEvent(this, "_emit", args);
                    }
                }, {
                    key: "on",
                    value: function on(type, callback, target) {
                        return this._target && this._target.isValid ? ("lastframe" === type && (this._lastframeEventOn = !0), 
                        this._target.on(type, callback, target)) : null;
                    }
                }, {
                    key: "once",
                    value: function once(type, callback, target) {
                        var _this3 = this;
                        return this._target && this._target.isValid ? ("lastframe" === type && (this._lastframeEventOn = !0), 
                        this._target.once(type, function(event) {
                            callback.call(target, event), _this3._lastframeEventOn = !1;
                        })) : null;
                    }
                }, {
                    key: "off",
                    value: function off(type, callback, target) {
                        this._target && this._target.isValid && ("lastframe" === type && (this._target.hasEventListener(type) || (this._lastframeEventOn = !1)), 
                        this._target.off(type, callback, target));
                    }
                }, {
                    key: "_setEventTarget",
                    value: function _setEventTarget(target) {
                        this._target = target;
                    }
                }, {
                    key: "setTime",
                    value: function setTime(time) {
                        this._currentFramePlayed = !1, this.time = time || 0, this._lastWrapInfoEvent = null, 
                        this._ignoreIndex = -1;
                        var info = this.getWrappedInfo(time, this._wrappedInfo), direction = info.direction, frameIndex = this._clip.getEventGroupIndexAtRatio(info.ratio);
                        frameIndex < 0 && (frameIndex = ~frameIndex - 1, direction < 0 && (frameIndex += 1), 
                        this._ignoreIndex = frameIndex);
                    }
                }, {
                    key: "update",
                    value: function update(delta) {
                        0 < this._delayTime && (this._delayTime -= delta, 0 < this._delayTime) || (this._currentFramePlayed ? this.time += delta * this.speed : this._currentFramePlayed = !0, 
                        this._process());
                    }
                }, {
                    key: "_needReverse",
                    value: function _needReverse(currentIterations) {
                        var wrapMode = this.wrapMode, needReverse = !1;
                        (wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong && (currentIterations - (0 | currentIterations) == 0 && 0 < currentIterations && (currentIterations -= 1), 
                        1 & currentIterations && (needReverse = !needReverse));
                        return (wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse && (needReverse = !needReverse), 
                        needReverse;
                    }
                }, {
                    key: "getWrappedInfo",
                    value: function getWrappedInfo(time, info) {
                        info = info || new WrappedInfo();
                        var stopped = !1, duration = this.duration, repeatCount = this.repeatCount, currentIterations = 0 < time ? time / duration : -time / duration;
                        if (repeatCount <= currentIterations) {
                            stopped = !0;
                            var tempRatio = (currentIterations = repeatCount) - (0 | repeatCount);
                            0 === tempRatio && (tempRatio = 1), time = tempRatio * duration * (0 < time ? 1 : -1);
                        }
                        if (duration < time) {
                            var tempTime = time % duration;
                            time = 0 == tempTime ? duration : tempTime;
                        } else time < 0 && 0 !== (time %= duration) && (time += duration);
                        var needReverse = !1, shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;
                        shouldWrap && (needReverse = this._needReverse(currentIterations));
                        var direction = needReverse ? -1 : 1;
                        return this.speed < 0 && (direction *= -1), shouldWrap && needReverse && (time = duration - time), 
                        info.ratio = time / duration, info.time = time, info.direction = direction, info.stopped = stopped, 
                        info.iterations = currentIterations, info;
                    }
                }, {
                    key: "sample",
                    value: function sample() {
                        var info = this.getWrappedInfo(this.time, this._wrappedInfo);
                        return this._sampleCurves(info.ratio), this._sampleEvents(info), info;
                    }
                }, {
                    key: "process",
                    value: function process() {
                        var lastInfo, info = this.sample();
                        this._lastframeEventOn && (lastInfo = this._lastWrapInfo ? this._lastWrapInfo : this._lastWrapInfo = new WrappedInfo(info), 
                        1 < this.repeatCount && (0 | info.iterations) > (0 | lastInfo.iterations) && this.emit("lastframe", this), 
                        lastInfo.set(info));
                        info.stopped && (this.stop(), this.emit("finished", this));
                    }
                }, {
                    key: "simpleProcess",
                    value: function simpleProcess() {
                        var time = this.time, duration = this.duration;
                        duration < time ? 0 === (time %= duration) && (time = duration) : time < 0 && 0 !== (time %= duration) && (time += duration);
                        var ratio = time / duration;
                        this._sampleCurves(ratio), this._clip.hasEvents() && this._sampleEvents(this.getWrappedInfo(this.time, this._wrappedInfo)), 
                        this._lastframeEventOn && (void 0 === this._lastIterations && (this._lastIterations = ratio), 
                        (0 < this.time && this._lastIterations > ratio || this.time < 0 && this._lastIterations < ratio) && this.emit("lastframe", this), 
                        this._lastIterations = ratio);
                    }
                }, {
                    key: "attachToBlendState",
                    value: function attachToBlendState(blendState) {
                        var _iterator = this._samplerSharedGroups, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var _iterator2 = _ref.curves, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                                var _ref2;
                                if (_isArray2) {
                                    if (_i2 >= _iterator2.length) break;
                                    _ref2 = _iterator2[_i2++];
                                } else {
                                    if ((_i2 = _iterator2.next()).done) break;
                                    _ref2 = _i2.value;
                                }
                                _ref2.attachToBlendState(blendState);
                            }
                        }
                    }
                }, {
                    key: "detachFromBlendState",
                    value: function detachFromBlendState(blendState) {
                        var _iterator3 = this._samplerSharedGroups, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i3 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i3++];
                            } else {
                                if ((_i3 = _iterator3.next()).done) break;
                                _ref3 = _i3.value;
                            }
                            var _iterator4 = _ref3.curves, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                            for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                                var _ref4;
                                if (_isArray4) {
                                    if (_i4 >= _iterator4.length) break;
                                    _ref4 = _iterator4[_i4++];
                                } else {
                                    if ((_i4 = _iterator4.next()).done) break;
                                    _ref4 = _i4.value;
                                }
                                _ref4.dettachFromBlendState(blendState);
                            }
                        }
                    }
                }, {
                    key: "cache",
                    value: function cache() {}
                }, {
                    key: "onPlay",
                    value: function onPlay() {
                        this.setTime(0), this._delayTime = this._delay, director.getAnimationManager().addAnimation(this), 
                        this.emit("play", this);
                    }
                }, {
                    key: "onStop",
                    value: function onStop() {
                        this.isPaused || director.getAnimationManager().removeAnimation(this), this.emit("stop", this);
                    }
                }, {
                    key: "onResume",
                    value: function onResume() {
                        director.getAnimationManager().addAnimation(this), this.emit("resume", this);
                    }
                }, {
                    key: "onPause",
                    value: function onPause() {
                        director.getAnimationManager().removeAnimation(this), this.emit("pause", this);
                    }
                }, {
                    key: "_sampleCurves",
                    value: function _sampleCurves(ratio) {
                        for (var iSamplerSharedGroup = 0, szSamplerSharedGroup = this._samplerSharedGroups.length; iSamplerSharedGroup < szSamplerSharedGroup; ++iSamplerSharedGroup) {
                            var samplerSharedGroup = this._samplerSharedGroups[iSamplerSharedGroup], sampler = samplerSharedGroup.sampler, samplerResultCache = samplerSharedGroup.samplerResultCache, index = 0, lerpRequired = !1;
                            sampler ? (index = sampler.sample(ratio)) < 0 && ((index = ~index) <= 0 ? index = 0 : index >= sampler.ratios.length ? index = sampler.ratios.length - 1 : (lerpRequired = !0, 
                            samplerResultCache.from = index - 1, samplerResultCache.fromRatio = sampler.ratios[samplerResultCache.from], 
                            samplerResultCache.to = index, samplerResultCache.toRatio = sampler.ratios[samplerResultCache.to])) : index = 0;
                            for (var iCurveInstance = 0, szCurves = samplerSharedGroup.curves.length; iCurveInstance < szCurves; ++iCurveInstance) {
                                samplerSharedGroup.curves[iCurveInstance].applySample(ratio, index, lerpRequired, samplerResultCache, this.weight);
                            }
                        }
                    }
                }, {
                    key: "_sampleEvents",
                    value: function _sampleEvents(wrapInfo) {
                        var length = this._clip.eventGroups.length, direction = wrapInfo.direction, eventIndex = this._clip.getEventGroupIndexAtRatio(wrapInfo.ratio);
                        if (eventIndex < 0 && (eventIndex = ~eventIndex - 1, direction < 0 && (eventIndex += 1)), 
                        this._ignoreIndex !== eventIndex && (this._ignoreIndex = -1), wrapInfo.frameIndex = eventIndex, 
                        !this._lastWrapInfoEvent) return this._fireEvent(eventIndex), void (this._lastWrapInfoEvent = new WrappedInfo(wrapInfo));
                        var wrapMode = this.wrapMode, currentIterations = wrapIterations(wrapInfo.iterations), lastWrappedInfo = this._lastWrapInfoEvent, lastIterations = wrapIterations(lastWrappedInfo.iterations), lastIndex = lastWrappedInfo.frameIndex, lastDirection = lastWrappedInfo.direction, interationsChanged = -1 !== lastIterations && currentIterations !== lastIterations;
                        if (lastIndex === eventIndex && interationsChanged && 1 === length) this._fireEvent(0); else if (lastIndex !== eventIndex || interationsChanged) {
                            direction = lastDirection;
                            do {
                                if (lastIndex !== eventIndex) {
                                    if (-1 === direction && 0 === lastIndex && 0 < eventIndex ? ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong ? direction *= -1 : lastIndex = length, 
                                    lastIterations++) : 1 === direction && lastIndex === length - 1 && eventIndex < length - 1 && ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong ? direction *= -1 : lastIndex = -1, 
                                    lastIterations++), lastIndex === eventIndex) break;
                                    if (currentIterations < lastIterations) break;
                                }
                                lastIndex += direction, director.getAnimationManager().pushDelayEvent(this, "_fireEvent", [ lastIndex ]);
                            } while (lastIndex !== eventIndex && -1 < lastIndex && lastIndex < length);
                        }
                        this._lastWrapInfoEvent.set(wrapInfo);
                    }
                }, {
                    key: "_fireEvent",
                    value: function _fireEvent(index) {
                        if (this._targetNode && this._targetNode.isValid) {
                            var eventGroups = this._clip.eventGroups;
                            if (!(index < 0 || index >= eventGroups.length || this._ignoreIndex === index)) {
                                var eventGroup = eventGroups[index], components = this._targetNode.components, _iterator5 = eventGroup.events, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                                    var _ref5;
                                    if (_isArray5) {
                                        if (_i5 >= _iterator5.length) break;
                                        _ref5 = _iterator5[_i5++];
                                    } else {
                                        if ((_i5 = _iterator5.next()).done) break;
                                        _ref5 = _i5.value;
                                    }
                                    var event = _ref5, functionName = event.functionName, _iterator6 = components, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                                    for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                                        var _ref6;
                                        if (_isArray6) {
                                            if (_i6 >= _iterator6.length) break;
                                            _ref6 = _iterator6[_i6++];
                                        } else {
                                            if ((_i6 = _iterator6.next()).done) break;
                                            _ref6 = _i6.value;
                                        }
                                        var component = _ref6, fx = component[functionName];
                                        "function" == typeof fx && fx.apply(component, event.parameters);
                                    }
                                }
                            }
                        }
                    }
                }, {
                    key: "curveLoaded",
                    get: function get() {
                        return this._curveLoaded;
                    }
                } ]), AnimationState;
            }());
            function wrapIterations(iterations) {
                return iterations - (0 | iterations) == 0 && (iterations -= 1), 0 | iterations;
            }
            function makeCubicSplineValueConstructor(name, constructorX, scaleFx, scaleAndAdd) {
                var _class, _class2, _descriptor, _descriptor2, _descriptor3, tempValue = new constructorX(), m0 = new constructorX(), m1 = new constructorX();
                return ccclass(name)((_descriptor = _applyDecoratedDescriptor((_class2 = function() {
                    function CubicSplineValueClass(dataPoint, inTangent, outTangent) {
                        _classCallCheck(this, CubicSplineValueClass), _initializerDefineProperty(this, "dataPoint", _descriptor, this), 
                        _initializerDefineProperty(this, "inTangent", _descriptor2, this), _initializerDefineProperty(this, "outTangent", _descriptor3, this), 
                        this.dataPoint = dataPoint || new constructorX(), this.inTangent = inTangent || new constructorX(), 
                        this.outTangent = outTangent || new constructorX();
                    }
                    return _createClass(CubicSplineValueClass, [ {
                        key: "lerp",
                        value: function lerp(to, t, dt) {
                            var p0 = this.dataPoint, p1 = to.dataPoint;
                            m0 = scaleFx(m0, this.outTangent, dt), m1 = scaleFx(m1, to.inTangent, dt);
                            var t_3 = t * t * t, t_2 = t * t, f_1 = t_3 - 2 * t_2 + t, f_2 = -2 * t_3 + 3 * t_2, f_3 = t_3 - t_2;
                            return tempValue = scaleFx(tempValue, p0, 2 * t_3 - 3 * t_2 + 1), tempValue = scaleAndAdd(tempValue, tempValue, m0, f_1), 
                            tempValue = scaleAndAdd(tempValue, tempValue, p1, f_2), tempValue = scaleAndAdd(tempValue, tempValue, m1, f_3);
                        }
                    }, {
                        key: "getNoLerp",
                        value: function getNoLerp() {
                            return this.dataPoint;
                        }
                    } ]), CubicSplineValueClass;
                }()).prototype, "dataPoint", [ property ], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function initializer() {
                        return new constructorX();
                    }
                }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "inTangent", [ property ], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function initializer() {
                        return new constructorX();
                    }
                }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "outTangent", [ property ], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function initializer() {
                        return new constructorX();
                    }
                }), _class = _class2)) || _class;
            }
            cc.AnimationState = AnimationState;
            var CubicSplineVec2Value = exports("CubicSplineVec2Value", makeCubicSplineValueConstructor("cc.CubicSplineVec2Value", Vec2, Vec2.multiplyScalar, Vec2.scaleAndAdd));
            cc.CubicSplineVec2Value = CubicSplineVec2Value;
            var CubicSplineVec3Value = exports("CubicSplineVec3Value", makeCubicSplineValueConstructor("cc.CubicSplineVec3Value", Vec3, Vec3.multiplyScalar, Vec3.scaleAndAdd));
            cc.CubicSplineVec3Value = CubicSplineVec3Value;
            var CubicSplineVec4Value = exports("CubicSplineVec4Value", makeCubicSplineValueConstructor("cc.CubicSplineVec4Value", Vec4, Vec4.multiplyScalar, Vec4.scaleAndAdd));
            cc.CubicSplineVec4Value = CubicSplineVec4Value;
            var CubicSplineQuatValue = exports("CubicSplineQuatValue", makeCubicSplineValueConstructor("cc.CubicSplineQuatValue", Quat, Quat.multiplyScalar, Quat.scaleAndAdd));
            cc.CubicSplineQuatValue = CubicSplineQuatValue;
            var CubicSplineNumberValue = exports("CubicSplineNumberValue", ccclass("cc.CubicSplineNumberValue")((_descriptor4$g = _applyDecoratedDescriptor((_class5$4 = function() {
                function CubicSplineNumberValue(dataPoint, inTangent, outTangent) {
                    _classCallCheck(this, CubicSplineNumberValue), _initializerDefineProperty(this, "dataPoint", _descriptor4$g, this), 
                    _initializerDefineProperty(this, "inTangent", _descriptor5$c, this), _initializerDefineProperty(this, "outTangent", _descriptor6$5, this), 
                    this.dataPoint = dataPoint, this.inTangent = inTangent, this.outTangent = outTangent;
                }
                return _createClass(CubicSplineNumberValue, [ {
                    key: "lerp",
                    value: function lerp(to, t, dt) {
                        var p0 = this.dataPoint, p1 = to.dataPoint, t_3 = t * t * t, t_2 = t * t;
                        return p0 * (2 * t_3 - 3 * t_2 + 1) + this.outTangent * dt * (t_3 - 2 * t_2 + t) + p1 * (-2 * t_3 + 3 * t_2) + to.inTangent * dt * (t_3 - t_2);
                    }
                }, {
                    key: "getNoLerp",
                    value: function getNoLerp() {
                        return this.dataPoint;
                    }
                } ]), CubicSplineNumberValue;
            }()).prototype, "dataPoint", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor5$c = _applyDecoratedDescriptor(_class5$4.prototype, "inTangent", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor6$5 = _applyDecoratedDescriptor(_class5$4.prototype, "outTangent", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _class4$4 = _class5$4)) || _class4$4);
            cc.CubicSplineNumberValue = CubicSplineNumberValue;
            var _dec$O, _dec2$u, _dec3$g, _dec4$d, _dec5$c, _dec6$9, _class$P, _class2$G, _descriptor$D, _descriptor2$t, _descriptor3$k, _class3$h, _temp$J, EventType, CrossFade = function() {
                function CrossFade() {
                    var _this;
                    return _classCallCheck(this, CrossFade), (_this = _possibleConstructorReturn(this, _getPrototypeOf(CrossFade).call(this)))._managedStates = [], 
                    _this._fadings = [], _this;
                }
                return _inherits(CrossFade, Playable), _createClass(CrossFade, [ {
                    key: "update",
                    value: function update(deltaTime) {
                        if (this.isPlaying && !this.isPaused) {
                            for (var iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                                var state = this._managedStates[iManagedState].state;
                                state && (state.weight = 0);
                            }
                            for (var absoluteWeight = 1, deadFadingBegin = this._fadings.length, iFading = 0; iFading < this._fadings.length; ++iFading) {
                                if (0 === absoluteWeight) {
                                    deadFadingBegin = iFading;
                                    break;
                                }
                                var fading = this._fadings[iFading];
                                fading.easeTime += deltaTime;
                                var relativeWeight = clamp01(fading.easeTime / fading.easeDuration), weight = relativeWeight * absoluteWeight;
                                absoluteWeight *= 1 - relativeWeight, fading.target.state && (fading.target.state.weight += weight);
                            }
                            if (deadFadingBegin !== this._fadings.length) {
                                for (var iDeadFading = deadFadingBegin; iDeadFading < this._fadings.length; ++iDeadFading) {
                                    var deadFading = this._fadings[iDeadFading];
                                    --deadFading.target.reference, deadFading.target.reference <= 0 && (deadFading.target.state && deadFading.target.state.stop(), 
                                    remove(this._managedStates, deadFading.target));
                                }
                                this._fadings.splice(deadFadingBegin);
                            }
                        }
                    }
                }, {
                    key: "crossFade",
                    value: function crossFade(state, duration) {
                        0 === duration && this.clear();
                        var target = this._managedStates.find(function(weightedState) {
                            return weightedState.state === state;
                        });
                        target || (target = {
                            state: state,
                            reference: 0
                        }, state && state.play(), this._managedStates.push(target)), ++target.reference, 
                        this._fadings.unshift({
                            easeDuration: duration,
                            easeTime: 0,
                            target: target
                        });
                    }
                }, {
                    key: "onPlay",
                    value: function onPlay() {
                        _get(_getPrototypeOf(CrossFade.prototype), "onPlay", this).call(this), director.getAnimationManager().addCrossFade(this);
                    }
                }, {
                    key: "onPause",
                    value: function onPause() {
                        _get(_getPrototypeOf(CrossFade.prototype), "onPause", this).call(this), director.getAnimationManager().removeCrossFade(this);
                        for (var iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                            var state = this._managedStates[iManagedState].state;
                            state && state.pause();
                        }
                    }
                }, {
                    key: "onResume",
                    value: function onResume() {
                        _get(_getPrototypeOf(CrossFade.prototype), "onResume", this).call(this), director.getAnimationManager().addCrossFade(this);
                        for (var iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                            var state = this._managedStates[iManagedState].state;
                            state && state.resume();
                        }
                    }
                }, {
                    key: "onStop",
                    value: function onStop() {
                        _get(_getPrototypeOf(CrossFade.prototype), "onStop", this).call(this), director.getAnimationManager().removeCrossFade(this), 
                        this.clear();
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        for (var iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                            var state = this._managedStates[iManagedState].state;
                            state && state.stop();
                        }
                        this._managedStates.length = 0, this._fadings.length = 0;
                    }
                } ]), CrossFade;
            }();
            !function(EventType) {
                EventType.PLAY = "play", EventType.STOP = "stop", EventType.PAUSE = "pause", EventType.RESUME = "resume", 
                EventType.LASTFRAME = "lastframe", EventType.FINISHED = "finished";
            }(EventType = EventType || exports("EventType", {})), ccenum(EventType);
            var _class$Q, AnimationComponent = exports("AnimationComponent", (_dec$O = ccclass("cc.AnimationComponent"), 
            _dec2$u = executionOrder(99), _dec3$g = menu("Components/Animation"), _dec4$d = property({
                type: [ AnimationClip ]
            }), _dec5$c = property({
                type: AnimationClip
            }), _dec6$9 = property({
                type: [ AnimationClip ]
            }), _dec$O(_class$P = _dec2$u(_class$P = executeInEditMode(_class$P = _dec3$g((_temp$J = _class3$h = function() {
                function AnimationComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, AnimationComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AnimationComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "playOnLoad", _descriptor$D, _assertThisInitialized(_this)), 
                    _this._callbackTable = createMap(!0), _this._crossFade = new CrossFade(), _this._nameToState = createMap(!0), 
                    _initializerDefineProperty(_this, "_clips", _descriptor2$t, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_defaultClip", _descriptor3$k, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(AnimationComponent, Component), _createClass(AnimationComponent, [ {
                    key: "onLoad",
                    value: function onLoad() {
                        this.clips = this._clips;
                        for (var _i = 0, _Object$keys = Object.keys(this._nameToState); _i < _Object$keys.length; _i++) {
                            var stateName = _Object$keys[_i];
                            this._nameToState[stateName].initialize(this.node);
                        }
                    }
                }, {
                    key: "start",
                    value: function start() {
                        this.playOnLoad && this._defaultClip && this.crossFade(this._defaultClip.name, 0);
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        this._crossFade.resume();
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this._crossFade.pause();
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this._crossFade.stop();
                        for (var _i2 = 0, _Object$keys2 = Object.keys(this._nameToState); _i2 < _Object$keys2.length; _i2++) {
                            var _name = _Object$keys2[_i2];
                            this._nameToState[_name].stop();
                        }
                        this._nameToState = createMap(!0);
                    }
                }, {
                    key: "play",
                    value: function play(name) {
                        if (!name) {
                            if (!this._defaultClip) return;
                            name = this._defaultClip.name;
                        }
                        this.crossFade(name, 0);
                    }
                }, {
                    key: "crossFade",
                    value: function crossFade(name, argument_1) {
                        var duration = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : .3, state = this._nameToState[name];
                        state && (this._crossFade.play(), this._crossFade.crossFade(state, duration));
                    }
                }, {
                    key: "pause",
                    value: function pause() {
                        this._crossFade.pause();
                    }
                }, {
                    key: "resume",
                    value: function resume() {
                        this._crossFade.resume();
                    }
                }, {
                    key: "stop",
                    value: function stop() {
                        this._crossFade.stop();
                    }
                }, {
                    key: "getAnimationState",
                    value: function getAnimationState(name) {
                        return this.getState(name);
                    }
                }, {
                    key: "getState",
                    value: function getState(name) {
                        var state = this._nameToState[name];
                        return state && !state.curveLoaded && state.initialize(this.node), state || null;
                    }
                }, {
                    key: "createState",
                    value: function createState(clip, name) {
                        return name = name || clip.name, this.removeState(name), this._doCreateState(clip, name);
                    }
                }, {
                    key: "removeState",
                    value: function removeState(name) {
                        var state = this._nameToState[name];
                        state && (state.stop(), delete this._nameToState[name]);
                    }
                }, {
                    key: "addClip",
                    value: function addClip(clip, name) {
                        return contains(this._clips, clip) || this._clips.push(clip), this.createState(clip, name);
                    }
                }, {
                    key: "removeClip",
                    value: function removeClip(clip, force) {
                        for (var state, _i3 = 0, _Object$keys3 = Object.keys(this._nameToState); _i3 < _Object$keys3.length; _i3++) {
                            var _name2 = _Object$keys3[_i3];
                            if ((state = this._nameToState[_name2]).clip === clip) break;
                        }
                        if (clip === this._defaultClip) {
                            if (!force) return void warnID(3902);
                            this._defaultClip = null;
                        }
                        if (state && state.isPlaying) {
                            if (!force) return void warnID(3903);
                            state.stop();
                        }
                        this._clips = this._clips.filter(function(item) {
                            return item !== clip;
                        }), state && delete this._nameToState[state.name];
                    }
                }, {
                    key: "on",
                    value: function on(type, callback, target) {
                        var ret = EventTarget.prototype.on.call(this, type, callback, target);
                        if ("lastframe" === type) for (var _i4 = 0, _Object$keys4 = Object.keys(this._nameToState); _i4 < _Object$keys4.length; _i4++) {
                            var stateName = _Object$keys4[_i4];
                            this._nameToState[stateName]._lastframeEventOn = !0;
                        }
                        return ret;
                    }
                }, {
                    key: "off",
                    value: function off(type, callback, target) {
                        if ("lastframe" === type) for (var nameToState = this._nameToState, _i5 = 0, _Object$keys5 = Object.keys(nameToState); _i5 < _Object$keys5.length; _i5++) {
                            nameToState[_Object$keys5[_i5]]._lastframeEventOn = !1;
                        }
                        EventTarget.prototype.off.call(this, type, callback, target);
                    }
                }, {
                    key: "targetOff",
                    value: function targetOff() {}
                }, {
                    key: "once",
                    value: function once() {}
                }, {
                    key: "dispatchEvent",
                    value: function dispatchEvent() {}
                }, {
                    key: "hasEventListener",
                    value: function hasEventListener() {
                        return !1;
                    }
                }, {
                    key: "removeAll",
                    value: function removeAll() {}
                }, {
                    key: "emit",
                    value: function emit() {}
                }, {
                    key: "_createState",
                    value: function _createState(clip, name) {
                        return new AnimationState(clip, name);
                    }
                }, {
                    key: "_doCreateState",
                    value: function _doCreateState(clip, name) {
                        var state = this._createState(clip, name);
                        return state._setEventTarget(this), this.node && state.initialize(this.node), this._nameToState[state.name] = state;
                    }
                }, {
                    key: "_getStateByNameOrDefaultClip",
                    value: function _getStateByNameOrDefaultClip(name) {
                        if (!name) {
                            if (!this._defaultClip) return null;
                            name = this._defaultClip.name;
                        }
                        var state = this._nameToState[name];
                        return state || null;
                    }
                }, {
                    key: "_removeStateOfAutomaticClip",
                    value: function _removeStateOfAutomaticClip(clip) {
                        for (var _name4 in this._nameToState) {
                            var _state4 = this._nameToState[_name4];
                            equalClips(clip, _state4.clip) && (_state4.stop(), delete this._nameToState[_name4]);
                        }
                    }
                }, {
                    key: "clips",
                    get: function get() {
                        return this._clips;
                    },
                    set: function set(value) {
                        var _this2 = this;
                        this._crossFade && this._crossFade.clear();
                        var _iterator = this._clips, _isArray = Array.isArray(_iterator), _i6 = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i6 >= _iterator.length) break;
                                _ref = _iterator[_i6++];
                            } else {
                                if ((_i6 = _iterator.next()).done) break;
                                _ref = _i6.value;
                            }
                            var clip = _ref;
                            clip && this._removeStateOfAutomaticClip(clip);
                        }
                        var _iterator2 = value, _isArray2 = Array.isArray(_iterator2), _i7 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i7 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i7++];
                            } else {
                                if ((_i7 = _iterator2.next()).done) break;
                                _ref2 = _i7.value;
                            }
                            var _clip = _ref2;
                            _clip && this.createState(_clip);
                        }
                        var newDefaultClip = value.find(function(clip) {
                            return equalClips(clip, _this2._defaultClip);
                        });
                        this._defaultClip = newDefaultClip || null, this._clips = value;
                    }
                }, {
                    key: "defaultClip",
                    get: function get() {
                        return this._defaultClip;
                    },
                    set: function set(value) {
                        (this._defaultClip = value) && (0 <= this._clips.findIndex(function(clip) {
                            return equalClips(clip, value);
                        }) || (this._clips.push(value), this.createState(value)));
                    }
                } ]), AnimationComponent;
            }(), _class3$h.EventType = EventType, _applyDecoratedDescriptor((_class2$G = _temp$J).prototype, "clips", [ _dec4$d ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "clips"), _class2$G.prototype), 
            _applyDecoratedDescriptor(_class2$G.prototype, "defaultClip", [ _dec5$c ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "defaultClip"), _class2$G.prototype), 
            _descriptor$D = _applyDecoratedDescriptor(_class2$G.prototype, "playOnLoad", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor2$t = _applyDecoratedDescriptor(_class2$G.prototype, "_clips", [ _dec6$9 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor3$k = _applyDecoratedDescriptor(_class2$G.prototype, "_defaultClip", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _class$P = _class2$G)) || _class$P) || _class$P) || _class$P) || _class$P)), _AnimationComponent$p = AnimationComponent.prototype, on = _AnimationComponent$p.on, off = _AnimationComponent$p.off;
            function equalClips(clip1, clip2) {
                return clip1 === clip2 || !(!clip1 || !clip2 || clip1.name !== clip2.name && clip1._uuid !== clip2._uuid);
            }
            applyMixins(AnimationComponent, [ CallbacksInvoker, EventTarget ]), AnimationComponent.prototype.on = on, 
            AnimationComponent.prototype.off = off, cc.AnimationComponent = AnimationComponent;
            var SkeletalAnimationClip = exports("SkeletalAnimationClip", ccclass("cc.SkeletalAnimationClip")(_class$Q = function() {
                function SkeletalAnimationClip() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, SkeletalAnimationClip);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SkeletalAnimationClip)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).originalKeys = [], 
                    _this.convertedData = {}, _this._converted = !1, _this;
                }
                return _inherits(SkeletalAnimationClip, AnimationClip), _createClass(SkeletalAnimationClip, [ {
                    key: "getPropertyCurves",
                    value: function getPropertyCurves(root) {
                        return this.hash, root.getComponent(cc.SkeletalAnimationComponent) ? this._convertToSkeletalCurves(root) : console.warn("skeletal clip in non-skeletal component"), 
                        _get(_getPrototypeOf(SkeletalAnimationClip.prototype), "getPropertyCurves", this).call(this, root);
                    }
                }, {
                    key: "_convertToSkeletalCurves",
                    value: function _convertToSkeletalCurves(root) {
                        var _this2 = this;
                        if (!this._converted) {
                            var convertedData = {};
                            this.curves.forEach(function(curve) {
                                if (!curve.valueAdapter && isCustomTargetModifier(curve.modifiers[0], HierachyModifier) && isPropertyModifier(curve.modifiers[1])) {
                                    var path = curve.modifiers[0].path, cs = convertedData[path];
                                    cs = cs || (convertedData[path] = {
                                        props: {}
                                    });
                                    var property = curve.modifiers[1];
                                    cs.props[property] = curve.data;
                                }
                            }), this.convertedData = convertedData, this.curves = [];
                            for (var _loop = function _loop() {
                                var path = _Object$keys[_i], props = convertedData[path] && convertedData[path].props;
                                if (!props) return "continue";
                                Object.defineProperty(props, "worldMatrix", {
                                    get: function get() {
                                        if (!props._worldMatrix) {
                                            var position = props.position, rotation = props.rotation, scale = props.scale;
                                            _this2._convertToUniformSample(position), _this2._convertToUniformSample(rotation), 
                                            _this2._convertToUniformSample(scale), _this2._convertToWorldSpace(path, props);
                                        }
                                        return props._worldMatrix;
                                    }
                                });
                            }, _i = 0, _Object$keys = Object.keys(convertedData); _i < _Object$keys.length; _i++) _loop();
                            for (var values = new Array(Math.ceil(this.sample * this._duration / this.speed) + 1), i = 0; i < values.length; i++) values[i] = i;
                            var curves = [ {
                                modifiers: [ new HierachyModifier(""), new ComponentModifier("cc.SkeletalAnimationComponent"), "frameID" ],
                                data: {
                                    keys: 0,
                                    values: values,
                                    interpolate: !1
                                }
                            } ];
                            if (this.curves = curves, this.originalKeys = this._keys, this._keys = [ values.map(function(_, i) {
                                return i * _this2.speed / _this2.sample;
                            }) ], this._duration = this._keys[0][values.length - 1], this._converted = !0, root) for (var comps = root.getComponentsInChildren(SkinningModelComponent), _i2 = 0; _i2 < comps.length; ++_i2) {
                                var comp = comps[_i2];
                                if (comp.skinningRoot === root && comp.skeleton) {
                                    var _iterator = comp.skeleton.joints, _isArray = Array.isArray(_iterator), _i3 = 0;
                                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                        var _ref;
                                        if (_isArray) {
                                            if (_i3 >= _iterator.length) break;
                                            _ref = _iterator[_i3++];
                                        } else {
                                            if ((_i3 = _iterator.next()).done) break;
                                            _ref = _i3.value;
                                        }
                                        var data = convertedData[_ref];
                                        data && data.props && data.props.worldMatrix;
                                    }
                                }
                            }
                        }
                    }
                }, {
                    key: "_convertToUniformSample",
                    value: function _convertToUniformSample(curve) {
                        var keys = this.originalKeys[curve.keys];
                        curve.keys = 0;
                        var len = this._keys[0].length, values = [];
                        if (keys && 1 !== keys.length) for (var _i4 = 0, idx = 0; _i4 < len; _i4++) {
                            for (var time = _i4 * this.speed / this.sample; keys[idx] <= time; ) idx++;
                            idx > keys.length - 1 ? time = keys[idx = keys.length - 1] : 0 === idx && (idx = 1);
                            var from = curve.values[idx - 1].clone();
                            from.lerp(curve.values[idx], (time - keys[idx - 1]) / (keys[idx] - keys[idx - 1])), 
                            values[_i4] = from;
                        } else for (var i = 0; i < len; i++) values[i] = curve.values[0].clone();
                        curve.values = values;
                    }
                }, {
                    key: "_convertToWorldSpace",
                    value: function _convertToWorldSpace(path, props) {
                        var oPos = props.position.values, oRot = props.rotation.values, oScale = props.scale.values, matrix = oPos.map(function() {
                            return new Mat4();
                        }), idx = path.lastIndexOf("/"), pMatrix = null;
                        if (0 < idx) {
                            var name = path.substring(0, idx), data = this.convertedData[name];
                            if (!data || !data.props) return void console.warn("no data for parent bone?");
                            pMatrix = data.props.worldMatrix.values;
                        }
                        for (var i = 0; i < oPos.length; i++) {
                            var oT = oPos[i], oR = oRot[i], oS = oScale[i], m = matrix[i];
                            Mat4.fromRTS(m, oR, oT, oS), pMatrix && Mat4.multiply(m, pMatrix[i], m);
                        }
                        Object.keys(props).forEach(function(k) {
                            return delete props[k];
                        }), props._worldMatrix = {
                            keys: 0,
                            interpolate: !1,
                            values: matrix
                        };
                    }
                } ]), SkeletalAnimationClip;
            }()) || _class$Q);
            cc.SkeletalAnimationClip = SkeletalAnimationClip;
            var m4_1$4 = new Mat4();
            function getPathFromRoot(target, root) {
                for (var node = target, path = ""; null !== node && node !== root; ) path = "".concat(node.name, "/").concat(path), 
                node = node.parent;
                return path.slice(0, -1);
            }
            function getWorldTransformUntilRoot(target, root, outMatrix) {
                for (Mat4.identity(outMatrix); target !== root; ) Mat4.fromRTS(m4_1$4, target.rotation, target.position, target.scale), 
                Mat4.multiply(outMatrix, m4_1$4, outMatrix), target = target.parent;
            }
            var m4_1$5 = new Mat4();
            var _dec$Q, _dec2$v, _class$R, _class2$H, _descriptor$E, _descriptor2$u, _dec3$h, _dec4$e, _dec5$d, _dec6$a, _dec7$7, _class4$5, _class5$5, _descriptor3$l, _class6, _temp2$5, SkeletalAnimationState = exports("SkeletalAnimationState", function() {
                function SkeletalAnimationState() {
                    return _classCallCheck(this, SkeletalAnimationState), _possibleConstructorReturn(this, _getPrototypeOf(SkeletalAnimationState).apply(this, arguments));
                }
                return _inherits(SkeletalAnimationState, AnimationState), _createClass(SkeletalAnimationState, [ {
                    key: "onPlay",
                    value: function onPlay() {
                        _get(_getPrototypeOf(SkeletalAnimationState.prototype), "onPlay", this).call(this);
                        for (var comps = this._targetNode.getComponentsInChildren(SkinningModelComponent), i = 0; i < comps.length; ++i) {
                            var comp = comps[i];
                            comp.skinningRoot === this._targetNode && comp.uploadAnimation(this.clip);
                        }
                    }
                }, {
                    key: "rebuildSocketCurves",
                    value: function rebuildSocketCurves(sockets) {
                        if (this._samplerSharedGroups.length) {
                            for (var modifiers, curves = this._samplerSharedGroups[0].curves, iCurve = 0; iCurve < curves.length; iCurve++) {
                                var curveDetail = curves[iCurve].curveDetail;
                                3 === (modifiers = curveDetail.modifiers).length && modifiers[0] instanceof HierachyModifier && modifiers[1] instanceof ComponentModifier && "frameID" === modifiers[2] || curves.splice(iCurve--, 1);
                            }
                            for (var iSocket = 0; iSocket < sockets.length; ++iSocket) {
                                var curve = this._buildSocketData(sockets[iSocket]);
                                curve && curves.push(curve);
                            }
                        }
                    }
                }, {
                    key: "_buildSocketData",
                    value: function _buildSocketData(socket) {
                        if (!this._targetNode) return null;
                        var root = this._targetNode, targetNode = root.getChildByPath(socket.path);
                        if (!targetNode || !socket.target) return null;
                        for (var targetPath = socket.path, sourceData = this.clip.convertedData, animPath = targetPath, source = sourceData[animPath], animNode = targetNode; !source || !source.props; ) {
                            var idx = animPath.lastIndexOf("/");
                            if (source = sourceData[animPath = animPath.substring(0, idx)], animNode = animNode.parent, 
                            idx < 0) return null;
                        }
                        var data = {
                            matrix: {
                                keys: 0,
                                interpolate: !1,
                                values: source.props.worldMatrix.values.map(function(v) {
                                    return v.clone();
                                })
                            }
                        }, matrix = data.matrix.values;
                        getWorldTransformUntilRoot(targetNode, animNode, m4_1$5);
                        for (var i = 0; i < matrix.length; i++) {
                            var m = matrix[i];
                            Mat4.multiply(m, m, m4_1$5);
                        }
                        var duration = this.clip.duration, hierachyModifier = new HierachyModifier();
                        return new ICurveInstance({
                            curve: new AnimCurve(data.matrix, duration),
                            modifiers: [ hierachyModifier, "matrix" ]
                        }, socket.target);
                    }
                } ]), SkeletalAnimationState;
            }());
            cc.SkeletalAnimationState = SkeletalAnimationState;
            var Socket = exports("Socket", (_dec$Q = ccclass("cc.SkeletalAnimationComponent.Socket"), 
            _dec2$v = property(Node$1), _dec$Q((_descriptor$E = _applyDecoratedDescriptor((_class2$H = function Socket() {
                var path = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "", target = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null;
                _classCallCheck(this, Socket), _initializerDefineProperty(this, "path", _descriptor$E, this), 
                _initializerDefineProperty(this, "target", _descriptor2$u, this), this.path = path, 
                this.target = target;
            }).prototype, "path", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return "";
                }
            }), _descriptor2$u = _applyDecoratedDescriptor(_class2$H.prototype, "target", [ _dec2$v ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _class$R = _class2$H)) || _class$R)), m4_1$6 = new Mat4();
            function collectRecursively(node, argument_1, argument_2) {
                for (var prefix = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : "", out = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : [], i = 0; i < node.children.length; i++) {
                    var child = node.children[i];
                    if (child) {
                        var path = prefix ? "".concat(prefix, "/").concat(child.name) : child.name;
                        out.push(path), collectRecursively(child, path, out);
                    }
                }
                return out;
            }
            var _class$S, _class2$I, _descriptor$F, _descriptor2$v, SkeletalAnimationComponent = exports("SkeletalAnimationComponent", (_dec3$h = ccclass("cc.SkeletalAnimationComponent"), 
            _dec4$e = executionOrder(99), _dec5$d = menu("Components/SkeletalAnimation"), _dec6$a = property({
                type: [ Socket ]
            }), _dec7$7 = property({
                type: [ Socket ]
            }), _dec3$h(_class4$5 = _dec4$e(_class4$5 = executeInEditMode(_class4$5 = _dec5$d((_temp2$5 = _class6 = function() {
                function SkeletalAnimationComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, SkeletalAnimationComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SkeletalAnimationComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_sockets", _descriptor3$l, _assertThisInitialized(_this)), 
                    _this._animInfo = null, _this;
                }
                return _inherits(SkeletalAnimationComponent, AnimationComponent), _createClass(SkeletalAnimationComponent, [ {
                    key: "onLoad",
                    value: function onLoad() {
                        _get(_getPrototypeOf(SkeletalAnimationComponent.prototype), "onLoad", this).call(this), 
                        this._animInfo = JointsAnimationInfo.create(this.node.uuid);
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this._animInfo && (JointsAnimationInfo.destroy(this.node.uuid), this._animInfo = null), 
                        _get(_getPrototypeOf(SkeletalAnimationComponent.prototype), "onDestroy", this).call(this);
                    }
                }, {
                    key: "start",
                    value: function start() {
                        _get(_getPrototypeOf(SkeletalAnimationComponent.prototype), "start", this).call(this), 
                        this.sockets = this._sockets;
                    }
                }, {
                    key: "querySockets",
                    value: function querySockets() {
                        var animPaths = this._defaultClip && Object.keys(this._defaultClip.convertedData).sort().reduce(function(acc, cur) {
                            return cur.startsWith(acc[acc.length - 1]) || acc.push(cur), acc;
                        }, []) || [];
                        if (!animPaths.length) return [ "default animation clip missing/invalid" ];
                        for (var out = [], i = 0; i < animPaths.length; i++) {
                            var path = animPaths[i], node = this.node.getChildByPath(path);
                            node && (out.push(path), collectRecursively(node, path, out));
                        }
                        return out;
                    }
                }, {
                    key: "rebuildSocketAnimations",
                    value: function rebuildSocketAnimations() {
                        var _iterator = this._sockets, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var socket = _ref, joint = this.node.getChildByPath(socket.path), target = socket.target;
                            joint && target && (target.name = "".concat(socket.path.substring(socket.path.lastIndexOf("/") + 1), " Socket"), 
                            target.parent = this.node, getWorldTransformUntilRoot(joint, this.node, m4_1$6), 
                            target.matrix = m4_1$6);
                        }
                        for (var _i2 = 0, _Object$keys = Object.keys(this._nameToState); _i2 < _Object$keys.length; _i2++) {
                            var stateName = _Object$keys[_i2];
                            this._nameToState[stateName].rebuildSocketCurves(this._sockets);
                        }
                    }
                }, {
                    key: "createSocket",
                    value: function createSocket(path) {
                        var socket = this._sockets.find(function(s) {
                            return s.path === path;
                        });
                        if (socket) return socket.target;
                        if (!this.node.getChildByPath(path)) return console.warn("illegal socket path"), 
                        null;
                        var target = new Node$1();
                        return target.parent = this.node, this._sockets.push(new Socket(path, target)), 
                        this.rebuildSocketAnimations(), target;
                    }
                }, {
                    key: "_createState",
                    value: function _createState(clip, name) {
                        return new SkeletalAnimationState(clip, name);
                    }
                }, {
                    key: "_doCreateState",
                    value: function _doCreateState(clip, name) {
                        clip instanceof SkeletalAnimationClip || console.warn("non-skeletal clip in skeletal component");
                        var state = _get(_getPrototypeOf(SkeletalAnimationComponent.prototype), "_doCreateState", this).call(this, clip, name);
                        return state.rebuildSocketCurves(this._sockets), state;
                    }
                }, {
                    key: "sockets",
                    get: function get() {
                        return this._sockets;
                    },
                    set: function set(val) {
                        this._sockets = val, this.rebuildSocketAnimations();
                    }
                }, {
                    key: "frameID",
                    set: function set(fid) {
                        if (this._animInfo) {
                            var _this$_animInfo = this._animInfo, data = _this$_animInfo.data, buffer = _this$_animInfo.buffer;
                            data[1] = fid, buffer.update(data);
                        }
                    },
                    get: function get() {
                        return this._animInfo && this._animInfo.data[1] || 0;
                    }
                } ]), SkeletalAnimationComponent;
            }(), _class6.Socket = Socket, _descriptor3$l = _applyDecoratedDescriptor((_class5$5 = _temp2$5).prototype, "_sockets", [ _dec6$a ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _applyDecoratedDescriptor(_class5$5.prototype, "sockets", [ _dec7$7 ], Object.getOwnPropertyDescriptor(_class5$5.prototype, "sockets"), _class5$5.prototype), 
            _class4$5 = _class5$5)) || _class4$5) || _class4$5) || _class4$5) || _class4$5));
            cc.SkeletalAnimationComponent = SkeletalAnimationComponent;
            var _class$T, UniformCurveValueAdapter = exports("UniformCurveValueAdapter", ccclass("cc.UniformCurveValueAdapter")((_descriptor$F = _applyDecoratedDescriptor((_class2$I = function() {
                function UniformCurveValueAdapter() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, UniformCurveValueAdapter);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UniformCurveValueAdapter)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "passIndex", _descriptor$F, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "uniformName", _descriptor2$v, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(UniformCurveValueAdapter, CurveValueAdapter), _createClass(UniformCurveValueAdapter, [ {
                    key: "forTarget",
                    value: function forTarget(target) {
                        var pass = target.passes[this.passIndex], handle = pass.getHandle(this.uniformName);
                        if (void 0 === handle) throw new Error('Material "'.concat(target.name, '" has no uniform "').concat(this.uniformName, '"'));
                        var bindingType = Pass.getBindingTypeFromHandle(handle);
                        if (bindingType === GFXBindingType.UNIFORM_BUFFER) return function isUniformArray(pass, name) {
                            var _iterator = pass.shaderInfo.blocks, _isArray = Array.isArray(_iterator), _i = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i >= _iterator.length) break;
                                    _ref = _iterator[_i++];
                                } else {
                                    if ((_i = _iterator.next()).done) break;
                                    _ref = _i.value;
                                }
                                var _iterator2 = _ref.members, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                                    var _ref2;
                                    if (_isArray2) {
                                        if (_i2 >= _iterator2.length) break;
                                        _ref2 = _iterator2[_i2++];
                                    } else {
                                        if ((_i2 = _iterator2.next()).done) break;
                                        _ref2 = _i2.value;
                                    }
                                    var uniform = _ref2;
                                    if (uniform.name === name) return 1 < uniform.count;
                                }
                            }
                            return !1;
                        }(pass, this.uniformName) ? {
                            set: function set(value) {
                                pass.setUniformArray(handle, value);
                            }
                        } : {
                            set: function set(value) {
                                pass.setUniform(handle, value);
                            }
                        };
                        if (bindingType !== GFXBindingType.SAMPLER) throw new Error("Animations are not avaiable for uniforms with binding type ".concat(bindingType, "."));
                        var binding = Pass.getBindingFromHandle(handle), prop = pass.properties[this.uniformName], texName = prop && prop.value ? prop.value + "-texture" : _type2default[prop.type], dftTex = builtinResMgr.get(texName);
                        return dftTex || (console.warn("illegal texture default value: " + texName), dftTex = builtinResMgr.get("default-texture")), 
                        {
                            set: function set(value) {
                                var tv = (value = value || dftTex).getGFXTextureView();
                                tv && tv.texture.width && tv.texture.height && (pass.bindTextureView(binding, tv), 
                                value instanceof TextureBase && pass.bindSampler(binding, samplerLib.getSampler(cc.game._gfxDevice, value.getSamplerHash())));
                            }
                        };
                    }
                } ]), UniformCurveValueAdapter;
            }()).prototype, "passIndex", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor2$v = _applyDecoratedDescriptor(_class2$I.prototype, "uniformName", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return "";
                }
            }), _class$S = _class2$I)) || _class$S);
            cc.UniformCurveValueAdapter = UniformCurveValueAdapter, replaceProperty(AnimationComponent.prototype, "AnimationComponent", [ {
                name: "getAnimationState",
                newName: "getState"
            }, {
                name: "removeClip",
                newName: "removeState",
                customFunction: function customFunction(argument_0) {
                    var arg0 = arguments.length <= 0 ? void 0 : argument_0;
                    return AnimationComponent.prototype.removeState.call(this, arg0.name);
                }
            } ]), cc.easing = easing;
            var _class$U, Counter = ccclass("cc.Counter")(_class$T = function() {
                function Counter(id, opts, now) {
                    _classCallCheck(this, Counter), this._id = void 0, this._opts = void 0, this._accumStart = void 0, 
                    this._total = 0, this._value = 0, this._averageValue = 0, this._accumValue = 0, 
                    this._accumSamples = 0, this._id = id, this._opts = opts, this._accumStart = now;
                }
                return _createClass(Counter, [ {
                    key: "value",
                    get: function get() {
                        return this._value;
                    },
                    set: function set(val) {
                        this._value = val;
                    }
                } ]), _createClass(Counter, [ {
                    key: "sample",
                    value: function sample(now) {
                        this._average(this._value, now);
                    }
                }, {
                    key: "human",
                    value: function human(argument_0) {
                        var isPoint = !(0 < arguments.length && void 0 !== argument_0) || argument_0, v = this._opts.average ? this._averageValue : this._value;
                        return isPoint ? Math.round(100 * v) / 100 : Math.round(v);
                    }
                }, {
                    key: "alarm",
                    value: function alarm() {
                        return this._opts.below && this._value < this._opts.below || this._opts.over && this._value > this._opts.over;
                    }
                }, {
                    key: "_average",
                    value: function _average(v, argument_1) {
                        var now = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : 0;
                        if (this._opts.average) {
                            this._accumValue += v, ++this._accumSamples;
                            var t = now;
                            t - this._accumStart >= this._opts.average && (this._averageValue = this._accumValue / this._accumSamples, 
                            this._accumValue = 0, this._accumStart = t, this._accumSamples = 0);
                        }
                    }
                } ]), Counter;
            }()) || _class$T, PerfCounter = ccclass("cc.PerfCounter")(_class$U = function() {
                function PerfCounter(id, opts, now) {
                    var _this;
                    return _classCallCheck(this, PerfCounter), (_this = _possibleConstructorReturn(this, _getPrototypeOf(PerfCounter).call(this, id, opts, now)))._time = void 0, 
                    _this._time = now, _this;
                }
                return _inherits(PerfCounter, Counter), _createClass(PerfCounter, [ {
                    key: "start",
                    value: function start(argument_0) {
                        var now = 0 < arguments.length && void 0 !== argument_0 ? argument_0 : 0;
                        this._time = now;
                    }
                }, {
                    key: "end",
                    value: function end(argument_0) {
                        var now = 0 < arguments.length && void 0 !== argument_0 ? argument_0 : 0;
                        this._value = now - this._time, this._average(this._value);
                    }
                }, {
                    key: "tick",
                    value: function tick() {
                        this.end(), this.start();
                    }
                }, {
                    key: "frame",
                    value: function frame(now) {
                        var t = now, e = t - this._time;
                        this._total++, (this._opts.average || 1e3) < e && (this._value = 1e3 * this._total / e, 
                        this._total = 0, this._time = t, this._average(this._value));
                    }
                } ]), PerfCounter;
            }()) || _class$U, Profiler = exports("Profiler", function() {
                function Profiler() {
                    _classCallCheck(this, Profiler), this._stats = null, this._showFPS = !1, this._fontSize = 22, 
                    this._lineHeight = this._fontSize + 2, this._left = 10, this._right = 10, this._top = 10, 
                    this._bottom = 10, this._rootNode = null, this._device = null, this._canvas = null, 
                    this._ctx = null, this._texture = null, this._textureView = null, this._region = new GFXBufferTextureCopy(), 
                    this._canvasArr = [], this._regionArr = [ this._region ], this._canvasDone = !1, 
                    this._statsDone = !1, this._canvas = document.createElement("canvas"), this._ctx = this._canvas.getContext("2d"), 
                    this._region = new GFXBufferTextureCopy(), this._canvasArr.push(this._canvas);
                }
                return _createClass(Profiler, [ {
                    key: "isShowingStats",
                    value: function isShowingStats() {
                        return this._showFPS;
                    }
                }, {
                    key: "hideStats",
                    value: function hideStats() {
                        this._showFPS && (this._rootNode && (this._rootNode.active = !1), director.off(Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this), 
                        director.off(Director.EVENT_AFTER_UPDATE, this.afterUpdate, this), director.off(Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this), 
                        director.off(Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this), director.off(Director.EVENT_BEFORE_DRAW, this.beforeDraw, this), 
                        director.off(Director.EVENT_AFTER_DRAW, this.afterDraw, this), this._showFPS = !1);
                    }
                }, {
                    key: "showStats",
                    value: function showStats() {
                        this._showFPS || (this.initDevice(), this.generateCanvas(), this.generateStats(), 
                        this._rootNode && (this._rootNode.active = !0), director.on(Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this), 
                        director.on(Director.EVENT_AFTER_UPDATE, this.afterUpdate, this), director.on(Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this), 
                        director.on(Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this), director.on(Director.EVENT_BEFORE_DRAW, this.beforeDraw, this), 
                        director.on(Director.EVENT_AFTER_DRAW, this.afterDraw, this), this._showFPS = !0, 
                        this._canvasDone = !0, this._statsDone = !0);
                    }
                }, {
                    key: "initDevice",
                    value: function initDevice() {
                        this._device || (this._device = director.root.device);
                    }
                }, {
                    key: "generateCanvas",
                    value: function generateCanvas() {
                        if (!this._canvasDone) {
                            this._ctx && this._canvas && (this._canvas.width = 350, this._canvas.height = 200, 
                            this._canvas.style.width = "".concat(this._canvas.width), this._canvas.style.height = "".concat(this._canvas.height), 
                            this._ctx.font = "".concat(this._fontSize, "px Arial"), this._ctx.textBaseline = "top", 
                            this._ctx.fillStyle = "#fff", this._texture = this._device.createTexture({
                                type: GFXTextureType.TEX2D,
                                usage: GFXTextureUsageBit.SAMPLED,
                                format: GFXFormat.RGBA8,
                                width: 350,
                                height: 200,
                                mipLevel: 1
                            }), this._textureView = this._device.createTextureView({
                                texture: this._texture,
                                type: GFXTextureViewType.TV2D,
                                format: GFXFormat.RGBA8
                            }), this._region.texExtent.width = 350, this._region.texExtent.height = 200);
                        }
                    }
                }, {
                    key: "generateStats",
                    value: function generateStats() {
                        if (!this._statsDone && this._ctx) {
                            this._stats = null;
                            var now = performance.now(), opts = {
                                frame: {
                                    desc: "Frame time (ms)",
                                    min: 0,
                                    max: 50,
                                    average: 500
                                },
                                fps: {
                                    desc: "Framerate (FPS)",
                                    below: 30,
                                    average: 500
                                },
                                draws: {
                                    desc: "Draw call"
                                },
                                tricount: {
                                    desc: "Triangle"
                                },
                                logic: {
                                    desc: "Game Logic (ms)",
                                    min: 0,
                                    max: 50,
                                    average: 500,
                                    color: "#080"
                                },
                                physics: {
                                    desc: "Physics (ms)",
                                    min: 0,
                                    max: 50,
                                    average: 500
                                },
                                render: {
                                    desc: "Renderer (ms)",
                                    min: 0,
                                    max: 50,
                                    average: 500,
                                    color: "#f90"
                                },
                                textureMemory: {
                                    desc: "GFX Texture Mem(M)"
                                },
                                bufferMemory: {
                                    desc: "GFX Buffer Mem(M)"
                                }
                            };
                            this._ctx.textAlign = "left";
                            for (var i = 0, _i = 0, _Object$keys = Object.keys(opts); _i < _Object$keys.length; _i++) {
                                var id = _Object$keys[_i];
                                this._ctx.fillText(opts[id].desc, this._left, this._top + i * this._lineHeight), 
                                opts[id].counter = new PerfCounter(id, opts[id], now), i++;
                            }
                            this._ctx.textAlign = "end", this._stats = opts;
                        }
                    }
                }, {
                    key: "generateNode",
                    value: function generateNode() {
                        if (!this._rootNode || !this._rootNode.isValid) {
                            this._rootNode = new Node$1("PROFILER_NODE"), cc.game.addPersistRootNode(this._rootNode);
                            var cameraNode = new Node$1("Profiler_Camera");
                            cameraNode.setPosition(0, 0, 1), cameraNode.parent = this._rootNode;
                            var camera = cameraNode.addComponent("cc.CameraComponent");
                            camera.projection = CameraComponent.ProjectionType.ORTHO, camera.near = 0, camera.far = 0, 
                            camera.orthoHeight = this._device.height, camera.visibility = Layers.BitMask.PROFILER, 
                            camera.clearFlags = GFXClearFlag.DEPTH | GFXClearFlag.STENCIL, camera.priority = 1073741928;
                            var managerNode = new Node$1("Profiler_Root");
                            managerNode.parent = this._rootNode;
                            var modelCom = managerNode.addComponent("cc.ModelComponent");
                            modelCom.mesh = createMesh({
                                positions: [ -.35, -.2, 0, -.35, .2, 0, .35, .2, 0, .35, -.2, 0 ],
                                indices: [ 0, 2, 1, 0, 3, 2 ],
                                uvs: [ 0, 1, 0, 0, 1, 0, 1, 1 ]
                            });
                            var _material = new Material();
                            _material.initialize({
                                effectName: "util/profiler"
                            }), _material.setProperty("offset", new Vec4(-.9, -.9, 0, 0));
                            var pass = _material.passes[0], handle = pass.getBinding("mainTexture");
                            pass.bindTextureView(handle, this._textureView), modelCom.material = _material, 
                            modelCom.node.layer = Layers.Enum.PROFILER;
                        }
                    }
                }, {
                    key: "beforeUpdate",
                    value: function beforeUpdate() {
                        if (this._stats) {
                            this.generateNode();
                            var now = performance.now();
                            this.getCounter("frame").end(now), this.getCounter("frame").start(now), this.getCounter("logic").start(now);
                        }
                    }
                }, {
                    key: "afterUpdate",
                    value: function afterUpdate() {
                        if (this._stats) {
                            var now = performance.now();
                            director.isPaused() ? this.getCounter("frame").start(now) : this.getCounter("logic").end(now);
                        }
                    }
                }, {
                    key: "beforePhysics",
                    value: function beforePhysics() {
                        if (this._stats) {
                            var now = performance.now();
                            this.getCounter("physics").start(now);
                        }
                    }
                }, {
                    key: "afterPhysics",
                    value: function afterPhysics() {
                        if (this._stats) {
                            var now = performance.now();
                            this.getCounter("physics").end(now);
                        }
                    }
                }, {
                    key: "beforeDraw",
                    value: function beforeDraw() {
                        if (this._stats) {
                            var now = performance.now();
                            this.getCounter("render").start(now);
                        }
                    }
                }, {
                    key: "afterDraw",
                    value: function afterDraw() {
                        if (this._stats && this._ctx && this._canvas) {
                            var now = performance.now();
                            this.getCounter("fps").frame(now), this.getCounter("draws").value = this._device.numDrawCalls, 
                            this.getCounter("bufferMemory").value = this._device.memoryStatus.bufferSize / 1048576, 
                            this.getCounter("textureMemory").value = this._device.memoryStatus.textureSize / 1048576, 
                            this.getCounter("tricount").value = this._device.numTris, this.getCounter("render").end(now);
                            var x = this._left + this._ctx.measureText("GFX Texture Mem(M)").width;
                            this._ctx.clearRect(x, 0, this._canvas.width - x, this._canvas.height);
                            for (var i = 0, _i2 = 0, _Object$keys2 = Object.keys(this._stats); _i2 < _Object$keys2.length; _i2++) {
                                var id = _Object$keys2[_i2], stat = this._stats[id];
                                stat.counter.sample(now), this._ctx.fillText(stat.counter.human(!("Framerate (FPS)" === stat.desc)), this._canvas.width - this._right, this._top + i * this._lineHeight), 
                                i++;
                            }
                            this._canvasArr[0] = this._canvas, this.updateTexture();
                        }
                    }
                }, {
                    key: "getCounter",
                    value: function getCounter(s) {
                        return this._stats[s].counter;
                    }
                }, {
                    key: "updateTexture",
                    value: function updateTexture() {
                        director.root.device.copyTexImagesToTexture(this._canvasArr, this._texture, this._regionArr);
                    }
                } ]), Profiler;
            }()), profiler = exports("profiler", new Profiler());
            cc.profiler = profiler;
            var vmath = {};
            replaceProperty(vmath, "vmath", [ {
                name: "vec2",
                newName: "Vec2",
                target: math,
                targetName: "math"
            }, {
                name: "vec3",
                newName: "Vec3",
                target: math,
                targetName: "math"
            }, {
                name: "vec4",
                newName: "Vec4",
                target: math,
                targetName: "math"
            }, {
                name: "quat",
                newName: "Quat",
                target: math,
                targetName: "math"
            }, {
                name: "mat3",
                newName: "Mat3",
                target: math,
                targetName: "math"
            }, {
                name: "mat4",
                newName: "Mat4",
                target: math,
                targetName: "math"
            }, {
                name: "color4",
                newName: "Color",
                target: math,
                targetName: "math"
            }, {
                name: "rect",
                newName: "Rect",
                target: math,
                targetName: "math"
            }, {
                name: "approx",
                newName: "approx",
                target: math,
                targetName: "math"
            }, {
                name: "EPSILON",
                newName: "EPSILON",
                target: math,
                targetName: "math"
            }, {
                name: "equals",
                newName: "equals",
                target: math,
                targetName: "math"
            }, {
                name: "clamp",
                newName: "clamp",
                target: math,
                targetName: "math"
            }, {
                name: "clamp01",
                newName: "clamp01",
                target: math,
                targetName: "math"
            }, {
                name: "lerp",
                newName: "lerp",
                target: math,
                targetName: "math"
            }, {
                name: "toRadian",
                newName: "toRadian",
                target: math,
                targetName: "math"
            }, {
                name: "toDegree",
                newName: "toDegree",
                target: math,
                targetName: "math"
            }, {
                name: "random",
                newName: "random",
                target: math,
                targetName: "math"
            }, {
                name: "randomRange",
                newName: "randomRange",
                target: math,
                targetName: "math"
            }, {
                name: "randomRangeInt",
                newName: "randomRangeInt",
                target: math,
                targetName: "math"
            }, {
                name: "pseudoRandom",
                newName: "pseudoRandom",
                target: math,
                targetName: "math"
            }, {
                name: "pseudoRandomRangeInt",
                newName: "pseudoRandomRangeInt",
                target: math,
                targetName: "math"
            }, {
                name: "nextPow2",
                newName: "nextPow2",
                target: math,
                targetName: "math"
            }, {
                name: "repeat",
                newName: "repeat",
                target: math,
                targetName: "math"
            }, {
                name: "pingPong",
                newName: "pingPong",
                target: math,
                targetName: "math"
            }, {
                name: "inverseLerp",
                newName: "inverseLerp",
                target: math,
                targetName: "math"
            } ]), cc.vmath = vmath, replaceProperty(Scheduler.prototype, "Scheduler.prototype", [ {
                name: "enableForTarget",
                newName: "enableForTarget",
                target: Scheduler,
                targetName: "Scheduler"
            } ]), cc.math = math, cc.geometry = geometry;
            var RenderQueue$1, PassStage, _stageOffset = 0, _name2stageID = {}, config_addStage = function addStage(name) {
                if (void 0 === _name2stageID[name]) {
                    var stageID = 1 << _stageOffset;
                    _name2stageID[name] = stageID, _stageOffset += 1;
                }
            };
            !function(RenderQueue) {
                RenderQueue[RenderQueue.OPAQUE = 0] = "OPAQUE", RenderQueue[RenderQueue.TRANSPARENT = 1] = "TRANSPARENT", 
                RenderQueue[RenderQueue.OVERLAY = 2] = "OVERLAY";
            }(RenderQueue$1 = RenderQueue$1 || {}), function(PassStage) {
                PassStage[PassStage.DEFAULT = 1] = "DEFAULT", PassStage[PassStage.FORWARD = 2] = "FORWARD", 
                PassStage[PassStage.SHADOWCAST = 4] = "SHADOWCAST";
            }(PassStage = PassStage || {}), replaceProperty(RenderScene.prototype, "RenderScene.prototype", [ {
                name: "raycastUI",
                newName: "raycastUI2D"
            }, {
                name: "raycastUINode",
                newName: "raycastUI2DNode"
            }, {
                name: "raycast",
                newName: "raycastModels"
            } ]);
            var CameraVisFlags = {};
            removeProperty(CameraVisFlags, "CameraVisFlags", [ {
                name: "GENERAL"
            } ]), replaceProperty(CameraVisFlags, "CameraVisFlags", [ {
                name: "PROFILER",
                newName: "PROFILER",
                target: Layers.BitMask,
                targetName: "PROFILER"
            }, {
                name: "GIZMOS",
                newName: "GIZMOS",
                target: Layers.BitMask,
                targetName: "GIZMOS"
            }, {
                name: "EDITOR",
                newName: "EDITOR",
                target: Layers.BitMask,
                targetName: "EDITOR"
            }, {
                name: "UI",
                newName: "UI",
                target: Layers.BitMask,
                targetName: "UI_3D"
            }, {
                name: "UI2D",
                newName: "UI2D",
                target: Layers.BitMask,
                targetName: "UI_2D"
            } ]), cc.CameraVisFlags = CameraVisFlags;
            var VisibilityFlags = {};
            removeProperty(VisibilityFlags, "VisibilityFlags", [ {
                name: "GENERAL"
            } ]), replaceProperty(VisibilityFlags, "VisibilityFlags", [ {
                name: "ALWALS",
                newName: "ALWALS",
                target: Layers.Enum,
                targetName: "ALWALS"
            }, {
                name: "PROFILER",
                newName: "PROFILER",
                target: Layers.Enum,
                targetName: "PROFILER"
            }, {
                name: "GIZMOS",
                newName: "GIZMOS",
                target: Layers.Enum,
                targetName: "GIZMOS"
            }, {
                name: "EDITOR",
                newName: "EDITOR",
                target: Layers.Enum,
                targetName: "EDITOR"
            }, {
                name: "UI",
                newName: "UI",
                target: Layers.Enum,
                targetName: "UI_3D"
            }, {
                name: "UI2D",
                newName: "UI2D",
                target: Layers.Enum,
                targetName: "UI_2D"
            } ]), cc.VisibilityFlags = VisibilityFlags;
            var addStage = config_addStage;
            cc.samplerLib = samplerLib;
            var renderer = Object.freeze({
                addStage: addStage,
                samplerLib: samplerLib,
                createIA: function createIA(device, data) {
                    if (!data.positions) return console.error("The data must have positions field"), 
                    null;
                    for (var verts = [], vcount = data.positions.length / 3, i = 0; i < vcount; ++i) verts.push(data.positions[3 * i], data.positions[3 * i + 1], data.positions[3 * i + 2]), 
                    data.normals && verts.push(data.normals[3 * i], data.normals[3 * i + 1], data.normals[3 * i + 2]), 
                    data.uvs && verts.push(data.uvs[2 * i], data.uvs[2 * i + 1]), data.colors && verts.push(data.colors[3 * i], data.uvs[3 * i + 1], data.colors[3 * i + 2]);
                    var vfmt = [];
                    vfmt.push({
                        name: GFXAttributeName.ATTR_POSITION,
                        format: GFXFormat.RGB32F
                    }), data.normals && vfmt.push({
                        name: GFXAttributeName.ATTR_NORMAL,
                        format: GFXFormat.RGB32F
                    }), data.uvs && vfmt.push({
                        name: GFXAttributeName.ATTR_TEX_COORD,
                        format: GFXFormat.RG32F
                    }), data.colors && vfmt.push({
                        name: GFXAttributeName.ATTR_COLOR,
                        format: GFXFormat.RGB32F
                    });
                    var vb = device.createBuffer({
                        usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                        size: 4 * verts.length,
                        stride: 4 * verts.length / vcount
                    });
                    vb.update(new Float32Array(verts));
                    var ib = device.createBuffer({
                        usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                        size: 2 * data.indices.length,
                        stride: 2
                    });
                    return ib.update(new Uint16Array(data.indices)), device.createInputAssembler({
                        attributes: vfmt,
                        vertexBuffers: [ vb ],
                        indexBuffer: ib
                    });
                },
                get RenderQueue() {
                    return RenderQueue$1;
                },
                get PassStage() {
                    return PassStage;
                },
                Pass: Pass,
                programLib: programLib,
                Light: Light,
                Camera: Camera,
                Model: Model,
                SkinningModel: SkinningModel,
                TextureBufferPool: TextureBufferPool,
                get JointsMediumType() {
                    return JointsMediumType;
                },
                selectJointsMediumType: selectJointsMediumType,
                JointsTexturePool: JointsTexturePool
            });
            exports("renderer", renderer);
            var _dec$U, _dec2$w, _class$V, _class2$J, _descriptor$G, _descriptor2$w, PrimitiveType$1, NodePool = exports("NodePool", function() {
                function NodePool(poolHandlerComp) {
                    _classCallCheck(this, NodePool), this.poolHandlerComp = void 0, this._pool = void 0, 
                    this.poolHandlerComp = poolHandlerComp, this._pool = [];
                }
                return _createClass(NodePool, [ {
                    key: "size",
                    value: function size() {
                        return this._pool.length;
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        for (var count = this._pool.length, i = 0; i < count; ++i) this._pool[i].destroy();
                        this._pool.length = 0;
                    }
                }, {
                    key: "put",
                    value: function put(obj) {
                        if (obj && -1 === this._pool.indexOf(obj)) {
                            obj.removeFromParent();
                            var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
                            handler && handler.unuse && handler.unuse(), this._pool.push(obj);
                        }
                    }
                }, {
                    key: "get",
                    value: function get() {
                        var last = this._pool.length - 1;
                        if (last < 0) return null;
                        var obj = this._pool[last];
                        this._pool.length = last;
                        var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
                        if (handler && handler.reuse) {
                            for (var _handler$reuse, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                            (_handler$reuse = handler.reuse).apply.apply(_handler$reuse, [ handler ].concat(args));
                        }
                        return obj;
                    }
                } ]), NodePool;
            }());
            cc.NodePool = NodePool, function(PrimitiveType) {
                PrimitiveType[PrimitiveType.BOX = 0] = "BOX", PrimitiveType[PrimitiveType.SPHERE = 1] = "SPHERE", 
                PrimitiveType[PrimitiveType.CYLINDER = 2] = "CYLINDER", PrimitiveType[PrimitiveType.CONE = 3] = "CONE", 
                PrimitiveType[PrimitiveType.CAPSULE = 4] = "CAPSULE", PrimitiveType[PrimitiveType.TORUS = 5] = "TORUS", 
                PrimitiveType[PrimitiveType.PLANE = 6] = "PLANE", PrimitiveType[PrimitiveType.QUAD = 7] = "QUAD";
            }(PrimitiveType$1 = PrimitiveType$1 || {}), ccenum(PrimitiveType$1);
            var Primitive = exports("Primitive", (_dec$U = ccclass("cc.Primitive"), _dec2$w = property({
                type: PrimitiveType$1
            }), _dec$U((_descriptor$G = _applyDecoratedDescriptor((_class2$J = function() {
                function Primitive() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, Primitive);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Primitive)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "type", _descriptor$G, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "info", _descriptor2$w, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(Primitive, Mesh), _createClass(Primitive, [ {
                    key: "onLoaded",
                    value: function onLoaded() {
                        createMesh(primitives[PrimitiveType$1[this.type]](this.info), this);
                    }
                } ]), Primitive;
            }()).prototype, "type", [ _dec2$w ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return PrimitiveType$1.BOX;
                }
            }), _descriptor2$w = _applyDecoratedDescriptor(_class2$J.prototype, "info", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return {};
                }
            }), _class$V = _class2$J)) || _class$V));
            cc.Primitive = Primitive, cc.renderer = renderer;
            exports("cclegacy", cc);
            cc.primitives = primitives;
            var WebGLEXT, GFXBindingLayout = function() {
                function GFXBindingLayout(device) {
                    var _this;
                    return _classCallCheck(this, GFXBindingLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXBindingLayout).call(this, GFXObjectType.BINDING_LAYOUT)))._device = void 0, 
                    _this._bindingUnits = [], _this._isDirty = !1, _this._device = device, _this;
                }
                return _inherits(GFXBindingLayout, GFXObject), _createClass(GFXBindingLayout, [ {
                    key: "bindBuffer",
                    value: function bindBuffer(binding, buffer) {
                        var _iterator = this._bindingUnits, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var bindingUnit = _ref;
                            if (bindingUnit.binding === binding) return void (bindingUnit.type === GFXBindingType.UNIFORM_BUFFER ? bindingUnit.buffer !== buffer && (bindingUnit.buffer = buffer, 
                            this._isDirty = !0) : console.error("Setting binding is not GFXBindingType.UNIFORM_BUFFER."));
                        }
                    }
                }, {
                    key: "bindSampler",
                    value: function bindSampler(binding, sampler) {
                        var _iterator2 = this._bindingUnits, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            var bindingUnit = _ref2;
                            if (bindingUnit.binding === binding) return void (bindingUnit.type === GFXBindingType.SAMPLER ? bindingUnit.sampler !== sampler && (bindingUnit.sampler = sampler, 
                            this._isDirty = !0) : console.error("Setting binding is not GFXBindingType.SAMPLER."));
                        }
                    }
                }, {
                    key: "bindTextureView",
                    value: function bindTextureView(binding, texView) {
                        var _iterator3 = this._bindingUnits, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i3 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i3++];
                            } else {
                                if ((_i3 = _iterator3.next()).done) break;
                                _ref3 = _i3.value;
                            }
                            var bindingUnit = _ref3;
                            if (bindingUnit.binding === binding) return void (bindingUnit.type === GFXBindingType.SAMPLER ? bindingUnit.texView !== texView && (bindingUnit.texView = texView, 
                            this._isDirty = !0) : console.error("Setting binding is not GFXBindingType.SAMPLER."));
                        }
                    }
                }, {
                    key: "getBindingUnit",
                    value: function getBindingUnit(binding) {
                        var _iterator4 = this._bindingUnits, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                        for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                            var _ref4;
                            if (_isArray4) {
                                if (_i4 >= _iterator4.length) break;
                                _ref4 = _iterator4[_i4++];
                            } else {
                                if ((_i4 = _iterator4.next()).done) break;
                                _ref4 = _i4.value;
                            }
                            var unit = _ref4;
                            if (unit.binding === binding) return unit;
                        }
                        return null;
                    }
                } ]), GFXBindingLayout;
            }(), WebGLGFXBindingLayout = function() {
                function WebGLGFXBindingLayout(device) {
                    var _this;
                    return _classCallCheck(this, WebGLGFXBindingLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXBindingLayout).call(this, device)))._gpuBindingLayout = null, 
                    _this;
                }
                return _inherits(WebGLGFXBindingLayout, GFXBindingLayout), _createClass(WebGLGFXBindingLayout, [ {
                    key: "gpuBindingLayout",
                    get: function get() {
                        return this._gpuBindingLayout;
                    }
                } ]), _createClass(WebGLGFXBindingLayout, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        this._bindingUnits = new Array(info.bindings.length);
                        for (var i = 0; i < info.bindings.length; ++i) {
                            var binding = info.bindings[i];
                            this._bindingUnits[i] = {
                                binding: binding.binding,
                                type: binding.type,
                                name: binding.name,
                                buffer: null,
                                texView: null,
                                sampler: null
                            };
                        }
                        this._gpuBindingLayout = {
                            gpuBindings: new Array(info.bindings.length)
                        };
                        for (var _i = 0; _i < info.bindings.length; ++_i) {
                            var _binding = info.bindings[_i];
                            this._gpuBindingLayout.gpuBindings[_i] = {
                                binding: _binding.binding,
                                type: _binding.type,
                                name: _binding.name,
                                gpuBuffer: null,
                                gpuTexView: null,
                                gpuSampler: null
                            };
                        }
                        return this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._gpuBindingLayout = null, this._status = GFXStatus.UNREADY;
                    }
                }, {
                    key: "update",
                    value: function update() {
                        if (this._isDirty && this._gpuBindingLayout) {
                            for (var i = 0; i < this._bindingUnits.length; ++i) {
                                var bindingUnit = this._bindingUnits[i];
                                switch (bindingUnit.type) {
                                  case GFXBindingType.UNIFORM_BUFFER:
                                    bindingUnit.buffer && (this._gpuBindingLayout.gpuBindings[i].gpuBuffer = bindingUnit.buffer.gpuBuffer);
                                    break;

                                  case GFXBindingType.SAMPLER:
                                    bindingUnit.texView && (this._gpuBindingLayout.gpuBindings[i].gpuTexView = bindingUnit.texView.gpuTextureView), 
                                    bindingUnit.sampler && (this._gpuBindingLayout.gpuBindings[i].gpuSampler = bindingUnit.sampler.gpuSampler);
                                }
                            }
                            this._isDirty = !1;
                        }
                    }
                } ]), WebGLGFXBindingLayout;
            }();
            function GFXFormatToWebGLType(format, gl) {
                switch (format) {
                  case GFXFormat.R8:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.R8SN:
                    return gl.BYTE;

                  case GFXFormat.R8UI:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.R8I:
                    return gl.BYTE;

                  case GFXFormat.R16F:
                    return WebGLEXT.HALF_FLOAT_OES;

                  case GFXFormat.R16UI:
                    return gl.UNSIGNED_SHORT;

                  case GFXFormat.R16I:
                    return gl.SHORT;

                  case GFXFormat.R32F:
                    return gl.FLOAT;

                  case GFXFormat.R32UI:
                    return gl.UNSIGNED_INT;

                  case GFXFormat.R32I:
                    return gl.INT;

                  case GFXFormat.RG8:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.RG8SN:
                    return gl.BYTE;

                  case GFXFormat.RG8UI:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.RG8I:
                    return gl.BYTE;

                  case GFXFormat.RG16F:
                    return WebGLEXT.HALF_FLOAT_OES;

                  case GFXFormat.RG16UI:
                    return gl.UNSIGNED_SHORT;

                  case GFXFormat.RG16I:
                    return gl.SHORT;

                  case GFXFormat.RG32F:
                    return gl.FLOAT;

                  case GFXFormat.RG32UI:
                    return gl.UNSIGNED_INT;

                  case GFXFormat.RG32I:
                    return gl.INT;

                  case GFXFormat.RGB8:
                  case GFXFormat.SRGB8:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.RGB8SN:
                    return gl.BYTE;

                  case GFXFormat.RGB8UI:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.RGB8I:
                    return gl.BYTE;

                  case GFXFormat.RGB16F:
                    return WebGLEXT.HALF_FLOAT_OES;

                  case GFXFormat.RGB16UI:
                    return gl.UNSIGNED_SHORT;

                  case GFXFormat.RGB16I:
                    return gl.SHORT;

                  case GFXFormat.RGB32F:
                    return gl.FLOAT;

                  case GFXFormat.RGB32UI:
                    return gl.UNSIGNED_INT;

                  case GFXFormat.RGB32I:
                    return gl.INT;

                  case GFXFormat.RGBA8:
                  case GFXFormat.SRGB8_A8:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.RGBA8SN:
                    return gl.BYTE;

                  case GFXFormat.RGBA8UI:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.RGBA8I:
                    return gl.BYTE;

                  case GFXFormat.RGBA16F:
                    return WebGLEXT.HALF_FLOAT_OES;

                  case GFXFormat.RGBA16UI:
                    return gl.UNSIGNED_SHORT;

                  case GFXFormat.RGBA16I:
                    return gl.SHORT;

                  case GFXFormat.RGBA32F:
                    return gl.FLOAT;

                  case GFXFormat.RGBA32UI:
                    return gl.UNSIGNED_INT;

                  case GFXFormat.RGBA32I:
                    return gl.INT;

                  case GFXFormat.R5G6B5:
                    return gl.UNSIGNED_SHORT_5_6_5;

                  case GFXFormat.R11G11B10F:
                    return gl.FLOAT;

                  case GFXFormat.RGB5A1:
                    return gl.UNSIGNED_SHORT_5_5_5_1;

                  case GFXFormat.RGBA4:
                    return gl.UNSIGNED_SHORT_4_4_4_4;

                  case GFXFormat.RGB10A2:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.RGB10A2UI:
                    return gl.UNSIGNED_INT;

                  case GFXFormat.RGB9E5:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.D16:
                  case GFXFormat.D16S8:
                    return gl.UNSIGNED_SHORT;

                  case GFXFormat.D24:
                    return gl.UNSIGNED_INT;

                  case GFXFormat.D24S8:
                    return WebGLEXT.UNSIGNED_INT_24_8_WEBGL;

                  case GFXFormat.D32F:
                  case GFXFormat.D32F_S8:
                    return gl.FLOAT;

                  case GFXFormat.BC1:
                  case GFXFormat.BC1_SRGB:
                  case GFXFormat.BC2:
                  case GFXFormat.BC2_SRGB:
                  case GFXFormat.BC3:
                  case GFXFormat.BC3_SRGB:
                  case GFXFormat.BC4:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.BC4_SNORM:
                    return gl.BYTE;

                  case GFXFormat.BC5:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.BC5_SNORM:
                    return gl.BYTE;

                  case GFXFormat.BC6H_SF16:
                  case GFXFormat.BC6H_UF16:
                    return gl.FLOAT;

                  case GFXFormat.BC7:
                  case GFXFormat.BC7_SRGB:
                  case GFXFormat.ETC_RGB8:
                  case GFXFormat.ETC2_RGB8:
                  case GFXFormat.ETC2_SRGB8:
                  case GFXFormat.ETC2_RGB8_A1:
                  case GFXFormat.ETC2_SRGB8_A1:
                  case GFXFormat.ETC2_RGB8:
                  case GFXFormat.ETC2_SRGB8:
                  case GFXFormat.EAC_R11:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.EAC_R11SN:
                    return gl.BYTE;

                  case GFXFormat.EAC_RG11:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.EAC_RG11SN:
                    return gl.BYTE;

                  case GFXFormat.PVRTC_RGB2:
                  case GFXFormat.PVRTC_RGBA2:
                  case GFXFormat.PVRTC_RGB4:
                  case GFXFormat.PVRTC_RGBA4:
                  case GFXFormat.PVRTC2_2BPP:
                  case GFXFormat.PVRTC2_4BPP:
                  default:
                    return gl.UNSIGNED_BYTE;
                }
            }
            function GFXFormatToWebGLInternalFormat(format, gl) {
                switch (format) {
                  case GFXFormat.A8:
                    return gl.ALPHA;

                  case GFXFormat.L8:
                    return gl.LUMINANCE;

                  case GFXFormat.LA8:
                    return gl.LUMINANCE_ALPHA;

                  case GFXFormat.RGB8:
                  case GFXFormat.RGB16F:
                  case GFXFormat.RGB32F:
                    return gl.RGB;

                  case GFXFormat.RGBA8:
                  case GFXFormat.RGBA16F:
                  case GFXFormat.RGBA32F:
                    return gl.RGBA;

                  case GFXFormat.R5G6B5:
                    return gl.RGB565;

                  case GFXFormat.RGB5A1:
                    return gl.RGB5_A1;

                  case GFXFormat.RGBA4:
                    return gl.RGBA4;

                  case GFXFormat.D16:
                    return gl.DEPTH_COMPONENT;

                  case GFXFormat.D16S8:
                    return gl.DEPTH_STENCIL;

                  case GFXFormat.D24:
                    return gl.DEPTH_COMPONENT;

                  case GFXFormat.D24S8:
                    return gl.DEPTH_STENCIL;

                  case GFXFormat.D32F:
                    return gl.DEPTH_COMPONENT;

                  case GFXFormat.D32F_S8:
                    return gl.DEPTH_STENCIL;

                  case GFXFormat.BC1:
                    return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

                  case GFXFormat.BC1_ALPHA:
                    return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

                  case GFXFormat.BC1_SRGB:
                    return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

                  case GFXFormat.BC1_SRGB_ALPHA:
                    return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

                  case GFXFormat.BC2:
                    return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

                  case GFXFormat.BC2_SRGB:
                    return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

                  case GFXFormat.BC3:
                    return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                  case GFXFormat.BC3_SRGB:
                    return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

                  case GFXFormat.ETC_RGB8:
                    return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

                  case GFXFormat.PVRTC_RGB2:
                    return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

                  case GFXFormat.PVRTC_RGBA2:
                    return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

                  case GFXFormat.PVRTC_RGB4:
                    return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

                  case GFXFormat.PVRTC_RGBA4:
                    return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

                  default:
                    return console.error("Unsupported GFXFormat, convert to WebGL internal format failed."), 
                    gl.RGBA;
                }
            }
            function GFXFormatToWebGLFormat(format, gl) {
                switch (format) {
                  case GFXFormat.A8:
                    return gl.ALPHA;

                  case GFXFormat.L8:
                    return gl.LUMINANCE;

                  case GFXFormat.LA8:
                    return gl.LUMINANCE_ALPHA;

                  case GFXFormat.RGB8:
                  case GFXFormat.RGB16F:
                  case GFXFormat.RGB32F:
                    return gl.RGB;

                  case GFXFormat.RGBA8:
                  case GFXFormat.RGBA16F:
                  case GFXFormat.RGBA32F:
                    return gl.RGBA;

                  case GFXFormat.R5G6B5:
                    return gl.RGB;

                  case GFXFormat.RGB5A1:
                  case GFXFormat.RGBA4:
                    return gl.RGBA;

                  case GFXFormat.D16:
                    return gl.DEPTH_COMPONENT;

                  case GFXFormat.D16S8:
                    return gl.DEPTH_STENCIL;

                  case GFXFormat.D24:
                    return gl.DEPTH_COMPONENT;

                  case GFXFormat.D24S8:
                    return gl.DEPTH_STENCIL;

                  case GFXFormat.D32F:
                    return gl.DEPTH_COMPONENT;

                  case GFXFormat.D32F_S8:
                    return gl.DEPTH_STENCIL;

                  case GFXFormat.BC1:
                    return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

                  case GFXFormat.BC1_ALPHA:
                    return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

                  case GFXFormat.BC1_SRGB:
                    return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

                  case GFXFormat.BC1_SRGB_ALPHA:
                    return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

                  case GFXFormat.BC2:
                    return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

                  case GFXFormat.BC2_SRGB:
                    return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

                  case GFXFormat.BC3:
                    return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                  case GFXFormat.BC3_SRGB:
                    return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

                  case GFXFormat.ETC_RGB8:
                    return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

                  case GFXFormat.ETC2_RGB8:
                    return WebGLEXT.COMPRESSED_RGB8_ETC2;

                  case GFXFormat.ETC2_SRGB8:
                    return WebGLEXT.COMPRESSED_SRGB8_ETC2;

                  case GFXFormat.ETC2_RGB8_A1:
                    return WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                  case GFXFormat.ETC2_SRGB8_A1:
                    return WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                  case GFXFormat.ETC2_RGBA8:
                    return WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC;

                  case GFXFormat.ETC2_SRGB8_A8:
                    return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

                  case GFXFormat.EAC_R11:
                    return WebGLEXT.COMPRESSED_R11_EAC;

                  case GFXFormat.EAC_R11SN:
                    return WebGLEXT.COMPRESSED_SIGNED_R11_EAC;

                  case GFXFormat.EAC_RG11:
                    return WebGLEXT.COMPRESSED_RG11_EAC;

                  case GFXFormat.EAC_RG11SN:
                    return WebGLEXT.COMPRESSED_SIGNED_RG11_EAC;

                  case GFXFormat.PVRTC_RGB2:
                    return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

                  case GFXFormat.PVRTC_RGBA2:
                    return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

                  case GFXFormat.PVRTC_RGB4:
                    return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

                  case GFXFormat.PVRTC_RGBA4:
                    return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

                  default:
                    return console.error("Unsupported GFXFormat, convert to WebGL format failed."), 
                    gl.RGBA;
                }
            }
            function GFXTypeToWebGLType(type, gl) {
                switch (type) {
                  case GFXType.BOOL:
                    return gl.BOOL;

                  case GFXType.BOOL2:
                    return gl.BOOL_VEC2;

                  case GFXType.BOOL3:
                    return gl.BOOL_VEC3;

                  case GFXType.BOOL4:
                    return gl.BOOL_VEC4;

                  case GFXType.INT:
                    return gl.INT;

                  case GFXType.INT2:
                    return gl.INT_VEC2;

                  case GFXType.INT3:
                    return gl.INT_VEC3;

                  case GFXType.INT4:
                    return gl.INT_VEC4;

                  case GFXType.UINT:
                    return gl.UNSIGNED_INT;

                  case GFXType.FLOAT:
                    return gl.FLOAT;

                  case GFXType.FLOAT2:
                    return gl.FLOAT_VEC2;

                  case GFXType.FLOAT3:
                    return gl.FLOAT_VEC3;

                  case GFXType.FLOAT4:
                    return gl.FLOAT_VEC4;

                  case GFXType.MAT2:
                    return gl.FLOAT_MAT2;

                  case GFXType.MAT3:
                    return gl.FLOAT_MAT3;

                  case GFXType.MAT4:
                    return gl.FLOAT_MAT4;

                  case GFXType.SAMPLER2D:
                    return gl.SAMPLER_2D;

                  case GFXType.SAMPLER_CUBE:
                    return gl.SAMPLER_CUBE;

                  default:
                    return console.error("Unsupported GLType, convert to GL type failed."), GFXType.UNKNOWN;
                }
            }
            function WebGLTypeToGFXType(glType, gl) {
                switch (glType) {
                  case gl.BOOL:
                    return GFXType.BOOL;

                  case gl.BOOL_VEC2:
                    return GFXType.BOOL2;

                  case gl.BOOL_VEC3:
                    return GFXType.BOOL3;

                  case gl.BOOL_VEC4:
                    return GFXType.BOOL4;

                  case gl.INT:
                    return GFXType.INT;

                  case gl.INT_VEC2:
                    return GFXType.INT2;

                  case gl.INT_VEC3:
                    return GFXType.INT3;

                  case gl.INT_VEC4:
                    return GFXType.INT4;

                  case gl.UNSIGNED_INT:
                    return GFXType.UINT;

                  case gl.FLOAT:
                    return GFXType.FLOAT;

                  case gl.FLOAT_VEC2:
                    return GFXType.FLOAT2;

                  case gl.FLOAT_VEC3:
                    return GFXType.FLOAT3;

                  case gl.FLOAT_VEC4:
                    return GFXType.FLOAT4;

                  case gl.FLOAT_MAT2:
                    return GFXType.MAT2;

                  case gl.FLOAT_MAT3:
                    return GFXType.MAT3;

                  case gl.FLOAT_MAT4:
                    return GFXType.MAT4;

                  case gl.SAMPLER_2D:
                    return GFXType.SAMPLER2D;

                  case gl.SAMPLER_CUBE:
                    return GFXType.SAMPLER_CUBE;

                  default:
                    return console.error("Unsupported GLType, convert to GFXType failed."), GFXType.UNKNOWN;
                }
            }
            function WebGLGetTypeSize(glType, gl) {
                switch (glType) {
                  case gl.BOOL:
                    return 4;

                  case gl.BOOL_VEC2:
                    return 8;

                  case gl.BOOL_VEC3:
                    return 12;

                  case gl.BOOL_VEC4:
                    return 16;

                  case gl.INT:
                    return 4;

                  case gl.INT_VEC2:
                    return 8;

                  case gl.INT_VEC3:
                    return 12;

                  case gl.INT_VEC4:
                    return 16;

                  case gl.UNSIGNED_INT:
                  case gl.FLOAT:
                    return 4;

                  case gl.FLOAT_VEC2:
                    return 8;

                  case gl.FLOAT_VEC3:
                    return 12;

                  case gl.FLOAT_VEC4:
                  case gl.FLOAT_MAT2:
                    return 16;

                  case gl.FLOAT_MAT3:
                    return 36;

                  case gl.FLOAT_MAT4:
                    return 64;

                  case gl.SAMPLER_2D:
                  case gl.SAMPLER_CUBE:
                    return 4;

                  default:
                    return console.error("Unsupported GLType, get type failed."), 0;
                }
            }
            function WebGLGetComponentCount(glType, gl) {
                switch (glType) {
                  case gl.FLOAT_MAT2:
                    return 2;

                  case gl.FLOAT_MAT3:
                    return 3;

                  case gl.FLOAT_MAT4:
                    return 4;

                  default:
                    return 1;
                }
            }
            !function(WebGLEXT) {
                WebGLEXT[WebGLEXT.RGBA16F_EXT = 34842] = "RGBA16F_EXT", WebGLEXT[WebGLEXT.RGB16F_EXT = 34843] = "RGB16F_EXT", 
                WebGLEXT[WebGLEXT.RGBA32F_EXT = 34836] = "RGBA32F_EXT", WebGLEXT[WebGLEXT.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT", 
                WebGLEXT[WebGLEXT.UNSIGNED_NORMALIZED_EXT = 35863] = "UNSIGNED_NORMALIZED_EXT", 
                WebGLEXT[WebGLEXT.UNSIGNED_INT_24_8_WEBGL = 34042] = "UNSIGNED_INT_24_8_WEBGL", 
                WebGLEXT[WebGLEXT.HALF_FLOAT_OES = 36193] = "HALF_FLOAT_OES", WebGLEXT[WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", 
                WebGLEXT[WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", 
                WebGLEXT[WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", 
                WebGLEXT[WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", 
                WebGLEXT[WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", 
                WebGLEXT[WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", 
                WebGLEXT[WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", 
                WebGLEXT[WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", 
                WebGLEXT[WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", 
                WebGLEXT[WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", 
                WebGLEXT[WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", 
                WebGLEXT[WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", 
                WebGLEXT[WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", 
                WebGLEXT[WebGLEXT.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", WebGLEXT[WebGLEXT.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", 
                WebGLEXT[WebGLEXT.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", WebGLEXT[WebGLEXT.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", 
                WebGLEXT[WebGLEXT.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", WebGLEXT[WebGLEXT.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", 
                WebGLEXT[WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", 
                WebGLEXT[WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", 
                WebGLEXT[WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", 
                WebGLEXT[WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
            }(WebGLEXT = WebGLEXT || {});
            var WebGLCmd, WebGLCmpFuncs = [ 512, 513, 514, 515, 516, 517, 518, 519 ], WebGLStencilOps = [ 0, 7680, 7681, 7682, 7683, 5386, 34055, 34056 ], WebGLBlendOps = [ 32774, 32778, 32779, 32774, 32774 ], WebGLBlendFactors = [ 0, 1, 770, 772, 771, 773, 768, 774, 769, 775, 776, 32769, 32770, 32771, 32772 ];
            !function(WebGLCmd) {
                WebGLCmd[WebGLCmd.BEGIN_RENDER_PASS = 0] = "BEGIN_RENDER_PASS", WebGLCmd[WebGLCmd.END_RENDER_PASS = 1] = "END_RENDER_PASS", 
                WebGLCmd[WebGLCmd.BIND_STATES = 2] = "BIND_STATES", WebGLCmd[WebGLCmd.DRAW = 3] = "DRAW", 
                WebGLCmd[WebGLCmd.UPDATE_BUFFER = 4] = "UPDATE_BUFFER", WebGLCmd[WebGLCmd.COPY_BUFFER_TO_TEXTURE = 5] = "COPY_BUFFER_TO_TEXTURE", 
                WebGLCmd[WebGLCmd.COUNT = 6] = "COUNT";
            }(WebGLCmd = WebGLCmd || {});
            function WebGLCmdObject(type) {
                _classCallCheck(this, WebGLCmdObject), this.cmdType = void 0, this.refCount = 0, 
                this.cmdType = type;
            }
            var WebGLCmdBeginRenderPass = function() {
                function WebGLCmdBeginRenderPass() {
                    var _this;
                    return _classCallCheck(this, WebGLCmdBeginRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdBeginRenderPass).call(this, WebGLCmd.BEGIN_RENDER_PASS))).gpuFramebuffer = null, 
                    _this.renderArea = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }, _this.clearFlag = GFXClearFlag.NONE, _this.clearColors = [], _this.clearDepth = 1, 
                    _this.clearStencil = 0, _this;
                }
                return _inherits(WebGLCmdBeginRenderPass, WebGLCmdObject), _createClass(WebGLCmdBeginRenderPass, [ {
                    key: "clear",
                    value: function clear() {
                        this.gpuFramebuffer = null, this.clearColors = [];
                    }
                } ]), WebGLCmdBeginRenderPass;
            }(), WebGLCmdBindStates = function() {
                function WebGLCmdBindStates() {
                    var _this2;
                    return _classCallCheck(this, WebGLCmdBindStates), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdBindStates).call(this, WebGLCmd.BIND_STATES))).gpuPipelineState = null, 
                    _this2.gpuBindingLayout = null, _this2.gpuInputAssembler = null, _this2.viewport = null, 
                    _this2.scissor = null, _this2.lineWidth = null, _this2.depthBias = null, _this2.blendConstants = null, 
                    _this2.depthBounds = null, _this2.stencilWriteMask = null, _this2.stencilCompareMask = null, 
                    _this2;
                }
                return _inherits(WebGLCmdBindStates, WebGLCmdObject), _createClass(WebGLCmdBindStates, [ {
                    key: "clear",
                    value: function clear() {
                        this.gpuPipelineState = null, this.gpuBindingLayout = null, this.gpuInputAssembler = null, 
                        this.viewport = null, this.scissor = null, this.lineWidth = null, this.depthBias = null, 
                        this.blendConstants = null, this.depthBounds = null, this.stencilWriteMask = null, 
                        this.stencilCompareMask = null;
                    }
                } ]), WebGLCmdBindStates;
            }(), WebGLCmdDraw = function() {
                function WebGLCmdDraw() {
                    var _this3;
                    return _classCallCheck(this, WebGLCmdDraw), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdDraw).call(this, WebGLCmd.DRAW))).drawInfo = {
                        vertexCount: 0,
                        firstVertex: 0,
                        indexCount: 0,
                        firstIndex: 0,
                        vertexOffset: 0,
                        instanceCount: 0,
                        firstInstance: 0
                    }, _this3;
                }
                return _inherits(WebGLCmdDraw, WebGLCmdObject), _createClass(WebGLCmdDraw, [ {
                    key: "clear",
                    value: function clear() {}
                } ]), WebGLCmdDraw;
            }(), WebGLCmdUpdateBuffer = function() {
                function WebGLCmdUpdateBuffer() {
                    var _this4;
                    return _classCallCheck(this, WebGLCmdUpdateBuffer), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdUpdateBuffer).call(this, WebGLCmd.UPDATE_BUFFER))).gpuBuffer = null, 
                    _this4.buffer = null, _this4.offset = 0, _this4.size = 0, _this4;
                }
                return _inherits(WebGLCmdUpdateBuffer, WebGLCmdObject), _createClass(WebGLCmdUpdateBuffer, [ {
                    key: "clear",
                    value: function clear() {
                        this.gpuBuffer = null, this.buffer = null;
                    }
                } ]), WebGLCmdUpdateBuffer;
            }(), WebGLCmdCopyBufferToTexture = function() {
                function WebGLCmdCopyBufferToTexture() {
                    var _this5;
                    return _classCallCheck(this, WebGLCmdCopyBufferToTexture), (_this5 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdCopyBufferToTexture).call(this, WebGLCmd.COPY_BUFFER_TO_TEXTURE))).gpuBuffer = null, 
                    _this5.gpuTexture = null, _this5.dstLayout = null, _this5.regions = [], _this5;
                }
                return _inherits(WebGLCmdCopyBufferToTexture, WebGLCmdObject), _createClass(WebGLCmdCopyBufferToTexture, [ {
                    key: "clear",
                    value: function clear() {
                        this.gpuBuffer = null, this.gpuTexture = null, this.dstLayout = null, this.regions = [];
                    }
                } ]), WebGLCmdCopyBufferToTexture;
            }(), WebGLCmdPackage = function() {
                function WebGLCmdPackage() {
                    _classCallCheck(this, WebGLCmdPackage), this.cmds = new CachedArray(1), this.beginRenderPassCmds = new CachedArray(1), 
                    this.bindStatesCmds = new CachedArray(1), this.drawCmds = new CachedArray(1), this.updateBufferCmds = new CachedArray(1), 
                    this.copyBufferToTextureCmds = new CachedArray(1);
                }
                return _createClass(WebGLCmdPackage, [ {
                    key: "clearCmds",
                    value: function clearCmds(allocator) {
                        this.beginRenderPassCmds.length && (allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds), 
                        this.beginRenderPassCmds.clear()), this.bindStatesCmds.length && (allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds), 
                        this.bindStatesCmds.clear()), this.drawCmds.length && (allocator.drawCmdPool.freeCmds(this.drawCmds), 
                        this.drawCmds.clear()), this.updateBufferCmds.length && (allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds), 
                        this.updateBufferCmds.clear()), this.copyBufferToTextureCmds.length && (allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds), 
                        this.copyBufferToTextureCmds.clear()), this.cmds.clear();
                    }
                } ]), WebGLCmdPackage;
            }();
            function WebGLCmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
                if (gpuBuffer.usage & GFXBufferUsageBit.UNIFORM) buffer instanceof Float32Array ? gpuBuffer.vf32.set(buffer, offset / Float32Array.BYTES_PER_ELEMENT) : gpuBuffer.vf32.set(new Float32Array(buffer), offset / Float32Array.BYTES_PER_ELEMENT); else if (gpuBuffer.usage & GFXBufferUsageBit.INDIRECT) gpuBuffer.indirects = buffer.drawInfos; else {
                    var buff = buffer, gl = device.gl, cache = device.stateCache;
                    switch (gpuBuffer.glTarget) {
                      case gl.ARRAY_BUFFER:
                        device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                        cache.glVAO = null), device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                        device.stateCache.glArrayBuffer = gpuBuffer.glBuffer);
                        break;

                      case gl.ELEMENT_ARRAY_BUFFER:
                        device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                        cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                        device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer);
                        break;

                      default:
                        return void console.error("Unsupported GFXBufferType, update buffer failed.");
                    }
                    size === buff.byteLength ? gl.bufferSubData(gpuBuffer.glTarget, offset, buff) : gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                }
            }
            var cmdIds = new Array(WebGLCmd.COUNT);
            function WebGLCmdFuncExecuteCmds(device, cmdPackage) {
                for (var gl = device.gl, cache = device.stateCache, i = 0; i < WebGLCmd.COUNT; ++i) cmdIds[i] = 0;
                for (var glWrapS, glWrapT, glMinFilter, gpuPipelineState = null, gpuShader = null, isShaderChanged = !1, gpuInputAssembler = null, glPrimitive = gl.TRIANGLES, _i19 = 0; _i19 < cmdPackage.cmds.length; ++_i19) {
                    var cmd = cmdPackage.cmds.array[_i19], cmdId = cmdIds[cmd]++;
                    switch (cmd) {
                      case WebGLCmd.BEGIN_RENDER_PASS:
                        var cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId], clears = 0;
                        if (cmd0.gpuFramebuffer) {
                            cache.glFramebuffer !== cmd0.gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, cmd0.gpuFramebuffer.glFramebuffer), 
                            cache.glFramebuffer = cmd0.gpuFramebuffer.glFramebuffer), cache.viewport.left === cmd0.renderArea.x && cache.viewport.top === cmd0.renderArea.y && cache.viewport.width === cmd0.renderArea.width && cache.viewport.height === cmd0.renderArea.height || (gl.viewport(cmd0.renderArea.x, cmd0.renderArea.y, cmd0.renderArea.width, cmd0.renderArea.height), 
                            cache.viewport.left = cmd0.renderArea.x, cache.viewport.top = cmd0.renderArea.y, 
                            cache.viewport.width = cmd0.renderArea.width, cache.viewport.height = cmd0.renderArea.height), 
                            cache.scissorRect.x === cmd0.renderArea.x && cache.scissorRect.y === cmd0.renderArea.y && cache.scissorRect.width === cmd0.renderArea.width && cache.scissorRect.height === cmd0.renderArea.height || (gl.scissor(cmd0.renderArea.x, cmd0.renderArea.y, cmd0.renderArea.width, cmd0.renderArea.height), 
                            cache.scissorRect.x = cmd0.renderArea.x, cache.scissorRect.y = cmd0.renderArea.y, 
                            cache.scissorRect.width = cmd0.renderArea.width, cache.scissorRect.height = cmd0.renderArea.height);
                            var curGPURenderPass = cmd0.gpuFramebuffer.gpuRenderPass, clearCount = cmd0.clearColors.length;
                            device.WEBGL_draw_buffers || (clearCount = 1);
                            for (var j = 0; j < clearCount; ++j) {
                                var colorAttachment = curGPURenderPass.colorAttachments[j];
                                if (colorAttachment.format !== GFXFormat.UNKNOWN) switch (colorAttachment.loadOp) {
                                  case GFXLoadOp.LOAD:
                                    break;

                                  case GFXLoadOp.CLEAR:
                                    if (cmd0.clearFlag & GFXClearFlag.COLOR) {
                                        cache.bs.targets[0].blendColorMask !== GFXColorMask.ALL && gl.colorMask(!0, !0, !0, !0);
                                        var clearColor = cmd0.clearColors[0];
                                        gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a), clears |= gl.COLOR_BUFFER_BIT;
                                    }
                                    break;

                                  case GFXLoadOp.DISCARD:
                                }
                            }
                            if (curGPURenderPass.depthStencilAttachment && curGPURenderPass.depthStencilAttachment.format !== GFXFormat.UNKNOWN) {
                                switch (curGPURenderPass.depthStencilAttachment.depthLoadOp) {
                                  case GFXLoadOp.LOAD:
                                    break;

                                  case GFXLoadOp.CLEAR:
                                    cmd0.clearFlag & GFXClearFlag.DEPTH && (cache.dss.depthWrite || gl.depthMask(!0), 
                                    gl.clearDepth(cmd0.clearDepth), clears |= gl.DEPTH_BUFFER_BIT);
                                    break;

                                  case GFXLoadOp.DISCARD:
                                }
                                if (GFXFormatInfos[curGPURenderPass.depthStencilAttachment.format].hasStencil) switch (curGPURenderPass.depthStencilAttachment.stencilLoadOp) {
                                  case GFXLoadOp.LOAD:
                                    break;

                                  case GFXLoadOp.CLEAR:
                                    cmd0.clearFlag & GFXClearFlag.STENCIL && (cache.dss.stencilWriteMaskFront || gl.stencilMaskSeparate(gl.FRONT, 4294967295), 
                                    cache.dss.stencilWriteMaskBack || gl.stencilMaskSeparate(gl.BACK, 4294967295), gl.clearStencil(cmd0.clearStencil), 
                                    clears |= gl.STENCIL_BUFFER_BIT);
                                    break;

                                  case GFXLoadOp.DISCARD:
                                }
                            }
                            if (clears && gl.clear(clears), clears & gl.COLOR_BUFFER_BIT) {
                                var colorMask = cache.bs.targets[0].blendColorMask;
                                if (colorMask !== GFXColorMask.ALL) {
                                    var r = (colorMask & GFXColorMask.R) !== GFXColorMask.NONE, g = (colorMask & GFXColorMask.G) !== GFXColorMask.NONE, b = (colorMask & GFXColorMask.B) !== GFXColorMask.NONE, a = (colorMask & GFXColorMask.A) !== GFXColorMask.NONE;
                                    gl.colorMask(r, g, b, a);
                                }
                            }
                            clears & gl.DEPTH_BUFFER_BIT && !cache.dss.depthWrite && gl.depthMask(!1), clears & gl.STENCIL_BUFFER_BIT && (cache.dss.stencilWriteMaskFront || gl.stencilMaskSeparate(gl.FRONT, 0), 
                            cache.dss.stencilWriteMaskBack || gl.stencilMaskSeparate(gl.BACK, 0));
                        }
                        break;

                      case WebGLCmd.BIND_STATES:
                        var cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
                        if (isShaderChanged = !1, cmd2.gpuPipelineState) {
                            if (gpuPipelineState = cmd2.gpuPipelineState, glPrimitive = cmd2.gpuPipelineState.glPrimitive, 
                            cmd2.gpuPipelineState.gpuShader) {
                                var glProgram = cmd2.gpuPipelineState.gpuShader.glProgram;
                                cache.glProgram !== glProgram && (gl.useProgram(glProgram), cache.glProgram = glProgram, 
                                isShaderChanged = !0), gpuShader = cmd2.gpuPipelineState.gpuShader;
                            }
                            var rs = cmd2.gpuPipelineState.rs;
                            if (rs) {
                                if (cache.rs.cullMode !== rs.cullMode) {
                                    switch (rs.cullMode) {
                                      case GFXCullMode.NONE:
                                        gl.disable(gl.CULL_FACE);
                                        break;

                                      case GFXCullMode.FRONT:
                                        gl.enable(gl.CULL_FACE), gl.cullFace(gl.FRONT);
                                        break;

                                      case GFXCullMode.BACK:
                                        gl.enable(gl.CULL_FACE), gl.cullFace(gl.BACK);
                                    }
                                    cache.rs.cullMode = rs.cullMode;
                                }
                                cache.rs.isFrontFaceCCW !== rs.isFrontFaceCCW && (gl.frontFace(rs.isFrontFaceCCW ? gl.CCW : gl.CW), 
                                cache.rs.isFrontFaceCCW = rs.isFrontFaceCCW), cache.rs.depthBias === rs.depthBias && cache.rs.depthBiasSlop === rs.depthBiasSlop || (gl.polygonOffset(rs.depthBias, rs.depthBiasSlop), 
                                cache.rs.depthBias = rs.depthBias, cache.rs.depthBiasSlop = rs.depthBiasSlop), cache.rs.lineWidth !== rs.lineWidth && (gl.lineWidth(rs.lineWidth), 
                                cache.rs.lineWidth = rs.lineWidth);
                            }
                            var dss = cmd2.gpuPipelineState.dss;
                            dss && (cache.dss.depthTest !== dss.depthTest && (dss.depthTest ? gl.enable(gl.DEPTH_TEST) : gl.disable(gl.DEPTH_TEST), 
                            cache.dss.depthTest = dss.depthTest), cache.dss.depthWrite !== dss.depthWrite && (gl.depthMask(dss.depthWrite), 
                            cache.dss.depthWrite = dss.depthWrite), cache.dss.depthFunc !== dss.depthFunc && (gl.depthFunc(WebGLCmpFuncs[dss.depthFunc]), 
                            cache.dss.depthFunc = dss.depthFunc), cache.dss.stencilTestFront === dss.stencilTestFront && cache.dss.stencilTestBack === dss.stencilTestBack || (dss.stencilTestFront || dss.stencilTestBack ? gl.enable(gl.STENCIL_TEST) : gl.disable(gl.STENCIL_TEST), 
                            cache.dss.stencilTestFront = dss.stencilTestFront, cache.dss.stencilTestBack = dss.stencilTestBack), 
                            cache.dss.stencilFuncFront === dss.stencilFuncFront && cache.dss.stencilRefFront === dss.stencilRefFront && cache.dss.stencilReadMaskFront === dss.stencilReadMaskFront || (gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront), 
                            cache.dss.stencilFuncFront = dss.stencilFuncFront, cache.dss.stencilRefFront = dss.stencilRefFront, 
                            cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront), cache.dss.stencilFailOpFront === dss.stencilFailOpFront && cache.dss.stencilZFailOpFront === dss.stencilZFailOpFront && cache.dss.stencilPassOpFront === dss.stencilPassOpFront || (gl.stencilOpSeparate(gl.FRONT, WebGLStencilOps[dss.stencilFailOpFront], WebGLStencilOps[dss.stencilZFailOpFront], WebGLStencilOps[dss.stencilPassOpFront]), 
                            cache.dss.stencilFailOpFront = dss.stencilFailOpFront, cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront, 
                            cache.dss.stencilPassOpFront = dss.stencilPassOpFront), cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront && (gl.stencilMaskSeparate(gl.FRONT, dss.stencilWriteMaskFront), 
                            cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront), cache.dss.stencilFuncBack === dss.stencilFuncBack && cache.dss.stencilRefBack === dss.stencilRefBack && cache.dss.stencilReadMaskBack === dss.stencilReadMaskBack || (gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack), 
                            cache.dss.stencilFuncBack = dss.stencilFuncBack, cache.dss.stencilRefBack = dss.stencilRefBack, 
                            cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack), cache.dss.stencilFailOpBack === dss.stencilFailOpBack && cache.dss.stencilZFailOpBack === dss.stencilZFailOpBack && cache.dss.stencilPassOpBack === dss.stencilPassOpBack || (gl.stencilOpSeparate(gl.BACK, WebGLStencilOps[dss.stencilFailOpBack], WebGLStencilOps[dss.stencilZFailOpBack], WebGLStencilOps[dss.stencilPassOpBack]), 
                            cache.dss.stencilFailOpBack = dss.stencilFailOpBack, cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack, 
                            cache.dss.stencilPassOpBack = dss.stencilPassOpBack), cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack && (gl.stencilMaskSeparate(gl.BACK, dss.stencilWriteMaskBack), 
                            cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack));
                            var bs = cmd2.gpuPipelineState.bs;
                            if (bs) {
                                cache.bs.isA2C !== bs.isA2C && (bs.isA2C ? gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE), 
                                cache.bs.isA2C = bs.isA2C), cache.bs.blendColor[0] === bs.blendColor[0] && cache.bs.blendColor[1] === bs.blendColor[1] && cache.bs.blendColor[2] === bs.blendColor[2] && cache.bs.blendColor[3] === bs.blendColor[3] || (gl.blendColor(bs.blendColor[0], bs.blendColor[1], bs.blendColor[2], bs.blendColor[3]), 
                                cache.bs.blendColor[0] = bs.blendColor[0], cache.bs.blendColor[1] = bs.blendColor[1], 
                                cache.bs.blendColor[2] = bs.blendColor[2], cache.bs.blendColor[3] = bs.blendColor[3]);
                                var target0 = bs.targets[0], target0Cache = cache.bs.targets[0];
                                target0Cache.blend !== target0.blend && (target0.blend ? gl.enable(gl.BLEND) : gl.disable(gl.BLEND), 
                                target0Cache.blend = target0.blend), target0Cache.blendEq === target0.blendEq && target0Cache.blendAlphaEq === target0.blendAlphaEq || (gl.blendEquationSeparate(WebGLBlendOps[target0.blendEq], WebGLBlendOps[target0.blendAlphaEq]), 
                                target0Cache.blendEq = target0.blendEq, target0Cache.blendAlphaEq = target0.blendAlphaEq), 
                                target0Cache.blendSrc === target0.blendSrc && target0Cache.blendDst === target0.blendDst && target0Cache.blendSrcAlpha === target0.blendSrcAlpha && target0Cache.blendDstAlpha === target0.blendDstAlpha || (gl.blendFuncSeparate(WebGLBlendFactors[target0.blendSrc], WebGLBlendFactors[target0.blendDst], WebGLBlendFactors[target0.blendSrcAlpha], WebGLBlendFactors[target0.blendDstAlpha]), 
                                target0Cache.blendSrc = target0.blendSrc, target0Cache.blendDst = target0.blendDst, 
                                target0Cache.blendSrcAlpha = target0.blendSrcAlpha, target0Cache.blendDstAlpha = target0.blendDstAlpha), 
                                target0Cache.blendColorMask !== target0.blendColorMask && (gl.colorMask((target0.blendColorMask & GFXColorMask.R) !== GFXColorMask.NONE, (target0.blendColorMask & GFXColorMask.G) !== GFXColorMask.NONE, (target0.blendColorMask & GFXColorMask.B) !== GFXColorMask.NONE, (target0.blendColorMask & GFXColorMask.A) !== GFXColorMask.NONE), 
                                target0Cache.blendColorMask = target0.blendColorMask);
                            }
                        }
                        if (cmd2.gpuBindingLayout && gpuShader) for (var bindingLen = cmd2.gpuBindingLayout.gpuBindings.length, _j = 0; _j < bindingLen; _j++) {
                            var gpuBinding = cmd2.gpuBindingLayout.gpuBindings[_j];
                            switch (gpuBinding.type) {
                              case GFXBindingType.UNIFORM_BUFFER:
                                if (gpuBinding.gpuBuffer && gpuBinding.gpuBuffer.buffer) {
                                    for (var glBlock = null, blockLen = gpuShader.glBlocks.length, k = 0; k < blockLen; k++) {
                                        var block = gpuShader.glBlocks[k];
                                        if (block.binding === gpuBinding.binding) {
                                            glBlock = block;
                                            break;
                                        }
                                    }
                                    if (glBlock && gpuBinding.gpuBuffer.vf32) for (var uniformLen = glBlock.glActiveUniforms.length, _k = 0; _k < uniformLen; _k++) {
                                        var glUniform = glBlock.glActiveUniforms[_k];
                                        switch (glUniform.glType) {
                                          case gl.BOOL:
                                          case gl.INT:
                                            for (var u = 0; u < glUniform.array.length; ++u) {
                                                var idx = glUniform.begin + u;
                                                if (gpuBinding.gpuBuffer.vf32[idx] !== glUniform.array[u]) {
                                                    for (var n = u, m = glUniform.begin + u; n < glUniform.array.length; ++n, ++m) glUniform.array[n] = gpuBinding.gpuBuffer.vf32[m];
                                                    gl.uniform1iv(glUniform.glLoc, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case gl.BOOL_VEC2:
                                          case gl.INT_VEC2:
                                            for (var _u = 0; _u < glUniform.array.length; ++_u) {
                                                var _idx = glUniform.begin + _u;
                                                if (gpuBinding.gpuBuffer.vf32[_idx] !== glUniform.array[_u]) {
                                                    for (var _n = _u, _m = glUniform.begin + _u; _n < glUniform.array.length; ++_n, 
                                                    ++_m) glUniform.array[_n] = gpuBinding.gpuBuffer.vf32[_m];
                                                    gl.uniform2iv(glUniform.glLoc, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case gl.BOOL_VEC3:
                                          case gl.INT_VEC3:
                                            for (var _u2 = 0; _u2 < glUniform.array.length; ++_u2) {
                                                var _idx2 = glUniform.begin + _u2;
                                                if (gpuBinding.gpuBuffer.vf32[_idx2] !== glUniform.array[_u2]) {
                                                    for (var _n2 = _u2, _m2 = glUniform.begin + _u2; _n2 < glUniform.array.length; ++_n2, 
                                                    ++_m2) glUniform.array[_n2] = gpuBinding.gpuBuffer.vf32[_m2];
                                                    gl.uniform3iv(glUniform.glLoc, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case gl.BOOL_VEC4:
                                          case gl.INT_VEC4:
                                            for (var _u3 = 0; _u3 < glUniform.array.length; ++_u3) {
                                                var _idx3 = glUniform.begin + _u3;
                                                if (gpuBinding.gpuBuffer.vf32[_idx3] !== glUniform.array[_u3]) {
                                                    for (var _n3 = _u3, _m3 = glUniform.begin + _u3; _n3 < glUniform.array.length; ++_n3, 
                                                    ++_m3) glUniform.array[_n3] = gpuBinding.gpuBuffer.vf32[_m3];
                                                    gl.uniform4iv(glUniform.glLoc, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case gl.FLOAT:
                                            for (var _u4 = 0; _u4 < glUniform.array.length; ++_u4) {
                                                var _idx4 = glUniform.begin + _u4;
                                                if (gpuBinding.gpuBuffer.vf32[_idx4] !== glUniform.array[_u4]) {
                                                    for (var _n4 = _u4, _m4 = glUniform.begin + _u4; _n4 < glUniform.array.length; ++_n4, 
                                                    ++_m4) glUniform.array[_n4] = gpuBinding.gpuBuffer.vf32[_m4];
                                                    gl.uniform1fv(glUniform.glLoc, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case gl.FLOAT_VEC2:
                                            for (var _u5 = 0; _u5 < glUniform.array.length; ++_u5) {
                                                var _idx5 = glUniform.begin + _u5;
                                                if (gpuBinding.gpuBuffer.vf32[_idx5] !== glUniform.array[_u5]) {
                                                    for (var _n5 = _u5, _m5 = glUniform.begin + _u5; _n5 < glUniform.array.length; ++_n5, 
                                                    ++_m5) glUniform.array[_n5] = gpuBinding.gpuBuffer.vf32[_m5];
                                                    gl.uniform2fv(glUniform.glLoc, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case gl.FLOAT_VEC3:
                                            for (var _u6 = 0; _u6 < glUniform.array.length; ++_u6) {
                                                var _idx6 = glUniform.begin + _u6;
                                                if (gpuBinding.gpuBuffer.vf32[_idx6] !== glUniform.array[_u6]) {
                                                    for (var _n6 = _u6, _m6 = glUniform.begin + _u6; _n6 < glUniform.array.length; ++_n6, 
                                                    ++_m6) glUniform.array[_n6] = gpuBinding.gpuBuffer.vf32[_m6];
                                                    gl.uniform3fv(glUniform.glLoc, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case gl.FLOAT_VEC4:
                                            for (var _u7 = 0; _u7 < glUniform.array.length; ++_u7) {
                                                var _idx7 = glUniform.begin + _u7;
                                                if (gpuBinding.gpuBuffer.vf32[_idx7] !== glUniform.array[_u7]) {
                                                    for (var _n7 = _u7, _m7 = glUniform.begin + _u7; _n7 < glUniform.array.length; ++_n7, 
                                                    ++_m7) glUniform.array[_n7] = gpuBinding.gpuBuffer.vf32[_m7];
                                                    gl.uniform4fv(glUniform.glLoc, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case gl.FLOAT_MAT2:
                                            for (var _u8 = 0; _u8 < glUniform.array.length; ++_u8) {
                                                var _idx8 = glUniform.begin + _u8;
                                                if (gpuBinding.gpuBuffer.vf32[_idx8] !== glUniform.array[_u8]) {
                                                    for (var _n8 = _u8, _m8 = glUniform.begin + _u8; _n8 < glUniform.array.length; ++_n8, 
                                                    ++_m8) glUniform.array[_n8] = gpuBinding.gpuBuffer.vf32[_m8];
                                                    gl.uniformMatrix2fv(glUniform.glLoc, !1, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case gl.FLOAT_MAT3:
                                            for (var _u9 = 0; _u9 < glUniform.array.length; ++_u9) {
                                                var _idx9 = glUniform.begin + _u9;
                                                if (gpuBinding.gpuBuffer.vf32[_idx9] !== glUniform.array[_u9]) {
                                                    for (var _n9 = _u9, _m9 = glUniform.begin + _u9; _n9 < glUniform.array.length; ++_n9, 
                                                    ++_m9) glUniform.array[_n9] = gpuBinding.gpuBuffer.vf32[_m9];
                                                    gl.uniformMatrix3fv(glUniform.glLoc, !1, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case gl.FLOAT_MAT4:
                                            for (var _u10 = 0; _u10 < glUniform.array.length; ++_u10) {
                                                var _idx10 = glUniform.begin + _u10;
                                                if (gpuBinding.gpuBuffer.vf32[_idx10] !== glUniform.array[_u10]) {
                                                    for (var _n10 = _u10, _m10 = glUniform.begin + _u10; _n10 < glUniform.array.length; ++_n10, 
                                                    ++_m10) glUniform.array[_n10] = gpuBinding.gpuBuffer.vf32[_m10];
                                                    gl.uniformMatrix4fv(glUniform.glLoc, !1, glUniform.array);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                                break;

                              case GFXBindingType.SAMPLER:
                                if (gpuBinding.gpuSampler) {
                                    for (var glSampler = null, samplerLen = gpuShader.glSamplers.length, _k2 = 0; _k2 < samplerLen; _k2++) {
                                        var sampler = gpuShader.glSamplers[_k2];
                                        if (sampler.binding === gpuBinding.binding) {
                                            glSampler = sampler;
                                            break;
                                        }
                                    }
                                    if (glSampler) for (var texUnitLen = glSampler.units.length, _k3 = 0; _k3 < texUnitLen; _k3++) {
                                        var texUnit = glSampler.units[_k3];
                                        if (gpuBinding.gpuTexView && 0 < gpuBinding.gpuTexView.gpuTexture.size) {
                                            var gpuTexture = gpuBinding.gpuTexView.gpuTexture, glTexUnit = cache.glTexUnits[texUnit];
                                            glTexUnit.glTexture !== gpuTexture.glTexture && (cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), 
                                            cache.texUnit = texUnit), gpuTexture.glTexture ? gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture) : gl.bindTexture(gpuTexture.glTarget, device.nullTex2D.gpuTexture.glTexture), 
                                            glTexUnit.glTexture = gpuTexture.glTexture);
                                            var gpuSampler = gpuBinding.gpuSampler;
                                            glWrapT = gpuTexture.isPowerOf2 ? (glWrapS = gpuSampler.glWrapS, gpuSampler.glWrapT) : (glWrapS = gl.CLAMP_TO_EDGE, 
                                            gl.CLAMP_TO_EDGE), glMinFilter = gpuTexture.isPowerOf2 ? gpuTexture.mipLevel <= 1 && (gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR) ? gl.LINEAR : gpuSampler.glMinFilter : gpuSampler.glMinFilter === gl.LINEAR || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR ? gl.LINEAR : gl.NEAREST, 
                                            gpuTexture.glWrapS !== glWrapS && (cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), 
                                            cache.texUnit = texUnit), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, glWrapS), 
                                            gpuTexture.glWrapS = glWrapS), gpuTexture.glWrapT !== glWrapT && (cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), 
                                            cache.texUnit = texUnit), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, glWrapT), 
                                            gpuTexture.glWrapT = glWrapT), gpuTexture.glMinFilter !== glMinFilter && (cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), 
                                            cache.texUnit = texUnit), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, glMinFilter), 
                                            gpuTexture.glMinFilter = glMinFilter), gpuTexture.glMagFilter !== gpuSampler.glMagFilter && (cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), 
                                            cache.texUnit = texUnit), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuSampler.glMagFilter), 
                                            gpuTexture.glMagFilter = gpuSampler.glMagFilter);
                                        }
                                    }
                                } else console.error("Not found sampler on binding unit " + gpuBinding.binding);
                            }
                        }
                        if (cmd2.gpuInputAssembler && gpuShader && (isShaderChanged || gpuInputAssembler !== cmd2.gpuInputAssembler)) if (gpuInputAssembler = cmd2.gpuInputAssembler, 
                        device.useVAO) {
                            var vao = device.OES_vertex_array_object, glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);
                            if (!glVAO) {
                                glVAO = vao.createVertexArrayOES(), gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO), 
                                vao.bindVertexArrayOES(glVAO), gl.bindBuffer(gl.ARRAY_BUFFER, null), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                                for (var glAttrib = void 0, inputLen = gpuShader.glInputs.length, _j2 = 0; _j2 < inputLen; _j2++) {
                                    var glInput = gpuShader.glInputs[_j2];
                                    glAttrib = null;
                                    for (var attribLen = gpuInputAssembler.glAttribs.length, _k4 = 0; _k4 < attribLen; _k4++) {
                                        var attrib = gpuInputAssembler.glAttribs[_k4];
                                        if (attrib.name === glInput.name) {
                                            glAttrib = attrib;
                                            break;
                                        }
                                    }
                                    if (glAttrib) {
                                        gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                                        for (var c = 0; c < glAttrib.componentCount; ++c) {
                                            var glLoc = glInput.glLoc + c, attribOffset = glAttrib.offset + glAttrib.size * c;
                                            gl.enableVertexAttribArray(glLoc), cache.glCurrentAttribLocs[glLoc] = !0, gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);
                                        }
                                    }
                                }
                                var gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
                                gpuBuffer && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), vao.bindVertexArrayOES(null), 
                                gl.bindBuffer(gl.ARRAY_BUFFER, null), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), 
                                cache.glArrayBuffer = null, cache.glElementArrayBuffer = null;
                            }
                            cache.glVAO !== glVAO && (vao.bindVertexArrayOES(glVAO), cache.glVAO = glVAO);
                        } else {
                            for (var _a = 0; _a < device.maxVertexAttributes; ++_a) cache.glCurrentAttribLocs[_a] = !1;
                            for (var _inputLen = gpuShader.glInputs.length, _j3 = 0; _j3 < _inputLen; _j3++) {
                                for (var _glInput = gpuShader.glInputs[_j3], _glAttrib = null, _attribLen = gpuInputAssembler.glAttribs.length, _k5 = 0; _k5 < _attribLen; _k5++) {
                                    var _attrib = gpuInputAssembler.glAttribs[_k5];
                                    if (_attrib.name === _glInput.name) {
                                        _glAttrib = _attrib;
                                        break;
                                    }
                                }
                                if (_glAttrib) {
                                    cache.glArrayBuffer !== _glAttrib.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, _glAttrib.glBuffer), 
                                    cache.glArrayBuffer = _glAttrib.glBuffer);
                                    for (var _c = 0; _c < _glAttrib.componentCount; ++_c) {
                                        var _glLoc2 = _glInput.glLoc + _c, _attribOffset = _glAttrib.offset + _glAttrib.size * _c;
                                        !cache.glEnabledAttribLocs[_glLoc2] && 0 <= _glLoc2 && (gl.enableVertexAttribArray(_glLoc2), 
                                        cache.glEnabledAttribLocs[_glLoc2] = !0), cache.glCurrentAttribLocs[_glLoc2] = !0, 
                                        gl.vertexAttribPointer(_glLoc2, _glAttrib.count, _glAttrib.glType, _glAttrib.isNormalized, _glAttrib.stride, _attribOffset);
                                    }
                                }
                            }
                            var _gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
                            _gpuBuffer && cache.glElementArrayBuffer !== _gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _gpuBuffer.glBuffer), 
                            cache.glElementArrayBuffer = _gpuBuffer.glBuffer);
                            for (var _a2 = 0; _a2 < device.maxVertexAttributes; ++_a2) cache.glEnabledAttribLocs[_a2] !== cache.glCurrentAttribLocs[_a2] && (gl.disableVertexAttribArray(_a2), 
                            cache.glEnabledAttribLocs[_a2] = !1);
                        }
                        if (gpuPipelineState) for (var dsLen = gpuPipelineState.dynamicStates.length, _j4 = 0; _j4 < dsLen; _j4++) {
                            switch (gpuPipelineState.dynamicStates[_j4]) {
                              case GFXDynamicState.VIEWPORT:
                                cmd2.viewport && (cache.viewport.left === cmd2.viewport.left && cache.viewport.top === cmd2.viewport.top && cache.viewport.width === cmd2.viewport.width && cache.viewport.height === cmd2.viewport.height || (gl.viewport(cmd2.viewport.left, cmd2.viewport.top, cmd2.viewport.width, cmd2.viewport.height), 
                                cache.viewport.left = cmd2.viewport.left, cache.viewport.top = cmd2.viewport.top, 
                                cache.viewport.width = cmd2.viewport.width, cache.viewport.height = cmd2.viewport.height));
                                break;

                              case GFXDynamicState.SCISSOR:
                                cmd2.scissor && (cache.scissorRect.x === cmd2.scissor.x && cache.scissorRect.y === cmd2.scissor.y && cache.scissorRect.width === cmd2.scissor.width && cache.scissorRect.height === cmd2.scissor.height || (gl.scissor(cmd2.scissor.x, cmd2.scissor.y, cmd2.scissor.width, cmd2.scissor.height), 
                                cache.scissorRect.x = cmd2.scissor.x, cache.scissorRect.y = cmd2.scissor.y, cache.scissorRect.width = cmd2.scissor.width, 
                                cache.scissorRect.height = cmd2.scissor.height));
                                break;

                              case GFXDynamicState.LINE_WIDTH:
                                cmd2.lineWidth && cache.rs.lineWidth !== cmd2.lineWidth && (gl.lineWidth(cmd2.lineWidth), 
                                cache.rs.lineWidth = cmd2.lineWidth);
                                break;

                              case GFXDynamicState.DEPTH_BIAS:
                                cmd2.depthBias && (cache.rs.depthBias === cmd2.depthBias.constantFactor && cache.rs.depthBiasSlop === cmd2.depthBias.slopeFactor || (gl.polygonOffset(cmd2.depthBias.constantFactor, cmd2.depthBias.slopeFactor), 
                                cache.rs.depthBias = cmd2.depthBias.constantFactor, cache.rs.depthBiasSlop = cmd2.depthBias.slopeFactor));
                                break;

                              case GFXDynamicState.BLEND_CONSTANTS:
                                cmd2.blendConstants && (cache.bs.blendColor[0] === cmd2.blendConstants[0] && cache.bs.blendColor[1] === cmd2.blendConstants[1] && cache.bs.blendColor[2] === cmd2.blendConstants[2] && cache.bs.blendColor[3] === cmd2.blendConstants[3] || (gl.blendColor(cmd2.blendConstants[0], cmd2.blendConstants[1], cmd2.blendConstants[2], cmd2.blendConstants[3]), 
                                cache.bs.blendColor[0] = cmd2.blendConstants[0], cache.bs.blendColor[1] = cmd2.blendConstants[1], 
                                cache.bs.blendColor[2] = cmd2.blendConstants[2], cache.bs.blendColor[3] = cmd2.blendConstants[3]));
                                break;

                              case GFXDynamicState.STENCIL_WRITE_MASK:
                                if (cmd2.stencilWriteMask) switch (cmd2.stencilWriteMask.face) {
                                  case GFXStencilFace.FRONT:
                                    cache.dss.stencilWriteMaskFront !== cmd2.stencilWriteMask.writeMask && (gl.stencilMaskSeparate(gl.FRONT, cmd2.stencilWriteMask.writeMask), 
                                    cache.dss.stencilWriteMaskFront = cmd2.stencilWriteMask.writeMask);
                                    break;

                                  case GFXStencilFace.BACK:
                                    cache.dss.stencilWriteMaskBack !== cmd2.stencilWriteMask.writeMask && (gl.stencilMaskSeparate(gl.BACK, cmd2.stencilWriteMask.writeMask), 
                                    cache.dss.stencilWriteMaskBack = cmd2.stencilWriteMask.writeMask);
                                    break;

                                  case GFXStencilFace.ALL:
                                    cache.dss.stencilWriteMaskFront === cmd2.stencilWriteMask.writeMask && cache.dss.stencilWriteMaskBack === cmd2.stencilWriteMask.writeMask || (gl.stencilMask(cmd2.stencilWriteMask.writeMask), 
                                    cache.dss.stencilWriteMaskFront = cmd2.stencilWriteMask.writeMask, cache.dss.stencilWriteMaskBack = cmd2.stencilWriteMask.writeMask);
                                }
                                break;

                              case GFXDynamicState.STENCIL_COMPARE_MASK:
                                if (cmd2.stencilCompareMask) switch (cmd2.stencilCompareMask.face) {
                                  case GFXStencilFace.FRONT:
                                    cache.dss.stencilRefFront === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskFront === cmd2.stencilCompareMask.compareMask || (gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[cache.dss.stencilFuncFront], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                                    cache.dss.stencilRefFront = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskFront = cmd2.stencilCompareMask.compareMask);
                                    break;

                                  case GFXStencilFace.BACK:
                                    cache.dss.stencilRefBack === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskBack === cmd2.stencilCompareMask.compareMask || (gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[cache.dss.stencilFuncBack], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                                    cache.dss.stencilRefBack = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskBack = cmd2.stencilCompareMask.compareMask);
                                    break;

                                  case GFXStencilFace.ALL:
                                    cache.dss.stencilRefFront === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskFront === cmd2.stencilCompareMask.compareMask && cache.dss.stencilRefBack === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskBack === cmd2.stencilCompareMask.compareMask || (gl.stencilFunc(WebGLCmpFuncs[cache.dss.stencilFuncBack], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                                    cache.dss.stencilRefFront = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskFront = cmd2.stencilCompareMask.compareMask, 
                                    cache.dss.stencilRefBack = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskBack = cmd2.stencilCompareMask.compareMask);
                                }
                            }
                        }
                        break;

                      case WebGLCmd.DRAW:
                        var cmd3 = cmdPackage.drawCmds.array[cmdId];
                        if (gpuInputAssembler && gpuShader) if (gpuInputAssembler.gpuIndirectBuffer) {
                            if (gpuInputAssembler.gpuIndirectBuffer) for (var diLen = gpuInputAssembler.gpuIndirectBuffer.indirects.length, _j5 = 0; _j5 < diLen; _j5++) {
                                var drawInfo = gpuInputAssembler.gpuIndirectBuffer.indirects[_j5], _gpuBuffer3 = gpuInputAssembler.gpuIndexBuffer;
                                if (_gpuBuffer3 && -1 < drawInfo.indexCount) {
                                    var _offset = drawInfo.firstIndex * _gpuBuffer3.stride;
                                    gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset);
                                } else gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
                            }
                        } else {
                            var _gpuBuffer2 = gpuInputAssembler.gpuIndexBuffer;
                            if (_gpuBuffer2 && -1 < cmd3.drawInfo.indexCount) {
                                var offset = cmd3.drawInfo.firstIndex * _gpuBuffer2.stride;
                                gl.drawElements(glPrimitive, cmd3.drawInfo.indexCount, gpuInputAssembler.glIndexType, offset);
                            } else gl.drawArrays(glPrimitive, cmd3.drawInfo.firstVertex, cmd3.drawInfo.vertexCount);
                        }
                        break;

                      case WebGLCmd.UPDATE_BUFFER:
                        var cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
                        WebGLCmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
                        break;

                      case WebGLCmd.COPY_BUFFER_TO_TEXTURE:
                        var cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
                        WebGLCmdFuncCopyBuffersToTexture(device, [ cmd5.gpuBuffer.buffer ], cmd5.gpuTexture, cmd5.regions);
                    }
                }
            }
            function WebGLCmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
                var gl = device.gl, glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture), 
                glTexUnit.glTexture = gpuTexture.glTexture);
                var m = 0, n = 0, w = 1, h = 1, f = 0, fmtInfo = GFXFormatInfos[gpuTexture.format], isCompressed = fmtInfo.isCompressed;
                switch (gpuTexture.glTarget) {
                  case gl.TEXTURE_2D:
                    var _iterator12 = regions, _isArray12 = Array.isArray(_iterator12), _i22 = 0;
                    for (_iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator](); ;) {
                        var _ref12;
                        if (_isArray12) {
                            if (_i22 >= _iterator12.length) break;
                            _ref12 = _iterator12[_i22++];
                        } else {
                            if ((_i22 = _iterator12.next()).done) break;
                            _ref12 = _i22.value;
                        }
                        var region = _ref12;
                        for (w = region.texExtent.width, h = region.texExtent.height, m = region.texSubres.baseMipLevel; m < region.texSubres.levelCount; ++m) {
                            var pixels = fmtInfo.type !== GFXFormatType.FLOAT || isCompressed ? new Uint8Array(buffers[n++]) : new Float32Array(buffers[n++]);
                            isCompressed ? gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL ? gl.compressedTexSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, pixels) : gl.compressedTexImage2D(gl.TEXTURE_2D, m, gpuTexture.glInternelFmt, w, h, 0, pixels) : gl.texSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, pixels), 
                            w = Math.max(1, w >> 1), h = Math.max(1, w >> 1);
                        }
                    }
                    break;

                  case gl.TEXTURE_CUBE_MAP:
                    var _iterator13 = regions, _isArray13 = Array.isArray(_iterator13), _i23 = 0;
                    for (_iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator](); ;) {
                        var _ref13;
                        if (_isArray13) {
                            if (_i23 >= _iterator13.length) break;
                            _ref13 = _iterator13[_i23++];
                        } else {
                            if ((_i23 = _iterator13.next()).done) break;
                            _ref13 = _i23.value;
                        }
                        var _region2 = _ref13;
                        n = 0;
                        var fcount = _region2.texSubres.baseArrayLayer + _region2.texSubres.layerCount;
                        for (f = _region2.texSubres.baseArrayLayer; f < fcount; ++f) {
                            w = _region2.texExtent.width, h = _region2.texExtent.height;
                            var mcount = _region2.texSubres.baseMipLevel + _region2.texSubres.levelCount;
                            for (m = _region2.texSubres.baseMipLevel; m < mcount; ++m) {
                                var _pixels = fmtInfo.type !== GFXFormatType.FLOAT || isCompressed ? new Uint8Array(buffers[n++]) : new Float32Array(buffers[n++]);
                                isCompressed ? gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL ? gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, _pixels) : gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, gpuTexture.glInternelFmt, w, h, 0, _pixels) : gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, _pixels), 
                                w = Math.max(1, w >> 1), h = Math.max(1, w >> 1);
                            }
                        }
                    }
                    break;

                  default:
                    console.error("Unsupported GL texture type, copy buffer to texture failed.");
                }
                gpuTexture.flags & GFXTextureFlagBit.GEN_MIPMAP && gl.generateMipmap(gpuTexture.glTarget);
            }
            function WebGLStateCache() {
                _classCallCheck(this, WebGLStateCache), this.glArrayBuffer = null, this.glElementArrayBuffer = null, 
                this.glVAO = null, this.texUnit = 0, this.glTexUnits = void 0, this.glRenderbuffer = null, 
                this.glFramebuffer = null, this.viewport = void 0, this.scissorRect = void 0, this.rs = void 0, 
                this.dss = void 0, this.bs = void 0, this.glProgram = null, this.glEnabledAttribLocs = void 0, 
                this.glCurrentAttribLocs = void 0, this.glTexUnits = new Array(GFX_MAX_TEXTURE_UNITS), 
                this.viewport = {
                    left: 0,
                    top: 0,
                    width: 0,
                    height: 0,
                    minDepth: 0,
                    maxDepth: 0
                }, this.scissorRect = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                }, this.rs = new GFXRasterizerState(), this.dss = new GFXDepthStencilState(), this.bs = new GFXBlendState(), 
                this.glEnabledAttribLocs = new Array(GFX_MAX_VERTEX_ATTRIBUTES), this.glCurrentAttribLocs = new Array(GFX_MAX_VERTEX_ATTRIBUTES), 
                this.glEnabledAttribLocs.fill(!1), this.glCurrentAttribLocs.fill(!1);
                for (var i = 0; i < GFX_MAX_TEXTURE_UNITS; ++i) this.glTexUnits[i] = {
                    glTexture: null
                };
            }
            var WebGLGFXBuffer = function() {
                function WebGLGFXBuffer(device) {
                    var _this;
                    return _classCallCheck(this, WebGLGFXBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXBuffer).call(this, device)))._gpuBuffer = null, 
                    _this._uniformBuffer = null, _this._indirectBuffer = null, _this;
                }
                return _inherits(WebGLGFXBuffer, GFXBuffer), _createClass(WebGLGFXBuffer, [ {
                    key: "gpuBuffer",
                    get: function get() {
                        return this._gpuBuffer;
                    }
                } ]), _createClass(WebGLGFXBuffer, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return this._usage = info.usage, this._memUsage = info.memUsage, this._size = info.size, 
                        this._stride = Math.max(info.stride || this._size, 1), this._count = this._size / this._stride, 
                        this._flags = void 0 !== info.flags ? info.flags : GFXBufferFlagBit.NONE, this._usage & GFXBufferUsageBit.INDIRECT ? this._indirectBuffer = {
                            drawInfos: []
                        } : this._usage & GFXBufferUsageBit.UNIFORM && 0 < this._size && (this._uniformBuffer = new ArrayBuffer(this._size)), 
                        this._flags & GFXBufferFlagBit.BAKUP_BUFFER && (this._bufferView = new Uint8Array(this._size)), 
                        this._gpuBuffer = {
                            usage: info.usage,
                            memUsage: info.memUsage,
                            size: info.size,
                            stride: this._stride,
                            buffer: null,
                            vf32: null,
                            indirects: [],
                            glTarget: 0,
                            glBuffer: null
                        }, info.usage & GFXBufferUsageBit.INDIRECT ? this._gpuBuffer.indirects = this._indirectBuffer.drawInfos : this._usage & GFXBufferUsageBit.UNIFORM && (this._gpuBuffer.buffer = this._uniformBuffer), 
                        function WebGLCmdFuncCreateBuffer(device, gpuBuffer) {
                            var gl = device.gl, cache = device.stateCache, glUsage = gpuBuffer.memUsage & GFXMemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
                            if (gpuBuffer.usage & GFXBufferUsageBit.VERTEX) {
                                gpuBuffer.glTarget = gl.ARRAY_BUFFER;
                                var glBuffer = gl.createBuffer();
                                glBuffer && (gpuBuffer.glBuffer = glBuffer, 0 < gpuBuffer.size && (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                                cache.glVAO = null), device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                                device.stateCache.glArrayBuffer = gpuBuffer.glBuffer), gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                                gl.bindBuffer(gl.ARRAY_BUFFER, null), device.stateCache.glArrayBuffer = null));
                            } else if (gpuBuffer.usage & GFXBufferUsageBit.INDEX) {
                                gpuBuffer.glTarget = gl.ELEMENT_ARRAY_BUFFER;
                                var _glBuffer = gl.createBuffer();
                                _glBuffer && (gpuBuffer.glBuffer = _glBuffer, 0 < gpuBuffer.size && (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                                cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                                device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer), gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), device.stateCache.glElementArrayBuffer = null));
                            } else gpuBuffer.usage & GFXBufferUsageBit.UNIFORM ? (gpuBuffer.glTarget = gl.NONE, 
                            gpuBuffer.buffer && (gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer))) : (gpuBuffer.usage & GFXBufferUsageBit.INDIRECT || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_DST || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_SRC || console.error("Unsupported GFXBufferType, create buffer failed."), 
                            gpuBuffer.glTarget = gl.NONE);
                        }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize += this._size, 
                        this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._gpuBuffer && (!function WebGLCmdFuncDestroyBuffer(device, gpuBuffer) {
                            gpuBuffer.glBuffer && (device.gl.deleteBuffer(gpuBuffer.glBuffer), gpuBuffer.glBuffer = null);
                        }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize -= this._size, 
                        this._gpuBuffer = null), this._bufferView = null, this._status = GFXStatus.UNREADY;
                    }
                }, {
                    key: "resize",
                    value: function resize(size) {
                        var oldSize = this._size;
                        if (this._size = size, this._count = this._size / this._stride, this._uniformBuffer && (this._uniformBuffer = new ArrayBuffer(this._size)), 
                        this._bufferView && oldSize !== size) {
                            var oldView = this._bufferView;
                            this._bufferView = new Uint8Array(this._size), this._bufferView.set(oldView), this._gpuBuffer && (this._gpuBuffer.buffer = this._bufferView.buffer);
                        }
                        this._gpuBuffer && (this._uniformBuffer && (this._gpuBuffer.buffer = this._uniformBuffer), 
                        this._gpuBuffer.size = this._size, 0 < this._size && (function WebGLCmdFuncResizeBuffer(device, gpuBuffer) {
                            var gl = device.gl, cache = device.stateCache, glUsage = gpuBuffer.memUsage & GFXMemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
                            gpuBuffer.usage & GFXBufferUsageBit.VERTEX ? (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                            cache.glVAO = null), device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                            gpuBuffer.buffer ? gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.buffer, glUsage) : gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                            gl.bindBuffer(gl.ARRAY_BUFFER, null), device.stateCache.glArrayBuffer = null) : gpuBuffer.usage & GFXBufferUsageBit.INDEX ? (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                            cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                            gpuBuffer.buffer ? gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.buffer, glUsage) : gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), device.stateCache.glElementArrayBuffer = null) : gpuBuffer.usage & GFXBufferUsageBit.UNIFORM ? gpuBuffer.buffer && (gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer)) : (gpuBuffer.usage & GFXBufferUsageBit.INDIRECT || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_DST || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_SRC || console.error("Unsupported GFXBufferType, create buffer failed."), 
                            gpuBuffer.glTarget = gl.NONE);
                        }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize -= oldSize, 
                        this._device.memoryStatus.bufferSize += this._size, this._bufferView && (this._device.memoryStatus.bufferSize -= oldSize, 
                        this._device.memoryStatus.bufferSize += this._size)));
                    }
                }, {
                    key: "update",
                    value: function update(buffer, offset, size) {
                        var buffSize;
                        if (buffSize = void 0 !== size ? size : this._usage & GFXBufferUsageBit.INDIRECT ? 0 : buffer.byteLength, 
                        this._bufferView) {
                            var view = new Uint8Array(buffer, 0, size);
                            this._bufferView.set(view, offset);
                        }
                        WebGLCmdFuncUpdateBuffer(this._device, this._gpuBuffer, buffer, offset || 0, buffSize);
                    }
                } ]), WebGLGFXBuffer;
            }(), GFXCommandAllocator = function() {
                function GFXCommandAllocator(device) {
                    var _this;
                    return _classCallCheck(this, GFXCommandAllocator), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXCommandAllocator).call(this, GFXObjectType.COMMAND_ALLOCATOR)))._device = void 0, 
                    _this._device = device, _this;
                }
                return _inherits(GFXCommandAllocator, GFXObject), GFXCommandAllocator;
            }(), WebGLGFXCommandPool = function() {
                function WebGLGFXCommandPool(clazz, count) {
                    _classCallCheck(this, WebGLGFXCommandPool), this._frees = void 0, this._freeIdx = 0, 
                    this._freeCmds = void 0, this._frees = new Array(count), this._freeCmds = new CachedArray(count);
                    for (var i = 0; i < count; ++i) this._frees[i] = new clazz();
                    this._freeIdx = count - 1;
                }
                return _createClass(WebGLGFXCommandPool, [ {
                    key: "alloc",
                    value: function alloc(clazz) {
                        if (this._freeIdx < 0) {
                            var size = 2 * this._frees.length, temp = this._frees;
                            this._frees = new Array(size);
                            for (var increase = size - temp.length, i = 0; i < increase; ++i) this._frees[i] = new clazz();
                            for (var _i = increase, j = 0; _i < size; ++_i, ++j) this._frees[_i] = temp[j];
                            this._freeIdx += increase;
                        }
                        var cmd = this._frees[this._freeIdx];
                        return this._frees[this._freeIdx--] = null, ++cmd.refCount, cmd;
                    }
                }, {
                    key: "free",
                    value: function free(cmd) {
                        0 == --cmd.refCount && this._freeCmds.push(cmd);
                    }
                }, {
                    key: "freeCmds",
                    value: function freeCmds(cmds) {
                        for (var i = 0; i < cmds.length; ++i) 0 == --cmds.array[i].refCount && this._freeCmds.push(cmds.array[i]);
                    }
                }, {
                    key: "release",
                    value: function release() {
                        for (var i = 0; i < this._freeCmds.length; ++i) {
                            var cmd = this._freeCmds.array[i];
                            cmd.clear(), this._frees[++this._freeIdx] = cmd;
                        }
                        this._freeCmds.clear();
                    }
                } ]), WebGLGFXCommandPool;
            }(), WebGLGFXCommandAllocator = function() {
                function WebGLGFXCommandAllocator(device) {
                    var _this;
                    return _classCallCheck(this, WebGLGFXCommandAllocator), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXCommandAllocator).call(this, device))).beginRenderPassCmdPool = void 0, 
                    _this.bindStatesCmdPool = void 0, _this.drawCmdPool = void 0, _this.updateBufferCmdPool = void 0, 
                    _this.copyBufferToTextureCmdPool = void 0, _this.beginRenderPassCmdPool = new WebGLGFXCommandPool(WebGLCmdBeginRenderPass, 1), 
                    _this.bindStatesCmdPool = new WebGLGFXCommandPool(WebGLCmdBindStates, 1), _this.drawCmdPool = new WebGLGFXCommandPool(WebGLCmdDraw, 1), 
                    _this.updateBufferCmdPool = new WebGLGFXCommandPool(WebGLCmdUpdateBuffer, 1), _this.copyBufferToTextureCmdPool = new WebGLGFXCommandPool(WebGLCmdCopyBufferToTexture, 1), 
                    _this;
                }
                return _inherits(WebGLGFXCommandAllocator, GFXCommandAllocator), _createClass(WebGLGFXCommandAllocator, [ {
                    key: "initialize",
                    value: function initialize() {
                        return this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._status = GFXStatus.UNREADY;
                    }
                }, {
                    key: "clearCmds",
                    value: function clearCmds(cmdPackage) {
                        cmdPackage.beginRenderPassCmds.length && (this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds), 
                        cmdPackage.beginRenderPassCmds.clear()), cmdPackage.bindStatesCmds.length && (this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds), 
                        cmdPackage.bindStatesCmds.clear()), cmdPackage.drawCmds.length && (this.drawCmdPool.freeCmds(cmdPackage.drawCmds), 
                        cmdPackage.drawCmds.clear()), cmdPackage.updateBufferCmds.length && (this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds), 
                        cmdPackage.updateBufferCmds.clear()), cmdPackage.copyBufferToTextureCmds.length && (this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds), 
                        cmdPackage.copyBufferToTextureCmds.clear()), cmdPackage.cmds.clear();
                    }
                }, {
                    key: "releaseCmds",
                    value: function releaseCmds() {
                        this.beginRenderPassCmdPool.release(), this.bindStatesCmdPool.release(), this.drawCmdPool.release(), 
                        this.updateBufferCmdPool.release(), this.copyBufferToTextureCmdPool.release();
                    }
                } ]), WebGLGFXCommandAllocator;
            }(), WebGLGFXCommandBuffer = function() {
                function WebGLGFXCommandBuffer(device) {
                    var _this;
                    return _classCallCheck(this, WebGLGFXCommandBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXCommandBuffer).call(this, device))).cmdPackage = new WebGLCmdPackage(), 
                    _this._webGLAllocator = null, _this._isInRenderPass = !1, _this._curGPUPipelineState = null, 
                    _this._curGPUBindingLayout = null, _this._curGPUInputAssembler = null, _this._curViewport = null, 
                    _this._curScissor = null, _this._curLineWidth = null, _this._curDepthBias = null, 
                    _this._curBlendConstants = [], _this._curDepthBounds = null, _this._curStencilWriteMask = null, 
                    _this._curStencilCompareMask = null, _this._isStateInvalied = !1, _this;
                }
                return _inherits(WebGLGFXCommandBuffer, GFXCommandBuffer), _createClass(WebGLGFXCommandBuffer, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return !!info.allocator && (this._allocator = info.allocator, this._webGLAllocator = this._allocator, 
                        this._type = info.type, this._status = GFXStatus.SUCCESS, !0);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._webGLAllocator && (this._webGLAllocator.clearCmds(this.cmdPackage), this._allocator = null, 
                        this._webGLAllocator = null), this._status = GFXStatus.UNREADY;
                    }
                }, {
                    key: "begin",
                    value: function begin() {
                        this._webGLAllocator.clearCmds(this.cmdPackage), this._curGPUPipelineState = null, 
                        this._curGPUBindingLayout = null, this._curGPUInputAssembler = null, this._curViewport = null, 
                        this._curScissor = null, this._curLineWidth = null, this._curDepthBias = null, this._curBlendConstants = [], 
                        this._curDepthBounds = null, this._curStencilWriteMask = null, this._curStencilCompareMask = null, 
                        this._numDrawCalls = 0, this._numTris = 0;
                    }
                }, {
                    key: "end",
                    value: function end() {
                        this._isStateInvalied && this.bindStates(), this._isInRenderPass = !1;
                    }
                }, {
                    key: "beginRenderPass",
                    value: function beginRenderPass(framebuffer, renderArea, clearFlag, clearColors, clearDepth, clearStencil) {
                        var cmd = this._webGLAllocator.beginRenderPassCmdPool.alloc(WebGLCmdBeginRenderPass);
                        cmd.gpuFramebuffer = framebuffer.gpuFramebuffer, cmd.renderArea = renderArea, cmd.clearFlag = clearFlag, 
                        cmd.clearColors.length = clearColors.length;
                        for (var i = 0; i < clearColors.length; ++i) cmd.clearColors[i] = clearColors[i];
                        cmd.clearDepth = clearDepth, cmd.clearStencil = clearStencil, this.cmdPackage.beginRenderPassCmds.push(cmd), 
                        this.cmdPackage.cmds.push(WebGLCmd.BEGIN_RENDER_PASS), this._isInRenderPass = !0;
                    }
                }, {
                    key: "endRenderPass",
                    value: function endRenderPass() {
                        this._isInRenderPass = !1;
                    }
                }, {
                    key: "bindPipelineState",
                    value: function bindPipelineState(pipelineState) {
                        var gpuPipelineState = pipelineState.gpuPipelineState;
                        this._curGPUPipelineState = gpuPipelineState, this._isStateInvalied = !0;
                    }
                }, {
                    key: "bindBindingLayout",
                    value: function bindBindingLayout(bindingLayout) {
                        var gpuBindingLayout = bindingLayout.gpuBindingLayout;
                        this._curGPUBindingLayout = gpuBindingLayout, this._isStateInvalied = !0;
                    }
                }, {
                    key: "bindInputAssembler",
                    value: function bindInputAssembler(inputAssembler) {
                        var gpuInputAssembler = inputAssembler.gpuInputAssembler;
                        this._curGPUInputAssembler = gpuInputAssembler, this._isStateInvalied = !0;
                    }
                }, {
                    key: "setViewport",
                    value: function setViewport(viewport) {
                        this._curViewport ? this._curViewport.left === viewport.left && this._curViewport.top === viewport.top && this._curViewport.width === viewport.width && this._curViewport.height === viewport.height && this._curViewport.minDepth === viewport.minDepth && this._curViewport.maxDepth === viewport.maxDepth || (this._curViewport.left = viewport.left, 
                        this._curViewport.top = viewport.top, this._curViewport.width = viewport.width, 
                        this._curViewport.height = viewport.height, this._curViewport.minDepth = viewport.minDepth, 
                        this._curViewport.maxDepth = viewport.maxDepth, this._isStateInvalied = !0) : this._curViewport = {
                            left: viewport.left,
                            top: viewport.top,
                            width: viewport.width,
                            height: viewport.height,
                            minDepth: viewport.minDepth,
                            maxDepth: viewport.maxDepth
                        }, this._curViewport !== viewport && (this._curViewport = viewport, this._isStateInvalied = !0);
                    }
                }, {
                    key: "setScissor",
                    value: function setScissor(scissor) {
                        this._curScissor ? this._curScissor.x === scissor.x && this._curScissor.y === scissor.y && this._curScissor.width === scissor.width && this._curScissor.height === scissor.height || (this._curScissor.x = scissor.x, 
                        this._curScissor.y = scissor.y, this._curScissor.width = scissor.width, this._curScissor.height = scissor.height, 
                        this._isStateInvalied = !0) : this._curScissor = {
                            x: scissor.x,
                            y: scissor.y,
                            width: scissor.width,
                            height: scissor.height
                        };
                    }
                }, {
                    key: "setLineWidth",
                    value: function setLineWidth(lineWidth) {
                        this._curLineWidth !== lineWidth && (this._curLineWidth = lineWidth, this._isStateInvalied = !0);
                    }
                }, {
                    key: "setDepthBias",
                    value: function setDepthBias(depthBiasConstantFacotr, depthBiasClamp, depthBiasSlopeFactor) {
                        this._curDepthBias ? this._curDepthBias.constantFactor === depthBiasConstantFacotr && this._curDepthBias.clamp === depthBiasClamp && this._curDepthBias.slopeFactor === depthBiasSlopeFactor || (this._curDepthBias.constantFactor = depthBiasConstantFacotr, 
                        this._curDepthBias.clamp = depthBiasClamp, this._curDepthBias.slopeFactor = depthBiasSlopeFactor, 
                        this._isStateInvalied = !0) : (this._curDepthBias = {
                            constantFactor: depthBiasConstantFacotr,
                            clamp: depthBiasClamp,
                            slopeFactor: depthBiasSlopeFactor
                        }, this._isStateInvalied = !0);
                    }
                }, {
                    key: "setBlendConstants",
                    value: function setBlendConstants(blendConstants) {
                        (this._curBlendConstants || 4 !== blendConstants.length) && (4 !== blendConstants.length || this._curBlendConstants[0] === blendConstants[0] && this._curBlendConstants[1] === blendConstants[1] && this._curBlendConstants[2] === blendConstants[2] && this._curBlendConstants[3] === blendConstants[3]) || (this._curBlendConstants = [ blendConstants[0], blendConstants[1], blendConstants[2], blendConstants[3] ], 
                        this._isStateInvalied = !0);
                    }
                }, {
                    key: "setDepthBound",
                    value: function setDepthBound(minDepthBounds, maxDepthBounds) {
                        this._curDepthBounds && this._curDepthBounds.minBounds === minDepthBounds && this._curDepthBounds.maxBounds === maxDepthBounds || (this._curDepthBounds = {
                            minBounds: minDepthBounds,
                            maxBounds: maxDepthBounds
                        }, this._isStateInvalied = !0);
                    }
                }, {
                    key: "setStencilWriteMask",
                    value: function setStencilWriteMask(face, writeMask) {
                        this._curStencilWriteMask ? this._curStencilWriteMask.face === face && this._curStencilWriteMask.writeMask === writeMask || (this._curStencilWriteMask.face = face, 
                        this._curStencilWriteMask.writeMask = writeMask, this._isStateInvalied = !0) : (this._curStencilWriteMask = {
                            face: face,
                            writeMask: writeMask
                        }, this._isStateInvalied = !0);
                    }
                }, {
                    key: "setStencilCompareMask",
                    value: function setStencilCompareMask(face, reference, compareMask) {
                        this._curStencilCompareMask ? this._curStencilCompareMask.face === face && this._curStencilCompareMask.reference === reference && this._curStencilCompareMask.compareMask === compareMask || (this._curStencilCompareMask.face = face, 
                        this._curStencilCompareMask.reference = reference, this._curStencilCompareMask.compareMask = compareMask, 
                        this._isStateInvalied = !0) : (this._curStencilCompareMask = {
                            face: face,
                            reference: reference,
                            compareMask: compareMask
                        }, this._isStateInvalied = !0);
                    }
                }, {
                    key: "draw",
                    value: function draw(inputAssembler) {
                        if (this._type === GFXCommandBufferType.PRIMARY && this._isInRenderPass || this._type === GFXCommandBufferType.SECONDARY) {
                            this._isStateInvalied && this.bindStates();
                            var cmd = this._allocator.drawCmdPool.alloc(WebGLCmdDraw);
                            if (inputAssembler.extractCmdDraw(cmd), this.cmdPackage.drawCmds.push(cmd), this.cmdPackage.cmds.push(WebGLCmd.DRAW), 
                            ++this._numDrawCalls, this._curGPUPipelineState) switch (this._curGPUPipelineState.glPrimitive) {
                              case 4:
                                this._numTris += inputAssembler.indexCount / 3 * Math.max(inputAssembler.instanceCount, 1);
                                break;

                              case 5:
                              case 6:
                                this._numTris += (inputAssembler.indexCount - 2) * Math.max(inputAssembler.instanceCount, 1);
                            }
                        } else console.error("Command 'draw' must be recorded inside a render pass.");
                    }
                }, {
                    key: "updateBuffer",
                    value: function updateBuffer(buffer, data, offset, size) {
                        if (this._type === GFXCommandBufferType.PRIMARY && !this._isInRenderPass || this._type === GFXCommandBufferType.SECONDARY) {
                            var gpuBuffer = buffer.gpuBuffer;
                            if (gpuBuffer) {
                                var cmd = this._webGLAllocator.updateBufferCmdPool.alloc(WebGLCmdUpdateBuffer);
                                if (cmd) {
                                    var buffSize;
                                    buffSize = void 0 !== size ? size : buffer.usage & GFXBufferUsageBit.INDIRECT ? 0 : data.byteLength;
                                    var buff = data;
                                    cmd.gpuBuffer = gpuBuffer, cmd.buffer = buff, cmd.offset = void 0 !== offset ? offset : 0, 
                                    cmd.size = buffSize, this.cmdPackage.updateBufferCmds.push(cmd), this.cmdPackage.cmds.push(WebGLCmd.UPDATE_BUFFER);
                                }
                            }
                        } else console.error("Command 'updateBuffer' must be recorded outside a render pass.");
                    }
                }, {
                    key: "copyBufferToTexture",
                    value: function copyBufferToTexture(srcBuff, dstTex, dstLayout, regions) {
                        if (this._type === GFXCommandBufferType.PRIMARY && !this._isInRenderPass || this._type === GFXCommandBufferType.SECONDARY) {
                            var gpuBuffer = srcBuff.gpuBuffer, gpuTexture = dstTex.gpuTexture;
                            if (gpuBuffer && gpuTexture) {
                                var cmd = this._webGLAllocator.copyBufferToTextureCmdPool.alloc(WebGLCmdCopyBufferToTexture);
                                cmd && (cmd.gpuBuffer = gpuBuffer, cmd.gpuTexture = gpuTexture, cmd.dstLayout = dstLayout, 
                                cmd.regions = regions, this.cmdPackage.copyBufferToTextureCmds.push(cmd), this.cmdPackage.cmds.push(WebGLCmd.COPY_BUFFER_TO_TEXTURE));
                            }
                        } else console.error("Command 'copyBufferToTexture' must be recorded outside a render pass.");
                    }
                }, {
                    key: "execute",
                    value: function execute(cmdBuffs, count) {
                        for (var i = 0; i < count; ++i) {
                            for (var webGLCmdBuff = cmdBuffs[i], c = 0; c < webGLCmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
                                var cmd = webGLCmdBuff.cmdPackage.beginRenderPassCmds.array[c];
                                ++cmd.refCount, this.cmdPackage.beginRenderPassCmds.push(cmd);
                            }
                            for (var _c = 0; _c < webGLCmdBuff.cmdPackage.bindStatesCmds.length; ++_c) {
                                var _cmd = webGLCmdBuff.cmdPackage.bindStatesCmds.array[_c];
                                ++_cmd.refCount, this.cmdPackage.bindStatesCmds.push(_cmd);
                            }
                            for (var _c2 = 0; _c2 < webGLCmdBuff.cmdPackage.drawCmds.length; ++_c2) {
                                var _cmd2 = webGLCmdBuff.cmdPackage.drawCmds.array[_c2];
                                ++_cmd2.refCount, this.cmdPackage.drawCmds.push(_cmd2);
                            }
                            for (var _c3 = 0; _c3 < webGLCmdBuff.cmdPackage.updateBufferCmds.length; ++_c3) {
                                var _cmd3 = webGLCmdBuff.cmdPackage.updateBufferCmds.array[_c3];
                                ++_cmd3.refCount, this.cmdPackage.updateBufferCmds.push(_cmd3);
                            }
                            for (var _c4 = 0; _c4 < webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++_c4) {
                                var _cmd4 = webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.array[_c4];
                                ++_cmd4.refCount, this.cmdPackage.copyBufferToTextureCmds.push(_cmd4);
                            }
                            this.cmdPackage.cmds.concat(webGLCmdBuff.cmdPackage.cmds), this._numDrawCalls += webGLCmdBuff._numDrawCalls, 
                            this._numTris += webGLCmdBuff._numTris;
                        }
                    }
                }, {
                    key: "bindStates",
                    value: function bindStates() {
                        var bindStatesCmd = this._webGLAllocator.bindStatesCmdPool.alloc(WebGLCmdBindStates);
                        bindStatesCmd && (bindStatesCmd.gpuPipelineState = this._curGPUPipelineState, bindStatesCmd.gpuBindingLayout = this._curGPUBindingLayout, 
                        bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler, bindStatesCmd.viewport = this._curViewport, 
                        bindStatesCmd.scissor = this._curScissor, bindStatesCmd.lineWidth = this._curLineWidth, 
                        bindStatesCmd.depthBias = this._curDepthBias, bindStatesCmd.blendConstants = this._curBlendConstants, 
                        bindStatesCmd.depthBounds = this._curDepthBounds, bindStatesCmd.stencilWriteMask = this._curStencilWriteMask, 
                        bindStatesCmd.stencilCompareMask = this._curStencilCompareMask, this.cmdPackage.bindStatesCmds.push(bindStatesCmd), 
                        this.cmdPackage.cmds.push(WebGLCmd.BIND_STATES), this._isStateInvalied = !1);
                    }
                }, {
                    key: "webGLDevice",
                    get: function get() {
                        return this._device;
                    }
                } ]), WebGLGFXCommandBuffer;
            }(), WebGLGFXFramebuffer = function() {
                function WebGLGFXFramebuffer(device) {
                    var _this;
                    return _classCallCheck(this, WebGLGFXFramebuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXFramebuffer).call(this, device)))._gpuFramebuffer = null, 
                    _this;
                }
                return _inherits(WebGLGFXFramebuffer, GFXFramebuffer), _createClass(WebGLGFXFramebuffer, [ {
                    key: "gpuFramebuffer",
                    get: function get() {
                        return this._gpuFramebuffer;
                    }
                } ]), _createClass(WebGLGFXFramebuffer, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        if (this._renderPass = info.renderPass, this._colorViews = info.colorViews || [], 
                        this._depthStencilView = info.depthStencilView || null, this._isOffscreen = void 0 === info.isOffscreen || info.isOffscreen, 
                        this._isOffscreen) {
                            var gpuColorViews = [];
                            if (void 0 !== info.colorViews) {
                                var _iterator = info.colorViews, _isArray = Array.isArray(_iterator), _i = 0;
                                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                    var _ref;
                                    if (_isArray) {
                                        if (_i >= _iterator.length) break;
                                        _ref = _iterator[_i++];
                                    } else {
                                        if ((_i = _iterator.next()).done) break;
                                        _ref = _i.value;
                                    }
                                    var colorView = _ref;
                                    gpuColorViews.push(colorView.gpuTextureView);
                                }
                            }
                            var gpuDepthStencilView = null;
                            info.depthStencilView && (gpuDepthStencilView = info.depthStencilView.gpuTextureView), 
                            this._gpuFramebuffer = {
                                gpuRenderPass: info.renderPass.gpuRenderPass,
                                gpuColorViews: gpuColorViews,
                                gpuDepthStencilView: gpuDepthStencilView,
                                isOffscreen: this._isOffscreen,
                                glFramebuffer: null
                            }, function WebGLCmdFuncCreateFramebuffer(device, gpuFramebuffer) {
                                if (gpuFramebuffer.isOffscreen) {
                                    var gl = device.gl, attachments = [], glFramebuffer = gl.createFramebuffer();
                                    if (glFramebuffer) {
                                        gpuFramebuffer.glFramebuffer = glFramebuffer, device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer), 
                                        device.stateCache.glFramebuffer = gpuFramebuffer.glFramebuffer);
                                        for (var i = 0; i < gpuFramebuffer.gpuColorViews.length; ++i) {
                                            var cv = gpuFramebuffer.gpuColorViews[i];
                                            cv && (cv.gpuTexture.glTexture ? gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, cv.gpuTexture.glTarget, cv.gpuTexture.glTexture, cv.baseLevel) : gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, cv.gpuTexture.glRenderbuffer), 
                                            attachments.push(gl.COLOR_ATTACHMENT0 + i));
                                        }
                                        var dsv = gpuFramebuffer.gpuDepthStencilView;
                                        if (dsv) {
                                            var glAttachment = GFXFormatInfos[dsv.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
                                            dsv.gpuTexture.glTexture ? gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dsv.gpuTexture.glTarget, dsv.gpuTexture.glTexture, dsv.baseLevel) : gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dsv.gpuTexture.glRenderbuffer);
                                        }
                                        device.WEBGL_draw_buffers && device.WEBGL_draw_buffers.drawBuffersWEBGL(attachments);
                                        var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                                        if (status !== gl.FRAMEBUFFER_COMPLETE) switch (status) {
                                          case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                                            console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                                            break;

                                          case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                                            console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                                            break;

                                          case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                                            console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                                            break;

                                          case gl.FRAMEBUFFER_UNSUPPORTED:
                                            console.error("glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED");
                                        }
                                    }
                                }
                            }(this._device, this._gpuFramebuffer);
                        } else this._gpuFramebuffer = {
                            gpuRenderPass: info.renderPass.gpuRenderPass,
                            gpuColorViews: [],
                            gpuDepthStencilView: null,
                            isOffscreen: !1,
                            glFramebuffer: null
                        };
                        return this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._isOffscreen && this._gpuFramebuffer && !function WebGLCmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
                            gpuFramebuffer.glFramebuffer && (device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer), 
                            gpuFramebuffer.glFramebuffer = null);
                        }(this._device, this._gpuFramebuffer), this._gpuFramebuffer = null, this._status = GFXStatus.UNREADY;
                    }
                } ]), WebGLGFXFramebuffer;
            }(), WebGLGFXInputAssembler = function() {
                function WebGLGFXInputAssembler(device) {
                    var _this;
                    return _classCallCheck(this, WebGLGFXInputAssembler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXInputAssembler).call(this, device)))._gpuInputAssembler = null, 
                    _this;
                }
                return _inherits(WebGLGFXInputAssembler, GFXInputAssembler), _createClass(WebGLGFXInputAssembler, [ {
                    key: "gpuInputAssembler",
                    get: function get() {
                        return this._gpuInputAssembler;
                    }
                } ]), _createClass(WebGLGFXInputAssembler, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        if (0 === info.vertexBuffers.length) return console.error("GFXInputAssemblerInfo.vertexBuffers is null."), 
                        !1;
                        if (this._attributes = info.attributes, this._vertexBuffers = info.vertexBuffers, 
                        void 0 !== info.indexBuffer) this._indexBuffer = info.indexBuffer, this._indexCount = this._indexBuffer.size / this._indexBuffer.stride; else {
                            var vertBuff = this._vertexBuffers[0];
                            this._vertexCount = vertBuff.size / vertBuff.stride;
                        }
                        this._indirectBuffer = info.indirectBuffer || null;
                        for (var gpuVertexBuffers = new Array(info.vertexBuffers.length), i = 0; i < info.vertexBuffers.length; ++i) {
                            var vb = info.vertexBuffers[i];
                            vb.gpuBuffer && (gpuVertexBuffers[i] = vb.gpuBuffer);
                        }
                        var gpuIndexBuffer = null, glIndexType = 0;
                        if (info.indexBuffer && (gpuIndexBuffer = info.indexBuffer.gpuBuffer)) switch (gpuIndexBuffer.stride) {
                          case 1:
                            glIndexType = 5121;
                            break;

                          case 2:
                            glIndexType = 5123;
                            break;

                          case 4:
                            glIndexType = 5125;
                            break;

                          default:
                            console.error("Error index buffer stride.");
                        }
                        var gpuIndirectBuffer = null;
                        return void 0 !== info.indirectBuffer && (gpuIndirectBuffer = info.indirectBuffer.gpuBuffer), 
                        this._gpuInputAssembler = {
                            attributes: info.attributes,
                            gpuVertexBuffers: gpuVertexBuffers,
                            gpuIndexBuffer: gpuIndexBuffer,
                            gpuIndirectBuffer: gpuIndirectBuffer,
                            glAttribs: [],
                            glIndexType: glIndexType,
                            glVAOs: new Map()
                        }, function WebGLCmdFuncCreateInputAssember(device, gpuInputAssembler) {
                            var gl = device.gl;
                            gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
                            for (var offsets = [ 0, 0, 0, 0, 0, 0, 0, 0 ], i = 0; i < gpuInputAssembler.attributes.length; ++i) {
                                var attrib = gpuInputAssembler.attributes[i], stream = void 0 !== attrib.stream ? attrib.stream : 0, gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream], glType = GFXFormatToWebGLType(attrib.format, gl), size = GFXFormatInfos[attrib.format].size;
                                gpuInputAssembler.glAttribs[i] = {
                                    name: attrib.name,
                                    glBuffer: gpuBuffer.glBuffer,
                                    glType: glType,
                                    size: size,
                                    count: GFXFormatInfos[attrib.format].count,
                                    stride: gpuBuffer.stride,
                                    componentCount: WebGLGetComponentCount(glType, gl),
                                    isNormalized: void 0 !== attrib.isNormalized && attrib.isNormalized,
                                    isInstanced: void 0 !== attrib.isInstanced && attrib.isInstanced,
                                    offset: offsets[stream]
                                }, offsets[stream] += size;
                            }
                        }(this._device, this._gpuInputAssembler), this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        var webglDev = this._device;
                        this._gpuInputAssembler && webglDev.useVAO && !function WebGLCmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
                            var _iterator9 = gpuInputAssembler.glVAOs, _isArray9 = Array.isArray(_iterator9), _i18 = 0;
                            for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                                var _ref9;
                                if (_isArray9) {
                                    if (_i18 >= _iterator9.length) break;
                                    _ref9 = _iterator9[_i18++];
                                } else {
                                    if ((_i18 = _iterator9.next()).done) break;
                                    _ref9 = _i18.value;
                                }
                                var vao = _ref9;
                                device.OES_vertex_array_object.deleteVertexArrayOES(vao[1]);
                            }
                            gpuInputAssembler.glVAOs.clear();
                        }(webglDev, this._gpuInputAssembler), this._gpuInputAssembler = null, this._status = GFXStatus.UNREADY;
                    }
                }, {
                    key: "extractCmdDraw",
                    value: function extractCmdDraw(cmd) {
                        cmd.drawInfo.vertexCount = this._vertexCount, cmd.drawInfo.firstVertex = this._firstVertex, 
                        cmd.drawInfo.indexCount = this._indexCount, cmd.drawInfo.firstIndex = this._firstIndex, 
                        cmd.drawInfo.vertexOffset = this._vertexOffset, cmd.drawInfo.instanceCount = this._instanceCount, 
                        cmd.drawInfo.firstInstance = this._firstInstance;
                    }
                } ]), WebGLGFXInputAssembler;
            }(), WebGLGFXPipelineLayout = function() {
                function WebGLGFXPipelineLayout(device) {
                    var _this;
                    return _classCallCheck(this, WebGLGFXPipelineLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXPipelineLayout).call(this, device)))._gpuPipelineLayout = null, 
                    _this;
                }
                return _inherits(WebGLGFXPipelineLayout, GFXPipelineLayout), _createClass(WebGLGFXPipelineLayout, [ {
                    key: "gpuPipelineLayout",
                    get: function get() {
                        return this._gpuPipelineLayout;
                    }
                } ]), _createClass(WebGLGFXPipelineLayout, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return this._layouts = info.layouts, this._pushConstantsRanges = info.pushConstantsRanges || [], 
                        this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._status = GFXStatus.UNREADY;
                    }
                } ]), WebGLGFXPipelineLayout;
            }(), WebGLPrimitives = [ 0, 1, 3, 2, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0 ], WebGLGFXPipelineState = function() {
                function WebGLGFXPipelineState(device) {
                    var _this;
                    return _classCallCheck(this, WebGLGFXPipelineState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXPipelineState).call(this, device)))._gpuPipelineState = null, 
                    _this;
                }
                return _inherits(WebGLGFXPipelineState, GFXPipelineState), _createClass(WebGLGFXPipelineState, [ {
                    key: "gpuPipelineState",
                    get: function get() {
                        return this._gpuPipelineState;
                    }
                } ]), _createClass(WebGLGFXPipelineState, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return this._primitive = info.primitive, this._shader = info.shader, this._is = info.is, 
                        this._rs = info.rs, this._dss = info.dss, this._bs = info.bs, this._dynamicStates = info.dynamicStates || [], 
                        this._layout = info.layout, this._renderPass = info.renderPass, this._gpuPipelineState = {
                            glPrimitive: WebGLPrimitives[info.primitive],
                            gpuShader: info.shader.gpuShader,
                            rs: info.rs,
                            dss: info.dss,
                            bs: info.bs,
                            dynamicStates: void 0 !== info.dynamicStates ? info.dynamicStates : [],
                            gpuLayout: info.layout.gpuPipelineLayout,
                            gpuRenderPass: info.renderPass.gpuRenderPass
                        }, this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._gpuPipelineState = null, this._status = GFXStatus.UNREADY;
                    }
                } ]), WebGLGFXPipelineState;
            }(), WebGLGFXQueue = function() {
                function WebGLGFXQueue(device) {
                    var _this;
                    return _classCallCheck(this, WebGLGFXQueue), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXQueue).call(this, device))).numDrawCalls = 0, 
                    _this.numTris = 0, _this._isAsync = !1, _this;
                }
                return _inherits(WebGLGFXQueue, GFXQueue), _createClass(WebGLGFXQueue, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return this._type = info.type, this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._status = GFXStatus.UNREADY;
                    }
                }, {
                    key: "submit",
                    value: function submit(cmdBuffs) {
                        if (!this._isAsync) for (var len = cmdBuffs.length, i = 0; i < len; i++) {
                            var cmdBuff = cmdBuffs[i];
                            WebGLCmdFuncExecuteCmds(this._device, cmdBuff.cmdPackage), this.numDrawCalls += cmdBuff.numDrawCalls, 
                            this.numTris += cmdBuff.numTris;
                        }
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        this.numDrawCalls = 0, this.numTris = 0;
                    }
                } ]), WebGLGFXQueue;
            }(), WebGLGFXRenderPass = function() {
                function WebGLGFXRenderPass(device) {
                    var _this;
                    return _classCallCheck(this, WebGLGFXRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXRenderPass).call(this, device)))._gpuRenderPass = null, 
                    _this;
                }
                return _inherits(WebGLGFXRenderPass, GFXRenderPass), _createClass(WebGLGFXRenderPass, [ {
                    key: "gpuRenderPass",
                    get: function get() {
                        return this._gpuRenderPass;
                    }
                } ]), _createClass(WebGLGFXRenderPass, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return this._colorInfos = info.colorAttachments || [], this._depthStencilInfo = info.depthStencilAttachment || null, 
                        this._gpuRenderPass = {
                            colorAttachments: this._colorInfos,
                            depthStencilAttachment: this._depthStencilInfo
                        }, this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._gpuRenderPass = null, this._status = GFXStatus.UNREADY;
                    }
                } ]), WebGLGFXRenderPass;
            }(), WebGLWraps = [ 10497, 33648, 33071, 33071 ], WebGLGFXSampler = function() {
                function WebGLGFXSampler(device) {
                    var _this;
                    return _classCallCheck(this, WebGLGFXSampler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXSampler).call(this, device)))._gpuSampler = null, 
                    _this._state = new GFXSamplerState(), _this;
                }
                return _inherits(WebGLGFXSampler, GFXSampler), _createClass(WebGLGFXSampler, [ {
                    key: "gpuSampler",
                    get: function get() {
                        return this._gpuSampler;
                    }
                } ]), _createClass(WebGLGFXSampler, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        void 0 !== info.name && (this._state.name = info.name), void 0 !== info.minFilter && (this._state.minFilter = info.minFilter), 
                        void 0 !== info.magFilter && (this._state.magFilter = info.magFilter), void 0 !== info.mipFilter && (this._state.mipFilter = info.mipFilter), 
                        void 0 !== info.addressU && (this._state.addressU = info.addressU), void 0 !== info.addressV && (this._state.addressV = info.addressV), 
                        void 0 !== info.addressW && (this._state.addressW = info.addressW), void 0 !== info.maxAnisotropy && (this._state.maxAnisotropy = info.maxAnisotropy), 
                        void 0 !== info.cmpFunc && (this._state.cmpFunc = info.cmpFunc), void 0 !== info.borderColor && (this._state.borderColor = info.borderColor), 
                        void 0 !== info.minLOD && (this._state.minLOD = info.minLOD), void 0 !== info.maxLOD && (this._state.maxLOD = info.maxLOD), 
                        void 0 !== info.mipLODBias && (this._state.mipLODBias = info.mipLODBias);
                        var glMinFilter = 0, glMagFilter = 0, minFilter = this._state.minFilter, magFilter = this._state.magFilter, mipFilter = this._state.mipFilter;
                        glMinFilter = minFilter === GFXFilter.LINEAR || minFilter === GFXFilter.ANISOTROPIC ? mipFilter === GFXFilter.LINEAR || mipFilter === GFXFilter.ANISOTROPIC ? 9987 : mipFilter === GFXFilter.POINT ? 9985 : 9729 : mipFilter === GFXFilter.LINEAR || mipFilter === GFXFilter.ANISOTROPIC ? 9986 : mipFilter === GFXFilter.POINT ? 9984 : 9728, 
                        glMagFilter = magFilter === GFXFilter.LINEAR || magFilter === GFXFilter.ANISOTROPIC ? 9729 : 9728;
                        var glWrapS = WebGLWraps[this._state.addressU], glWrapT = WebGLWraps[this._state.addressV], glWrapR = WebGLWraps[this._state.addressW];
                        return this._gpuSampler = {
                            glMinFilter: glMinFilter,
                            glMagFilter: glMagFilter,
                            glWrapS: glWrapS,
                            glWrapT: glWrapT,
                            glWrapR: glWrapR
                        }, this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._gpuSampler = null, this._status = GFXStatus.UNREADY;
                    }
                } ]), WebGLGFXSampler;
            }(), WebGLGFXShader = function() {
                function WebGLGFXShader(device) {
                    var _this;
                    return _classCallCheck(this, WebGLGFXShader), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXShader).call(this, device)))._gpuShader = null, 
                    _this;
                }
                return _inherits(WebGLGFXShader, GFXShader), _createClass(WebGLGFXShader, [ {
                    key: "gpuShader",
                    get: function get() {
                        return this._gpuShader;
                    }
                } ]), _createClass(WebGLGFXShader, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        this._name = info.name, this._stages = info.stages, void 0 !== info.blocks && (this._blocks = info.blocks), 
                        void 0 !== info.samplers && (this._samplers = info.samplers), this._gpuShader = {
                            name: info.name ? info.name : "",
                            blocks: void 0 !== info.blocks ? info.blocks : [],
                            samplers: void 0 !== info.samplers ? info.samplers : [],
                            gpuStages: new Array(info.stages.length),
                            glProgram: null,
                            glInputs: [],
                            glUniforms: [],
                            glBlocks: [],
                            glSamplers: []
                        };
                        for (var i = 0; i < info.stages.length; ++i) {
                            var stage = info.stages[i];
                            this._gpuShader.gpuStages[i] = {
                                type: stage.type,
                                source: stage.source,
                                macros: stage.macros ? stage.macros : [],
                                glShader: null
                            };
                        }
                        return function WebGLCmdFuncCreateShader(device, gpuShader) {
                            function _loop2() {
                                if (_isArray) {
                                    if (_i7 >= _iterator.length) return "break";
                                    _ref = _iterator[_i7++];
                                } else {
                                    if ((_i7 = _iterator.next()).done) return "break";
                                    _ref = _i7.value;
                                }
                                var gpuStage = _ref, glShaderType = 0, shaderTypeStr = "", lineNumber = 1;
                                switch (gpuStage.type) {
                                  case GFXShaderType.VERTEX:
                                    shaderTypeStr = "VertexShader", glShaderType = gl.VERTEX_SHADER;
                                    break;

                                  case GFXShaderType.FRAGMENT:
                                    shaderTypeStr = "FragmentShader", glShaderType = gl.FRAGMENT_SHADER;
                                    break;

                                  default:
                                    return console.error("Unsupported GFXShaderType."), {
                                        v: void 0
                                    };
                                }
                                var glShader = gl.createShader(glShaderType);
                                if (glShader && (gpuStage.glShader = glShader, gl.shaderSource(gpuStage.glShader, gpuStage.source), 
                                gl.compileShader(gpuStage.glShader), !gl.getShaderParameter(gpuStage.glShader, gl.COMPILE_STATUS))) return console.error(shaderTypeStr + " in '" + gpuShader.name + "' compilation failed."), 
                                console.error("Shader source dump:", gpuStage.source.replace(/^|\n/g, function() {
                                    return "\n".concat(lineNumber++, " ");
                                })), console.error(gl.getShaderInfoLog(gpuStage.glShader)), gl.deleteShader(gpuStage.glShader), 
                                gpuStage.glShader = null, {
                                    v: void 0
                                };
                            }
                            var gl = device.gl, _iterator = gpuShader.gpuStages, _isArray = Array.isArray(_iterator), _i7 = 0;
                            _loop: for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref, _ret = _loop2();
                                switch (_ret) {
                                  case "break":
                                    break _loop;

                                  default:
                                    if ("object" === _typeof(_ret)) return _ret.v;
                                }
                            }
                            var glProgram = gl.createProgram();
                            if (glProgram) {
                                gpuShader.glProgram = glProgram;
                                var _iterator2 = gpuShader.gpuStages, _isArray2 = Array.isArray(_iterator2), _i8 = 0;
                                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                                    var _ref2;
                                    if (_isArray2) {
                                        if (_i8 >= _iterator2.length) break;
                                        _ref2 = _iterator2[_i8++];
                                    } else {
                                        if ((_i8 = _iterator2.next()).done) break;
                                        _ref2 = _i8.value;
                                    }
                                    var _gpuStage = _ref2;
                                    gl.attachShader(gpuShader.glProgram, _gpuStage.glShader);
                                }
                                if (gl.linkProgram(gpuShader.glProgram), gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) {
                                    console.info("Shader '" + gpuShader.name + "' compilation successed.");
                                    var activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
                                    gpuShader.glInputs = new Array(activeAttribCount);
                                    for (var i = 0; i < activeAttribCount; ++i) {
                                        var attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);
                                        if (attribInfo) {
                                            var varName = void 0, nameOffset = attribInfo.name.indexOf("[");
                                            varName = -1 !== nameOffset ? attribInfo.name.substr(0, nameOffset) : attribInfo.name;
                                            var glLoc = gl.getAttribLocation(gpuShader.glProgram, varName), type = WebGLTypeToGFXType(attribInfo.type, gl), stride = WebGLGetTypeSize(attribInfo.type, gl);
                                            gpuShader.glInputs[i] = {
                                                binding: glLoc,
                                                name: varName,
                                                type: type,
                                                stride: stride,
                                                count: attribInfo.size,
                                                size: stride * attribInfo.size,
                                                glType: attribInfo.type,
                                                glLoc: glLoc
                                            };
                                        }
                                    }
                                    if (0 < gpuShader.blocks.length) {
                                        gpuShader.glBlocks = new Array(gpuShader.blocks.length);
                                        for (var _i10 = 0; _i10 < gpuShader.blocks.length; ++_i10) {
                                            var block = gpuShader.blocks[_i10], glBlock = {
                                                binding: block.binding,
                                                name: block.name,
                                                size: 0,
                                                glUniforms: new Array(block.members.length),
                                                glActiveUniforms: [],
                                                isUniformPackage: !0
                                            };
                                            gpuShader.glBlocks[_i10] = glBlock;
                                            for (var u = 0; u < block.members.length; ++u) {
                                                var uniform = block.members[u], glType = GFXTypeToWebGLType(uniform.type, gl), _stride = WebGLGetTypeSize(glType, gl), size = _stride * uniform.count, begin = glBlock.size / 4, array = new Array(size / 4);
                                                array.fill(0), glBlock.glUniforms[u] = {
                                                    binding: -1,
                                                    name: uniform.name,
                                                    type: uniform.type,
                                                    stride: _stride,
                                                    count: uniform.count,
                                                    size: size,
                                                    offset: glBlock.size,
                                                    glType: glType,
                                                    glLoc: -1,
                                                    array: array,
                                                    begin: begin
                                                }, glBlock.size += size;
                                            }
                                        }
                                    }
                                    if (0 < gpuShader.samplers.length) {
                                        gpuShader.glSamplers = new Array(gpuShader.samplers.length);
                                        for (var _i11 = 0; _i11 < gpuShader.samplers.length; ++_i11) {
                                            var sampler = gpuShader.samplers[_i11];
                                            gpuShader.glSamplers[_i11] = {
                                                binding: sampler.binding,
                                                name: sampler.name,
                                                type: sampler.type,
                                                units: [],
                                                glType: GFXTypeToWebGLType(sampler.type, gl),
                                                glLoc: -1
                                            };
                                        }
                                    }
                                    for (var activeUniformCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORMS), unitIdx = 0, glActiveSamplers = [], _i12 = 0; _i12 < activeUniformCount; ++_i12) {
                                        var uniformInfo = gl.getActiveUniform(gpuShader.glProgram, _i12);
                                        if (uniformInfo) {
                                            var _glLoc = gl.getUniformLocation(gpuShader.glProgram, uniformInfo.name);
                                            if (_glLoc) {
                                                var _varName = void 0, _nameOffset = uniformInfo.name.indexOf("[");
                                                if (_varName = -1 !== _nameOffset ? uniformInfo.name.substr(0, _nameOffset) : uniformInfo.name, 
                                                uniformInfo.type === gl.SAMPLER_2D || uniformInfo.type === gl.SAMPLER_CUBE) {
                                                    var _iterator6 = gpuShader.glSamplers, _isArray6 = Array.isArray(_iterator6), _i15 = 0;
                                                    for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                                                        var _ref6;
                                                        if (_isArray6) {
                                                            if (_i15 >= _iterator6.length) break;
                                                            _ref6 = _iterator6[_i15++];
                                                        } else {
                                                            if ((_i15 = _iterator6.next()).done) break;
                                                            _ref6 = _i15.value;
                                                        }
                                                        var glSampler = _ref6;
                                                        if (glSampler.name === _varName) {
                                                            for (var t = 0; t < uniformInfo.size; ++t) glSampler.units.push(unitIdx + t);
                                                            glSampler.glLoc = _glLoc, unitIdx += uniformInfo.size, glActiveSamplers.push(glSampler);
                                                            break;
                                                        }
                                                    }
                                                } else {
                                                    var _iterator4 = gpuShader.glBlocks, _isArray4 = Array.isArray(_iterator4), _i13 = 0;
                                                    for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                                                        var _ref4;
                                                        if (_isArray4) {
                                                            if (_i13 >= _iterator4.length) break;
                                                            _ref4 = _iterator4[_i13++];
                                                        } else {
                                                            if ((_i13 = _iterator4.next()).done) break;
                                                            _ref4 = _i13.value;
                                                        }
                                                        var _glBlock = _ref4, _iterator5 = _glBlock.glUniforms, _isArray5 = Array.isArray(_iterator5), _i14 = 0;
                                                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                                                            var _ref5;
                                                            if (_isArray5) {
                                                                if (_i14 >= _iterator5.length) break;
                                                                _ref5 = _iterator5[_i14++];
                                                            } else {
                                                                if ((_i14 = _iterator5.next()).done) break;
                                                                _ref5 = _i14.value;
                                                            }
                                                            var glUniform = _ref5;
                                                            if (glUniform.name === _varName) {
                                                                glUniform.glLoc = _glLoc, _glBlock.glActiveUniforms.push(glUniform);
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (glActiveSamplers.length) {
                                        device.stateCache.glProgram !== gpuShader.glProgram && (gl.useProgram(gpuShader.glProgram), 
                                        device.stateCache.glProgram = gpuShader.glProgram);
                                        var _iterator7 = glActiveSamplers, _isArray7 = Array.isArray(_iterator7), _i16 = 0;
                                        for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                                            var _ref7;
                                            if (_isArray7) {
                                                if (_i16 >= _iterator7.length) break;
                                                _ref7 = _iterator7[_i16++];
                                            } else {
                                                if ((_i16 = _iterator7.next()).done) break;
                                                _ref7 = _i16.value;
                                            }
                                            var _glSampler = _ref7;
                                            gl.uniform1iv(_glSampler.glLoc, _glSampler.units);
                                        }
                                    }
                                } else {
                                    console.error("Failed to link shader '" + gpuShader.name + "'."), console.error(gl.getProgramInfoLog(gpuShader.glProgram));
                                    var _iterator3 = gpuShader.gpuStages, _isArray3 = Array.isArray(_iterator3), _i9 = 0;
                                    for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                                        var _ref3;
                                        if (_isArray3) {
                                            if (_i9 >= _iterator3.length) break;
                                            _ref3 = _iterator3[_i9++];
                                        } else {
                                            if ((_i9 = _iterator3.next()).done) break;
                                            _ref3 = _i9.value;
                                        }
                                        var gpuStage = _ref3;
                                        gpuStage.glShader && (gl.deleteShader(gpuStage.glShader), gpuStage.glShader = null);
                                    }
                                }
                            }
                        }(this._device, this._gpuShader), this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._gpuShader && (!function WebGLCmdFuncDestroyShader(device, gpuShader) {
                            var _iterator8 = gpuShader.gpuStages, _isArray8 = Array.isArray(_iterator8), _i17 = 0;
                            for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                                var _ref8;
                                if (_isArray8) {
                                    if (_i17 >= _iterator8.length) break;
                                    _ref8 = _iterator8[_i17++];
                                } else {
                                    if ((_i17 = _iterator8.next()).done) break;
                                    _ref8 = _i17.value;
                                }
                                var gpuStage = _ref8;
                                gpuStage.glShader && (device.gl.deleteShader(gpuStage.glShader), gpuStage.glShader = null);
                            }
                            gpuShader.glProgram && (device.gl.deleteProgram(gpuShader.glProgram), gpuShader.glProgram = null);
                        }(this._device, this._gpuShader), this._gpuShader = null), this._status = GFXStatus.UNREADY;
                    }
                } ]), WebGLGFXShader;
            }();
            function IsPowerOf2(x) {
                return 0 < x && 0 == (x & x - 1);
            }
            var WebGLGFXTexture = function() {
                function WebGLGFXTexture(device) {
                    var _this;
                    return _classCallCheck(this, WebGLGFXTexture), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXTexture).call(this, device)))._gpuTexture = null, 
                    _this;
                }
                return _inherits(WebGLGFXTexture, GFXTexture), _createClass(WebGLGFXTexture, [ {
                    key: "gpuTexture",
                    get: function get() {
                        return this._gpuTexture;
                    }
                } ]), _createClass(WebGLGFXTexture, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        var viewType;
                        switch (this._type = info.type, this._usage = info.usage, this._format = info.format, 
                        this._width = info.width, this._height = info.height, void 0 !== info.depth && (this._depth = info.depth), 
                        void 0 !== info.arrayLayer && (this._arrayLayer = info.arrayLayer), void 0 !== info.mipLevel && (this._mipLevel = info.mipLevel), 
                        void 0 !== info.samples && (this._samples = info.samples), void 0 !== info.flags && (this._flags = info.flags), 
                        this._isPowerOf2 = IsPowerOf2(this._width) && IsPowerOf2(this._height), this._size = GFXFormatSurfaceSize(this._format, this.width, this.height, this.depth, this.mipLevel) * this._arrayLayer, 
                        this._flags & GFXTextureFlagBit.BAKUP_BUFFER && (this._buffer = new ArrayBuffer(this._size)), 
                        info.type) {
                          case GFXTextureType.TEX1D:
                            viewType = info.arrayLayer ? info.arrayLayer <= 1 ? GFXTextureViewType.TV1D : GFXTextureViewType.TV1D_ARRAY : GFXTextureViewType.TV1D;
                            break;

                          case GFXTextureType.TEX2D:
                            var flags = GFXTextureFlagBit.NONE;
                            info.flags && (flags = info.flags), viewType = info.arrayLayer ? info.arrayLayer <= 1 ? GFXTextureViewType.TV2D : flags & GFXTextureFlagBit.CUBEMAP ? GFXTextureViewType.CUBE : GFXTextureViewType.TV2D_ARRAY : GFXTextureViewType.TV2D;
                            break;

                          case GFXTextureType.TEX3D:
                            viewType = GFXTextureViewType.TV3D;
                            break;

                          default:
                            viewType = GFXTextureViewType.TV2D;
                        }
                        return this._gpuTexture = {
                            type: this._type,
                            viewType: viewType,
                            format: this._format,
                            usage: this._usage,
                            width: this._width,
                            height: this._height,
                            depth: this._depth,
                            size: this._size,
                            arrayLayer: this._arrayLayer,
                            mipLevel: this._mipLevel,
                            samples: this._samples,
                            flags: this._flags,
                            isPowerOf2: this._isPowerOf2,
                            glTarget: 0,
                            glInternelFmt: 0,
                            glFormat: 0,
                            glType: 0,
                            glUsage: 0,
                            glTexture: null,
                            glRenderbuffer: null,
                            glWrapS: 0,
                            glWrapT: 0,
                            glMinFilter: 0,
                            glMagFilter: 0
                        }, function WebGLCmdFuncCreateTexture(device, gpuTexture) {
                            var gl = device.gl;
                            gpuTexture.glInternelFmt = GFXFormatToWebGLInternalFormat(gpuTexture.format, gl), 
                            gpuTexture.glFormat = GFXFormatToWebGLFormat(gpuTexture.format, gl), gpuTexture.glType = GFXFormatToWebGLType(gpuTexture.format, gl);
                            var w = gpuTexture.width, h = gpuTexture.height;
                            switch (gpuTexture.viewType) {
                              case GFXTextureViewType.TV2D:
                                gpuTexture.viewType = GFXTextureViewType.TV2D, gpuTexture.glTarget = gl.TEXTURE_2D;
                                var maxSize = Math.max(w, h);
                                if (maxSize > device.maxTextureSize && errorID(9100, maxSize, device.maxTextureSize), 
                                gpuTexture.samples === GFXSampleCount.X1) {
                                    var glTexture = gl.createTexture();
                                    if (glTexture && 0 < gpuTexture.size) {
                                        gpuTexture.glTexture = glTexture;
                                        var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                                        if (glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
                                        glTexUnit.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _i = 0; _i < gpuTexture.mipLevel; ++_i) {
                                            var imgSize = GFXFormatSize(gpuTexture.format, w, h, 1), view = new Uint8Array(imgSize);
                                            gl.compressedTexImage2D(gl.TEXTURE_2D, _i, gpuTexture.glInternelFmt, w, h, 0, view), 
                                            w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                        } else {
                                            var _imgSize = GFXFormatSize(gpuTexture.format, 2, 2, 1), _view = new Uint8Array(_imgSize);
                                            gl.compressedTexImage2D(gl.TEXTURE_2D, 0, gpuTexture.glInternelFmt, 2, 2, 0, _view);
                                        } else for (var i = 0; i < gpuTexture.mipLevel; ++i) gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                                        w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                        gpuTexture.isPowerOf2 ? (gpuTexture.glWrapS = gl.REPEAT, gpuTexture.glWrapT = gl.REPEAT) : (gpuTexture.glWrapS = gl.CLAMP_TO_EDGE, 
                                        gpuTexture.glWrapT = gl.CLAMP_TO_EDGE), gpuTexture.glMinFilter = gl.LINEAR, gpuTexture.glMagFilter = gl.LINEAR, 
                                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT), 
                                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter), 
                                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                                    }
                                }
                                break;

                              case GFXTextureViewType.CUBE:
                                gpuTexture.viewType = GFXTextureViewType.CUBE, gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
                                var _maxSize = Math.max(w, h);
                                _maxSize > device.maxCubeMapTextureSize && errorID(9100, _maxSize, device.maxTextureSize);
                                var _glTexture = gl.createTexture();
                                if (_glTexture && 0 < gpuTexture.size) {
                                    gpuTexture.glTexture = _glTexture;
                                    var _glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                                    if (_glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                                    _glTexUnit.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _f = 0; _f < 6; ++_f) {
                                        w = gpuTexture.width, h = gpuTexture.height;
                                        for (var _i3 = 0; _i3 < gpuTexture.mipLevel; ++_i3) {
                                            var _imgSize2 = GFXFormatSize(gpuTexture.format, w, h, 1), _view2 = new Uint8Array(_imgSize2);
                                            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f, _i3, gpuTexture.glInternelFmt, w, h, 0, _view2), 
                                            w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                        }
                                    } else for (var _f2 = 0; _f2 < 6; ++_f2) {
                                        var _imgSize3 = GFXFormatSize(gpuTexture.format, 2, 2, 1), _view3 = new Uint8Array(_imgSize3);
                                        gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f2, 0, gpuTexture.glInternelFmt, 2, 2, 0, _view3);
                                    } else for (var f = 0; f < 6; ++f) {
                                        w = gpuTexture.width, h = gpuTexture.height;
                                        for (var _i2 = 0; _i2 < gpuTexture.mipLevel; ++_i2) gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i2, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                                        w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                    }
                                    gpuTexture.isPowerOf2 ? (gpuTexture.glWrapS = gl.REPEAT, gpuTexture.glWrapT = gl.REPEAT) : (gpuTexture.glWrapS = gl.CLAMP_TO_EDGE, 
                                    gpuTexture.glWrapT = gl.CLAMP_TO_EDGE), gpuTexture.glMinFilter = gl.LINEAR, gpuTexture.glMagFilter = gl.LINEAR, 
                                    gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT), 
                                    gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter), 
                                    gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                                }
                                break;

                              default:
                                console.error("Unsupported GFXTextureType, create texture failed."), gpuTexture.viewType = GFXTextureViewType.TV2D, 
                                gpuTexture.glTarget = gl.TEXTURE_2D;
                            }
                        }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize += this._size, 
                        this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._gpuTexture && (!function WebGLCmdFuncDestroyTexture(device, gpuTexture) {
                            gpuTexture.glTexture && (device.gl.deleteTexture(gpuTexture.glTexture), gpuTexture.glTexture = null), 
                            gpuTexture.glRenderbuffer && (device.gl.deleteRenderbuffer(gpuTexture.glRenderbuffer), 
                            gpuTexture.glRenderbuffer = null);
                        }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize -= this._size, 
                        this._gpuTexture = null), this._status = GFXStatus.UNREADY, this._buffer = null;
                    }
                }, {
                    key: "resize",
                    value: function resize(width, height) {
                        var oldSize = this._size;
                        this._width = width, this._height = height, this._size = GFXFormatSurfaceSize(this._format, this.width, this.height, this.depth, this.mipLevel) * this._arrayLayer, 
                        this._gpuTexture && (this._gpuTexture.width = this._width, this._gpuTexture.height = this._height, 
                        this._gpuTexture.size = this._size, function WebGLCmdFuncResizeTexture(device, gpuTexture) {
                            var gl = device.gl;
                            gpuTexture.glInternelFmt = GFXFormatToWebGLInternalFormat(gpuTexture.format, gl), 
                            gpuTexture.glFormat = GFXFormatToWebGLFormat(gpuTexture.format, gl), gpuTexture.glType = GFXFormatToWebGLType(gpuTexture.format, gl);
                            var w = gpuTexture.width, h = gpuTexture.height;
                            switch (gpuTexture.viewType) {
                              case GFXTextureViewType.TV2D:
                                gpuTexture.viewType = GFXTextureViewType.TV2D, gpuTexture.glTarget = gl.TEXTURE_2D;
                                var maxSize = Math.max(w, h);
                                if (maxSize > device.maxTextureSize && errorID(9100, maxSize, device.maxTextureSize), 
                                gpuTexture.samples === GFXSampleCount.X1) {
                                    var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                                    if (glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
                                    glTexUnit.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) {
                                        if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _i4 = 0; _i4 < gpuTexture.mipLevel; ++_i4) {
                                            var imgSize = GFXFormatSize(gpuTexture.format, w, h, 1), view = new Uint8Array(imgSize);
                                            gl.compressedTexImage2D(gl.TEXTURE_2D, _i4, gpuTexture.glInternelFmt, w, h, 0, view), 
                                            w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                        }
                                    } else for (var i = 0; i < gpuTexture.mipLevel; ++i) gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                                    w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                }
                                break;

                              case GFXTextureViewType.CUBE:
                                gpuTexture.viewType = GFXTextureViewType.CUBE, gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
                                var _maxSize2 = Math.max(w, h);
                                _maxSize2 > device.maxCubeMapTextureSize && errorID(9100, _maxSize2, device.maxTextureSize);
                                var _glTexUnit2 = device.stateCache.glTexUnits[device.stateCache.texUnit];
                                if (_glTexUnit2.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                                _glTexUnit2.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) {
                                    if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _f3 = 0; _f3 < 6; ++_f3) {
                                        w = gpuTexture.width, h = gpuTexture.height;
                                        for (var _i6 = 0; _i6 < gpuTexture.mipLevel; ++_i6) {
                                            var _imgSize4 = GFXFormatSize(gpuTexture.format, w, h, 1), _view4 = new Uint8Array(_imgSize4);
                                            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f3, _i6, gpuTexture.glInternelFmt, w, h, 0, _view4), 
                                            w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                        }
                                    }
                                } else for (var f = 0; f < 6; ++f) {
                                    w = gpuTexture.width, h = gpuTexture.height;
                                    for (var _i5 = 0; _i5 < gpuTexture.mipLevel; ++_i5) gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i5, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                                    w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                }
                                break;

                              default:
                                console.error("Unsupported GFXTextureType, create texture failed."), gpuTexture.viewType = GFXTextureViewType.TV2D, 
                                gpuTexture.glTarget = gl.TEXTURE_2D;
                            }
                        }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize -= oldSize, 
                        this._device.memoryStatus.textureSize += this._size), this._status = GFXStatus.UNREADY;
                    }
                } ]), WebGLGFXTexture;
            }(), WebGLGFXTextureView = function() {
                function WebGLGFXTextureView(device) {
                    var _this;
                    return _classCallCheck(this, WebGLGFXTextureView), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXTextureView).call(this, device)))._gpuTextureView = null, 
                    _this;
                }
                return _inherits(WebGLGFXTextureView, GFXTextureView), _createClass(WebGLGFXTextureView, [ {
                    key: "gpuTextureView",
                    get: function get() {
                        return this._gpuTextureView;
                    }
                } ]), _createClass(WebGLGFXTextureView, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return this._texture = info.texture, this._type = info.type, this._format = info.format, 
                        this._format = info.format, void 0 !== info.baseLevel && (this._baseLevel = info.baseLevel), 
                        void 0 !== info.levelCount && (this._levelCount = info.levelCount), void 0 !== info.baseLayer && (this._baseLayer = info.baseLayer), 
                        void 0 !== info.layerCount && (this._layerCount = info.layerCount), this._gpuTextureView = {
                            gpuTexture: info.texture.gpuTexture,
                            type: info.type,
                            format: info.format,
                            baseLevel: info.baseLevel ? info.baseLevel : 0,
                            levelCount: info.levelCount ? info.levelCount : 1
                        }, this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._gpuTextureView = null, this._texture = null, this._status = GFXStatus.UNREADY;
                    }
                } ]), WebGLGFXTextureView;
            }(), GFXWindow = function() {
                function GFXWindow(device) {
                    var _this;
                    return _classCallCheck(this, GFXWindow), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXWindow).call(this, GFXObjectType.WINDOW)))._device = void 0, 
                    _this._title = "", _this._left = 0, _this._top = 0, _this._width = 0, _this._height = 0, 
                    _this._nativeWidth = 0, _this._nativeHeight = 0, _this._colorFmt = GFXFormat.UNKNOWN, 
                    _this._depthStencilFmt = GFXFormat.UNKNOWN, _this._isOffscreen = !1, _this._renderPass = null, 
                    _this._colorTex = null, _this._colorTexView = null, _this._depthStencilTex = null, 
                    _this._depthStencilTexView = null, _this._framebuffer = null, _this._device = device, 
                    _this;
                }
                return _inherits(GFXWindow, GFXObject), _createClass(GFXWindow, [ {
                    key: "width",
                    get: function get() {
                        return this._width;
                    }
                }, {
                    key: "height",
                    get: function get() {
                        return this._height;
                    }
                }, {
                    key: "colorFormat",
                    get: function get() {
                        return this._colorFmt;
                    }
                }, {
                    key: "detphStencilFormat",
                    get: function get() {
                        return this._depthStencilFmt;
                    }
                }, {
                    key: "isOffscreen",
                    get: function get() {
                        return this._isOffscreen;
                    }
                }, {
                    key: "renderPass",
                    get: function get() {
                        return this._renderPass;
                    }
                }, {
                    key: "colorTexView",
                    get: function get() {
                        return this._colorTexView;
                    }
                }, {
                    key: "depthStencilTexView",
                    get: function get() {
                        return this._depthStencilTexView;
                    }
                }, {
                    key: "framebuffer",
                    get: function get() {
                        return this._framebuffer;
                    }
                } ]), GFXWindow;
            }(), WebGLGFXWindow = function() {
                function WebGLGFXWindow(device) {
                    return _classCallCheck(this, WebGLGFXWindow), _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXWindow).call(this, device));
                }
                return _inherits(WebGLGFXWindow, GFXWindow), _createClass(WebGLGFXWindow, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        void 0 !== info.title && (this._title = info.title), void 0 !== info.left && (this._left = info.left), 
                        void 0 !== info.top && (this._top = info.top), void 0 !== info.isOffscreen && (this._isOffscreen = info.isOffscreen), 
                        this._width = info.width, this._height = info.height, this._nativeWidth = this._width, 
                        this._nativeHeight = this._height, this._colorFmt = info.colorFmt, this._depthStencilFmt = info.depthStencilFmt, 
                        this._renderPass = this._device.createRenderPass({
                            colorAttachments: [ {
                                format: this._colorFmt,
                                loadOp: GFXLoadOp.CLEAR,
                                storeOp: GFXStoreOp.STORE,
                                sampleCount: 1,
                                beginLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL,
                                endLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL
                            } ],
                            depthStencilAttachment: {
                                format: this._depthStencilFmt,
                                depthLoadOp: GFXLoadOp.CLEAR,
                                depthStoreOp: GFXStoreOp.STORE,
                                stencilLoadOp: GFXLoadOp.CLEAR,
                                stencilStoreOp: GFXStoreOp.STORE,
                                sampleCount: 1,
                                beginLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
                                endLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL
                            }
                        });
                        var colorViews = [];
                        return this._isOffscreen && (this._colorFmt !== GFXFormat.UNKNOWN && (this._colorTex = this._device.createTexture({
                            type: GFXTextureType.TEX2D,
                            usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                            format: this._colorFmt,
                            width: this._width,
                            height: this._height,
                            depth: 1,
                            arrayLayer: 1,
                            mipLevel: 1,
                            flags: GFXTextureFlagBit.NONE
                        }), this._colorTexView = this._device.createTextureView({
                            texture: this._colorTex,
                            type: GFXTextureViewType.TV2D,
                            format: this._colorFmt,
                            baseLevel: 0,
                            levelCount: 1,
                            baseLayer: 0,
                            layerCount: 1
                        }), colorViews.push(this._colorTexView)), this._depthStencilFmt !== GFXFormat.UNKNOWN && (this._depthStencilTex = this._device.createTexture({
                            type: GFXTextureType.TEX2D,
                            usage: GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT,
                            format: this._depthStencilFmt,
                            width: this._width,
                            height: this._height,
                            depth: 1,
                            arrayLayer: 1,
                            mipLevel: 1,
                            flags: GFXTextureFlagBit.NONE
                        }), this._depthStencilTexView = this._device.createTextureView({
                            texture: this._depthStencilTex,
                            type: GFXTextureViewType.TV2D,
                            format: this._depthStencilFmt,
                            baseLevel: 0,
                            levelCount: 1,
                            baseLayer: 0,
                            layerCount: 1
                        }))), this._framebuffer = this._device.createFramebuffer({
                            renderPass: this._renderPass,
                            colorViews: colorViews,
                            depthStencilView: this._depthStencilTexView,
                            isOffscreen: this._isOffscreen
                        }), this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._depthStencilTexView && (this._depthStencilTexView.destroy(), this._depthStencilTexView = null), 
                        this._depthStencilTex && (this._depthStencilTex.destroy(), this._depthStencilTex = null), 
                        this._colorTexView && (this._colorTexView.destroy(), this._colorTexView = null), 
                        this._colorTex && (this._colorTex.destroy(), this._colorTex = null), this._framebuffer && (this._framebuffer.destroy(), 
                        this._framebuffer = null), this._renderPass && (this._renderPass.destroy(), this._renderPass = null), 
                        this._status = GFXStatus.UNREADY;
                    }
                }, {
                    key: "resize",
                    value: function resize(width, height) {
                        this._width = width, this._height = height, (width > this._nativeWidth || height > this._nativeHeight) && (this._nativeWidth = width, 
                        this._nativeHeight = height, this._depthStencilTex && (this._depthStencilTex.resize(width, height), 
                        this._depthStencilTexView.destroy(), this._depthStencilTexView.initialize({
                            texture: this._depthStencilTex,
                            type: GFXTextureViewType.TV2D,
                            format: this._depthStencilFmt
                        })), this._colorTex && (this._colorTex.resize(width, height), this._colorTexView.destroy(), 
                        this._colorTexView.initialize({
                            texture: this._colorTex,
                            type: GFXTextureViewType.TV2D,
                            format: this._colorFmt
                        })), this._framebuffer && this._framebuffer.isOffscreen && (this._framebuffer.destroy(), 
                        this._framebuffer.initialize({
                            renderPass: this._renderPass,
                            colorViews: [ this._colorTexView ],
                            depthStencilView: this._depthStencilTexView
                        })));
                    }
                } ]), WebGLGFXWindow;
            }(), WebGLGFXDevice = function() {
                function WebGLGFXDevice() {
                    var _this;
                    return _classCallCheck(this, WebGLGFXDevice), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXDevice).call(this))).stateCache = new WebGLStateCache(), 
                    _this.nullTex2D = null, _this.nullTexCube = null, _this._webGLRC = null, _this._isAntialias = !0, 
                    _this._isPremultipliedAlpha = !0, _this._useVAO = !1, _this._extensions = null, 
                    _this._EXT_texture_filter_anisotropic = null, _this._EXT_frag_depth = null, _this._EXT_shader_texture_lod = null, 
                    _this._EXT_sRGB = null, _this._OES_vertex_array_object = null, _this._EXT_color_buffer_half_float = null, 
                    _this._WEBGL_color_buffer_float = null, _this._WEBGL_compressed_texture_etc1 = null, 
                    _this._WEBGL_compressed_texture_etc = null, _this._WEBGL_compressed_texture_pvrtc = null, 
                    _this._WEBGL_compressed_texture_astc = null, _this._WEBGL_compressed_texture_s3tc = null, 
                    _this._WEBGL_compressed_texture_s3tc_srgb = null, _this._WEBGL_debug_shaders = null, 
                    _this._WEBGL_draw_buffers = null, _this._WEBGL_lose_context = null, _this._WEBGL_depth_texture = null, 
                    _this._WEBGL_debug_renderer_info = null, _this._OES_texture_half_float = null, _this._OES_texture_half_float_linear = null, 
                    _this._OES_texture_float = null, _this._OES_texture_float_linear = null, _this._OES_standard_derivatives = null, 
                    _this._OES_element_index_uint = null, _this._ANGLE_instanced_arrays = null, _this;
                }
                return _inherits(WebGLGFXDevice, GFXDevice), _createClass(WebGLGFXDevice, [ {
                    key: "gl",
                    get: function get() {
                        return this._webGLRC;
                    }
                }, {
                    key: "webGLQueue",
                    get: function get() {
                        return this._queue;
                    }
                }, {
                    key: "isAntialias",
                    get: function get() {
                        return this._isAntialias;
                    }
                }, {
                    key: "isPremultipliedAlpha",
                    get: function get() {
                        return this._isPremultipliedAlpha;
                    }
                }, {
                    key: "useVAO",
                    get: function get() {
                        return this._useVAO;
                    }
                }, {
                    key: "EXT_texture_filter_anisotropic",
                    get: function get() {
                        return this._EXT_texture_filter_anisotropic;
                    }
                }, {
                    key: "EXT_frag_depth",
                    get: function get() {
                        return this._EXT_frag_depth;
                    }
                }, {
                    key: "EXT_shader_texture_lod",
                    get: function get() {
                        return this._EXT_shader_texture_lod;
                    }
                }, {
                    key: "EXT_sRGB",
                    get: function get() {
                        return this._EXT_sRGB;
                    }
                }, {
                    key: "OES_vertex_array_object",
                    get: function get() {
                        return this._OES_vertex_array_object;
                    }
                }, {
                    key: "WEBGL_color_buffer_float",
                    get: function get() {
                        return this._WEBGL_color_buffer_float;
                    }
                }, {
                    key: "WEBGL_compressed_texture_etc1",
                    get: function get() {
                        return this._WEBGL_compressed_texture_etc1;
                    }
                }, {
                    key: "WEBGL_compressed_texture_pvrtc",
                    get: function get() {
                        return this._WEBGL_compressed_texture_pvrtc;
                    }
                }, {
                    key: "WEBGL_compressed_texture_astc",
                    get: function get() {
                        return this._WEBGL_compressed_texture_astc;
                    }
                }, {
                    key: "WEBGL_compressed_texture_s3tc",
                    get: function get() {
                        return this._WEBGL_compressed_texture_s3tc;
                    }
                }, {
                    key: "WEBGL_compressed_texture_s3tc_srgb",
                    get: function get() {
                        return this._WEBGL_compressed_texture_s3tc_srgb;
                    }
                }, {
                    key: "WEBGL_debug_shaders",
                    get: function get() {
                        return this._WEBGL_debug_shaders;
                    }
                }, {
                    key: "WEBGL_draw_buffers",
                    get: function get() {
                        return this._WEBGL_draw_buffers;
                    }
                }, {
                    key: "WEBGL_lose_context",
                    get: function get() {
                        return this._WEBGL_lose_context;
                    }
                }, {
                    key: "WEBGL_depth_texture",
                    get: function get() {
                        return this._WEBGL_depth_texture;
                    }
                }, {
                    key: "WEBGL_debug_renderer_info",
                    get: function get() {
                        return this._WEBGL_debug_renderer_info;
                    }
                }, {
                    key: "OES_texture_half_float",
                    get: function get() {
                        return this._OES_texture_half_float;
                    }
                }, {
                    key: "OES_texture_half_float_linear",
                    get: function get() {
                        return this._OES_texture_half_float_linear;
                    }
                }, {
                    key: "OES_texture_float",
                    get: function get() {
                        return this._OES_texture_float;
                    }
                }, {
                    key: "OES_standard_derivatives",
                    get: function get() {
                        return this._OES_standard_derivatives;
                    }
                }, {
                    key: "OES_element_index_uint",
                    get: function get() {
                        return this._OES_element_index_uint;
                    }
                }, {
                    key: "ANGLE_instanced_arrays",
                    get: function get() {
                        return this._ANGLE_instanced_arrays;
                    }
                } ]), _createClass(WebGLGFXDevice, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        this._canvas = info.canvasElm, this._isAntialias = void 0 === info.isAntialias || info.isAntialias, 
                        this._isPremultipliedAlpha = void 0 === info.isPremultipliedAlpha || info.isPremultipliedAlpha;
                        try {
                            var webGLCtxAttribs = {
                                alpha: !1,
                                antialias: this._isAntialias,
                                depth: !0,
                                stencil: !0,
                                premultipliedAlpha: this._isPremultipliedAlpha,
                                preserveDrawingBuffer: !1,
                                powerPreference: "default",
                                failIfMajorPerformanceCaveat: !1
                            };
                            this._webGLRC = this._canvas.getContext("webgl", webGLCtxAttribs);
                        } catch (err) {
                            return console.error(err), !1;
                        }
                        if (!this._webGLRC) return console.error("This device does not support WebGL."), 
                        !1;
                        this._canvas2D = document.createElement("canvas"), console.info("WebGL device initialized."), 
                        this._gfxAPI = GFXAPI.WEBGL, this._deviceName = "WebGL";
                        var gl = this._webGLRC;
                        this._WEBGL_debug_renderer_info = this.getExtension("WEBGL_debug_renderer_info"), 
                        this._WEBGL_debug_renderer_info ? (this._renderer = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL), 
                        this._vendor = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL)) : (this._renderer = gl.getParameter(gl.RENDERER), 
                        this._vendor = gl.getParameter(gl.VENDOR)), this._version = gl.getParameter(gl.VERSION), 
                        this._maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS), this._maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS), 
                        this._maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS), 
                        this._maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), this._maxVertexTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS), 
                        this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE), this._maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE), 
                        this._depthBits = gl.getParameter(gl.DEPTH_BITS), this._stencilBits = gl.getParameter(gl.STENCIL_BITS), 
                        this._devicePixelRatio = info.devicePixelRatio || 1, this._width = this._canvas.width, 
                        this._height = this._canvas.height, this._nativeWidth = Math.max(info.nativeWidth || this._width, 0), 
                        this._nativeHeight = Math.max(info.nativeHeight || this._height, 0), this._colorFmt = GFXFormat.RGBA8, 
                        24 === this._depthBits ? 8 === this._stencilBits ? this._depthStencilFmt = GFXFormat.D24S8 : this._depthStencilFmt = GFXFormat.D24 : 8 === this._stencilBits ? this._depthStencilFmt = GFXFormat.D16S8 : this._depthStencilFmt = GFXFormat.D16, 
                        this._extensions = gl.getSupportedExtensions();
                        var extensions = "";
                        if (this._extensions) {
                            var _iterator = this._extensions, _isArray = Array.isArray(_iterator), _i = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i >= _iterator.length) break;
                                    _ref = _iterator[_i++];
                                } else {
                                    if ((_i = _iterator.next()).done) break;
                                    _ref = _i.value;
                                }
                                extensions += _ref + " ";
                            }
                            console.debug("EXTENSIONS: " + extensions);
                        }
                        this._EXT_texture_filter_anisotropic = this.getExtension("EXT_texture_filter_anisotropic"), 
                        this._EXT_frag_depth = this.getExtension("EXT_frag_depth"), this._EXT_shader_texture_lod = this.getExtension("EXT_shader_texture_lod"), 
                        this._EXT_sRGB = this.getExtension("EXT_sRGB"), this._OES_vertex_array_object = this.getExtension("OES_vertex_array_object"), 
                        this._EXT_color_buffer_half_float = this.getExtension("EXT_color_buffer_half_float"), 
                        this._WEBGL_color_buffer_float = this.getExtension("WEBGL_color_buffer_float"), 
                        this._WEBGL_compressed_texture_etc1 = this.getExtension("WEBGL_compressed_texture_etc1"), 
                        this._WEBGL_compressed_texture_etc = this.getExtension("WEBGL_compressed_texture_etc"), 
                        this._WEBGL_compressed_texture_pvrtc = this.getExtension("WEBGL_compressed_texture_pvrtc"), 
                        this._WEBGL_compressed_texture_astc = this.getExtension("WEBGL_compressed_texture_astc"), 
                        this._WEBGL_compressed_texture_s3tc = this.getExtension("WEBGL_compressed_texture_s3tc"), 
                        this._WEBGL_compressed_texture_s3tc_srgb = this.getExtension("WEBGL_compressed_texture_s3tc_srgb"), 
                        this._WEBGL_debug_shaders = this.getExtension("WEBGL_debug_shaders"), this._WEBGL_draw_buffers = this.getExtension("WEBGL_draw_buffers"), 
                        this._WEBGL_lose_context = this.getExtension("WEBGL_lose_context"), this._WEBGL_depth_texture = this.getExtension("WEBGL_depth_texture"), 
                        this._OES_texture_half_float = this.getExtension("OES_texture_half_float"), this._OES_texture_half_float_linear = this.getExtension("OES_texture_half_float_linear"), 
                        this._OES_texture_float = this.getExtension("OES_texture_float"), this._OES_texture_float_linear = this.getExtension("OES_texture_float_linear"), 
                        this._OES_standard_derivatives = this.getExtension("OES_standard_derivatives"), 
                        this._OES_element_index_uint = this.getExtension("OES_element_index_uint"), this._ANGLE_instanced_arrays = this.getExtension("ANGLE_instanced_arrays"), 
                        this._features.fill(!1), this._WEBGL_color_buffer_float && (this._features[GFXFeature.COLOR_FLOAT] = !0), 
                        this._EXT_color_buffer_half_float && (this._features[GFXFeature.COLOR_HALF_FLOAT] = !0), 
                        this._OES_texture_float && (this._features[GFXFeature.TEXTURE_FLOAT] = !0), this._OES_texture_half_float && (this._features[GFXFeature.TEXTURE_HALF_FLOAT] = !0), 
                        this._OES_texture_float_linear && (this._features[GFXFeature.TEXTURE_FLOAT_LINEAR] = !0), 
                        this._OES_texture_half_float_linear && (this._features[GFXFeature.TEXTURE_HALF_FLOAT_LINEAR] = !0), 
                        this._WEBGL_depth_texture && (this._features[GFXFeature.FORMAT_D24S8] = !0);
                        var compressedFormat = "";
                        this._WEBGL_compressed_texture_etc1 && (this._features[GFXFeature.FORMAT_ETC1] = !0, 
                        compressedFormat += "etc1 "), this._WEBGL_compressed_texture_etc && (this._features[GFXFeature.FORMAT_ETC2] = !0, 
                        compressedFormat += "etc2 "), this._WEBGL_compressed_texture_s3tc && (this._features[GFXFeature.FORMAT_DXT] = !0, 
                        compressedFormat += "dxt "), this._WEBGL_compressed_texture_pvrtc && (this._features[GFXFeature.FORMAT_PVRTC] = !0, 
                        compressedFormat += "pvrtc "), this._WEBGL_compressed_texture_astc && (this._features[GFXFeature.FORMAT_ASTC] = !0, 
                        compressedFormat += "astc "), this._features[GFXFeature.MSAA] = !1, this._OES_vertex_array_object && (this._useVAO = !0), 
                        console.info("RENDERER: " + this._renderer), console.info("VENDOR: " + this._vendor), 
                        console.info("VERSION: " + this._version), console.info("DPR: " + this._devicePixelRatio), 
                        console.info("SCREEN_SIZE: " + this._width + " x " + this._height), console.info("NATIVE_SIZE: " + this._nativeWidth + " x " + this._nativeHeight), 
                        console.info("MAX_VERTEX_UNIFORM_VECTORS: " + this._maxVertexUniformVectors), console.info("DEPTH_BITS: " + this._depthBits), 
                        console.info("STENCIL_BITS: " + this._stencilBits), this._EXT_texture_filter_anisotropic && console.info("MAX_TEXTURE_MAX_ANISOTROPY_EXT: " + this._EXT_texture_filter_anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT), 
                        console.info("USE_VAO: " + this._useVAO), console.info("COMPRESSED_FORMAT: " + compressedFormat), 
                        this.initStates(gl), this._queue = this.createQueue({
                            type: GFXQueueType.GRAPHICS
                        });
                        var canvas = this._webGLRC.canvas;
                        this._mainWindow = this.createWindow({
                            title: canvas.title || "",
                            left: canvas.offsetLeft || 0,
                            top: canvas.offsetTop || 0,
                            width: this._webGLRC.drawingBufferWidth,
                            height: this._webGLRC.drawingBufferHeight,
                            colorFmt: this._colorFmt,
                            depthStencilFmt: this._depthStencilFmt
                        }), this._cmdAllocator = this.createCommandAllocator({}), this.nullTex2D = new WebGLGFXTexture(this), 
                        this.nullTex2D.initialize({
                            type: GFXTextureType.TEX2D,
                            usage: GFXTextureUsageBit.SAMPLED,
                            format: GFXFormat.RGBA8,
                            width: 2,
                            height: 2,
                            flags: GFXTextureFlagBit.GEN_MIPMAP
                        }), this.nullTexCube = new WebGLGFXTexture(this), this.nullTexCube.initialize({
                            type: GFXTextureType.TEX2D,
                            usage: GFXTextureUsageBit.SAMPLED,
                            format: GFXFormat.RGBA8,
                            width: 2,
                            height: 2,
                            arrayLayer: 6,
                            flags: GFXTextureFlagBit.CUBEMAP | GFXTextureFlagBit.GEN_MIPMAP
                        });
                        var nullTexRegion = {
                            buffOffset: 0,
                            buffStride: 0,
                            buffTexHeight: 0,
                            texOffset: {
                                x: 0,
                                y: 0,
                                z: 0
                            },
                            texExtent: {
                                width: 2,
                                height: 2,
                                depth: 1
                            },
                            texSubres: {
                                baseMipLevel: 0,
                                levelCount: 1,
                                baseArrayLayer: 0,
                                layerCount: 1
                            }
                        }, nullTexBuff = new Uint8Array(this.nullTex2D.size);
                        return nullTexBuff.fill(0), this.copyBuffersToTexture([ nullTexBuff ], this.nullTex2D, [ nullTexRegion ]), 
                        nullTexRegion.texSubres.layerCount = 6, this.copyBuffersToTexture([ nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff ], this.nullTexCube, [ nullTexRegion ]), 
                        !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.nullTex2D && (this.nullTex2D.destroy(), this.nullTex2D = null), this.nullTexCube && (this.nullTexCube.destroy(), 
                        this.nullTexCube = null), this._mainWindow && (this._mainWindow.destroy(), this._mainWindow = null), 
                        this._cmdAllocator && (this._cmdAllocator.destroy(), this._cmdAllocator = null), 
                        this._queue && (this._queue.destroy(), this._queue = null), this._webGLRC = null;
                    }
                }, {
                    key: "resize",
                    value: function resize(width, height) {
                        this._width === width && this._height === height || (console.info("Resizing device: " + width + "x" + height), 
                        this._canvas.width = width, this._canvas.height = height, this._width = width, this._height = height);
                    }
                }, {
                    key: "createBuffer",
                    value: function createBuffer(info) {
                        var buffer = new WebGLGFXBuffer(this);
                        return buffer.initialize(info), buffer;
                    }
                }, {
                    key: "createTexture",
                    value: function createTexture(info) {
                        var texture = new WebGLGFXTexture(this);
                        return texture.initialize(info), texture;
                    }
                }, {
                    key: "createTextureView",
                    value: function createTextureView(info) {
                        var texView = new WebGLGFXTextureView(this);
                        return texView.initialize(info), texView;
                    }
                }, {
                    key: "createSampler",
                    value: function createSampler(info) {
                        var sampler = new WebGLGFXSampler(this);
                        return sampler.initialize(info), sampler;
                    }
                }, {
                    key: "createBindingLayout",
                    value: function createBindingLayout(info) {
                        var bindingLayout = new WebGLGFXBindingLayout(this);
                        return bindingLayout.initialize(info), bindingLayout;
                    }
                }, {
                    key: "createShader",
                    value: function createShader(info) {
                        var shader = new WebGLGFXShader(this);
                        return shader.initialize(info), shader;
                    }
                }, {
                    key: "createInputAssembler",
                    value: function createInputAssembler(info) {
                        var inputAssembler = new WebGLGFXInputAssembler(this);
                        return inputAssembler.initialize(info), inputAssembler;
                    }
                }, {
                    key: "createRenderPass",
                    value: function createRenderPass(info) {
                        var renderPass = new WebGLGFXRenderPass(this);
                        return renderPass.initialize(info), renderPass;
                    }
                }, {
                    key: "createFramebuffer",
                    value: function createFramebuffer(info) {
                        var framebuffer = new WebGLGFXFramebuffer(this);
                        return framebuffer.initialize(info), framebuffer;
                    }
                }, {
                    key: "createPipelineLayout",
                    value: function createPipelineLayout(info) {
                        var pipelineLayout = new WebGLGFXPipelineLayout(this);
                        return pipelineLayout.initialize(info), pipelineLayout;
                    }
                }, {
                    key: "createPipelineState",
                    value: function createPipelineState(info) {
                        var pipelineState = new WebGLGFXPipelineState(this);
                        return pipelineState.initialize(info), pipelineState;
                    }
                }, {
                    key: "createCommandAllocator",
                    value: function createCommandAllocator(info) {
                        var cmdAllocator = new WebGLGFXCommandAllocator(this);
                        return cmdAllocator.initialize(info), cmdAllocator;
                    }
                }, {
                    key: "createCommandBuffer",
                    value: function createCommandBuffer(info) {
                        var cmdBuff = new WebGLGFXCommandBuffer(this);
                        return cmdBuff.initialize(info), cmdBuff;
                    }
                }, {
                    key: "createQueue",
                    value: function createQueue(info) {
                        var queue = new WebGLGFXQueue(this);
                        return queue.initialize(info), queue;
                    }
                }, {
                    key: "createWindow",
                    value: function createWindow(info) {
                        var window = new WebGLGFXWindow(this);
                        return window.initialize(info), window;
                    }
                }, {
                    key: "present",
                    value: function present() {
                        this._cmdAllocator.releaseCmds();
                        var queue = this._queue;
                        this._numDrawCalls = queue.numDrawCalls, this._numTris = queue.numTris, queue.clear();
                    }
                }, {
                    key: "copyBuffersToTexture",
                    value: function copyBuffersToTexture(buffers, texture, regions) {
                        WebGLCmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
                    }
                }, {
                    key: "copyTexImagesToTexture",
                    value: function copyTexImagesToTexture(texImages, texture, regions) {
                        !function WebGLCmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
                            var gl = device.gl, glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                            glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture), 
                            glTexUnit.glTexture = gpuTexture.glTexture);
                            var m = 0, n = 0, f = 0;
                            switch (gpuTexture.glTarget) {
                              case gl.TEXTURE_2D:
                                var _iterator10 = regions, _isArray10 = Array.isArray(_iterator10), _i20 = 0;
                                for (_iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator](); ;) {
                                    var _ref10;
                                    if (_isArray10) {
                                        if (_i20 >= _iterator10.length) break;
                                        _ref10 = _iterator10[_i20++];
                                    } else {
                                        if ((_i20 = _iterator10.next()).done) break;
                                        _ref10 = _i20.value;
                                    }
                                    var region = _ref10;
                                    for (m = region.texSubres.baseMipLevel; m < region.texSubres.levelCount; ++m) gl.texSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                                }
                                break;

                              case gl.TEXTURE_CUBE_MAP:
                                var _iterator11 = regions, _isArray11 = Array.isArray(_iterator11), _i21 = 0;
                                for (_iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator](); ;) {
                                    var _ref11;
                                    if (_isArray11) {
                                        if (_i21 >= _iterator11.length) break;
                                        _ref11 = _iterator11[_i21++];
                                    } else {
                                        if ((_i21 = _iterator11.next()).done) break;
                                        _ref11 = _i21.value;
                                    }
                                    var _region = _ref11, fcount = _region.texSubres.baseArrayLayer + _region.texSubres.layerCount;
                                    for (f = _region.texSubres.baseArrayLayer; f < fcount; ++f) {
                                        var mcount = _region.texSubres.baseMipLevel + _region.texSubres.levelCount;
                                        for (m = _region.texSubres.baseMipLevel; m < mcount; ++m) gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region.texOffset.x, _region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                                    }
                                }
                                break;

                              default:
                                console.error("Unsupported GL texture type, copy buffer to texture failed.");
                            }
                            gpuTexture.flags & GFXTextureFlagBit.GEN_MIPMAP && gpuTexture.isPowerOf2 && gl.generateMipmap(gpuTexture.glTarget);
                        }(this, texImages, texture.gpuTexture, regions);
                    }
                }, {
                    key: "copyFramebufferToBuffer",
                    value: function copyFramebufferToBuffer(srcFramebuffer, dstBuffer, regions) {
                        var gl = this._webGLRC, gpuFramebuffer = srcFramebuffer.gpuFramebuffer, curFBO = this.stateCache.glFramebuffer;
                        this.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer), 
                        this.stateCache.glFramebuffer = gpuFramebuffer.glFramebuffer);
                        var view = new Uint8Array(dstBuffer), _iterator2 = regions, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            var region = _ref2, buffOffset = region.buffOffset + region.buffTexHeight * region.buffStride, w = region.texExtent.width, h = region.texExtent.height, memSize = GFXFormatSize(GFXFormat.RGBA8, w, h, 1), data = view.subarray(buffOffset, buffOffset + memSize);
                            gl.readPixels(region.texOffset.x, region.texOffset.y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, data);
                        }
                        this.stateCache.glFramebuffer !== curFBO && (gl.bindFramebuffer(gl.FRAMEBUFFER, curFBO), 
                        this.stateCache.glFramebuffer = curFBO);
                    }
                }, {
                    key: "blitFramebuffer",
                    value: function blitFramebuffer() {}
                }, {
                    key: "getExtension",
                    value: function getExtension(ext) {
                        for (var prefixes = [ "", "WEBKIT_", "MOZ_" ], i = 0; i < prefixes.length; ++i) {
                            var _ext = this._webGLRC.getExtension(prefixes[i] + ext);
                            if (_ext) return _ext;
                        }
                        return null;
                    }
                }, {
                    key: "initStates",
                    value: function initStates(gl) {
                        gl.activeTexture(gl.TEXTURE0), gl.pixelStorei(gl.PACK_ALIGNMENT, 1), gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1), 
                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0), gl.bindFramebuffer(gl.FRAMEBUFFER, null), 
                        gl.disable(gl.SCISSOR_TEST), gl.enable(gl.CULL_FACE), gl.cullFace(gl.BACK), gl.frontFace(gl.CCW), 
                        gl.disable(gl.POLYGON_OFFSET_FILL), gl.polygonOffset(0, 0), gl.enable(gl.DEPTH_TEST), 
                        gl.depthMask(!0), gl.depthFunc(gl.LESS), gl.depthRange(0, 1), gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 4294967295), 
                        gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP), gl.stencilMaskSeparate(gl.FRONT, 4294967295), 
                        gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 4294967295), gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP), 
                        gl.stencilMaskSeparate(gl.BACK, 4294967295), gl.disable(gl.STENCIL_TEST), gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE), 
                        gl.disable(gl.BLEND), gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO), 
                        gl.colorMask(!0, !0, !0, !0), gl.blendColor(0, 0, 0, 0);
                    }
                } ]), WebGLGFXDevice;
            }();
            cc.WebGLGFXDevice = WebGLGFXDevice;
            var WebGL2GFXBindingLayout = function() {
                function WebGL2GFXBindingLayout(device) {
                    var _this;
                    return _classCallCheck(this, WebGL2GFXBindingLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXBindingLayout).call(this, device)))._gpuBindingLayout = null, 
                    _this;
                }
                return _inherits(WebGL2GFXBindingLayout, GFXBindingLayout), _createClass(WebGL2GFXBindingLayout, [ {
                    key: "gpuBindingLayout",
                    get: function get() {
                        return this._gpuBindingLayout;
                    }
                } ]), _createClass(WebGL2GFXBindingLayout, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        this._bindingUnits = new Array(info.bindings.length);
                        for (var i = 0; i < info.bindings.length; ++i) {
                            var binding = info.bindings[i];
                            this._bindingUnits[i] = {
                                binding: binding.binding,
                                type: binding.type,
                                name: binding.name,
                                buffer: null,
                                texView: null,
                                sampler: null
                            };
                        }
                        this._gpuBindingLayout = {
                            gpuBindings: new Array(info.bindings.length)
                        };
                        for (var _i = 0; _i < info.bindings.length; ++_i) {
                            var _binding = info.bindings[_i];
                            this._gpuBindingLayout.gpuBindings[_i] = {
                                binding: _binding.binding,
                                type: _binding.type,
                                name: _binding.name,
                                gpuBuffer: null,
                                gpuTexView: null,
                                gpuSampler: null
                            };
                        }
                        return this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._gpuBindingLayout = null, this._status = GFXStatus.UNREADY;
                    }
                }, {
                    key: "update",
                    value: function update() {
                        if (this._isDirty && this._gpuBindingLayout) {
                            for (var i = 0; i < this._bindingUnits.length; ++i) {
                                var bindingUnit = this._bindingUnits[i];
                                switch (bindingUnit.type) {
                                  case GFXBindingType.UNIFORM_BUFFER:
                                    bindingUnit.buffer && (this._gpuBindingLayout.gpuBindings[i].gpuBuffer = bindingUnit.buffer.gpuBuffer);
                                    break;

                                  case GFXBindingType.SAMPLER:
                                    bindingUnit.texView && (this._gpuBindingLayout.gpuBindings[i].gpuTexView = bindingUnit.texView.gpuTextureView), 
                                    bindingUnit.sampler && (this._gpuBindingLayout.gpuBindings[i].gpuSampler = bindingUnit.sampler.gpuSampler);
                                }
                            }
                            this._isDirty = !1;
                        }
                    }
                } ]), WebGL2GFXBindingLayout;
            }(), WebGLWraps$1 = [ WebGLRenderingContext.REPEAT, WebGLRenderingContext.MIRRORED_REPEAT, WebGLRenderingContext.CLAMP_TO_EDGE, WebGLRenderingContext.CLAMP_TO_EDGE ], SAMPLES = [ 1, 2, 4, 8, 16, 32, 64 ], _f32v4 = new Float32Array(4);
            function GFXFormatToWebGLType$1(format, gl) {
                switch (format) {
                  case GFXFormat.R8:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.R8SN:
                    return gl.BYTE;

                  case GFXFormat.R8UI:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.R8I:
                    return gl.BYTE;

                  case GFXFormat.R16F:
                    return gl.HALF_FLOAT;

                  case GFXFormat.R16UI:
                    return gl.UNSIGNED_SHORT;

                  case GFXFormat.R16I:
                    return gl.SHORT;

                  case GFXFormat.R32F:
                    return gl.FLOAT;

                  case GFXFormat.R32UI:
                    return gl.UNSIGNED_INT;

                  case GFXFormat.R32I:
                    return gl.INT;

                  case GFXFormat.RG8:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.RG8SN:
                    return gl.BYTE;

                  case GFXFormat.RG8UI:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.RG8I:
                    return gl.BYTE;

                  case GFXFormat.RG16F:
                    return gl.HALF_FLOAT;

                  case GFXFormat.RG16UI:
                    return gl.UNSIGNED_SHORT;

                  case GFXFormat.RG16I:
                    return gl.SHORT;

                  case GFXFormat.RG32F:
                    return gl.FLOAT;

                  case GFXFormat.RG32UI:
                    return gl.UNSIGNED_INT;

                  case GFXFormat.RG32I:
                    return gl.INT;

                  case GFXFormat.RGB8:
                  case GFXFormat.SRGB8:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.RGB8SN:
                    return gl.BYTE;

                  case GFXFormat.RGB8UI:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.RGB8I:
                    return gl.BYTE;

                  case GFXFormat.RGB16F:
                    return gl.HALF_FLOAT;

                  case GFXFormat.RGB16UI:
                    return gl.UNSIGNED_SHORT;

                  case GFXFormat.RGB16I:
                    return gl.SHORT;

                  case GFXFormat.RGB32F:
                    return gl.FLOAT;

                  case GFXFormat.RGB32UI:
                    return gl.UNSIGNED_INT;

                  case GFXFormat.RGB32I:
                    return gl.INT;

                  case GFXFormat.RGBA8:
                  case GFXFormat.SRGB8_A8:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.RGBA8SN:
                    return gl.BYTE;

                  case GFXFormat.RGBA8UI:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.RGBA8I:
                    return gl.BYTE;

                  case GFXFormat.RGBA16F:
                    return gl.HALF_FLOAT;

                  case GFXFormat.RGBA16UI:
                    return gl.UNSIGNED_SHORT;

                  case GFXFormat.RGBA16I:
                    return gl.SHORT;

                  case GFXFormat.RGBA32F:
                    return gl.FLOAT;

                  case GFXFormat.RGBA32UI:
                    return gl.UNSIGNED_INT;

                  case GFXFormat.RGBA32I:
                    return gl.INT;

                  case GFXFormat.R5G6B5:
                    return gl.UNSIGNED_SHORT_5_6_5;

                  case GFXFormat.R11G11B10F:
                    return gl.UNSIGNED_INT_10F_11F_11F_REV;

                  case GFXFormat.RGB5A1:
                    return gl.UNSIGNED_SHORT_5_5_5_1;

                  case GFXFormat.RGBA4:
                    return gl.UNSIGNED_SHORT_4_4_4_4;

                  case GFXFormat.RGB10A2:
                  case GFXFormat.RGB10A2UI:
                    return gl.UNSIGNED_INT_2_10_10_10_REV;

                  case GFXFormat.RGB9E5:
                    return gl.FLOAT;

                  case GFXFormat.D16:
                  case GFXFormat.D16S8:
                    return gl.UNSIGNED_SHORT;

                  case GFXFormat.D24:
                    return gl.UNSIGNED_INT;

                  case GFXFormat.D24S8:
                    return gl.UNSIGNED_INT_24_8;

                  case GFXFormat.D32F:
                    return gl.FLOAT;

                  case GFXFormat.D32F_S8:
                    return gl.FLOAT_32_UNSIGNED_INT_24_8_REV;

                  case GFXFormat.BC1:
                  case GFXFormat.BC1_SRGB:
                  case GFXFormat.BC2:
                  case GFXFormat.BC2_SRGB:
                  case GFXFormat.BC3:
                  case GFXFormat.BC3_SRGB:
                  case GFXFormat.BC4:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.BC4_SNORM:
                    return gl.BYTE;

                  case GFXFormat.BC5:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.BC5_SNORM:
                    return gl.BYTE;

                  case GFXFormat.BC6H_SF16:
                  case GFXFormat.BC6H_UF16:
                    return gl.FLOAT;

                  case GFXFormat.BC7:
                  case GFXFormat.BC7_SRGB:
                  case GFXFormat.ETC_RGB8:
                  case GFXFormat.ETC2_RGB8:
                  case GFXFormat.ETC2_SRGB8:
                  case GFXFormat.ETC2_RGB8_A1:
                  case GFXFormat.ETC2_SRGB8_A1:
                  case GFXFormat.ETC2_RGB8:
                  case GFXFormat.ETC2_SRGB8:
                  case GFXFormat.EAC_R11:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.EAC_R11SN:
                    return gl.BYTE;

                  case GFXFormat.EAC_RG11:
                    return gl.UNSIGNED_BYTE;

                  case GFXFormat.EAC_RG11SN:
                    return gl.BYTE;

                  case GFXFormat.PVRTC_RGB2:
                  case GFXFormat.PVRTC_RGBA2:
                  case GFXFormat.PVRTC_RGB4:
                  case GFXFormat.PVRTC_RGBA4:
                  case GFXFormat.PVRTC2_2BPP:
                  case GFXFormat.PVRTC2_4BPP:
                  default:
                    return gl.UNSIGNED_BYTE;
                }
            }
            function GFXFormatToWebGLInternalFormat$1(format, gl) {
                switch (format) {
                  case GFXFormat.A8:
                    return gl.ALPHA;

                  case GFXFormat.L8:
                    return gl.LUMINANCE;

                  case GFXFormat.LA8:
                    return gl.LUMINANCE_ALPHA;

                  case GFXFormat.R8:
                    return gl.R8;

                  case GFXFormat.R8SN:
                    return gl.R8_SNORM;

                  case GFXFormat.R8UI:
                    return gl.R8UI;

                  case GFXFormat.R8I:
                    return gl.R8I;

                  case GFXFormat.RG8:
                    return gl.RG8;

                  case GFXFormat.RG8SN:
                    return gl.RG8_SNORM;

                  case GFXFormat.RG8UI:
                    return gl.RG8UI;

                  case GFXFormat.RG8I:
                    return gl.RG8I;

                  case GFXFormat.RGB8:
                    return gl.RGB8;

                  case GFXFormat.RGB8SN:
                    return gl.RGB8_SNORM;

                  case GFXFormat.RGB8UI:
                    return gl.RGB8UI;

                  case GFXFormat.RGB8I:
                    return gl.RGB8I;

                  case GFXFormat.RGBA8:
                    return gl.RGBA8;

                  case GFXFormat.RGBA8SN:
                    return gl.RGBA8_SNORM;

                  case GFXFormat.RGBA8UI:
                    return gl.RGBA8UI;

                  case GFXFormat.RGBA8I:
                    return gl.RGBA8I;

                  case GFXFormat.R16I:
                    return gl.R16I;

                  case GFXFormat.R16UI:
                    return gl.R16UI;

                  case GFXFormat.R16F:
                    return gl.R16F;

                  case GFXFormat.RG16I:
                    return gl.RG16I;

                  case GFXFormat.RG16UI:
                    return gl.RG16UI;

                  case GFXFormat.RG16F:
                    return gl.RG16F;

                  case GFXFormat.RGB16I:
                    return gl.RGB16I;

                  case GFXFormat.RGB16UI:
                    return gl.RGB16UI;

                  case GFXFormat.RGB16F:
                    return gl.RGB16F;

                  case GFXFormat.RGBA16I:
                    return gl.RGBA16I;

                  case GFXFormat.RGBA16UI:
                    return gl.RGBA16UI;

                  case GFXFormat.RGBA16F:
                    return gl.RGBA16F;

                  case GFXFormat.R32I:
                    return gl.R32I;

                  case GFXFormat.R32UI:
                    return gl.R32UI;

                  case GFXFormat.R32F:
                    return gl.R32F;

                  case GFXFormat.RG32I:
                    return gl.RG32I;

                  case GFXFormat.RG32UI:
                    return gl.RG32UI;

                  case GFXFormat.RG32F:
                    return gl.RG32F;

                  case GFXFormat.RGB32I:
                    return gl.RGB32I;

                  case GFXFormat.RGB32UI:
                    return gl.RGB32UI;

                  case GFXFormat.RGB32F:
                    return gl.RGB32F;

                  case GFXFormat.RGBA32I:
                    return gl.RGBA32I;

                  case GFXFormat.RGBA32UI:
                    return gl.RGBA32UI;

                  case GFXFormat.RGBA32F:
                    return gl.RGBA32F;

                  case GFXFormat.R5G6B5:
                    return gl.RGB565;

                  case GFXFormat.RGB5A1:
                    return gl.RGB5_A1;

                  case GFXFormat.RGBA4:
                    return gl.RGBA4;

                  case GFXFormat.RGB10A2:
                    return gl.RGB10_A2;

                  case GFXFormat.RGB10A2UI:
                    return gl.RGB10_A2UI;

                  case GFXFormat.R11G11B10F:
                    return gl.R11F_G11F_B10F;

                  case GFXFormat.D16:
                    return gl.DEPTH_COMPONENT16;

                  case GFXFormat.D16S8:
                    return gl.DEPTH_STENCIL;

                  case GFXFormat.D24:
                    return gl.DEPTH_COMPONENT24;

                  case GFXFormat.D24S8:
                    return gl.DEPTH24_STENCIL8;

                  case GFXFormat.D32F:
                    return gl.DEPTH_COMPONENT32F;

                  case GFXFormat.D32F_S8:
                    return gl.DEPTH32F_STENCIL8;

                  case GFXFormat.BC1:
                    return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

                  case GFXFormat.BC1_ALPHA:
                    return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

                  case GFXFormat.BC1_SRGB:
                    return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

                  case GFXFormat.BC1_SRGB_ALPHA:
                    return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

                  case GFXFormat.BC2:
                    return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

                  case GFXFormat.BC2_SRGB:
                    return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

                  case GFXFormat.BC3:
                    return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                  case GFXFormat.BC3_SRGB:
                    return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

                  case GFXFormat.ETC_RGB8:
                    return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

                  case GFXFormat.ETC2_RGB8:
                    return WebGLEXT.COMPRESSED_RGB8_ETC2;

                  case GFXFormat.ETC2_SRGB8:
                    return WebGLEXT.COMPRESSED_SRGB8_ETC2;

                  case GFXFormat.ETC2_RGB8_A1:
                    return WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                  case GFXFormat.ETC2_SRGB8_A1:
                    return WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                  case GFXFormat.ETC2_RGBA8:
                    return WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC;

                  case GFXFormat.ETC2_SRGB8_A8:
                    return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

                  case GFXFormat.EAC_R11:
                    return WebGLEXT.COMPRESSED_R11_EAC;

                  case GFXFormat.EAC_R11SN:
                    return WebGLEXT.COMPRESSED_SIGNED_R11_EAC;

                  case GFXFormat.EAC_RG11:
                    return WebGLEXT.COMPRESSED_RG11_EAC;

                  case GFXFormat.EAC_RG11SN:
                    return WebGLEXT.COMPRESSED_SIGNED_RG11_EAC;

                  case GFXFormat.PVRTC_RGB2:
                    return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

                  case GFXFormat.PVRTC_RGBA2:
                    return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

                  case GFXFormat.PVRTC_RGB4:
                    return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

                  case GFXFormat.PVRTC_RGBA4:
                    return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

                  default:
                    return console.error("Unsupported GFXFormat, convert to WebGL internal format failed."), 
                    gl.RGBA;
                }
            }
            function GFXFormatToWebGLFormat$1(format, gl) {
                switch (format) {
                  case GFXFormat.A8:
                    return gl.ALPHA;

                  case GFXFormat.L8:
                    return gl.LUMINANCE;

                  case GFXFormat.LA8:
                    return gl.LUMINANCE_ALPHA;

                  case GFXFormat.R8:
                  case GFXFormat.R8SN:
                    return gl.RED;

                  case GFXFormat.R8UI:
                  case GFXFormat.R8I:
                    return gl.RED;

                  case GFXFormat.RG8:
                  case GFXFormat.RG8SN:
                  case GFXFormat.RG8UI:
                  case GFXFormat.RG8I:
                    return gl.RG;

                  case GFXFormat.RGB8:
                  case GFXFormat.RGB8SN:
                  case GFXFormat.RGB8UI:
                  case GFXFormat.RGB8I:
                    return gl.RGB;

                  case GFXFormat.RGBA8:
                  case GFXFormat.RGBA8SN:
                  case GFXFormat.RGBA8UI:
                  case GFXFormat.RGBA8I:
                    return gl.RGBA;

                  case GFXFormat.R16UI:
                  case GFXFormat.R16I:
                  case GFXFormat.R16F:
                    return gl.RED;

                  case GFXFormat.RG16UI:
                  case GFXFormat.RG16I:
                  case GFXFormat.RG16F:
                    return gl.RG;

                  case GFXFormat.RGB16UI:
                  case GFXFormat.RGB16I:
                  case GFXFormat.RGB16F:
                    return gl.RGB;

                  case GFXFormat.RGBA16UI:
                  case GFXFormat.RGBA16I:
                  case GFXFormat.RGBA16F:
                    return gl.RGBA;

                  case GFXFormat.R32UI:
                  case GFXFormat.R32I:
                  case GFXFormat.R32F:
                    return gl.RED;

                  case GFXFormat.RG32UI:
                  case GFXFormat.RG32I:
                  case GFXFormat.RG32F:
                    return gl.RG;

                  case GFXFormat.RGB32UI:
                  case GFXFormat.RGB32I:
                  case GFXFormat.RGB32F:
                    return gl.RGB;

                  case GFXFormat.RGBA32UI:
                  case GFXFormat.RGBA32I:
                  case GFXFormat.RGBA32F:
                  case GFXFormat.RGB10A2:
                    return gl.RGBA;

                  case GFXFormat.R11G11B10F:
                  case GFXFormat.R5G6B5:
                    return gl.RGB;

                  case GFXFormat.RGB5A1:
                  case GFXFormat.RGBA4:
                    return gl.RGBA;

                  case GFXFormat.D16:
                    return gl.DEPTH_COMPONENT;

                  case GFXFormat.D16S8:
                    return gl.DEPTH_STENCIL;

                  case GFXFormat.D24:
                    return gl.DEPTH_COMPONENT;

                  case GFXFormat.D24S8:
                    return gl.DEPTH_STENCIL;

                  case GFXFormat.D32F:
                    return gl.DEPTH_COMPONENT;

                  case GFXFormat.D32F_S8:
                    return gl.DEPTH_STENCIL;

                  case GFXFormat.BC1:
                    return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

                  case GFXFormat.BC1_ALPHA:
                    return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

                  case GFXFormat.BC1_SRGB:
                    return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

                  case GFXFormat.BC1_SRGB_ALPHA:
                    return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

                  case GFXFormat.BC2:
                    return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

                  case GFXFormat.BC2_SRGB:
                    return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

                  case GFXFormat.BC3:
                    return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                  case GFXFormat.BC3_SRGB:
                    return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

                  case GFXFormat.ETC_RGB8:
                    return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

                  case GFXFormat.PVRTC_RGB2:
                    return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

                  case GFXFormat.PVRTC_RGBA2:
                    return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

                  case GFXFormat.PVRTC_RGB4:
                    return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

                  case GFXFormat.PVRTC_RGBA4:
                    return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

                  default:
                    return console.error("Unsupported GFXFormat, convert to WebGL format failed."), 
                    gl.RGBA;
                }
            }
            function GFXTypeToWebGLType$1(type, gl) {
                switch (type) {
                  case GFXType.BOOL:
                    return gl.BOOL;

                  case GFXType.BOOL2:
                    return gl.BOOL_VEC2;

                  case GFXType.BOOL3:
                    return gl.BOOL_VEC3;

                  case GFXType.BOOL4:
                    return gl.BOOL_VEC4;

                  case GFXType.INT:
                    return gl.INT;

                  case GFXType.INT2:
                    return gl.INT_VEC2;

                  case GFXType.INT3:
                    return gl.INT_VEC3;

                  case GFXType.INT4:
                    return gl.INT_VEC4;

                  case GFXType.UINT:
                    return gl.UNSIGNED_INT;

                  case GFXType.FLOAT:
                    return gl.FLOAT;

                  case GFXType.FLOAT2:
                    return gl.FLOAT_VEC2;

                  case GFXType.FLOAT3:
                    return gl.FLOAT_VEC3;

                  case GFXType.FLOAT4:
                    return gl.FLOAT_VEC4;

                  case GFXType.MAT2:
                    return gl.FLOAT_MAT2;

                  case GFXType.MAT2X3:
                    return gl.FLOAT_MAT2x3;

                  case GFXType.MAT2X4:
                    return gl.FLOAT_MAT2x4;

                  case GFXType.MAT3X2:
                    return gl.FLOAT_MAT3x2;

                  case GFXType.MAT3:
                    return gl.FLOAT_MAT3;

                  case GFXType.MAT3X4:
                    return gl.FLOAT_MAT3x4;

                  case GFXType.MAT4X2:
                    return gl.FLOAT_MAT4x2;

                  case GFXType.MAT4X3:
                    return gl.FLOAT_MAT4x3;

                  case GFXType.MAT4:
                    return gl.FLOAT_MAT4;

                  case GFXType.SAMPLER2D:
                    return gl.SAMPLER_2D;

                  case GFXType.SAMPLER2D_ARRAY:
                    return gl.SAMPLER_2D_ARRAY;

                  case GFXType.SAMPLER3D:
                    return gl.SAMPLER_3D;

                  case GFXType.SAMPLER_CUBE:
                    return gl.SAMPLER_CUBE;

                  default:
                    return console.error("Unsupported GLType, convert to GL type failed."), GFXType.UNKNOWN;
                }
            }
            function WebGLTypeToGFXType$1(glType, gl) {
                switch (glType) {
                  case gl.BOOL:
                    return GFXType.BOOL;

                  case gl.BOOL_VEC2:
                    return GFXType.BOOL2;

                  case gl.BOOL_VEC3:
                    return GFXType.BOOL3;

                  case gl.BOOL_VEC4:
                    return GFXType.BOOL4;

                  case gl.INT:
                    return GFXType.INT;

                  case gl.INT_VEC2:
                    return GFXType.INT2;

                  case gl.INT_VEC3:
                    return GFXType.INT3;

                  case gl.INT_VEC4:
                    return GFXType.INT4;

                  case gl.UNSIGNED_INT:
                    return GFXType.UINT;

                  case gl.UNSIGNED_INT_VEC2:
                    return GFXType.UINT2;

                  case gl.UNSIGNED_INT_VEC3:
                    return GFXType.UINT3;

                  case gl.UNSIGNED_INT_VEC4:
                    return GFXType.UINT4;

                  case gl.UNSIGNED_INT:
                    return GFXType.UINT;

                  case gl.FLOAT:
                    return GFXType.FLOAT;

                  case gl.FLOAT_VEC2:
                    return GFXType.FLOAT2;

                  case gl.FLOAT_VEC3:
                    return GFXType.FLOAT3;

                  case gl.FLOAT_VEC4:
                    return GFXType.FLOAT4;

                  case gl.FLOAT_MAT2:
                    return GFXType.MAT2;

                  case gl.FLOAT_MAT2x3:
                    return GFXType.MAT2X3;

                  case gl.FLOAT_MAT2x4:
                    return GFXType.MAT2X4;

                  case gl.FLOAT_MAT3x2:
                    return GFXType.MAT3X2;

                  case gl.FLOAT_MAT3:
                    return GFXType.MAT3;

                  case gl.FLOAT_MAT3x4:
                    return GFXType.MAT3X4;

                  case gl.FLOAT_MAT4x2:
                    return GFXType.MAT4X2;

                  case gl.FLOAT_MAT4x3:
                    return GFXType.MAT4X3;

                  case gl.FLOAT_MAT4:
                    return GFXType.MAT4;

                  case gl.SAMPLER_2D:
                    return GFXType.SAMPLER2D;

                  case gl.SAMPLER_2D_ARRAY:
                    return GFXType.SAMPLER2D_ARRAY;

                  case gl.SAMPLER_3D:
                    return GFXType.SAMPLER3D;

                  case gl.SAMPLER_CUBE:
                    return GFXType.SAMPLER_CUBE;

                  default:
                    return console.error("Unsupported GLType, convert to GFXType failed."), GFXType.UNKNOWN;
                }
            }
            function WebGLGetTypeSize$1(glType, gl) {
                switch (glType) {
                  case gl.BOOL:
                    return 4;

                  case gl.BOOL_VEC2:
                    return 8;

                  case gl.BOOL_VEC3:
                    return 12;

                  case gl.BOOL_VEC4:
                    return 16;

                  case gl.INT:
                    return 4;

                  case gl.INT_VEC2:
                    return 8;

                  case gl.INT_VEC3:
                    return 12;

                  case gl.INT_VEC4:
                    return 16;

                  case gl.UNSIGNED_INT:
                    return 4;

                  case gl.UNSIGNED_INT_VEC2:
                    return 8;

                  case gl.UNSIGNED_INT_VEC3:
                    return 12;

                  case gl.UNSIGNED_INT_VEC4:
                    return 16;

                  case gl.FLOAT:
                    return 4;

                  case gl.FLOAT_VEC2:
                    return 8;

                  case gl.FLOAT_VEC3:
                    return 12;

                  case gl.FLOAT_VEC4:
                  case gl.FLOAT_MAT2:
                    return 16;

                  case gl.FLOAT_MAT2x3:
                    return 24;

                  case gl.FLOAT_MAT2x4:
                    return 32;

                  case gl.FLOAT_MAT3x2:
                    return 24;

                  case gl.FLOAT_MAT3:
                    return 36;

                  case gl.FLOAT_MAT3x4:
                    return 48;

                  case gl.FLOAT_MAT4x2:
                    return 32;

                  case gl.FLOAT_MAT4x3:
                    return 48;

                  case gl.FLOAT_MAT4:
                    return 64;

                  case gl.SAMPLER_2D:
                  case gl.SAMPLER_2D_ARRAY:
                  case gl.SAMPLER_2D_ARRAY_SHADOW:
                  case gl.SAMPLER_3D:
                  case gl.SAMPLER_CUBE:
                  case gl.INT_SAMPLER_2D:
                  case gl.INT_SAMPLER_2D_ARRAY:
                  case gl.INT_SAMPLER_3D:
                  case gl.INT_SAMPLER_CUBE:
                  case gl.UNSIGNED_INT_SAMPLER_2D:
                  case gl.UNSIGNED_INT_SAMPLER_2D_ARRAY:
                  case gl.UNSIGNED_INT_SAMPLER_3D:
                  case gl.UNSIGNED_INT_SAMPLER_CUBE:
                    return 4;

                  default:
                    return console.error("Unsupported GLType, get type failed."), 0;
                }
            }
            function WebGLGetComponentCount$1(glType, gl) {
                switch (glType) {
                  case gl.FLOAT_MAT2:
                  case gl.FLOAT_MAT2x3:
                  case gl.FLOAT_MAT2x4:
                    return 2;

                  case gl.FLOAT_MAT3x2:
                  case gl.FLOAT_MAT3:
                  case gl.FLOAT_MAT3x4:
                    return 3;

                  case gl.FLOAT_MAT4x2:
                  case gl.FLOAT_MAT4x3:
                  case gl.FLOAT_MAT4:
                    return 4;

                  default:
                    return 1;
                }
            }
            var WebGL2Cmd, WebGLCmpFuncs$1 = [ 512, 513, 514, 515, 516, 517, 518, 519 ], WebGLStencilOps$1 = [ 0, 7680, 7681, 7682, 7683, 5386, 34055, 34056 ], WebGLBlendOps$1 = [ 32774, 32778, 32779, 32774, 32774 ], WebGLBlendFactors$1 = [ 0, 1, 770, 772, 771, 773, 768, 774, 769, 775, 776, 32769, 32770, 32771, 32772 ];
            !function(WebGL2Cmd) {
                WebGL2Cmd[WebGL2Cmd.BEGIN_RENDER_PASS = 0] = "BEGIN_RENDER_PASS", WebGL2Cmd[WebGL2Cmd.END_RENDER_PASS = 1] = "END_RENDER_PASS", 
                WebGL2Cmd[WebGL2Cmd.BIND_STATES = 2] = "BIND_STATES", WebGL2Cmd[WebGL2Cmd.DRAW = 3] = "DRAW", 
                WebGL2Cmd[WebGL2Cmd.UPDATE_BUFFER = 4] = "UPDATE_BUFFER", WebGL2Cmd[WebGL2Cmd.COPY_BUFFER_TO_TEXTURE = 5] = "COPY_BUFFER_TO_TEXTURE", 
                WebGL2Cmd[WebGL2Cmd.COUNT = 6] = "COUNT";
            }(WebGL2Cmd = WebGL2Cmd || {});
            function WebGL2CmdObject(type) {
                _classCallCheck(this, WebGL2CmdObject), this.cmdType = void 0, this.refCount = 0, 
                this.cmdType = type;
            }
            var WebGL2CmdBeginRenderPass = function() {
                function WebGL2CmdBeginRenderPass() {
                    var _this;
                    return _classCallCheck(this, WebGL2CmdBeginRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2CmdBeginRenderPass).call(this, WebGL2Cmd.BEGIN_RENDER_PASS))).gpuFramebuffer = null, 
                    _this.renderArea = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }, _this.clearFlag = GFXClearFlag.NONE, _this.clearColors = [], _this.clearDepth = 1, 
                    _this.clearStencil = 0, _this;
                }
                return _inherits(WebGL2CmdBeginRenderPass, WebGL2CmdObject), _createClass(WebGL2CmdBeginRenderPass, [ {
                    key: "clear",
                    value: function clear() {
                        this.gpuFramebuffer = null, this.clearColors = [];
                    }
                } ]), WebGL2CmdBeginRenderPass;
            }(), WebGL2CmdBindStates = function() {
                function WebGL2CmdBindStates() {
                    var _this2;
                    return _classCallCheck(this, WebGL2CmdBindStates), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2CmdBindStates).call(this, WebGL2Cmd.BIND_STATES))).gpuPipelineState = null, 
                    _this2.gpuBindingLayout = null, _this2.gpuInputAssembler = null, _this2.viewport = null, 
                    _this2.scissor = null, _this2.lineWidth = null, _this2.depthBias = null, _this2.blendConstants = null, 
                    _this2.depthBounds = null, _this2.stencilWriteMask = null, _this2.stencilCompareMask = null, 
                    _this2;
                }
                return _inherits(WebGL2CmdBindStates, WebGL2CmdObject), _createClass(WebGL2CmdBindStates, [ {
                    key: "clear",
                    value: function clear() {
                        this.gpuPipelineState = null, this.gpuBindingLayout = null, this.gpuInputAssembler = null, 
                        this.viewport = null, this.scissor = null, this.lineWidth = null, this.depthBias = null, 
                        this.blendConstants = null, this.depthBounds = null, this.stencilWriteMask = null, 
                        this.stencilCompareMask = null;
                    }
                } ]), WebGL2CmdBindStates;
            }(), WebGL2CmdDraw = function() {
                function WebGL2CmdDraw() {
                    var _this3;
                    return _classCallCheck(this, WebGL2CmdDraw), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2CmdDraw).call(this, WebGL2Cmd.DRAW))).drawInfo = {
                        vertexCount: 0,
                        firstVertex: 0,
                        indexCount: 0,
                        firstIndex: 0,
                        vertexOffset: 0,
                        instanceCount: 0,
                        firstInstance: 0
                    }, _this3;
                }
                return _inherits(WebGL2CmdDraw, WebGL2CmdObject), _createClass(WebGL2CmdDraw, [ {
                    key: "clear",
                    value: function clear() {}
                } ]), WebGL2CmdDraw;
            }(), WebGL2CmdUpdateBuffer = function() {
                function WebGL2CmdUpdateBuffer() {
                    var _this4;
                    return _classCallCheck(this, WebGL2CmdUpdateBuffer), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2CmdUpdateBuffer).call(this, WebGL2Cmd.UPDATE_BUFFER))).gpuBuffer = null, 
                    _this4.buffer = null, _this4.offset = 0, _this4.size = 0, _this4;
                }
                return _inherits(WebGL2CmdUpdateBuffer, WebGL2CmdObject), _createClass(WebGL2CmdUpdateBuffer, [ {
                    key: "clear",
                    value: function clear() {
                        this.gpuBuffer = null, this.buffer = null;
                    }
                } ]), WebGL2CmdUpdateBuffer;
            }(), WebGL2CmdCopyBufferToTexture = function() {
                function WebGL2CmdCopyBufferToTexture() {
                    var _this5;
                    return _classCallCheck(this, WebGL2CmdCopyBufferToTexture), (_this5 = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2CmdCopyBufferToTexture).call(this, WebGL2Cmd.COPY_BUFFER_TO_TEXTURE))).gpuBuffer = null, 
                    _this5.gpuTexture = null, _this5.dstLayout = null, _this5.regions = [], _this5;
                }
                return _inherits(WebGL2CmdCopyBufferToTexture, WebGL2CmdObject), _createClass(WebGL2CmdCopyBufferToTexture, [ {
                    key: "clear",
                    value: function clear() {
                        this.gpuBuffer = null, this.gpuTexture = null, this.dstLayout = null, this.regions = [];
                    }
                } ]), WebGL2CmdCopyBufferToTexture;
            }(), WebGL2CmdPackage = function() {
                function WebGL2CmdPackage() {
                    _classCallCheck(this, WebGL2CmdPackage), this.cmds = new CachedArray(1), this.beginRenderPassCmds = new CachedArray(1), 
                    this.bindStatesCmds = new CachedArray(1), this.drawCmds = new CachedArray(1), this.updateBufferCmds = new CachedArray(1), 
                    this.copyBufferToTextureCmds = new CachedArray(1);
                }
                return _createClass(WebGL2CmdPackage, [ {
                    key: "clearCmds",
                    value: function clearCmds(allocator) {
                        this.beginRenderPassCmds.length && (allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds), 
                        this.beginRenderPassCmds.clear()), this.bindStatesCmds.length && (allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds), 
                        this.bindStatesCmds.clear()), this.drawCmds.length && (allocator.drawCmdPool.freeCmds(this.drawCmds), 
                        this.drawCmds.clear()), this.updateBufferCmds.length && (allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds), 
                        this.updateBufferCmds.clear()), this.copyBufferToTextureCmds.length && (allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds), 
                        this.copyBufferToTextureCmds.clear()), this.cmds.clear();
                    }
                } ]), WebGL2CmdPackage;
            }();
            function WebGL2CmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
                if (gpuBuffer.usage & GFXBufferUsageBit.INDIRECT) gpuBuffer.indirects = buffer.drawInfos; else {
                    var buff = buffer, gl = device.gl, cache = device.stateCache;
                    switch (gpuBuffer.glTarget) {
                      case gl.ARRAY_BUFFER:
                        cache.glVAO && (gl.bindVertexArray(null), cache.glVAO = null), cache.glArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                        cache.glArrayBuffer = gpuBuffer.glBuffer), size === buff.byteLength ? gl.bufferSubData(gpuBuffer.glTarget, offset, buff) : gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                        break;

                      case gl.ELEMENT_ARRAY_BUFFER:
                        cache.glVAO && (gl.bindVertexArray(null), cache.glVAO = null), cache.glElementArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                        cache.glElementArrayBuffer = gpuBuffer.glBuffer), size === buff.byteLength ? gl.bufferSubData(gpuBuffer.glTarget, offset, buff) : gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                        break;

                      case gl.UNIFORM_BUFFER:
                        var buf;
                        cache.glUniformBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer), 
                        cache.glUniformBuffer = gpuBuffer.glBuffer), size === (buf = buffer instanceof Float32Array ? buffer : new Float32Array(buff, 0, size / 4)).byteLength ? gl.bufferSubData(gpuBuffer.glTarget, offset, buf) : gl.bufferSubData(gpuBuffer.glTarget, offset, new Float32Array(buf.buffer, 0, size / 4));
                        break;

                      default:
                        return void console.error("Unsupported GFXBufferType, update buffer failed.");
                    }
                }
            }
            var cmdIds$1 = new Array(WebGL2Cmd.COUNT);
            function WebGL2CmdFuncExecuteCmds(device, cmdPackage) {
                for (var gl = device.gl, cache = device.stateCache, i = 0; i < WebGL2Cmd.COUNT; ++i) cmdIds$1[i] = 0;
                for (var gpuPipelineState = null, gpuShader = null, isShaderChanged = !1, gpuInputAssembler = null, glPrimitive = gl.TRIANGLES, _i17 = 0; _i17 < cmdPackage.cmds.length; ++_i17) {
                    var cmd = cmdPackage.cmds.array[_i17], cmdId = cmdIds$1[cmd]++;
                    switch (cmd) {
                      case WebGL2Cmd.BEGIN_RENDER_PASS:
                        var cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId], clears = 0;
                        if (cmd0.gpuFramebuffer) {
                            cache.glFramebuffer !== cmd0.gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, cmd0.gpuFramebuffer.glFramebuffer), 
                            cache.glFramebuffer = cmd0.gpuFramebuffer.glFramebuffer), cache.viewport.left === cmd0.renderArea.x && cache.viewport.top === cmd0.renderArea.y && cache.viewport.width === cmd0.renderArea.width && cache.viewport.height === cmd0.renderArea.height || (gl.viewport(cmd0.renderArea.x, cmd0.renderArea.y, cmd0.renderArea.width, cmd0.renderArea.height), 
                            cache.viewport.left = cmd0.renderArea.x, cache.viewport.top = cmd0.renderArea.y, 
                            cache.viewport.width = cmd0.renderArea.width, cache.viewport.height = cmd0.renderArea.height), 
                            cache.scissorRect.x === cmd0.renderArea.x && cache.scissorRect.y === cmd0.renderArea.y && cache.scissorRect.width === cmd0.renderArea.width && cache.scissorRect.height === cmd0.renderArea.height || (gl.scissor(cmd0.renderArea.x, cmd0.renderArea.y, cmd0.renderArea.width, cmd0.renderArea.height), 
                            cache.scissorRect.x = cmd0.renderArea.x, cache.scissorRect.y = cmd0.renderArea.y, 
                            cache.scissorRect.width = cmd0.renderArea.width, cache.scissorRect.height = cmd0.renderArea.height);
                            for (var curGPURenderPass = cmd0.gpuFramebuffer.gpuRenderPass, invalidateAttachments = [], j = 0; j < cmd0.clearColors.length; ++j) {
                                var colorAttachment = curGPURenderPass.colorAttachments[j];
                                if (colorAttachment.format !== GFXFormat.UNKNOWN) switch (colorAttachment.loadOp) {
                                  case GFXLoadOp.LOAD:
                                    break;

                                  case GFXLoadOp.CLEAR:
                                    if (cmd0.clearFlag & GFXClearFlag.COLOR) if (cache.bs.targets[0].blendColorMask !== GFXColorMask.ALL && gl.colorMask(!0, !0, !0, !0), 
                                    cmd0.gpuFramebuffer.isOffscreen) _f32v4[0] = cmd0.clearColors[j].r, _f32v4[1] = cmd0.clearColors[j].g, 
                                    _f32v4[2] = cmd0.clearColors[j].b, _f32v4[3] = cmd0.clearColors[j].a, gl.clearBufferfv(gl.COLOR, j, _f32v4); else {
                                        var clearColor = cmd0.clearColors[0];
                                        gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a), clears |= gl.COLOR_BUFFER_BIT;
                                    }
                                    break;

                                  case GFXLoadOp.DISCARD:
                                    invalidateAttachments.push(gl.COLOR_ATTACHMENT0 + j);
                                }
                            }
                            if (curGPURenderPass.depthStencilAttachment && curGPURenderPass.depthStencilAttachment.format !== GFXFormat.UNKNOWN) {
                                switch (curGPURenderPass.depthStencilAttachment.depthLoadOp) {
                                  case GFXLoadOp.LOAD:
                                    break;

                                  case GFXLoadOp.CLEAR:
                                    cmd0.clearFlag & GFXClearFlag.DEPTH && (cache.dss.depthWrite || gl.depthMask(!0), 
                                    gl.clearDepth(cmd0.clearDepth), clears |= gl.DEPTH_BUFFER_BIT);
                                    break;

                                  case GFXLoadOp.DISCARD:
                                    invalidateAttachments.push(gl.DEPTH_ATTACHMENT);
                                }
                                if (GFXFormatInfos[curGPURenderPass.depthStencilAttachment.format].hasStencil) switch (curGPURenderPass.depthStencilAttachment.stencilLoadOp) {
                                  case GFXLoadOp.LOAD:
                                    break;

                                  case GFXLoadOp.CLEAR:
                                    cmd0.clearFlag & GFXClearFlag.STENCIL && (cache.dss.stencilWriteMaskFront || gl.stencilMaskSeparate(gl.FRONT, 4294967295), 
                                    cache.dss.stencilWriteMaskBack || gl.stencilMaskSeparate(gl.BACK, 4294967295), gl.clearStencil(cmd0.clearStencil), 
                                    clears |= gl.STENCIL_BUFFER_BIT);
                                    break;

                                  case GFXLoadOp.DISCARD:
                                    invalidateAttachments.push(gl.STENCIL_ATTACHMENT);
                                }
                            }
                            if (invalidateAttachments.length && gl.invalidateFramebuffer(gl.FRAMEBUFFER, invalidateAttachments), 
                            clears && gl.clear(clears), clears & gl.COLOR_BUFFER_BIT) {
                                var colorMask = cache.bs.targets[0].blendColorMask;
                                if (colorMask !== GFXColorMask.ALL) {
                                    var r = (colorMask & GFXColorMask.R) !== GFXColorMask.NONE, g = (colorMask & GFXColorMask.G) !== GFXColorMask.NONE, b = (colorMask & GFXColorMask.B) !== GFXColorMask.NONE, a = (colorMask & GFXColorMask.A) !== GFXColorMask.NONE;
                                    gl.colorMask(r, g, b, a);
                                }
                            }
                            clears & gl.DEPTH_BUFFER_BIT && !cache.dss.depthWrite && gl.depthMask(!1), clears & gl.STENCIL_BUFFER_BIT && (cache.dss.stencilWriteMaskFront || gl.stencilMaskSeparate(gl.FRONT, 0), 
                            cache.dss.stencilWriteMaskBack || gl.stencilMaskSeparate(gl.BACK, 0));
                        }
                        break;

                      case WebGL2Cmd.END_RENDER_PASS:
                        break;

                      case WebGL2Cmd.BIND_STATES:
                        var cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
                        if (isShaderChanged = !1, cmd2.gpuPipelineState) {
                            if (gpuPipelineState = cmd2.gpuPipelineState, glPrimitive = cmd2.gpuPipelineState.glPrimitive, 
                            cmd2.gpuPipelineState.gpuShader) {
                                var glProgram = cmd2.gpuPipelineState.gpuShader.glProgram;
                                cache.glProgram !== glProgram && (gl.useProgram(glProgram), cache.glProgram = glProgram, 
                                isShaderChanged = !0), gpuShader = cmd2.gpuPipelineState.gpuShader;
                            }
                            var rs = cmd2.gpuPipelineState.rs;
                            if (rs) {
                                if (cache.rs.cullMode !== rs.cullMode) {
                                    switch (rs.cullMode) {
                                      case GFXCullMode.NONE:
                                        gl.disable(gl.CULL_FACE);
                                        break;

                                      case GFXCullMode.FRONT:
                                        gl.enable(gl.CULL_FACE), gl.cullFace(gl.FRONT);
                                        break;

                                      case GFXCullMode.BACK:
                                        gl.enable(gl.CULL_FACE), gl.cullFace(gl.BACK);
                                    }
                                    device.stateCache.rs.cullMode = rs.cullMode;
                                }
                                device.stateCache.rs.isFrontFaceCCW !== rs.isFrontFaceCCW && (gl.frontFace(rs.isFrontFaceCCW ? gl.CCW : gl.CW), 
                                device.stateCache.rs.isFrontFaceCCW = rs.isFrontFaceCCW), device.stateCache.rs.depthBias === rs.depthBias && device.stateCache.rs.depthBiasSlop === rs.depthBiasSlop || (gl.polygonOffset(rs.depthBias, rs.depthBiasSlop), 
                                device.stateCache.rs.depthBias = rs.depthBias, device.stateCache.rs.depthBiasSlop = rs.depthBiasSlop), 
                                device.stateCache.rs.lineWidth !== rs.lineWidth && (gl.lineWidth(rs.lineWidth), 
                                device.stateCache.rs.lineWidth = rs.lineWidth);
                            }
                            var dss = cmd2.gpuPipelineState.dss;
                            dss && (cache.dss.depthTest !== dss.depthTest && (dss.depthTest ? gl.enable(gl.DEPTH_TEST) : gl.disable(gl.DEPTH_TEST), 
                            cache.dss.depthTest = dss.depthTest), cache.dss.depthWrite !== dss.depthWrite && (gl.depthMask(dss.depthWrite), 
                            cache.dss.depthWrite = dss.depthWrite), cache.dss.depthFunc !== dss.depthFunc && (gl.depthFunc(WebGLCmpFuncs$1[dss.depthFunc]), 
                            cache.dss.depthFunc = dss.depthFunc), cache.dss.stencilTestFront === dss.stencilTestFront && cache.dss.stencilTestBack === dss.stencilTestBack || (dss.stencilTestFront || dss.stencilTestBack ? gl.enable(gl.STENCIL_TEST) : gl.disable(gl.STENCIL_TEST), 
                            cache.dss.stencilTestFront = dss.stencilTestFront, cache.dss.stencilTestBack = dss.stencilTestBack), 
                            cache.dss.stencilFuncFront === dss.stencilFuncFront && cache.dss.stencilRefFront === dss.stencilRefFront && cache.dss.stencilReadMaskFront === dss.stencilReadMaskFront || (gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs$1[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront), 
                            cache.dss.stencilFuncFront = dss.stencilFuncFront, cache.dss.stencilRefFront = dss.stencilRefFront, 
                            cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront), cache.dss.stencilFailOpFront === dss.stencilFailOpFront && cache.dss.stencilZFailOpFront === dss.stencilZFailOpFront && cache.dss.stencilPassOpFront === dss.stencilPassOpFront || (gl.stencilOpSeparate(gl.FRONT, WebGLStencilOps$1[dss.stencilFailOpFront], WebGLStencilOps$1[dss.stencilZFailOpFront], WebGLStencilOps$1[dss.stencilPassOpFront]), 
                            cache.dss.stencilFailOpFront = dss.stencilFailOpFront, cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront, 
                            cache.dss.stencilPassOpFront = dss.stencilPassOpFront), cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront && (gl.stencilMaskSeparate(gl.FRONT, dss.stencilWriteMaskFront), 
                            cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront), cache.dss.stencilFuncBack === dss.stencilFuncBack && cache.dss.stencilRefBack === dss.stencilRefBack && cache.dss.stencilReadMaskBack === dss.stencilReadMaskBack || (gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs$1[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack), 
                            cache.dss.stencilFuncBack = dss.stencilFuncBack, cache.dss.stencilRefBack = dss.stencilRefBack, 
                            cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack), cache.dss.stencilFailOpBack === dss.stencilFailOpBack && cache.dss.stencilZFailOpBack === dss.stencilZFailOpBack && cache.dss.stencilPassOpBack === dss.stencilPassOpBack || (gl.stencilOpSeparate(gl.BACK, WebGLStencilOps$1[dss.stencilFailOpBack], WebGLStencilOps$1[dss.stencilZFailOpBack], WebGLStencilOps$1[dss.stencilPassOpBack]), 
                            cache.dss.stencilFailOpBack = dss.stencilFailOpBack, cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack, 
                            cache.dss.stencilPassOpBack = dss.stencilPassOpBack), cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack && (gl.stencilMaskSeparate(gl.BACK, dss.stencilWriteMaskBack), 
                            cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack));
                            var bs = cmd2.gpuPipelineState.bs;
                            if (bs) {
                                cache.bs.isA2C !== bs.isA2C && (bs.isA2C ? gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE), 
                                cache.bs.isA2C = bs.isA2C), cache.bs.blendColor[0] === bs.blendColor[0] && cache.bs.blendColor[1] === bs.blendColor[1] && cache.bs.blendColor[2] === bs.blendColor[2] && cache.bs.blendColor[3] === bs.blendColor[3] || (gl.blendColor(bs.blendColor[0], bs.blendColor[1], bs.blendColor[2], bs.blendColor[3]), 
                                cache.bs.blendColor[0] = bs.blendColor[0], cache.bs.blendColor[1] = bs.blendColor[1], 
                                cache.bs.blendColor[2] = bs.blendColor[2], cache.bs.blendColor[3] = bs.blendColor[3]);
                                var target0 = bs.targets[0], target0Cache = cache.bs.targets[0];
                                target0Cache.blend !== target0.blend && (target0.blend ? gl.enable(gl.BLEND) : gl.disable(gl.BLEND), 
                                target0Cache.blend = target0.blend), target0Cache.blendEq === target0.blendEq && target0Cache.blendAlphaEq === target0.blendAlphaEq || (gl.blendEquationSeparate(WebGLBlendOps$1[target0.blendEq], WebGLBlendOps$1[target0.blendAlphaEq]), 
                                target0Cache.blendEq = target0.blendEq, target0Cache.blendAlphaEq = target0.blendAlphaEq), 
                                target0Cache.blendSrc === target0.blendSrc && target0Cache.blendDst === target0.blendDst && target0Cache.blendSrcAlpha === target0.blendSrcAlpha && target0Cache.blendDstAlpha === target0.blendDstAlpha || (gl.blendFuncSeparate(WebGLBlendFactors$1[target0.blendSrc], WebGLBlendFactors$1[target0.blendDst], WebGLBlendFactors$1[target0.blendSrcAlpha], WebGLBlendFactors$1[target0.blendDstAlpha]), 
                                target0Cache.blendSrc = target0.blendSrc, target0Cache.blendDst = target0.blendDst, 
                                target0Cache.blendSrcAlpha = target0.blendSrcAlpha, target0Cache.blendDstAlpha = target0.blendDstAlpha), 
                                target0Cache.blendColorMask !== target0.blendColorMask && (gl.colorMask((target0.blendColorMask & GFXColorMask.R) !== GFXColorMask.NONE, (target0.blendColorMask & GFXColorMask.G) !== GFXColorMask.NONE, (target0.blendColorMask & GFXColorMask.B) !== GFXColorMask.NONE, (target0.blendColorMask & GFXColorMask.A) !== GFXColorMask.NONE), 
                                target0Cache.blendColorMask = target0.blendColorMask);
                            }
                        }
                        if (cmd2.gpuBindingLayout && gpuShader) {
                            var _iterator9 = cmd2.gpuBindingLayout.gpuBindings, _isArray9 = Array.isArray(_iterator9), _i18 = 0;
                            for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                                var _ref9;
                                if (_isArray9) {
                                    if (_i18 >= _iterator9.length) break;
                                    _ref9 = _iterator9[_i18++];
                                } else {
                                    if ((_i18 = _iterator9.next()).done) break;
                                    _ref9 = _i18.value;
                                }
                                var gpuBinding = _ref9;
                                switch (gpuBinding.type) {
                                  case GFXBindingType.UNIFORM_BUFFER:
                                    if (gpuBinding.gpuBuffer) {
                                        var _iterator10 = gpuShader.glBlocks, _isArray10 = Array.isArray(_iterator10), _i19 = 0;
                                        for (_iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator](); ;) {
                                            var _ref10;
                                            if (_isArray10) {
                                                if (_i19 >= _iterator10.length) break;
                                                _ref10 = _iterator10[_i19++];
                                            } else {
                                                if ((_i19 = _iterator10.next()).done) break;
                                                _ref10 = _i19.value;
                                            }
                                            var glBlock = _ref10;
                                            if (glBlock.binding === gpuBinding.binding) {
                                                cache.glBindUBOs[glBlock.binding] !== gpuBinding.gpuBuffer.glBuffer && (gl.bindBufferBase(gl.UNIFORM_BUFFER, glBlock.binding, gpuBinding.gpuBuffer.glBuffer), 
                                                cache.glBindUBOs[glBlock.binding] = gpuBinding.gpuBuffer.glBuffer, cache.glUniformBuffer = gpuBinding.gpuBuffer.glBuffer);
                                                break;
                                            }
                                        }
                                    }
                                    break;

                                  case GFXBindingType.SAMPLER:
                                    if (gpuBinding.gpuSampler) {
                                        var glSampler = null, _iterator11 = gpuShader.glSamplers, _isArray11 = Array.isArray(_iterator11), _i20 = 0;
                                        for (_iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator](); ;) {
                                            var _ref11;
                                            if (_isArray11) {
                                                if (_i20 >= _iterator11.length) break;
                                                _ref11 = _iterator11[_i20++];
                                            } else {
                                                if ((_i20 = _iterator11.next()).done) break;
                                                _ref11 = _i20.value;
                                            }
                                            var sampler = _ref11;
                                            if (sampler.binding === gpuBinding.binding) {
                                                glSampler = sampler;
                                                break;
                                            }
                                        }
                                        if (glSampler) {
                                            var _iterator12 = glSampler.units, _isArray12 = Array.isArray(_iterator12), _i21 = 0;
                                            for (_iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator](); ;) {
                                                var _ref12;
                                                if (_isArray12) {
                                                    if (_i21 >= _iterator12.length) break;
                                                    _ref12 = _iterator12[_i21++];
                                                } else {
                                                    if ((_i21 = _iterator12.next()).done) break;
                                                    _ref12 = _i21.value;
                                                }
                                                var texUnit = _ref12, glTexUnit = cache.glTexUnits[texUnit];
                                                if (gpuBinding.gpuTexView && 0 < gpuBinding.gpuTexView.gpuTexture.size) {
                                                    var gpuTexture = gpuBinding.gpuTexView.gpuTexture;
                                                    glTexUnit.glTexture !== gpuTexture.glTexture && (cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), 
                                                    cache.texUnit = texUnit), gpuTexture.glTexture ? gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture) : gl.bindTexture(gpuTexture.glTarget, device.nullTex2D.gpuTexture.glTexture), 
                                                    glTexUnit.glTexture = gpuTexture.glTexture);
                                                    var gpuSampler = gpuBinding.gpuSampler;
                                                    cache.glSamplerUnits[texUnit] !== gpuSampler.glSampler && (gl.bindSampler(texUnit, gpuSampler.glSampler), 
                                                    cache.glSamplerUnits[texUnit] = gpuSampler.glSampler);
                                                }
                                            }
                                        }
                                    } else console.error("Not found sampler on binding unit " + gpuBinding.binding);
                                }
                            }
                        }
                        if (cmd2.gpuInputAssembler && gpuShader && (isShaderChanged || gpuInputAssembler !== cmd2.gpuInputAssembler)) if (gpuInputAssembler = cmd2.gpuInputAssembler, 
                        device.useVAO) {
                            var glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);
                            if (!glVAO) {
                                glVAO = gl.createVertexArray(), gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO), 
                                gl.bindVertexArray(glVAO), gl.bindBuffer(gl.ARRAY_BUFFER, null), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                                var glAttrib = void 0, _iterator13 = gpuShader.glInputs, _isArray13 = Array.isArray(_iterator13), _i22 = 0;
                                for (_iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator](); ;) {
                                    var _ref13;
                                    if (_isArray13) {
                                        if (_i22 >= _iterator13.length) break;
                                        _ref13 = _iterator13[_i22++];
                                    } else {
                                        if ((_i22 = _iterator13.next()).done) break;
                                        _ref13 = _i22.value;
                                    }
                                    var glInput = _ref13;
                                    glAttrib = null;
                                    var _iterator14 = gpuInputAssembler.glAttribs, _isArray14 = Array.isArray(_iterator14), _i23 = 0;
                                    for (_iterator14 = _isArray14 ? _iterator14 : _iterator14[Symbol.iterator](); ;) {
                                        var _ref14;
                                        if (_isArray14) {
                                            if (_i23 >= _iterator14.length) break;
                                            _ref14 = _iterator14[_i23++];
                                        } else {
                                            if ((_i23 = _iterator14.next()).done) break;
                                            _ref14 = _i23.value;
                                        }
                                        var attrib = _ref14;
                                        if (attrib.name === glInput.name) {
                                            glAttrib = attrib;
                                            break;
                                        }
                                    }
                                    if (glAttrib) {
                                        gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                                        for (var c = 0; c < glAttrib.componentCount; ++c) {
                                            var glLoc = glInput.glLoc + c, attribOffset = glAttrib.offset + glAttrib.size * c;
                                            gl.enableVertexAttribArray(glLoc), cache.glCurrentAttribLocs[glLoc] = !0, gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset), 
                                            gl.vertexAttribDivisor(glLoc, glAttrib.isInstanced ? 1 : 0);
                                        }
                                    }
                                }
                                var gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
                                gpuBuffer && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), gl.bindVertexArray(null), 
                                gl.bindBuffer(gl.ARRAY_BUFFER, null), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), 
                                cache.glArrayBuffer = null, cache.glElementArrayBuffer = null;
                            }
                            cache.glVAO !== glVAO && (gl.bindVertexArray(glVAO), cache.glVAO = glVAO);
                        } else {
                            for (var _a = 0; _a < device.maxVertexAttributes; ++_a) cache.glCurrentAttribLocs[_a] = !1;
                            var _iterator15 = gpuShader.glInputs, _isArray15 = Array.isArray(_iterator15), _i24 = 0;
                            for (_iterator15 = _isArray15 ? _iterator15 : _iterator15[Symbol.iterator](); ;) {
                                var _ref15;
                                if (_isArray15) {
                                    if (_i24 >= _iterator15.length) break;
                                    _ref15 = _iterator15[_i24++];
                                } else {
                                    if ((_i24 = _iterator15.next()).done) break;
                                    _ref15 = _i24.value;
                                }
                                var _glInput = _ref15, _glAttrib = null, _iterator16 = gpuInputAssembler.glAttribs, _isArray16 = Array.isArray(_iterator16), _i25 = 0;
                                for (_iterator16 = _isArray16 ? _iterator16 : _iterator16[Symbol.iterator](); ;) {
                                    var _ref16;
                                    if (_isArray16) {
                                        if (_i25 >= _iterator16.length) break;
                                        _ref16 = _iterator16[_i25++];
                                    } else {
                                        if ((_i25 = _iterator16.next()).done) break;
                                        _ref16 = _i25.value;
                                    }
                                    var _attrib = _ref16;
                                    if (_attrib.name === _glInput.name) {
                                        _glAttrib = _attrib;
                                        break;
                                    }
                                }
                                if (_glAttrib) {
                                    cache.glArrayBuffer !== _glAttrib.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, _glAttrib.glBuffer), 
                                    cache.glArrayBuffer = _glAttrib.glBuffer);
                                    for (var _c = 0; _c < _glAttrib.componentCount; ++_c) {
                                        var _glLoc2 = _glInput.glLoc + _c, _attribOffset = _glAttrib.offset + _glAttrib.size * _c;
                                        !cache.glEnabledAttribLocs[_glLoc2] && 0 <= _glLoc2 && (gl.enableVertexAttribArray(_glLoc2), 
                                        cache.glEnabledAttribLocs[_glLoc2] = !0), cache.glCurrentAttribLocs[_glLoc2] = !0, 
                                        gl.vertexAttribPointer(_glLoc2, _glAttrib.count, _glAttrib.glType, _glAttrib.isNormalized, _glAttrib.stride, _attribOffset);
                                    }
                                }
                            }
                            var _gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
                            _gpuBuffer && cache.glElementArrayBuffer !== _gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _gpuBuffer.glBuffer), 
                            cache.glElementArrayBuffer = _gpuBuffer.glBuffer);
                            for (var _a2 = 0; _a2 < device.maxVertexAttributes; ++_a2) cache.glEnabledAttribLocs[_a2] !== cache.glCurrentAttribLocs[_a2] && (gl.disableVertexAttribArray(_a2), 
                            cache.glEnabledAttribLocs[_a2] = !1);
                        }
                        if (gpuPipelineState) {
                            var _iterator17 = gpuPipelineState.dynamicStates, _isArray17 = Array.isArray(_iterator17), _i26 = 0;
                            for (_iterator17 = _isArray17 ? _iterator17 : _iterator17[Symbol.iterator](); ;) {
                                var _ref17;
                                if (_isArray17) {
                                    if (_i26 >= _iterator17.length) break;
                                    _ref17 = _iterator17[_i26++];
                                } else {
                                    if ((_i26 = _iterator17.next()).done) break;
                                    _ref17 = _i26.value;
                                }
                                switch (_ref17) {
                                  case GFXDynamicState.VIEWPORT:
                                    cmd2.viewport && (cache.viewport.left === cmd2.viewport.left && cache.viewport.top === cmd2.viewport.top && cache.viewport.width === cmd2.viewport.width && cache.viewport.height === cmd2.viewport.height || (gl.viewport(cmd2.viewport.left, cmd2.viewport.top, cmd2.viewport.width, cmd2.viewport.height), 
                                    cache.viewport.left = cmd2.viewport.left, cache.viewport.top = cmd2.viewport.top, 
                                    cache.viewport.width = cmd2.viewport.width, cache.viewport.height = cmd2.viewport.height));
                                    break;

                                  case GFXDynamicState.SCISSOR:
                                    cmd2.scissor && (cache.scissorRect.x === cmd2.scissor.x && cache.scissorRect.y === cmd2.scissor.y && cache.scissorRect.width === cmd2.scissor.width && cache.scissorRect.height === cmd2.scissor.height || (gl.scissor(cmd2.scissor.x, cmd2.scissor.y, cmd2.scissor.width, cmd2.scissor.height), 
                                    cache.scissorRect.x = cmd2.scissor.x, cache.scissorRect.y = cmd2.scissor.y, cache.scissorRect.width = cmd2.scissor.width, 
                                    cache.scissorRect.height = cmd2.scissor.height));
                                    break;

                                  case GFXDynamicState.LINE_WIDTH:
                                    cmd2.lineWidth && cache.rs.lineWidth !== cmd2.lineWidth && (gl.lineWidth(cmd2.lineWidth), 
                                    cache.rs.lineWidth = cmd2.lineWidth);
                                    break;

                                  case GFXDynamicState.DEPTH_BIAS:
                                    cmd2.depthBias && (cache.rs.depthBias === cmd2.depthBias.constantFactor && cache.rs.depthBiasSlop === cmd2.depthBias.slopeFactor || (gl.polygonOffset(cmd2.depthBias.constantFactor, cmd2.depthBias.slopeFactor), 
                                    cache.rs.depthBias = cmd2.depthBias.constantFactor, cache.rs.depthBiasSlop = cmd2.depthBias.slopeFactor));
                                    break;

                                  case GFXDynamicState.BLEND_CONSTANTS:
                                    cmd2.blendConstants && (cache.bs.blendColor[0] === cmd2.blendConstants[0] && cache.bs.blendColor[1] === cmd2.blendConstants[1] && cache.bs.blendColor[2] === cmd2.blendConstants[2] && cache.bs.blendColor[3] === cmd2.blendConstants[3] || (gl.blendColor(cmd2.blendConstants[0], cmd2.blendConstants[1], cmd2.blendConstants[2], cmd2.blendConstants[3]), 
                                    cache.bs.blendColor[0] = cmd2.blendConstants[0], cache.bs.blendColor[1] = cmd2.blendConstants[1], 
                                    cache.bs.blendColor[2] = cmd2.blendConstants[2], cache.bs.blendColor[3] = cmd2.blendConstants[3]));
                                    break;

                                  case GFXDynamicState.STENCIL_WRITE_MASK:
                                    if (cmd2.stencilWriteMask) switch (cmd2.stencilWriteMask.face) {
                                      case GFXStencilFace.FRONT:
                                        cache.dss.stencilWriteMaskFront !== cmd2.stencilWriteMask.writeMask && (gl.stencilMaskSeparate(gl.FRONT, cmd2.stencilWriteMask.writeMask), 
                                        cache.dss.stencilWriteMaskFront = cmd2.stencilWriteMask.writeMask);
                                        break;

                                      case GFXStencilFace.BACK:
                                        cache.dss.stencilWriteMaskBack !== cmd2.stencilWriteMask.writeMask && (gl.stencilMaskSeparate(gl.BACK, cmd2.stencilWriteMask.writeMask), 
                                        cache.dss.stencilWriteMaskBack = cmd2.stencilWriteMask.writeMask);
                                        break;

                                      case GFXStencilFace.ALL:
                                        cache.dss.stencilWriteMaskFront === cmd2.stencilWriteMask.writeMask && cache.dss.stencilWriteMaskBack === cmd2.stencilWriteMask.writeMask || (gl.stencilMask(cmd2.stencilWriteMask.writeMask), 
                                        cache.dss.stencilWriteMaskFront = cmd2.stencilWriteMask.writeMask, cache.dss.stencilWriteMaskBack = cmd2.stencilWriteMask.writeMask);
                                    }
                                    break;

                                  case GFXDynamicState.STENCIL_COMPARE_MASK:
                                    if (cmd2.stencilCompareMask) switch (cmd2.stencilCompareMask.face) {
                                      case GFXStencilFace.FRONT:
                                        cache.dss.stencilRefFront === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskFront === cmd2.stencilCompareMask.compareMask || (gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs$1[cache.dss.stencilFuncFront], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                                        cache.dss.stencilRefFront = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskFront = cmd2.stencilCompareMask.compareMask);
                                        break;

                                      case GFXStencilFace.BACK:
                                        cache.dss.stencilRefBack === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskBack === cmd2.stencilCompareMask.compareMask || (gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs$1[cache.dss.stencilFuncBack], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                                        cache.dss.stencilRefBack = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskBack = cmd2.stencilCompareMask.compareMask);
                                        break;

                                      case GFXStencilFace.ALL:
                                        cache.dss.stencilRefFront === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskFront === cmd2.stencilCompareMask.compareMask && cache.dss.stencilRefBack === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskBack === cmd2.stencilCompareMask.compareMask || (gl.stencilFunc(WebGLCmpFuncs$1[cache.dss.stencilFuncBack], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                                        cache.dss.stencilRefFront = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskFront = cmd2.stencilCompareMask.compareMask, 
                                        cache.dss.stencilRefBack = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskBack = cmd2.stencilCompareMask.compareMask);
                                    }
                                }
                            }
                        }
                        break;

                      case WebGL2Cmd.DRAW:
                        var cmd3 = cmdPackage.drawCmds.array[cmdId];
                        if (gpuInputAssembler && gpuShader) if (gpuInputAssembler.gpuIndirectBuffer) {
                            if (gpuInputAssembler.gpuIndirectBuffer) {
                                var _iterator18 = gpuInputAssembler.gpuIndirectBuffer.indirects, _isArray18 = Array.isArray(_iterator18), _i27 = 0;
                                for (_iterator18 = _isArray18 ? _iterator18 : _iterator18[Symbol.iterator](); ;) {
                                    var _ref18;
                                    if (_isArray18) {
                                        if (_i27 >= _iterator18.length) break;
                                        _ref18 = _iterator18[_i27++];
                                    } else {
                                        if ((_i27 = _iterator18.next()).done) break;
                                        _ref18 = _i27.value;
                                    }
                                    var drawInfo = _ref18, _gpuBuffer2 = gpuInputAssembler.gpuIndexBuffer;
                                    if (_gpuBuffer2 && -1 < drawInfo.indexCount) {
                                        var _offset = drawInfo.firstIndex * _gpuBuffer2.stride;
                                        gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset);
                                    } else gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
                                }
                            }
                        } else if (gpuInputAssembler.gpuIndexBuffer && -1 < cmd3.drawInfo.indexCount) {
                            var offset = cmd3.drawInfo.firstIndex * gpuInputAssembler.gpuIndexBuffer.stride;
                            gl.drawElements(glPrimitive, cmd3.drawInfo.indexCount, gpuInputAssembler.glIndexType, offset);
                        } else gl.drawArrays(glPrimitive, cmd3.drawInfo.firstVertex, cmd3.drawInfo.vertexCount);
                        break;

                      case WebGL2Cmd.UPDATE_BUFFER:
                        var cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
                        WebGL2CmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
                        break;

                      case WebGL2Cmd.COPY_BUFFER_TO_TEXTURE:
                        var cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
                        WebGL2CmdFuncCopyBuffersToTexture(device, [ cmd5.gpuBuffer.buffer ], cmd5.gpuTexture, cmd5.regions);
                    }
                }
            }
            function WebGL2CmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
                var gl = device.gl, glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture), 
                glTexUnit.glTexture = gpuTexture.glTexture);
                var m = 0, n = 0, w = 1, h = 1, f = 0, fmtInfo = GFXFormatInfos[gpuTexture.format], isCompressed = fmtInfo.isCompressed;
                switch (gpuTexture.glTarget) {
                  case gl.TEXTURE_2D:
                    var _iterator21 = regions, _isArray21 = Array.isArray(_iterator21), _i30 = 0;
                    for (_iterator21 = _isArray21 ? _iterator21 : _iterator21[Symbol.iterator](); ;) {
                        var _ref21;
                        if (_isArray21) {
                            if (_i30 >= _iterator21.length) break;
                            _ref21 = _iterator21[_i30++];
                        } else {
                            if ((_i30 = _iterator21.next()).done) break;
                            _ref21 = _i30.value;
                        }
                        var region = _ref21;
                        for (w = region.texExtent.width, h = region.texExtent.height, m = region.texSubres.baseMipLevel; m < region.texSubres.levelCount; ++m) {
                            var pixels = fmtInfo.type !== GFXFormatType.FLOAT || isCompressed ? new Uint8Array(buffers[n++]) : new Float32Array(buffers[n++]);
                            isCompressed ? gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL ? gl.compressedTexSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, pixels) : gl.compressedTexImage2D(gl.TEXTURE_2D, m, gpuTexture.glInternelFmt, w, h, 0, pixels) : gl.texSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, pixels), 
                            w = Math.max(1, w >> 1), h = Math.max(1, w >> 1);
                        }
                    }
                    break;

                  case gl.TEXTURE_CUBE_MAP:
                    var _iterator22 = regions, _isArray22 = Array.isArray(_iterator22), _i31 = 0;
                    for (_iterator22 = _isArray22 ? _iterator22 : _iterator22[Symbol.iterator](); ;) {
                        var _ref22;
                        if (_isArray22) {
                            if (_i31 >= _iterator22.length) break;
                            _ref22 = _iterator22[_i31++];
                        } else {
                            if ((_i31 = _iterator22.next()).done) break;
                            _ref22 = _i31.value;
                        }
                        var _region2 = _ref22;
                        n = 0;
                        var fcount = _region2.texSubres.baseArrayLayer + _region2.texSubres.layerCount;
                        for (f = _region2.texSubres.baseArrayLayer; f < fcount; ++f) {
                            w = _region2.texExtent.width, h = _region2.texExtent.height;
                            var mcount = _region2.texSubres.baseMipLevel + _region2.texSubres.levelCount;
                            for (m = _region2.texSubres.baseMipLevel; m < mcount; ++m) {
                                var _pixels = fmtInfo.type !== GFXFormatType.FLOAT || isCompressed ? new Uint8Array(buffers[n++]) : new Float32Array(buffers[n++]);
                                isCompressed ? gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL ? gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, _pixels) : gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, gpuTexture.glInternelFmt, w, h, 0, _pixels) : gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, _pixels), 
                                w = Math.max(1, w >> 1), h = Math.max(1, w >> 1);
                            }
                        }
                    }
                    break;

                  default:
                    console.error("Unsupported GL texture type, copy buffer to texture failed.");
                }
                gpuTexture.flags & GFXTextureFlagBit.GEN_MIPMAP && gl.generateMipmap(gpuTexture.glTarget);
            }
            function WebGL2StateCache() {
                _classCallCheck(this, WebGL2StateCache), this.glArrayBuffer = null, this.glElementArrayBuffer = null, 
                this.glUniformBuffer = null, this.glBindUBOs = void 0, this.glVAO = null, this.texUnit = 0, 
                this.glTexUnits = void 0, this.glSamplerUnits = void 0, this.glRenderbuffer = null, 
                this.glFramebuffer = null, this.glReadFramebuffer = null, this.viewport = void 0, 
                this.scissorRect = void 0, this.rs = void 0, this.dss = void 0, this.bs = void 0, 
                this.glProgram = null, this.glEnabledAttribLocs = void 0, this.glCurrentAttribLocs = void 0, 
                this.glBindUBOs = new Array(GFX_MAX_BUFFER_BINDINGS), this.glBindUBOs.fill(null), 
                this.glTexUnits = new Array(GFX_MAX_TEXTURE_UNITS), this.glSamplerUnits = new Array(GFX_MAX_TEXTURE_UNITS), 
                this.glSamplerUnits.fill(null), this.viewport = {
                    left: 0,
                    top: 0,
                    width: 0,
                    height: 0,
                    minDepth: 0,
                    maxDepth: 0
                }, this.scissorRect = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                }, this.rs = new GFXRasterizerState(), this.dss = new GFXDepthStencilState(), this.bs = new GFXBlendState(), 
                this.glEnabledAttribLocs = new Array(GFX_MAX_VERTEX_ATTRIBUTES), this.glCurrentAttribLocs = new Array(GFX_MAX_VERTEX_ATTRIBUTES), 
                this.glEnabledAttribLocs.fill(!1), this.glCurrentAttribLocs.fill(!1);
                for (var i = 0; i < GFX_MAX_TEXTURE_UNITS; ++i) this.glTexUnits[i] = {
                    glTexture: null
                };
            }
            var WebGL2GFXBuffer = function() {
                function WebGL2GFXBuffer(device) {
                    var _this;
                    return _classCallCheck(this, WebGL2GFXBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXBuffer).call(this, device)))._gpuBuffer = null, 
                    _this._indirectBuffer = null, _this;
                }
                return _inherits(WebGL2GFXBuffer, GFXBuffer), _createClass(WebGL2GFXBuffer, [ {
                    key: "gpuBuffer",
                    get: function get() {
                        return this._gpuBuffer;
                    }
                } ]), _createClass(WebGL2GFXBuffer, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return this._usage = info.usage, this._memUsage = info.memUsage, this._size = info.size, 
                        this._stride = Math.max(info.stride || this._size, 1), this._count = this._size / this._stride, 
                        this._flags = void 0 !== info.flags ? info.flags : GFXBufferFlagBit.NONE, this._usage & GFXBufferUsageBit.INDIRECT && (this._indirectBuffer = {
                            drawInfos: []
                        }), this._flags & GFXBufferFlagBit.BAKUP_BUFFER && (this._bufferView = new Uint8Array(this._size)), 
                        this._gpuBuffer = {
                            usage: info.usage,
                            memUsage: info.memUsage,
                            size: info.size,
                            stride: this._stride,
                            buffer: null,
                            vf32: null,
                            indirects: [],
                            glTarget: 0,
                            glBuffer: null
                        }, info.usage & GFXBufferUsageBit.INDIRECT && (this._gpuBuffer.indirects = this._indirectBuffer.drawInfos), 
                        function WebGL2CmdFuncCreateBuffer(device, gpuBuffer) {
                            var gl = device.gl, cache = device.stateCache, glUsage = gpuBuffer.memUsage & GFXMemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
                            if (gpuBuffer.usage & GFXBufferUsageBit.VERTEX) {
                                gpuBuffer.glTarget = gl.ARRAY_BUFFER;
                                var glBuffer = gl.createBuffer();
                                glBuffer && (gpuBuffer.glBuffer = glBuffer, 0 < gpuBuffer.size && (device.useVAO && cache.glVAO && (gl.bindVertexArray(null), 
                                cache.glVAO = null), device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                                device.stateCache.glArrayBuffer = gpuBuffer.glBuffer), gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                                gl.bindBuffer(gl.ARRAY_BUFFER, null), device.stateCache.glArrayBuffer = null));
                            } else if (gpuBuffer.usage & GFXBufferUsageBit.INDEX) {
                                gpuBuffer.glTarget = gl.ELEMENT_ARRAY_BUFFER;
                                var _glBuffer = gl.createBuffer();
                                _glBuffer && (gpuBuffer.glBuffer = _glBuffer, 0 < gpuBuffer.size && (device.useVAO && cache.glVAO && (gl.bindVertexArray(null), 
                                cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                                device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer), gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), device.stateCache.glElementArrayBuffer = null));
                            } else if (gpuBuffer.usage & GFXBufferUsageBit.UNIFORM) {
                                gpuBuffer.glTarget = gl.UNIFORM_BUFFER;
                                var _glBuffer2 = gl.createBuffer();
                                _glBuffer2 && 0 < gpuBuffer.size && (gpuBuffer.glBuffer = _glBuffer2, device.stateCache.glUniformBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer), 
                                device.stateCache.glUniformBuffer = gpuBuffer.glBuffer), gl.bufferData(gl.UNIFORM_BUFFER, gpuBuffer.size, glUsage), 
                                gl.bindBuffer(gl.UNIFORM_BUFFER, null), device.stateCache.glUniformBuffer = null);
                            } else gpuBuffer.usage & GFXBufferUsageBit.INDIRECT || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_DST || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_SRC || console.error("Unsupported GFXBufferType, create buffer failed."), 
                            gpuBuffer.glTarget = gl.NONE;
                        }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize += this._size, 
                        this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._gpuBuffer && (!function WebGL2CmdFuncDestroyBuffer(device, gpuBuffer) {
                            gpuBuffer.glBuffer && (device.gl.deleteBuffer(gpuBuffer.glBuffer), gpuBuffer.glBuffer = null);
                        }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize -= this._size, 
                        this._gpuBuffer = null), this._bufferView = null, this._status = GFXStatus.UNREADY;
                    }
                }, {
                    key: "resize",
                    value: function resize(size) {
                        var oldSize = this._size;
                        if (this._size = size, this._count = this._size / this._stride, this._bufferView && oldSize !== size) {
                            var oldView = this._bufferView;
                            this._bufferView = new Uint8Array(this._size), this._bufferView.set(oldView), this._gpuBuffer && (this._gpuBuffer.buffer = this._bufferView.buffer);
                        }
                        this._gpuBuffer && (this._gpuBuffer.size = this._size, 0 < this._size && (function WebGL2CmdFuncResizeBuffer(device, gpuBuffer) {
                            var gl = device.gl, cache = device.stateCache, glUsage = gpuBuffer.memUsage & GFXMemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
                            gpuBuffer.usage & GFXBufferUsageBit.VERTEX ? (device.useVAO && cache.glVAO && (gl.bindVertexArray(null), 
                            cache.glVAO = null), cache.glArrayBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                            gpuBuffer.buffer ? gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.buffer, glUsage) : gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                            gl.bindBuffer(gl.ARRAY_BUFFER, null), cache.glArrayBuffer = null) : gpuBuffer.usage & GFXBufferUsageBit.INDEX ? (device.useVAO && cache.glVAO && (gl.bindVertexArray(null), 
                            cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                            gpuBuffer.buffer ? gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.buffer, glUsage) : gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), device.stateCache.glElementArrayBuffer = null) : gpuBuffer.usage & GFXBufferUsageBit.UNIFORM ? (device.stateCache.glUniformBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer), 
                            gl.bufferData(gl.UNIFORM_BUFFER, gpuBuffer.size, glUsage), gl.bindBuffer(gl.UNIFORM_BUFFER, null), 
                            device.stateCache.glUniformBuffer = null) : (gpuBuffer.usage & GFXBufferUsageBit.INDIRECT || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_DST || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_SRC || console.error("Unsupported GFXBufferType, create buffer failed."), 
                            gpuBuffer.glTarget = gl.NONE);
                        }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize -= oldSize, 
                        this._device.memoryStatus.bufferSize += this._size, this._bufferView && (this._device.memoryStatus.bufferSize -= oldSize, 
                        this._device.memoryStatus.bufferSize += this._size)));
                    }
                }, {
                    key: "update",
                    value: function update(buffer, offset, size) {
                        var buffSize;
                        if (buffSize = void 0 !== size ? size : this._usage & GFXBufferUsageBit.INDIRECT ? 0 : buffer.byteLength, 
                        this._bufferView) {
                            var view = new Uint8Array(buffer, 0, size);
                            this._bufferView.set(view, offset);
                        }
                        WebGL2CmdFuncUpdateBuffer(this._device, this._gpuBuffer, buffer, offset || 0, buffSize);
                    }
                } ]), WebGL2GFXBuffer;
            }(), WebGL2GFXCommandPool = function() {
                function WebGL2GFXCommandPool(clazz, count) {
                    _classCallCheck(this, WebGL2GFXCommandPool), this._frees = void 0, this._freeIdx = 0, 
                    this._freeCmds = void 0, this._frees = new Array(count), this._freeCmds = new CachedArray(count);
                    for (var i = 0; i < count; ++i) this._frees[i] = new clazz();
                    this._freeIdx = count - 1;
                }
                return _createClass(WebGL2GFXCommandPool, [ {
                    key: "alloc",
                    value: function alloc(clazz) {
                        if (this._freeIdx < 0) {
                            var size = 2 * this._frees.length, temp = this._frees;
                            this._frees = new Array(size);
                            for (var increase = size - temp.length, i = 0; i < increase; ++i) this._frees[i] = new clazz();
                            for (var _i = increase, j = 0; _i < size; ++_i, ++j) this._frees[_i] = temp[j];
                            this._freeIdx += increase;
                        }
                        var cmd = this._frees[this._freeIdx];
                        return this._frees[this._freeIdx--] = null, ++cmd.refCount, cmd;
                    }
                }, {
                    key: "free",
                    value: function free(cmd) {
                        0 == --cmd.refCount && this._freeCmds.push(cmd);
                    }
                }, {
                    key: "freeCmds",
                    value: function freeCmds(cmds) {
                        for (var i = 0; i < cmds.length; ++i) 0 == --cmds.array[i].refCount && this._freeCmds.push(cmds.array[i]);
                    }
                }, {
                    key: "release",
                    value: function release() {
                        for (var i = 0; i < this._freeCmds.length; ++i) {
                            var cmd = this._freeCmds.array[i];
                            cmd.clear(), this._frees[++this._freeIdx] = cmd;
                        }
                        this._freeCmds.clear();
                    }
                } ]), WebGL2GFXCommandPool;
            }(), WebGL2GFXCommandAllocator = function() {
                function WebGL2GFXCommandAllocator(device) {
                    var _this;
                    return _classCallCheck(this, WebGL2GFXCommandAllocator), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXCommandAllocator).call(this, device))).beginRenderPassCmdPool = void 0, 
                    _this.bindStatesCmdPool = void 0, _this.drawCmdPool = void 0, _this.updateBufferCmdPool = void 0, 
                    _this.copyBufferToTextureCmdPool = void 0, _this.beginRenderPassCmdPool = new WebGL2GFXCommandPool(WebGL2CmdBeginRenderPass, 1), 
                    _this.bindStatesCmdPool = new WebGL2GFXCommandPool(WebGL2CmdBindStates, 1), _this.drawCmdPool = new WebGL2GFXCommandPool(WebGL2CmdDraw, 1), 
                    _this.updateBufferCmdPool = new WebGL2GFXCommandPool(WebGL2CmdUpdateBuffer, 1), 
                    _this.copyBufferToTextureCmdPool = new WebGL2GFXCommandPool(WebGL2CmdCopyBufferToTexture, 1), 
                    _this;
                }
                return _inherits(WebGL2GFXCommandAllocator, GFXCommandAllocator), _createClass(WebGL2GFXCommandAllocator, [ {
                    key: "initialize",
                    value: function initialize() {
                        return this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._status = GFXStatus.UNREADY;
                    }
                }, {
                    key: "clearCmds",
                    value: function clearCmds(cmdPackage) {
                        cmdPackage.beginRenderPassCmds.length && (this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds), 
                        cmdPackage.beginRenderPassCmds.clear()), cmdPackage.bindStatesCmds.length && (this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds), 
                        cmdPackage.bindStatesCmds.clear()), cmdPackage.drawCmds.length && (this.drawCmdPool.freeCmds(cmdPackage.drawCmds), 
                        cmdPackage.drawCmds.clear()), cmdPackage.updateBufferCmds.length && (this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds), 
                        cmdPackage.updateBufferCmds.clear()), cmdPackage.copyBufferToTextureCmds.length && (this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds), 
                        cmdPackage.copyBufferToTextureCmds.clear()), cmdPackage.cmds.clear();
                    }
                }, {
                    key: "releaseCmds",
                    value: function releaseCmds() {
                        this.beginRenderPassCmdPool.release(), this.bindStatesCmdPool.release(), this.drawCmdPool.release(), 
                        this.updateBufferCmdPool.release(), this.copyBufferToTextureCmdPool.release();
                    }
                } ]), WebGL2GFXCommandAllocator;
            }(), WebGL2GFXCommandBuffer = function() {
                function WebGL2GFXCommandBuffer(device) {
                    var _this;
                    return _classCallCheck(this, WebGL2GFXCommandBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXCommandBuffer).call(this, device))).cmdPackage = new WebGL2CmdPackage(), 
                    _this._webGLAllocator = null, _this._isInRenderPass = !1, _this._curGPUPipelineState = null, 
                    _this._curGPUBindingLayout = null, _this._curGPUInputAssembler = null, _this._curViewport = null, 
                    _this._curScissor = null, _this._curLineWidth = null, _this._curDepthBias = null, 
                    _this._curBlendConstants = [], _this._curDepthBounds = null, _this._curStencilWriteMask = null, 
                    _this._curStencilCompareMask = null, _this._isStateInvalied = !1, _this;
                }
                return _inherits(WebGL2GFXCommandBuffer, GFXCommandBuffer), _createClass(WebGL2GFXCommandBuffer, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return !!info.allocator && (this._allocator = info.allocator, this._webGLAllocator = this._allocator, 
                        this._type = info.type, this._status = GFXStatus.SUCCESS, !0);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._webGLAllocator && (this._webGLAllocator.clearCmds(this.cmdPackage), this._allocator = null, 
                        this._webGLAllocator = null), this._status = GFXStatus.UNREADY;
                    }
                }, {
                    key: "begin",
                    value: function begin() {
                        this._webGLAllocator.clearCmds(this.cmdPackage), this._curGPUPipelineState = null, 
                        this._curGPUBindingLayout = null, this._curGPUInputAssembler = null, this._curViewport = null, 
                        this._curScissor = null, this._curLineWidth = null, this._curDepthBias = null, this._curBlendConstants = [], 
                        this._curDepthBounds = null, this._curStencilWriteMask = null, this._curStencilCompareMask = null, 
                        this._numDrawCalls = 0, this._numTris = 0;
                    }
                }, {
                    key: "end",
                    value: function end() {
                        this._isStateInvalied && this.bindStates(), this._isInRenderPass = !1;
                    }
                }, {
                    key: "beginRenderPass",
                    value: function beginRenderPass(framebuffer, renderArea, clearFlag, clearColors, clearDepth, clearStencil) {
                        var cmd = this._webGLAllocator.beginRenderPassCmdPool.alloc(WebGL2CmdBeginRenderPass);
                        cmd.gpuFramebuffer = framebuffer.gpuFramebuffer, cmd.renderArea = renderArea, cmd.clearFlag = clearFlag;
                        for (var i = 0; i < clearColors.length; ++i) cmd.clearColors[i] = clearColors[i];
                        cmd.clearDepth = clearDepth, cmd.clearStencil = clearStencil, this.cmdPackage.beginRenderPassCmds.push(cmd), 
                        this.cmdPackage.cmds.push(WebGL2Cmd.BEGIN_RENDER_PASS), this._isInRenderPass = !0;
                    }
                }, {
                    key: "endRenderPass",
                    value: function endRenderPass() {
                        this._isInRenderPass = !1;
                    }
                }, {
                    key: "bindPipelineState",
                    value: function bindPipelineState(pipelineState) {
                        var gpuPipelineState = pipelineState.gpuPipelineState;
                        this._curGPUPipelineState = gpuPipelineState, this._isStateInvalied = !0;
                    }
                }, {
                    key: "bindBindingLayout",
                    value: function bindBindingLayout(bindingLayout) {
                        var gpuBindingLayout = bindingLayout.gpuBindingLayout;
                        this._curGPUBindingLayout = gpuBindingLayout, this._isStateInvalied = !0;
                    }
                }, {
                    key: "bindInputAssembler",
                    value: function bindInputAssembler(inputAssembler) {
                        var gpuInputAssembler = inputAssembler.gpuInputAssembler;
                        this._curGPUInputAssembler = gpuInputAssembler, this._isStateInvalied = !0;
                    }
                }, {
                    key: "setViewport",
                    value: function setViewport(viewport) {
                        this._curViewport ? this._curViewport.left === viewport.left && this._curViewport.top === viewport.top && this._curViewport.width === viewport.width && this._curViewport.height === viewport.height && this._curViewport.minDepth === viewport.minDepth && this._curViewport.maxDepth === viewport.maxDepth || (this._curViewport.left = viewport.left, 
                        this._curViewport.top = viewport.top, this._curViewport.width = viewport.width, 
                        this._curViewport.height = viewport.height, this._curViewport.minDepth = viewport.minDepth, 
                        this._curViewport.maxDepth = viewport.maxDepth, this._isStateInvalied = !0) : this._curViewport = {
                            left: viewport.left,
                            top: viewport.top,
                            width: viewport.width,
                            height: viewport.height,
                            minDepth: viewport.minDepth,
                            maxDepth: viewport.maxDepth
                        }, this._curViewport !== viewport && (this._curViewport = viewport, this._isStateInvalied = !0);
                    }
                }, {
                    key: "setScissor",
                    value: function setScissor(scissor) {
                        this._curScissor ? this._curScissor.x === scissor.x && this._curScissor.y === scissor.y && this._curScissor.width === scissor.width && this._curScissor.height === scissor.height || (this._curScissor.x = scissor.x, 
                        this._curScissor.y = scissor.y, this._curScissor.width = scissor.width, this._curScissor.height = scissor.height, 
                        this._isStateInvalied = !0) : this._curScissor = {
                            x: scissor.x,
                            y: scissor.y,
                            width: scissor.width,
                            height: scissor.height
                        };
                    }
                }, {
                    key: "setLineWidth",
                    value: function setLineWidth(lineWidth) {
                        this._curLineWidth !== lineWidth && (this._curLineWidth = lineWidth, this._isStateInvalied = !0);
                    }
                }, {
                    key: "setDepthBias",
                    value: function setDepthBias(depthBiasConstantFacotr, depthBiasClamp, depthBiasSlopeFactor) {
                        this._curDepthBias ? this._curDepthBias.constantFactor === depthBiasConstantFacotr && this._curDepthBias.clamp === depthBiasClamp && this._curDepthBias.slopeFactor === depthBiasSlopeFactor || (this._curDepthBias.constantFactor = depthBiasConstantFacotr, 
                        this._curDepthBias.clamp = depthBiasClamp, this._curDepthBias.slopeFactor = depthBiasSlopeFactor, 
                        this._isStateInvalied = !0) : (this._curDepthBias = {
                            constantFactor: depthBiasConstantFacotr,
                            clamp: depthBiasClamp,
                            slopeFactor: depthBiasSlopeFactor
                        }, this._isStateInvalied = !0);
                    }
                }, {
                    key: "setBlendConstants",
                    value: function setBlendConstants(blendConstants) {
                        (this._curBlendConstants || 4 !== blendConstants.length) && (4 !== blendConstants.length || this._curBlendConstants[0] === blendConstants[0] && this._curBlendConstants[1] === blendConstants[1] && this._curBlendConstants[2] === blendConstants[2] && this._curBlendConstants[3] === blendConstants[3]) || (this._curBlendConstants = [ blendConstants[0], blendConstants[1], blendConstants[2], blendConstants[3] ], 
                        this._isStateInvalied = !0);
                    }
                }, {
                    key: "setDepthBound",
                    value: function setDepthBound(minDepthBounds, maxDepthBounds) {
                        this._curDepthBounds && this._curDepthBounds.minBounds === minDepthBounds && this._curDepthBounds.maxBounds === maxDepthBounds || (this._curDepthBounds = {
                            minBounds: minDepthBounds,
                            maxBounds: maxDepthBounds
                        }, this._isStateInvalied = !0);
                    }
                }, {
                    key: "setStencilWriteMask",
                    value: function setStencilWriteMask(face, writeMask) {
                        this._curStencilWriteMask ? this._curStencilWriteMask.face === face && this._curStencilWriteMask.writeMask === writeMask || (this._curStencilWriteMask.face = face, 
                        this._curStencilWriteMask.writeMask = writeMask, this._isStateInvalied = !0) : (this._curStencilWriteMask = {
                            face: face,
                            writeMask: writeMask
                        }, this._isStateInvalied = !0);
                    }
                }, {
                    key: "setStencilCompareMask",
                    value: function setStencilCompareMask(face, reference, compareMask) {
                        this._curStencilCompareMask ? this._curStencilCompareMask.face === face && this._curStencilCompareMask.reference === reference && this._curStencilCompareMask.compareMask === compareMask || (this._curStencilCompareMask.face = face, 
                        this._curStencilCompareMask.reference = reference, this._curStencilCompareMask.compareMask = compareMask, 
                        this._isStateInvalied = !0) : (this._curStencilCompareMask = {
                            face: face,
                            reference: reference,
                            compareMask: compareMask
                        }, this._isStateInvalied = !0);
                    }
                }, {
                    key: "draw",
                    value: function draw(inputAssembler) {
                        if (this._type === GFXCommandBufferType.PRIMARY && this._isInRenderPass || this._type === GFXCommandBufferType.SECONDARY) {
                            this._isStateInvalied && this.bindStates();
                            var cmd = this._allocator.drawCmdPool.alloc(WebGL2CmdDraw);
                            if (inputAssembler.extractCmdDraw(cmd), this.cmdPackage.drawCmds.push(cmd), this.cmdPackage.cmds.push(WebGL2Cmd.DRAW), 
                            ++this._numDrawCalls, this._curGPUPipelineState) switch (this._curGPUPipelineState.glPrimitive) {
                              case WebGL2RenderingContext.TRIANGLES:
                                this._numTris += inputAssembler.indexCount / 3 * Math.max(inputAssembler.instanceCount, 1);
                                break;

                              case WebGL2RenderingContext.TRIANGLE_STRIP:
                              case WebGL2RenderingContext.TRIANGLE_FAN:
                                this._numTris += (inputAssembler.indexCount - 2) * Math.max(inputAssembler.instanceCount, 1);
                            }
                        } else console.error("Command 'draw' must be recorded inside a render pass.");
                    }
                }, {
                    key: "updateBuffer",
                    value: function updateBuffer(buffer, data, offset, size) {
                        if (this._type === GFXCommandBufferType.PRIMARY && !this._isInRenderPass || this._type === GFXCommandBufferType.SECONDARY) {
                            var gpuBuffer = buffer.gpuBuffer;
                            if (gpuBuffer) {
                                var buffSize, cmd = this._webGLAllocator.updateBufferCmdPool.alloc(WebGL2CmdUpdateBuffer);
                                buffSize = void 0 !== size ? size : buffer.usage & GFXBufferUsageBit.INDIRECT ? 0 : data.byteLength;
                                var buff = data;
                                cmd.gpuBuffer = gpuBuffer, cmd.buffer = buff, cmd.offset = void 0 !== offset ? offset : 0, 
                                cmd.size = buffSize, this.cmdPackage.updateBufferCmds.push(cmd), this.cmdPackage.cmds.push(WebGL2Cmd.UPDATE_BUFFER);
                            }
                        } else console.error("Command 'updateBuffer' must be recorded outside a render pass.");
                    }
                }, {
                    key: "copyBufferToTexture",
                    value: function copyBufferToTexture(srcBuff, dstTex, dstLayout, regions) {
                        if (this._type === GFXCommandBufferType.PRIMARY && !this._isInRenderPass || this._type === GFXCommandBufferType.SECONDARY) {
                            var gpuBuffer = srcBuff.gpuBuffer, gpuTexture = dstTex.gpuTexture;
                            if (gpuBuffer && gpuTexture) {
                                var cmd = this._webGLAllocator.copyBufferToTextureCmdPool.alloc(WebGL2CmdCopyBufferToTexture);
                                cmd.gpuBuffer = gpuBuffer, cmd.gpuTexture = gpuTexture, cmd.dstLayout = dstLayout, 
                                cmd.regions = regions, this.cmdPackage.copyBufferToTextureCmds.push(cmd), this.cmdPackage.cmds.push(WebGL2Cmd.COPY_BUFFER_TO_TEXTURE);
                            }
                        } else console.error("Command 'copyBufferToTexture' must be recorded outside a render pass.");
                    }
                }, {
                    key: "execute",
                    value: function execute(cmdBuffs, count) {
                        for (var i = 0; i < count; ++i) {
                            for (var webGLCmdBuff = cmdBuffs[i], c = 0; c < webGLCmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
                                var cmd = webGLCmdBuff.cmdPackage.beginRenderPassCmds.array[c];
                                ++cmd.refCount, this.cmdPackage.beginRenderPassCmds.push(cmd);
                            }
                            for (var _c = 0; _c < webGLCmdBuff.cmdPackage.bindStatesCmds.length; ++_c) {
                                var _cmd = webGLCmdBuff.cmdPackage.bindStatesCmds.array[_c];
                                ++_cmd.refCount, this.cmdPackage.bindStatesCmds.push(_cmd);
                            }
                            for (var _c2 = 0; _c2 < webGLCmdBuff.cmdPackage.drawCmds.length; ++_c2) {
                                var _cmd2 = webGLCmdBuff.cmdPackage.drawCmds.array[_c2];
                                ++_cmd2.refCount, this.cmdPackage.drawCmds.push(_cmd2);
                            }
                            for (var _c3 = 0; _c3 < webGLCmdBuff.cmdPackage.updateBufferCmds.length; ++_c3) {
                                var _cmd3 = webGLCmdBuff.cmdPackage.updateBufferCmds.array[_c3];
                                ++_cmd3.refCount, this.cmdPackage.updateBufferCmds.push(_cmd3);
                            }
                            for (var _c4 = 0; _c4 < webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++_c4) {
                                var _cmd4 = webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.array[_c4];
                                ++_cmd4.refCount, this.cmdPackage.copyBufferToTextureCmds.push(_cmd4);
                            }
                            this.cmdPackage.cmds.concat(webGLCmdBuff.cmdPackage.cmds), this._numDrawCalls += webGLCmdBuff._numDrawCalls, 
                            this._numTris += webGLCmdBuff._numTris;
                        }
                    }
                }, {
                    key: "bindStates",
                    value: function bindStates() {
                        var bindStatesCmd = this._webGLAllocator.bindStatesCmdPool.alloc(WebGL2CmdBindStates);
                        bindStatesCmd.gpuPipelineState = this._curGPUPipelineState, bindStatesCmd.gpuBindingLayout = this._curGPUBindingLayout, 
                        bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler, bindStatesCmd.viewport = this._curViewport, 
                        bindStatesCmd.scissor = this._curScissor, bindStatesCmd.lineWidth = this._curLineWidth, 
                        bindStatesCmd.depthBias = this._curDepthBias, bindStatesCmd.blendConstants = this._curBlendConstants, 
                        bindStatesCmd.depthBounds = this._curDepthBounds, bindStatesCmd.stencilWriteMask = this._curStencilWriteMask, 
                        bindStatesCmd.stencilCompareMask = this._curStencilCompareMask, this.cmdPackage.bindStatesCmds.push(bindStatesCmd), 
                        this.cmdPackage.cmds.push(WebGL2Cmd.BIND_STATES), this._isStateInvalied = !1;
                    }
                }, {
                    key: "webGLDevice",
                    get: function get() {
                        return this._device;
                    }
                } ]), WebGL2GFXCommandBuffer;
            }(), WebGL2GFXFramebuffer = function() {
                function WebGL2GFXFramebuffer(device) {
                    var _this;
                    return _classCallCheck(this, WebGL2GFXFramebuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXFramebuffer).call(this, device)))._gpuFramebuffer = null, 
                    _this;
                }
                return _inherits(WebGL2GFXFramebuffer, GFXFramebuffer), _createClass(WebGL2GFXFramebuffer, [ {
                    key: "gpuFramebuffer",
                    get: function get() {
                        return this._gpuFramebuffer;
                    }
                } ]), _createClass(WebGL2GFXFramebuffer, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        if (this._renderPass = info.renderPass, this._colorViews = info.colorViews || [], 
                        this._depthStencilView = info.depthStencilView || null, this._isOffscreen = void 0 === info.isOffscreen || info.isOffscreen, 
                        this._isOffscreen) {
                            var gpuColorViews = [];
                            if (void 0 !== info.colorViews) {
                                var _iterator = info.colorViews, _isArray = Array.isArray(_iterator), _i = 0;
                                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                    var _ref;
                                    if (_isArray) {
                                        if (_i >= _iterator.length) break;
                                        _ref = _iterator[_i++];
                                    } else {
                                        if ((_i = _iterator.next()).done) break;
                                        _ref = _i.value;
                                    }
                                    var colorView = _ref;
                                    gpuColorViews.push(colorView.gpuTextureView);
                                }
                            }
                            var gpuDepthStencilView = null;
                            info.depthStencilView && (gpuDepthStencilView = info.depthStencilView.gpuTextureView), 
                            this._gpuFramebuffer = {
                                gpuRenderPass: info.renderPass.gpuRenderPass,
                                gpuColorViews: gpuColorViews,
                                gpuDepthStencilView: gpuDepthStencilView,
                                isOffscreen: this._isOffscreen,
                                glFramebuffer: null
                            }, function WebGL2CmdFuncCreateFramebuffer(device, gpuFramebuffer) {
                                if (gpuFramebuffer.isOffscreen) {
                                    var gl = device.gl, attachments = [], glFramebuffer = gl.createFramebuffer();
                                    if (glFramebuffer) {
                                        gpuFramebuffer.glFramebuffer = glFramebuffer, device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer), 
                                        device.stateCache.glFramebuffer = gpuFramebuffer.glFramebuffer);
                                        for (var i = 0; i < gpuFramebuffer.gpuColorViews.length; ++i) {
                                            var cv = gpuFramebuffer.gpuColorViews[i];
                                            cv && (cv.gpuTexture.glTexture ? gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, cv.gpuTexture.glTarget, cv.gpuTexture.glTexture, cv.baseLevel) : gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, cv.gpuTexture.glRenderbuffer), 
                                            attachments.push(gl.COLOR_ATTACHMENT0 + i));
                                        }
                                        var dsv = gpuFramebuffer.gpuDepthStencilView;
                                        if (dsv) {
                                            var glAttachment = GFXFormatInfos[dsv.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
                                            dsv.gpuTexture.glTexture ? gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dsv.gpuTexture.glTarget, dsv.gpuTexture.glTexture, dsv.baseLevel) : gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dsv.gpuTexture.glRenderbuffer);
                                        }
                                        gl.drawBuffers(attachments);
                                        var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                                        if (status !== gl.FRAMEBUFFER_COMPLETE) switch (status) {
                                          case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                                            console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                                            break;

                                          case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                                            console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                                            break;

                                          case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                                            console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                                            break;

                                          case gl.FRAMEBUFFER_UNSUPPORTED:
                                            console.error("glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED");
                                        }
                                    }
                                }
                            }(this._device, this._gpuFramebuffer);
                        } else this._gpuFramebuffer = {
                            gpuRenderPass: info.renderPass.gpuRenderPass,
                            gpuColorViews: [],
                            gpuDepthStencilView: null,
                            isOffscreen: info.isOffscreen,
                            glFramebuffer: null
                        };
                        return this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._isOffscreen && this._gpuFramebuffer && !function WebGL2CmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
                            gpuFramebuffer.glFramebuffer && (device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer), 
                            gpuFramebuffer.glFramebuffer = null);
                        }(this._device, this._gpuFramebuffer), this._gpuFramebuffer = null, this._status = GFXStatus.UNREADY;
                    }
                } ]), WebGL2GFXFramebuffer;
            }(), WebGL2GFXInputAssembler = function() {
                function WebGL2GFXInputAssembler(device) {
                    var _this;
                    return _classCallCheck(this, WebGL2GFXInputAssembler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXInputAssembler).call(this, device)))._gpuInputAssembler = null, 
                    _this;
                }
                return _inherits(WebGL2GFXInputAssembler, GFXInputAssembler), _createClass(WebGL2GFXInputAssembler, [ {
                    key: "gpuInputAssembler",
                    get: function get() {
                        return this._gpuInputAssembler;
                    }
                } ]), _createClass(WebGL2GFXInputAssembler, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        if (0 === info.vertexBuffers.length) return console.error("GFXInputAssemblerInfo.vertexBuffers is null."), 
                        !1;
                        if (this._attributes = info.attributes, this._vertexBuffers = info.vertexBuffers, 
                        void 0 !== info.indexBuffer) this._indexBuffer = info.indexBuffer, this._indexCount = this._indexBuffer.size / this._indexBuffer.stride; else {
                            var vertBuff = this._vertexBuffers[0];
                            this._vertexCount = vertBuff.size / vertBuff.stride;
                        }
                        this._indirectBuffer = info.indirectBuffer || null;
                        for (var gpuVertexBuffers = new Array(info.vertexBuffers.length), i = 0; i < info.vertexBuffers.length; ++i) {
                            var vb = info.vertexBuffers[i];
                            vb.gpuBuffer && (gpuVertexBuffers[i] = vb.gpuBuffer);
                        }
                        var gpuIndexBuffer = null, glIndexType = 0;
                        if (info.indexBuffer && (gpuIndexBuffer = info.indexBuffer.gpuBuffer)) switch (gpuIndexBuffer.stride) {
                          case 1:
                            glIndexType = 5121;
                            break;

                          case 2:
                            glIndexType = 5123;
                            break;

                          case 4:
                            glIndexType = 5125;
                            break;

                          default:
                            console.error("Illegal index buffer stride.");
                        }
                        var gpuIndirectBuffer = null;
                        return void 0 !== info.indirectBuffer && (gpuIndirectBuffer = info.indirectBuffer.gpuBuffer), 
                        this._gpuInputAssembler = {
                            attributes: info.attributes,
                            gpuVertexBuffers: gpuVertexBuffers,
                            gpuIndexBuffer: gpuIndexBuffer,
                            gpuIndirectBuffer: gpuIndirectBuffer,
                            glAttribs: [],
                            glIndexType: glIndexType,
                            glVAOs: new Map()
                        }, function WebGL2CmdFuncCreateInputAssember(device, gpuInputAssembler) {
                            var gl = device.gl;
                            gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
                            for (var offsets = [ 0, 0, 0, 0, 0, 0, 0, 0 ], i = 0; i < gpuInputAssembler.attributes.length; ++i) {
                                var attrib = gpuInputAssembler.attributes[i], stream = void 0 !== attrib.stream ? attrib.stream : 0, gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream], glType = GFXFormatToWebGLType$1(attrib.format, gl), size = GFXFormatInfos[attrib.format].size;
                                gpuInputAssembler.glAttribs[i] = {
                                    name: attrib.name,
                                    glBuffer: gpuBuffer.glBuffer,
                                    glType: glType,
                                    size: size,
                                    count: GFXFormatInfos[attrib.format].count,
                                    stride: gpuBuffer.stride,
                                    componentCount: WebGLGetComponentCount$1(glType, gl),
                                    isNormalized: void 0 !== attrib.isNormalized && attrib.isNormalized,
                                    isInstanced: void 0 !== attrib.isInstanced && attrib.isInstanced,
                                    offset: offsets[stream]
                                }, offsets[stream] += size;
                            }
                        }(this._device, this._gpuInputAssembler), this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        var webgl2Dev = this._device;
                        this._gpuInputAssembler && webgl2Dev.useVAO && !function WebGL2CmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
                            var _iterator8 = gpuInputAssembler.glVAOs, _isArray8 = Array.isArray(_iterator8), _i16 = 0;
                            for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                                var _ref8;
                                if (_isArray8) {
                                    if (_i16 >= _iterator8.length) break;
                                    _ref8 = _iterator8[_i16++];
                                } else {
                                    if ((_i16 = _iterator8.next()).done) break;
                                    _ref8 = _i16.value;
                                }
                                var vao = _ref8;
                                device.gl.deleteVertexArray(vao[1]);
                            }
                            gpuInputAssembler.glVAOs.clear();
                        }(webgl2Dev, this._gpuInputAssembler), this._gpuInputAssembler = null, this._status = GFXStatus.UNREADY;
                    }
                }, {
                    key: "extractCmdDraw",
                    value: function extractCmdDraw(cmd) {
                        cmd.drawInfo.vertexCount = this._vertexCount, cmd.drawInfo.firstVertex = this._firstVertex, 
                        cmd.drawInfo.indexCount = this._indexCount, cmd.drawInfo.firstIndex = this._firstIndex, 
                        cmd.drawInfo.vertexOffset = this._vertexOffset, cmd.drawInfo.instanceCount = this._instanceCount, 
                        cmd.drawInfo.firstInstance = this._firstInstance;
                    }
                } ]), WebGL2GFXInputAssembler;
            }(), WebGL2GFXPipelineLayout = function() {
                function WebGL2GFXPipelineLayout(device) {
                    var _this;
                    return _classCallCheck(this, WebGL2GFXPipelineLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXPipelineLayout).call(this, device)))._gpuPipelineLayout = null, 
                    _this;
                }
                return _inherits(WebGL2GFXPipelineLayout, GFXPipelineLayout), _createClass(WebGL2GFXPipelineLayout, [ {
                    key: "gpuPipelineLayout",
                    get: function get() {
                        return this._gpuPipelineLayout;
                    }
                } ]), _createClass(WebGL2GFXPipelineLayout, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return this._layouts = info.layouts, this._pushConstantsRanges = info.pushConstantsRanges || [], 
                        this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._status = GFXStatus.UNREADY;
                    }
                } ]), WebGL2GFXPipelineLayout;
            }(), WebGLPrimitives$1 = [ 0, 1, 3, 2, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0 ], WebGL2GFXPipelineState = function() {
                function WebGL2GFXPipelineState(device) {
                    var _this;
                    return _classCallCheck(this, WebGL2GFXPipelineState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXPipelineState).call(this, device)))._gpuPipelineState = null, 
                    _this;
                }
                return _inherits(WebGL2GFXPipelineState, GFXPipelineState), _createClass(WebGL2GFXPipelineState, [ {
                    key: "gpuPipelineState",
                    get: function get() {
                        return this._gpuPipelineState;
                    }
                } ]), _createClass(WebGL2GFXPipelineState, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return this._primitive = info.primitive, this._shader = info.shader, this._is = info.is, 
                        this._rs = info.rs, this._dss = info.dss, this._bs = info.bs, this._dynamicStates = info.dynamicStates || [], 
                        this._layout = info.layout, this._renderPass = info.renderPass, this._gpuPipelineState = {
                            glPrimitive: WebGLPrimitives$1[info.primitive],
                            gpuShader: info.shader.gpuShader,
                            rs: info.rs,
                            dss: info.dss,
                            bs: info.bs,
                            dynamicStates: void 0 !== info.dynamicStates ? info.dynamicStates : [],
                            gpuLayout: info.layout.gpuPipelineLayout,
                            gpuRenderPass: info.renderPass.gpuRenderPass
                        }, this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._gpuPipelineState = null, this._status = GFXStatus.UNREADY;
                    }
                } ]), WebGL2GFXPipelineState;
            }(), WebGL2GFXQueue = function() {
                function WebGL2GFXQueue(device) {
                    var _this;
                    return _classCallCheck(this, WebGL2GFXQueue), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXQueue).call(this, device))).numDrawCalls = 0, 
                    _this.numTris = 0, _this._isAsync = !1, _this;
                }
                return _inherits(WebGL2GFXQueue, GFXQueue), _createClass(WebGL2GFXQueue, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return this._type = info.type, this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._status = GFXStatus.UNREADY;
                    }
                }, {
                    key: "submit",
                    value: function submit(cmdBuffs) {
                        if (!this._isAsync) {
                            var _iterator = cmdBuffs, _isArray = Array.isArray(_iterator), _i = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i >= _iterator.length) break;
                                    _ref = _iterator[_i++];
                                } else {
                                    if ((_i = _iterator.next()).done) break;
                                    _ref = _i.value;
                                }
                                var cmdBuff = _ref;
                                WebGL2CmdFuncExecuteCmds(this._device, cmdBuff.cmdPackage), this.numDrawCalls += cmdBuff.numDrawCalls, 
                                this.numTris += cmdBuff.numTris;
                            }
                        }
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        this.numDrawCalls = 0, this.numTris = 0;
                    }
                } ]), WebGL2GFXQueue;
            }(), WebGL2GFXRenderPass = function() {
                function WebGL2GFXRenderPass(device) {
                    var _this;
                    return _classCallCheck(this, WebGL2GFXRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXRenderPass).call(this, device)))._gpuRenderPass = null, 
                    _this;
                }
                return _inherits(WebGL2GFXRenderPass, GFXRenderPass), _createClass(WebGL2GFXRenderPass, [ {
                    key: "gpuRenderPass",
                    get: function get() {
                        return this._gpuRenderPass;
                    }
                } ]), _createClass(WebGL2GFXRenderPass, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return this._colorInfos = info.colorAttachments || [], this._depthStencilInfo = info.depthStencilAttachment || null, 
                        this._gpuRenderPass = {
                            colorAttachments: this._colorInfos,
                            depthStencilAttachment: this._depthStencilInfo
                        }, this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._gpuRenderPass = null, this._status = GFXStatus.UNREADY;
                    }
                } ]), WebGL2GFXRenderPass;
            }(), WebGL2GFXSampler = function() {
                function WebGL2GFXSampler(device) {
                    var _this;
                    return _classCallCheck(this, WebGL2GFXSampler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXSampler).call(this, device)))._gpuSampler = null, 
                    _this._state = new GFXSamplerState(), _this;
                }
                return _inherits(WebGL2GFXSampler, GFXSampler), _createClass(WebGL2GFXSampler, [ {
                    key: "gpuSampler",
                    get: function get() {
                        return this._gpuSampler;
                    }
                } ]), _createClass(WebGL2GFXSampler, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return void 0 !== info.name && (this._state.name = info.name), void 0 !== info.minFilter && (this._state.minFilter = info.minFilter), 
                        void 0 !== info.magFilter && (this._state.magFilter = info.magFilter), void 0 !== info.mipFilter && (this._state.mipFilter = info.mipFilter), 
                        void 0 !== info.addressU && (this._state.addressU = info.addressU), void 0 !== info.addressV && (this._state.addressV = info.addressV), 
                        void 0 !== info.addressW && (this._state.addressW = info.addressW), void 0 !== info.maxAnisotropy && (this._state.maxAnisotropy = info.maxAnisotropy), 
                        void 0 !== info.cmpFunc && (this._state.cmpFunc = info.cmpFunc), void 0 !== info.borderColor && (this._state.borderColor = info.borderColor), 
                        void 0 !== info.minLOD && (this._state.minLOD = info.minLOD), void 0 !== info.maxLOD && (this._state.maxLOD = info.maxLOD), 
                        void 0 !== info.mipLODBias && (this._state.mipLODBias = info.mipLODBias), this._gpuSampler = {
                            glSampler: null,
                            minFilter: this._state.minFilter,
                            magFilter: this._state.magFilter,
                            mipFilter: this._state.mipFilter,
                            addressU: this._state.addressU,
                            addressV: this._state.addressV,
                            addressW: this._state.addressW,
                            minLOD: this._state.minLOD,
                            maxLOD: this._state.maxLOD,
                            glMinFilter: WebGL2RenderingContext.NONE,
                            glMagFilter: WebGL2RenderingContext.NONE,
                            glWrapS: WebGL2RenderingContext.NONE,
                            glWrapT: WebGL2RenderingContext.NONE,
                            glWrapR: WebGL2RenderingContext.NONE
                        }, function WebGL2CmdFuncCreateSampler(device, gpuSampler) {
                            var gl = device.gl, glSampler = gl.createSampler();
                            glSampler && (gpuSampler.minFilter === GFXFilter.LINEAR || gpuSampler.minFilter === GFXFilter.ANISOTROPIC ? gpuSampler.mipFilter === GFXFilter.LINEAR || gpuSampler.mipFilter === GFXFilter.ANISOTROPIC ? gpuSampler.glMinFilter = gl.LINEAR_MIPMAP_LINEAR : gpuSampler.mipFilter === GFXFilter.POINT ? gpuSampler.glMinFilter = gl.LINEAR_MIPMAP_NEAREST : gpuSampler.glMinFilter = gl.LINEAR : gpuSampler.mipFilter === GFXFilter.LINEAR || gpuSampler.mipFilter === GFXFilter.ANISOTROPIC ? gpuSampler.glMinFilter = gl.NEAREST_MIPMAP_LINEAR : gpuSampler.mipFilter === GFXFilter.POINT ? gpuSampler.glMinFilter = gl.NEAREST_MIPMAP_NEAREST : gpuSampler.glMinFilter = gl.NEAREST, 
                            gpuSampler.magFilter === GFXFilter.LINEAR || gpuSampler.magFilter === GFXFilter.ANISOTROPIC ? gpuSampler.glMagFilter = WebGLRenderingContext.LINEAR : gpuSampler.glMagFilter = WebGLRenderingContext.NEAREST, 
                            gpuSampler.glWrapS = WebGLWraps$1[gpuSampler.addressU], gpuSampler.glWrapT = WebGLWraps$1[gpuSampler.addressV], 
                            gpuSampler.glWrapR = WebGLWraps$1[gpuSampler.addressW], gpuSampler.glSampler = glSampler, 
                            gl.samplerParameteri(glSampler, gl.TEXTURE_MIN_FILTER, gpuSampler.glMinFilter), 
                            gl.samplerParameteri(glSampler, gl.TEXTURE_MAG_FILTER, gpuSampler.glMagFilter), 
                            gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_S, gpuSampler.glWrapS), gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_T, gpuSampler.glWrapT), 
                            gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_R, gpuSampler.glWrapR), gl.samplerParameterf(glSampler, gl.TEXTURE_MIN_LOD, gpuSampler.minLOD), 
                            gl.samplerParameterf(glSampler, gl.TEXTURE_MAX_LOD, gpuSampler.maxLOD));
                        }(this._device, this._gpuSampler), this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._gpuSampler && (!function WebGL2CmdFuncDestroySampler(device, gpuSampler) {
                            gpuSampler.glSampler && (device.gl.deleteSampler(gpuSampler.glSampler), gpuSampler.glSampler = null);
                        }(this._device, this._gpuSampler), this._gpuSampler = null), this._status = GFXStatus.UNREADY;
                    }
                } ]), WebGL2GFXSampler;
            }(), WebGL2GFXShader = function() {
                function WebGL2GFXShader(device) {
                    var _this;
                    return _classCallCheck(this, WebGL2GFXShader), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXShader).call(this, device)))._gpuShader = null, 
                    _this;
                }
                return _inherits(WebGL2GFXShader, GFXShader), _createClass(WebGL2GFXShader, [ {
                    key: "gpuShader",
                    get: function get() {
                        return this._gpuShader;
                    }
                } ]), _createClass(WebGL2GFXShader, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        this._name = info.name, this._stages = info.stages, void 0 !== info.blocks && (this._blocks = info.blocks), 
                        void 0 !== info.samplers && (this._samplers = info.samplers), this._gpuShader = {
                            name: info.name ? info.name : "",
                            blocks: void 0 !== info.blocks ? info.blocks : [],
                            samplers: void 0 !== info.samplers ? info.samplers : [],
                            gpuStages: new Array(info.stages.length),
                            glProgram: null,
                            glInputs: [],
                            glUniforms: [],
                            glBlocks: [],
                            glSamplers: []
                        };
                        for (var i = 0; i < info.stages.length; ++i) {
                            var stage = info.stages[i];
                            this._gpuShader.gpuStages[i] = {
                                type: stage.type,
                                source: stage.source,
                                macros: stage.macros ? stage.macros : [],
                                glShader: null
                            };
                        }
                        return function WebGL2CmdFuncCreateShader(device, gpuShader) {
                            function _loop2() {
                                if (_isArray) {
                                    if (_i7 >= _iterator.length) return "break";
                                    _ref = _iterator[_i7++];
                                } else {
                                    if ((_i7 = _iterator.next()).done) return "break";
                                    _ref = _i7.value;
                                }
                                var gpuStage = _ref, glShaderType = 0, shaderTypeStr = "", lineNumber = 1;
                                switch (gpuStage.type) {
                                  case GFXShaderType.VERTEX:
                                    shaderTypeStr = "VertexShader", glShaderType = gl.VERTEX_SHADER;
                                    break;

                                  case GFXShaderType.FRAGMENT:
                                    shaderTypeStr = "FragmentShader", glShaderType = gl.FRAGMENT_SHADER;
                                    break;

                                  default:
                                    return console.error("Unsupported GFXShaderType."), {
                                        v: void 0
                                    };
                                }
                                var glShader = gl.createShader(glShaderType);
                                if (glShader && (gpuStage.glShader = glShader, gl.shaderSource(gpuStage.glShader, gpuStage.source), 
                                gl.compileShader(gpuStage.glShader), !gl.getShaderParameter(gpuStage.glShader, gl.COMPILE_STATUS))) return console.error(shaderTypeStr + " in '" + gpuShader.name + "' compilation failed."), 
                                console.error("Shader source dump:", gpuStage.source.replace(/^|\n/g, function() {
                                    return "\n".concat(lineNumber++, " ");
                                })), console.error(gl.getShaderInfoLog(gpuStage.glShader)), gl.deleteShader(gpuStage.glShader), 
                                gpuStage.glShader = null, {
                                    v: void 0
                                };
                            }
                            var gl = device.gl, _iterator = gpuShader.gpuStages, _isArray = Array.isArray(_iterator), _i7 = 0;
                            _loop: for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref, _ret = _loop2();
                                switch (_ret) {
                                  case "break":
                                    break _loop;

                                  default:
                                    if ("object" === _typeof(_ret)) return _ret.v;
                                }
                            }
                            var glProgram = gl.createProgram();
                            if (glProgram) {
                                gpuShader.glProgram = glProgram;
                                var _iterator2 = gpuShader.gpuStages, _isArray2 = Array.isArray(_iterator2), _i8 = 0;
                                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                                    var _ref2;
                                    if (_isArray2) {
                                        if (_i8 >= _iterator2.length) break;
                                        _ref2 = _iterator2[_i8++];
                                    } else {
                                        if ((_i8 = _iterator2.next()).done) break;
                                        _ref2 = _i8.value;
                                    }
                                    var _gpuStage = _ref2;
                                    gl.attachShader(gpuShader.glProgram, _gpuStage.glShader);
                                }
                                if (gl.linkProgram(gpuShader.glProgram), gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) {
                                    console.info("Shader '" + gpuShader.name + "' compilation successed.");
                                    var activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
                                    gpuShader.glInputs = new Array(activeAttribCount);
                                    for (var i = 0; i < activeAttribCount; ++i) {
                                        var attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);
                                        if (attribInfo) {
                                            var varName = void 0, nameOffset = attribInfo.name.indexOf("[");
                                            varName = -1 !== nameOffset ? attribInfo.name.substr(0, nameOffset) : attribInfo.name;
                                            var glLoc = gl.getAttribLocation(gpuShader.glProgram, varName), type = WebGLTypeToGFXType$1(attribInfo.type, gl), stride = WebGLGetTypeSize$1(attribInfo.type, gl);
                                            gpuShader.glInputs[i] = {
                                                binding: glLoc,
                                                name: varName,
                                                type: type,
                                                stride: stride,
                                                count: attribInfo.size,
                                                size: stride * attribInfo.size,
                                                glType: attribInfo.type,
                                                glLoc: glLoc
                                            };
                                        }
                                    }
                                    var blockName, blockIdx, blockSize, blockBinding, blockUniformCount, uIndices, indices, glUniformSizes, glUniformOffsets, glUniformInfo, activeBlockCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORM_BLOCKS);
                                    if (activeBlockCount) {
                                        gpuShader.glBlocks = new Array(activeBlockCount);
                                        for (var b = 0; b < activeBlockCount; ++b) {
                                            var _nameOffset = (blockName = gl.getActiveUniformBlockName(gpuShader.glProgram, b)).indexOf("[");
                                            -1 !== _nameOffset && (blockName = blockName.substr(0, _nameOffset)), blockBinding = -1;
                                            var _iterator4 = gpuShader.blocks, _isArray4 = Array.isArray(_iterator4), _i10 = 0;
                                            for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                                                var _ref4;
                                                if (_isArray4) {
                                                    if (_i10 >= _iterator4.length) break;
                                                    _ref4 = _iterator4[_i10++];
                                                } else {
                                                    if ((_i10 = _iterator4.next()).done) break;
                                                    _ref4 = _i10.value;
                                                }
                                                var block = _ref4;
                                                if (block.name === blockName) {
                                                    blockBinding = block.binding;
                                                    break;
                                                }
                                            }
                                            if (0 <= blockBinding) {
                                                blockIdx = b, blockSize = gl.getActiveUniformBlockParameter(gpuShader.glProgram, blockIdx, gl.UNIFORM_BLOCK_DATA_SIZE), 
                                                blockUniformCount = gl.getActiveUniformBlockParameter(gpuShader.glProgram, blockIdx, gl.UNIFORM_BLOCK_ACTIVE_UNIFORMS), 
                                                gl.uniformBlockBinding(gpuShader.glProgram, blockIdx, blockBinding);
                                                var glBlock = {
                                                    binding: blockBinding,
                                                    idx: blockIdx,
                                                    name: blockName,
                                                    size: blockSize,
                                                    glUniforms: new Array(blockUniformCount),
                                                    glActiveUniforms: [],
                                                    isUniformPackage: !1
                                                };
                                                gpuShader.glBlocks[b] = glBlock, uIndices = gl.getActiveUniformBlockParameter(gpuShader.glProgram, blockIdx, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES), 
                                                indices = new Array(uIndices.length);
                                                for (var n = 0; n < uIndices.length; ++n) indices[n] = uIndices[n];
                                                glUniformSizes = gl.getActiveUniforms(gpuShader.glProgram, indices, gl.UNIFORM_SIZE), 
                                                glUniformOffsets = gl.getActiveUniforms(gpuShader.glProgram, indices, gl.UNIFORM_OFFSET);
                                                for (var u = 0; u < blockUniformCount; ++u) if (glUniformInfo = gl.getActiveUniform(gpuShader.glProgram, uIndices[u])) {
                                                    var _stride = WebGLGetTypeSize$1(glUniformInfo.type, gl), size = glUniformSizes[u] * _stride, begin = glUniformOffsets[u] / 4, array = new Array(size / 4);
                                                    array.fill(0), glBlock.glUniforms[u] = {
                                                        binding: -1,
                                                        name: glUniformInfo.name,
                                                        type: WebGLTypeToGFXType$1(glUniformInfo.type, gl),
                                                        stride: _stride,
                                                        count: glUniformInfo.size,
                                                        size: size,
                                                        offset: glUniformOffsets[u],
                                                        glType: glUniformInfo.type,
                                                        glLoc: -1,
                                                        array: array,
                                                        begin: begin
                                                    };
                                                }
                                            }
                                        }
                                    }
                                    if (0 < gpuShader.samplers.length) {
                                        gpuShader.glSamplers = new Array(gpuShader.samplers.length);
                                        for (var _i11 = 0; _i11 < gpuShader.samplers.length; ++_i11) {
                                            var sampler = gpuShader.samplers[_i11];
                                            gpuShader.glSamplers[_i11] = {
                                                binding: sampler.binding,
                                                name: sampler.name,
                                                type: sampler.type,
                                                units: [],
                                                glType: GFXTypeToWebGLType$1(sampler.type, gl),
                                                glLoc: -1
                                            };
                                        }
                                    }
                                    for (var activeUniformCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORMS), unitIdx = 0, glActiveSamplers = [], _i12 = 0; _i12 < activeUniformCount; ++_i12) {
                                        var uniformInfo = gl.getActiveUniform(gpuShader.glProgram, _i12);
                                        if (uniformInfo) {
                                            var _glLoc = gl.getUniformLocation(gpuShader.glProgram, uniformInfo.name);
                                            if (_glLoc) {
                                                var _varName = void 0, _nameOffset2 = uniformInfo.name.indexOf("[");
                                                if (_varName = -1 !== _nameOffset2 ? uniformInfo.name.substr(0, _nameOffset2) : uniformInfo.name, 
                                                uniformInfo.type === gl.SAMPLER_2D || uniformInfo.type === gl.SAMPLER_CUBE) {
                                                    var _iterator5 = gpuShader.glSamplers, _isArray5 = Array.isArray(_iterator5), _i13 = 0;
                                                    for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                                                        var _ref5;
                                                        if (_isArray5) {
                                                            if (_i13 >= _iterator5.length) break;
                                                            _ref5 = _iterator5[_i13++];
                                                        } else {
                                                            if ((_i13 = _iterator5.next()).done) break;
                                                            _ref5 = _i13.value;
                                                        }
                                                        var glSampler = _ref5;
                                                        if (glSampler.name === _varName) {
                                                            for (var t = 0; t < uniformInfo.size; ++t) glSampler.units.push(unitIdx + t);
                                                            glSampler.glLoc = _glLoc, unitIdx += uniformInfo.size, glActiveSamplers.push(glSampler);
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (glActiveSamplers.length) {
                                        device.stateCache.glProgram !== gpuShader.glProgram && (gl.useProgram(gpuShader.glProgram), 
                                        device.stateCache.glProgram = gpuShader.glProgram);
                                        var _iterator6 = glActiveSamplers, _isArray6 = Array.isArray(_iterator6), _i14 = 0;
                                        for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                                            var _ref6;
                                            if (_isArray6) {
                                                if (_i14 >= _iterator6.length) break;
                                                _ref6 = _iterator6[_i14++];
                                            } else {
                                                if ((_i14 = _iterator6.next()).done) break;
                                                _ref6 = _i14.value;
                                            }
                                            var _glSampler = _ref6;
                                            gl.uniform1iv(_glSampler.glLoc, _glSampler.units);
                                        }
                                    }
                                } else {
                                    console.error("Failed to link shader '" + gpuShader.name + "'."), console.error(gl.getProgramInfoLog(gpuShader.glProgram));
                                    var _iterator3 = gpuShader.gpuStages, _isArray3 = Array.isArray(_iterator3), _i9 = 0;
                                    for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                                        var _ref3;
                                        if (_isArray3) {
                                            if (_i9 >= _iterator3.length) break;
                                            _ref3 = _iterator3[_i9++];
                                        } else {
                                            if ((_i9 = _iterator3.next()).done) break;
                                            _ref3 = _i9.value;
                                        }
                                        var gpuStage = _ref3;
                                        gpuStage.glShader && (gl.deleteShader(gpuStage.glShader), gpuStage.glShader = null);
                                    }
                                }
                            }
                        }(this._device, this._gpuShader), this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._gpuShader && (!function WebGL2CmdFuncDestroyShader(device, gpuShader) {
                            var _iterator7 = gpuShader.gpuStages, _isArray7 = Array.isArray(_iterator7), _i15 = 0;
                            for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                                var _ref7;
                                if (_isArray7) {
                                    if (_i15 >= _iterator7.length) break;
                                    _ref7 = _iterator7[_i15++];
                                } else {
                                    if ((_i15 = _iterator7.next()).done) break;
                                    _ref7 = _i15.value;
                                }
                                var gpuStage = _ref7;
                                gpuStage.glShader && (device.gl.deleteShader(gpuStage.glShader), gpuStage.glShader = null);
                            }
                            gpuShader.glProgram && (device.gl.deleteProgram(gpuShader.glProgram), gpuShader.glProgram = null);
                        }(this._device, this._gpuShader), this._gpuShader = null), this._status = GFXStatus.UNREADY;
                    }
                } ]), WebGL2GFXShader;
            }();
            function IsPowerOf2$1(x) {
                return 0 < x && 0 == (x & x - 1);
            }
            var WebGL2GFXTexture = function() {
                function WebGL2GFXTexture(device) {
                    var _this;
                    return _classCallCheck(this, WebGL2GFXTexture), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXTexture).call(this, device)))._gpuTexture = null, 
                    _this;
                }
                return _inherits(WebGL2GFXTexture, GFXTexture), _createClass(WebGL2GFXTexture, [ {
                    key: "gpuTexture",
                    get: function get() {
                        return this._gpuTexture;
                    }
                } ]), _createClass(WebGL2GFXTexture, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        var viewType;
                        switch (this._type = info.type, this._usage = info.usage, this._format = info.format, 
                        this._width = info.width, this._height = info.height, void 0 !== info.depth && (this._depth = info.depth), 
                        void 0 !== info.arrayLayer && (this._arrayLayer = info.arrayLayer), void 0 !== info.mipLevel && (this._mipLevel = info.mipLevel), 
                        void 0 !== info.samples && (this._samples = info.samples), void 0 !== info.flags && (this._flags = info.flags), 
                        this._isPowerOf2 = IsPowerOf2$1(this._width) && IsPowerOf2$1(this._height), this._size = GFXFormatSurfaceSize(this._format, this.width, this.height, this.depth, this.mipLevel) * this._arrayLayer, 
                        this._flags & GFXTextureFlagBit.BAKUP_BUFFER && (this._buffer = new ArrayBuffer(this._size)), 
                        info.type) {
                          case GFXTextureType.TEX1D:
                            viewType = info.arrayLayer ? info.arrayLayer <= 1 ? GFXTextureViewType.TV1D : GFXTextureViewType.TV1D_ARRAY : GFXTextureViewType.TV1D;
                            break;

                          case GFXTextureType.TEX2D:
                            var flags = GFXTextureFlagBit.NONE;
                            info.flags && (flags = info.flags), viewType = info.arrayLayer ? info.arrayLayer <= 1 ? GFXTextureViewType.TV2D : flags & GFXTextureFlagBit.CUBEMAP ? GFXTextureViewType.CUBE : GFXTextureViewType.TV2D_ARRAY : GFXTextureViewType.TV2D;
                            break;

                          case GFXTextureType.TEX3D:
                            viewType = GFXTextureViewType.TV3D;
                            break;

                          default:
                            viewType = GFXTextureViewType.TV2D;
                        }
                        return this._gpuTexture = {
                            type: this._type,
                            viewType: viewType,
                            format: this._format,
                            usage: this._usage,
                            width: this._width,
                            height: this._height,
                            depth: this._depth,
                            size: this._size,
                            arrayLayer: this._arrayLayer,
                            mipLevel: this._mipLevel,
                            samples: this._samples,
                            flags: this._flags,
                            isPowerOf2: this._isPowerOf2,
                            glTarget: 0,
                            glInternelFmt: 0,
                            glFormat: 0,
                            glType: 0,
                            glUsage: 0,
                            glTexture: null,
                            glRenderbuffer: null,
                            glWrapS: 0,
                            glWrapT: 0,
                            glMinFilter: 0,
                            glMagFilter: 0
                        }, function WebGL2CmdFuncCreateTexture(device, gpuTexture) {
                            var gl = device.gl;
                            gpuTexture.glInternelFmt = GFXFormatToWebGLInternalFormat$1(gpuTexture.format, gl), 
                            gpuTexture.glFormat = GFXFormatToWebGLFormat$1(gpuTexture.format, gl), gpuTexture.glType = GFXFormatToWebGLType$1(gpuTexture.format, gl);
                            var w = gpuTexture.width, h = gpuTexture.height;
                            switch (gpuTexture.viewType) {
                              case GFXTextureViewType.TV2D:
                                gpuTexture.viewType = GFXTextureViewType.TV2D, gpuTexture.glTarget = gl.TEXTURE_2D;
                                var maxSize = Math.max(w, h);
                                if (maxSize > device.maxTextureSize && errorID(9100, maxSize, device.maxTextureSize), 
                                gpuTexture.samples === GFXSampleCount.X1) {
                                    var glTexture = gl.createTexture();
                                    if (glTexture && 0 < gpuTexture.size) {
                                        gpuTexture.glTexture = glTexture;
                                        var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                                        if (glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
                                        glTexUnit.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _i = 0; _i < gpuTexture.mipLevel; ++_i) {
                                            var imgSize = GFXFormatSize(gpuTexture.format, w, h, 1), view = new Uint8Array(imgSize);
                                            gl.compressedTexImage2D(gl.TEXTURE_2D, _i, gpuTexture.glInternelFmt, w, h, 0, view), 
                                            w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                        } else {
                                            var _imgSize = GFXFormatSize(gpuTexture.format, 2, 2, 1), _view = new Uint8Array(_imgSize);
                                            gl.compressedTexImage2D(gl.TEXTURE_2D, 0, gpuTexture.glInternelFmt, 2, 2, 0, _view);
                                        } else for (var i = 0; i < gpuTexture.mipLevel; ++i) gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                                        w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                    }
                                } else {
                                    var glRenderbuffer = gl.createRenderbuffer();
                                    glRenderbuffer && 0 < gpuTexture.size && (gpuTexture.glRenderbuffer = glRenderbuffer, 
                                    device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer && (gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer), 
                                    device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer), gl.renderbufferStorageMultisample(gl.RENDERBUFFER, SAMPLES[gpuTexture.samples], gpuTexture.glInternelFmt, gpuTexture.width, gpuTexture.height));
                                }
                                break;

                              case GFXTextureViewType.CUBE:
                                gpuTexture.viewType = GFXTextureViewType.CUBE, gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
                                var _maxSize = Math.max(w, h);
                                _maxSize > device.maxCubeMapTextureSize && errorID(9100, _maxSize, device.maxTextureSize);
                                var _glTexture = gl.createTexture();
                                if (_glTexture && 0 < gpuTexture.size) {
                                    gpuTexture.glTexture = _glTexture;
                                    var _glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                                    if (_glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                                    _glTexUnit.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _f = 0; _f < 6; ++_f) {
                                        w = gpuTexture.width, h = gpuTexture.height;
                                        for (var _i3 = 0; _i3 < gpuTexture.mipLevel; ++_i3) {
                                            var _imgSize2 = GFXFormatSize(gpuTexture.format, w, h, 1), _view2 = new Uint8Array(_imgSize2);
                                            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f, _i3, gpuTexture.glInternelFmt, w, h, 0, _view2), 
                                            w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                        }
                                    } else for (var _f2 = 0; _f2 < 6; ++_f2) {
                                        var _imgSize3 = GFXFormatSize(gpuTexture.format, 2, 2, 1), _view3 = new Uint8Array(_imgSize3);
                                        gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f2, 0, gpuTexture.glInternelFmt, 2, 2, 0, _view3);
                                    } else for (var f = 0; f < 6; ++f) {
                                        w = gpuTexture.width, h = gpuTexture.height;
                                        for (var _i2 = 0; _i2 < gpuTexture.mipLevel; ++_i2) gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i2, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                                        w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                    }
                                }
                                break;

                              default:
                                console.error("Unsupported GFXTextureType, create texture failed."), gpuTexture.viewType = GFXTextureViewType.TV2D, 
                                gpuTexture.glTarget = gl.TEXTURE_2D;
                            }
                        }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize += this._size, 
                        this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._gpuTexture && (!function WebGL2CmdFuncDestroyTexture(device, gpuTexture) {
                            gpuTexture.glTexture && (device.gl.deleteTexture(gpuTexture.glTexture), gpuTexture.glTexture = null), 
                            gpuTexture.glRenderbuffer && (device.gl.deleteRenderbuffer(gpuTexture.glRenderbuffer), 
                            gpuTexture.glRenderbuffer = null);
                        }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize -= this._size, 
                        this._gpuTexture = null), this._status = GFXStatus.UNREADY, this._buffer = null;
                    }
                }, {
                    key: "resize",
                    value: function resize(width, height) {
                        var oldSize = this._size;
                        this._width = width, this._height = height, this._size = GFXFormatSurfaceSize(this._format, this.width, this.height, this.depth, this.mipLevel) * this._arrayLayer, 
                        this._gpuTexture && (this._gpuTexture.width = this._width, this._gpuTexture.height = this._height, 
                        this._gpuTexture.size = this._size, function WebGL2CmdFuncResizeTexture(device, gpuTexture) {
                            var gl = device.gl;
                            gpuTexture.glInternelFmt = GFXFormatToWebGLInternalFormat$1(gpuTexture.format, gl), 
                            gpuTexture.glFormat = GFXFormatToWebGLFormat$1(gpuTexture.format, gl), gpuTexture.glType = GFXFormatToWebGLType$1(gpuTexture.format, gl);
                            var w = gpuTexture.width, h = gpuTexture.height;
                            switch (gpuTexture.viewType) {
                              case GFXTextureViewType.TV2D:
                                gpuTexture.viewType = GFXTextureViewType.TV2D, gpuTexture.glTarget = gl.TEXTURE_2D;
                                var maxSize = Math.max(w, h);
                                if (maxSize > device.maxTextureSize && errorID(9100, maxSize, device.maxTextureSize), 
                                gpuTexture.samples === GFXSampleCount.X1) {
                                    var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                                    if (glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
                                    glTexUnit.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) {
                                        if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _i4 = 0; _i4 < gpuTexture.mipLevel; ++_i4) {
                                            var imgSize = GFXFormatSize(gpuTexture.format, w, h, 1), view = new Uint8Array(imgSize);
                                            gl.compressedTexImage2D(gl.TEXTURE_2D, _i4, gpuTexture.glInternelFmt, w, h, 0, view), 
                                            w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                        }
                                    } else for (var i = 0; i < gpuTexture.mipLevel; ++i) gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                                    w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                } else {
                                    var glRenderbuffer = gl.createRenderbuffer();
                                    glRenderbuffer && 0 < gpuTexture.size && (gpuTexture.glRenderbuffer = glRenderbuffer, 
                                    device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer && (gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer), 
                                    device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer), gl.renderbufferStorageMultisample(gl.RENDERBUFFER, SAMPLES[gpuTexture.samples], gpuTexture.glInternelFmt, gpuTexture.width, gpuTexture.height));
                                }
                                break;

                              case GFXTextureViewType.CUBE:
                                gpuTexture.viewType = GFXTextureViewType.CUBE, gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
                                var _maxSize2 = Math.max(w, h);
                                _maxSize2 > device.maxCubeMapTextureSize && errorID(9100, _maxSize2, device.maxTextureSize);
                                var _glTexUnit2 = device.stateCache.glTexUnits[device.stateCache.texUnit];
                                if (_glTexUnit2.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                                _glTexUnit2.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) {
                                    if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _f3 = 0; _f3 < 6; ++_f3) {
                                        w = gpuTexture.width, h = gpuTexture.height;
                                        for (var _i6 = 0; _i6 < gpuTexture.mipLevel; ++_i6) {
                                            var _imgSize4 = GFXFormatSize(gpuTexture.format, w, h, 1), _view4 = new Uint8Array(_imgSize4);
                                            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f3, _i6, gpuTexture.glInternelFmt, w, h, 0, _view4), 
                                            w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                        }
                                    }
                                } else for (var f = 0; f < 6; ++f) {
                                    w = gpuTexture.width, h = gpuTexture.height;
                                    for (var _i5 = 0; _i5 < gpuTexture.mipLevel; ++_i5) gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i5, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                                    w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                }
                                break;

                              default:
                                console.error("Unsupported GFXTextureType, create texture failed."), gpuTexture.viewType = GFXTextureViewType.TV2D, 
                                gpuTexture.glTarget = gl.TEXTURE_2D;
                            }
                        }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize -= oldSize, 
                        this._device.memoryStatus.textureSize += this._size), this._status = GFXStatus.UNREADY;
                    }
                } ]), WebGL2GFXTexture;
            }(), WebGL2GFXTextureView = function() {
                function WebGL2GFXTextureView(device) {
                    var _this;
                    return _classCallCheck(this, WebGL2GFXTextureView), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXTextureView).call(this, device)))._gpuTextureView = null, 
                    _this;
                }
                return _inherits(WebGL2GFXTextureView, GFXTextureView), _createClass(WebGL2GFXTextureView, [ {
                    key: "gpuTextureView",
                    get: function get() {
                        return this._gpuTextureView;
                    }
                } ]), _createClass(WebGL2GFXTextureView, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        return this._texture = info.texture, this._type = info.type, this._format = info.format, 
                        this._format = info.format, void 0 !== info.baseLevel && (this._baseLevel = info.baseLevel), 
                        void 0 !== info.levelCount && (this._levelCount = info.levelCount), void 0 !== info.baseLayer && (this._baseLayer = info.baseLayer), 
                        void 0 !== info.layerCount && (this._layerCount = info.layerCount), this._gpuTextureView = {
                            gpuTexture: info.texture.gpuTexture,
                            type: info.type,
                            format: info.format,
                            baseLevel: info.baseLevel ? info.baseLevel : 0,
                            levelCount: info.levelCount ? info.levelCount : 1
                        }, this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._gpuTextureView = null, this._texture = null, this._status = GFXStatus.UNREADY;
                    }
                } ]), WebGL2GFXTextureView;
            }(), WebGL2GFXWindow = function() {
                function WebGL2GFXWindow(device) {
                    return _classCallCheck(this, WebGL2GFXWindow), _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXWindow).call(this, device));
                }
                return _inherits(WebGL2GFXWindow, GFXWindow), _createClass(WebGL2GFXWindow, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        void 0 !== info.title && (this._title = info.title), void 0 !== info.left && (this._left = info.left), 
                        void 0 !== info.top && (this._top = info.top), void 0 !== info.isOffscreen && (this._isOffscreen = info.isOffscreen), 
                        this._width = info.width, this._height = info.height, this._nativeWidth = this._width, 
                        this._nativeHeight = this._height, this._colorFmt = info.colorFmt, this._depthStencilFmt = info.depthStencilFmt, 
                        this._renderPass = this._device.createRenderPass({
                            colorAttachments: [ {
                                format: this._colorFmt,
                                loadOp: GFXLoadOp.CLEAR,
                                storeOp: GFXStoreOp.STORE,
                                sampleCount: 1,
                                beginLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL,
                                endLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL
                            } ],
                            depthStencilAttachment: {
                                format: this._depthStencilFmt,
                                depthLoadOp: GFXLoadOp.CLEAR,
                                depthStoreOp: GFXStoreOp.STORE,
                                stencilLoadOp: GFXLoadOp.CLEAR,
                                stencilStoreOp: GFXStoreOp.STORE,
                                sampleCount: 1,
                                beginLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
                                endLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL
                            }
                        });
                        var colorViews = [];
                        return this._isOffscreen && (this._colorFmt !== GFXFormat.UNKNOWN && (this._colorTex = this._device.createTexture({
                            type: GFXTextureType.TEX2D,
                            usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                            format: this._colorFmt,
                            width: this._width,
                            height: this._height,
                            depth: 1,
                            arrayLayer: 1,
                            mipLevel: 1,
                            flags: GFXTextureFlagBit.NONE
                        }), this._colorTexView = this._device.createTextureView({
                            texture: this._colorTex,
                            type: GFXTextureViewType.TV2D,
                            format: this._colorFmt,
                            baseLevel: 0,
                            levelCount: 1,
                            baseLayer: 0,
                            layerCount: 1
                        }), colorViews.push(this._colorTexView)), this._depthStencilFmt !== GFXFormat.UNKNOWN && (this._depthStencilTex = this._device.createTexture({
                            type: GFXTextureType.TEX2D,
                            usage: GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT,
                            format: this._depthStencilFmt,
                            width: this._width,
                            height: this._height,
                            depth: 1,
                            arrayLayer: 1,
                            mipLevel: 1,
                            flags: GFXTextureFlagBit.NONE
                        }), this._depthStencilTexView = this._device.createTextureView({
                            texture: this._depthStencilTex,
                            type: GFXTextureViewType.TV2D,
                            format: this._depthStencilFmt,
                            baseLevel: 0,
                            levelCount: 1,
                            baseLayer: 0,
                            layerCount: 1
                        }))), this._framebuffer = this._device.createFramebuffer({
                            renderPass: this._renderPass,
                            colorViews: colorViews,
                            depthStencilView: this._depthStencilTexView,
                            isOffscreen: this._isOffscreen
                        }), this._status = GFXStatus.SUCCESS, !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._depthStencilTexView && (this._depthStencilTexView.destroy(), this._depthStencilTexView = null), 
                        this._depthStencilTex && (this._depthStencilTex.destroy(), this._depthStencilTex = null), 
                        this._colorTexView && (this._colorTexView.destroy(), this._colorTexView = null), 
                        this._colorTex && (this._colorTex.destroy(), this._colorTex = null), this._framebuffer && (this._framebuffer.destroy(), 
                        this._framebuffer = null), this._renderPass && (this._renderPass.destroy(), this._renderPass = null), 
                        this._status = GFXStatus.UNREADY;
                    }
                }, {
                    key: "resize",
                    value: function resize(width, height) {
                        this._width = width, this._height = height, (width > this._nativeWidth || height > this._nativeHeight) && (this._nativeWidth = width, 
                        this._nativeHeight = height, this._depthStencilTex && (this._depthStencilTex.resize(width, height), 
                        this._depthStencilTexView.destroy(), this._depthStencilTexView.initialize({
                            texture: this._depthStencilTex,
                            type: GFXTextureViewType.TV2D,
                            format: this._depthStencilFmt
                        })), this._colorTex && (this._colorTex.resize(width, height), this._colorTexView.destroy(), 
                        this._colorTexView.initialize({
                            texture: this._colorTex,
                            type: GFXTextureViewType.TV2D,
                            format: this._colorFmt
                        })), this._framebuffer && this._framebuffer.isOffscreen && (this._framebuffer.destroy(), 
                        this._framebuffer.initialize({
                            renderPass: this._renderPass,
                            colorViews: [ this._colorTexView ],
                            depthStencilView: this._depthStencilTexView
                        })));
                    }
                } ]), WebGL2GFXWindow;
            }(), WebGL2GFXDevice = function() {
                function WebGL2GFXDevice() {
                    var _this;
                    return _classCallCheck(this, WebGL2GFXDevice), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXDevice).call(this))).stateCache = new WebGL2StateCache(), 
                    _this.nullTex2D = null, _this.nullTexCube = null, _this._webGL2RC = null, _this._isAntialias = !0, 
                    _this._isPremultipliedAlpha = !0, _this._useVAO = !0, _this._extensions = null, 
                    _this._EXT_texture_filter_anisotropic = null, _this._OES_texture_float_linear = null, 
                    _this._OES_texture_half_float_linear = null, _this._EXT_color_buffer_float = null, 
                    _this._EXT_disjoint_timer_query_webgl2 = null, _this._WEBGL_compressed_texture_etc1 = null, 
                    _this._WEBGL_compressed_texture_etc = null, _this._WEBGL_compressed_texture_pvrtc = null, 
                    _this._WEBGL_compressed_texture_astc = null, _this._WEBGL_compressed_texture_s3tc = null, 
                    _this._WEBGL_compressed_texture_s3tc_srgb = null, _this._WEBGL_debug_renderer_info = null, 
                    _this._WEBGL_texture_storage_multisample = null, _this._WEBGL_debug_shaders = null, 
                    _this._WEBGL_lose_context = null, _this;
                }
                return _inherits(WebGL2GFXDevice, GFXDevice), _createClass(WebGL2GFXDevice, [ {
                    key: "gl",
                    get: function get() {
                        return this._webGL2RC;
                    }
                }, {
                    key: "isAntialias",
                    get: function get() {
                        return this._isAntialias;
                    }
                }, {
                    key: "isPremultipliedAlpha",
                    get: function get() {
                        return this._isPremultipliedAlpha;
                    }
                }, {
                    key: "useVAO",
                    get: function get() {
                        return this._useVAO;
                    }
                }, {
                    key: "EXT_texture_filter_anisotropic",
                    get: function get() {
                        return this._EXT_texture_filter_anisotropic;
                    }
                }, {
                    key: "OES_texture_float_linear",
                    get: function get() {
                        return this._OES_texture_float_linear;
                    }
                }, {
                    key: "EXT_color_buffer_float",
                    get: function get() {
                        return this._EXT_color_buffer_float;
                    }
                }, {
                    key: "EXT_disjoint_timer_query_webgl2",
                    get: function get() {
                        return this._EXT_disjoint_timer_query_webgl2;
                    }
                }, {
                    key: "WEBGL_compressed_texture_etc1",
                    get: function get() {
                        return this._WEBGL_compressed_texture_etc1;
                    }
                }, {
                    key: "WEBGL_compressed_texture_etc",
                    get: function get() {
                        return this._WEBGL_compressed_texture_etc;
                    }
                }, {
                    key: "WEBGL_compressed_texture_pvrtc",
                    get: function get() {
                        return this._WEBGL_compressed_texture_pvrtc;
                    }
                }, {
                    key: "WEBGL_compressed_texture_s3tc",
                    get: function get() {
                        return this._WEBGL_compressed_texture_s3tc;
                    }
                }, {
                    key: "WEBGL_compressed_texture_s3tc_srgb",
                    get: function get() {
                        return this._WEBGL_compressed_texture_s3tc_srgb;
                    }
                } ]), _createClass(WebGL2GFXDevice, [ {
                    key: "initialize",
                    value: function initialize(info) {
                        this._canvas = info.canvasElm, this._isAntialias = void 0 === info.isAntialias || info.isAntialias, 
                        this._isPremultipliedAlpha = void 0 === info.isPremultipliedAlpha || info.isPremultipliedAlpha;
                        try {
                            var webGLCtxAttribs = {
                                alpha: !1,
                                antialias: this._isAntialias,
                                depth: !0,
                                stencil: !0,
                                premultipliedAlpha: this._isPremultipliedAlpha,
                                preserveDrawingBuffer: !1,
                                powerPreference: "default",
                                failIfMajorPerformanceCaveat: !1
                            };
                            this._webGL2RC = this._canvas.getContext("webgl2", webGLCtxAttribs);
                        } catch (err) {
                            return console.error(err), !1;
                        }
                        if (!this._webGL2RC) return console.error("This device does not support WebGL2."), 
                        !1;
                        this._canvas2D = document.createElement("canvas"), console.info("WebGL2 device initialized."), 
                        this._gfxAPI = GFXAPI.WEBGL2, this._deviceName = "WebGL2";
                        var gl = this._webGL2RC;
                        this._WEBGL_debug_renderer_info = this.getExtension("WEBGL_debug_renderer_info"), 
                        this._WEBGL_debug_renderer_info ? (this._renderer = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL), 
                        this._vendor = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL)) : (this._renderer = gl.getParameter(gl.RENDERER), 
                        this._vendor = gl.getParameter(gl.VENDOR)), this._version = gl.getParameter(gl.VERSION), 
                        this._maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS), this._maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS), 
                        this._maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS), 
                        this._maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), this._maxVertexTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS), 
                        this._maxUniformBufferBindings = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS), 
                        this._maxUniformBlockSize = gl.getParameter(gl.MAX_UNIFORM_BLOCK_SIZE), this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE), 
                        this._maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE), this._depthBits = gl.getParameter(gl.DEPTH_BITS), 
                        this._stencilBits = gl.getParameter(gl.STENCIL_BITS), this._devicePixelRatio = info.devicePixelRatio || 1, 
                        this._width = this._canvas.width, this._height = this._canvas.height, this._nativeWidth = Math.max(info.nativeWidth || this._width, 0), 
                        this._nativeHeight = Math.max(info.nativeHeight || this._height, 0), this._colorFmt = GFXFormat.RGBA8, 
                        32 === this._depthBits ? 8 === this._stencilBits ? this._depthStencilFmt = GFXFormat.D32F_S8 : this._depthStencilFmt = GFXFormat.D32F : 24 === this._depthBits ? 8 === this._stencilBits ? this._depthStencilFmt = GFXFormat.D24S8 : this._depthStencilFmt = GFXFormat.D24 : 8 === this._stencilBits ? this._depthStencilFmt = GFXFormat.D16S8 : this._depthStencilFmt = GFXFormat.D16, 
                        this._extensions = gl.getSupportedExtensions();
                        var extensions = "";
                        if (this._extensions) {
                            var _iterator = this._extensions, _isArray = Array.isArray(_iterator), _i = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i >= _iterator.length) break;
                                    _ref = _iterator[_i++];
                                } else {
                                    if ((_i = _iterator.next()).done) break;
                                    _ref = _i.value;
                                }
                                extensions += _ref + " ";
                            }
                            console.debug("EXTENSIONS: " + extensions);
                        }
                        this._EXT_texture_filter_anisotropic = this.getExtension("EXT_texture_filter_anisotropic"), 
                        this._EXT_color_buffer_float = this.getExtension("EXT_color_buffer_float"), this._EXT_disjoint_timer_query_webgl2 = this.getExtension("EXT_disjoint_timer_query_webgl2"), 
                        this._OES_texture_float_linear = this.getExtension("OES_texture_float_linear"), 
                        this._OES_texture_half_float_linear = this.getExtension("OES_texture_half_float_linear"), 
                        this._WEBGL_compressed_texture_etc1 = this.getExtension("WEBGL_compressed_texture_etc1"), 
                        this._WEBGL_compressed_texture_etc = this.getExtension("WEBGL_compressed_texture_etc"), 
                        this._WEBGL_compressed_texture_pvrtc = this.getExtension("WEBGL_compressed_texture_pvrtc"), 
                        this._WEBGL_compressed_texture_astc = this.getExtension("WEBGL_compressed_texture_astc"), 
                        this._WEBGL_compressed_texture_s3tc = this.getExtension("WEBGL_compressed_texture_s3tc"), 
                        this._WEBGL_compressed_texture_s3tc_srgb = this.getExtension("WEBGL_compressed_texture_s3tc_srgb"), 
                        this._WEBGL_texture_storage_multisample = this.getExtension("WEBGL_texture_storage_multisample"), 
                        this._WEBGL_debug_shaders = this.getExtension("WEBGL_debug_shaders"), this._WEBGL_lose_context = this.getExtension("WEBGL_lose_context"), 
                        this._features.fill(!1), this._features[GFXFeature.TEXTURE_FLOAT] = !0, this._features[GFXFeature.TEXTURE_HALF_FLOAT] = !0, 
                        this._features[GFXFeature.FORMAT_R11G11B10F] = !0, this._features[GFXFeature.FORMAT_D24S8] = !0, 
                        this._features[GFXFeature.FORMAT_ETC2] = !0, this._features[GFXFeature.MSAA] = !0, 
                        this._EXT_color_buffer_float && (this._features[GFXFeature.COLOR_FLOAT] = !0, this._features[GFXFeature.COLOR_HALF_FLOAT] = !0), 
                        this._OES_texture_float_linear && (this._features[GFXFeature.TEXTURE_FLOAT_LINEAR] = !0), 
                        this._OES_texture_half_float_linear && (this._features[GFXFeature.TEXTURE_HALF_FLOAT_LINEAR] = !0);
                        var compressedFormat = "";
                        this._WEBGL_compressed_texture_etc1 && (this._features[GFXFeature.FORMAT_ETC1] = !0, 
                        compressedFormat += "etc1 "), this._WEBGL_compressed_texture_etc && (this._features[GFXFeature.FORMAT_ETC2] = !0, 
                        compressedFormat += "etc2 "), this._WEBGL_compressed_texture_s3tc && (this._features[GFXFeature.FORMAT_DXT] = !0, 
                        compressedFormat += "dxt "), this._WEBGL_compressed_texture_pvrtc && (this._features[GFXFeature.FORMAT_PVRTC] = !0, 
                        compressedFormat += "pvrtc "), this._WEBGL_compressed_texture_astc && (this._features[GFXFeature.FORMAT_ASTC] = !0, 
                        compressedFormat += "astc "), console.info("RENDERER: " + this._renderer), console.info("VENDOR: " + this._vendor), 
                        console.info("VERSION: " + this._version), console.info("DPR: " + this._devicePixelRatio), 
                        console.info("SCREEN_SIZE: " + this._width + " x " + this._height), console.info("NATIVE_SIZE: " + this._nativeWidth + " x " + this._nativeHeight), 
                        console.info("MAX_VERTEX_UNIFORM_VECTORS: " + this._maxVertexUniformVectors), console.info("MAX_UNIFORM_BUFFER_BINDINGS: " + this._maxUniformBufferBindings), 
                        console.info("DEPTH_BITS: " + this._depthBits), console.info("STENCIL_BITS: " + this._stencilBits), 
                        this._EXT_texture_filter_anisotropic && console.info("MAX_TEXTURE_MAX_ANISOTROPY_EXT: " + this._EXT_texture_filter_anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT), 
                        console.info("USE_VAO: " + this._useVAO), console.info("COMPRESSED_FORMAT: " + compressedFormat), 
                        this.initStates(gl), this._queue = this.createQueue({
                            type: GFXQueueType.GRAPHICS
                        });
                        var canvas = this._webGL2RC.canvas;
                        this._mainWindow = this.createWindow({
                            title: canvas.title || "",
                            left: canvas.offsetLeft || 0,
                            top: canvas.offsetTop || 0,
                            width: this._webGL2RC.drawingBufferWidth,
                            height: this._webGL2RC.drawingBufferHeight,
                            colorFmt: this._colorFmt,
                            depthStencilFmt: this._depthStencilFmt
                        }), this._cmdAllocator = this.createCommandAllocator({}), this.nullTex2D = new WebGL2GFXTexture(this), 
                        this.nullTex2D.initialize({
                            type: GFXTextureType.TEX2D,
                            usage: GFXTextureUsageBit.SAMPLED,
                            format: GFXFormat.RGBA8,
                            width: 2,
                            height: 2,
                            flags: GFXTextureFlagBit.GEN_MIPMAP
                        }), this.nullTexCube = new WebGL2GFXTexture(this), this.nullTexCube.initialize({
                            type: GFXTextureType.TEX2D,
                            usage: GFXTextureUsageBit.SAMPLED,
                            format: GFXFormat.RGBA8,
                            width: 2,
                            height: 2,
                            arrayLayer: 6,
                            flags: GFXTextureFlagBit.CUBEMAP | GFXTextureFlagBit.GEN_MIPMAP
                        });
                        var nullTexRegion = {
                            buffOffset: 0,
                            buffStride: 0,
                            buffTexHeight: 0,
                            texOffset: {
                                x: 0,
                                y: 0,
                                z: 0
                            },
                            texExtent: {
                                width: 2,
                                height: 2,
                                depth: 1
                            },
                            texSubres: {
                                baseMipLevel: 0,
                                levelCount: 1,
                                baseArrayLayer: 0,
                                layerCount: 1
                            }
                        }, nullTexBuff = new Uint8Array(this.nullTex2D.size);
                        return nullTexBuff.fill(0), this.copyBuffersToTexture([ nullTexBuff ], this.nullTex2D, [ nullTexRegion ]), 
                        nullTexRegion.texSubres.layerCount = 6, this.copyBuffersToTexture([ nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff ], this.nullTexCube, [ nullTexRegion ]), 
                        !0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.nullTex2D && (this.nullTex2D.destroy(), this.nullTex2D = null), this.nullTexCube && (this.nullTexCube.destroy(), 
                        this.nullTexCube = null), this._mainWindow && (this._mainWindow.destroy(), this._mainWindow = null), 
                        this._cmdAllocator && (this._cmdAllocator.destroy(), this._cmdAllocator = null), 
                        this._queue && (this._queue.destroy(), this._queue = null), this._webGL2RC = null;
                    }
                }, {
                    key: "resize",
                    value: function resize(width, height) {
                        this._width === width && this._height === height || (console.info("Resizing device: " + width + "x" + height), 
                        this._canvas.width = width, this._canvas.height = height, this._width = width, this._height = height);
                    }
                }, {
                    key: "createBuffer",
                    value: function createBuffer(info) {
                        var buffer = new WebGL2GFXBuffer(this);
                        return buffer.initialize(info), buffer;
                    }
                }, {
                    key: "createTexture",
                    value: function createTexture(info) {
                        var texture = new WebGL2GFXTexture(this);
                        return texture.initialize(info), texture;
                    }
                }, {
                    key: "createTextureView",
                    value: function createTextureView(info) {
                        var texView = new WebGL2GFXTextureView(this);
                        return texView.initialize(info), texView;
                    }
                }, {
                    key: "createSampler",
                    value: function createSampler(info) {
                        var sampler = new WebGL2GFXSampler(this);
                        return sampler.initialize(info), sampler;
                    }
                }, {
                    key: "createBindingLayout",
                    value: function createBindingLayout(info) {
                        var bindingLayout = new WebGL2GFXBindingLayout(this);
                        return bindingLayout.initialize(info), bindingLayout;
                    }
                }, {
                    key: "createShader",
                    value: function createShader(info) {
                        var shader = new WebGL2GFXShader(this);
                        return shader.initialize(info), shader;
                    }
                }, {
                    key: "createInputAssembler",
                    value: function createInputAssembler(info) {
                        var inputAssembler = new WebGL2GFXInputAssembler(this);
                        return inputAssembler.initialize(info), inputAssembler;
                    }
                }, {
                    key: "createRenderPass",
                    value: function createRenderPass(info) {
                        var renderPass = new WebGL2GFXRenderPass(this);
                        return renderPass.initialize(info), renderPass;
                    }
                }, {
                    key: "createFramebuffer",
                    value: function createFramebuffer(info) {
                        var framebuffer = new WebGL2GFXFramebuffer(this);
                        return framebuffer.initialize(info), framebuffer;
                    }
                }, {
                    key: "createPipelineLayout",
                    value: function createPipelineLayout(info) {
                        var pipelineLayout = new WebGL2GFXPipelineLayout(this);
                        return pipelineLayout.initialize(info), pipelineLayout;
                    }
                }, {
                    key: "createPipelineState",
                    value: function createPipelineState(info) {
                        var pipelineState = new WebGL2GFXPipelineState(this);
                        return pipelineState.initialize(info), pipelineState;
                    }
                }, {
                    key: "createCommandAllocator",
                    value: function createCommandAllocator(info) {
                        var cmdAllocator = new WebGL2GFXCommandAllocator(this);
                        return cmdAllocator.initialize(info), cmdAllocator;
                    }
                }, {
                    key: "createCommandBuffer",
                    value: function createCommandBuffer(info) {
                        var cmdBuff = new WebGL2GFXCommandBuffer(this);
                        return cmdBuff.initialize(info), cmdBuff;
                    }
                }, {
                    key: "createQueue",
                    value: function createQueue(info) {
                        var queue = new WebGL2GFXQueue(this);
                        return queue.initialize(info), queue;
                    }
                }, {
                    key: "createWindow",
                    value: function createWindow(info) {
                        var window = new WebGL2GFXWindow(this);
                        return window.initialize(info), window;
                    }
                }, {
                    key: "present",
                    value: function present() {
                        this._cmdAllocator.releaseCmds();
                        var queue = this._queue;
                        this._numDrawCalls = queue.numDrawCalls, this._numTris = queue.numTris, queue.clear();
                    }
                }, {
                    key: "copyBuffersToTexture",
                    value: function copyBuffersToTexture(buffers, texture, regions) {
                        WebGL2CmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
                    }
                }, {
                    key: "copyTexImagesToTexture",
                    value: function copyTexImagesToTexture(texImages, texture, regions) {
                        !function WebGL2CmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
                            var gl = device.gl, glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                            glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture), 
                            glTexUnit.glTexture = gpuTexture.glTexture);
                            var m = 0, n = 0, f = 0;
                            switch (gpuTexture.glTarget) {
                              case gl.TEXTURE_2D:
                                var _iterator19 = regions, _isArray19 = Array.isArray(_iterator19), _i28 = 0;
                                for (_iterator19 = _isArray19 ? _iterator19 : _iterator19[Symbol.iterator](); ;) {
                                    var _ref19;
                                    if (_isArray19) {
                                        if (_i28 >= _iterator19.length) break;
                                        _ref19 = _iterator19[_i28++];
                                    } else {
                                        if ((_i28 = _iterator19.next()).done) break;
                                        _ref19 = _i28.value;
                                    }
                                    var region = _ref19;
                                    for (m = region.texSubres.baseMipLevel; m < region.texSubres.levelCount; ++m) gl.texSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                                }
                                break;

                              case gl.TEXTURE_CUBE_MAP:
                                var _iterator20 = regions, _isArray20 = Array.isArray(_iterator20), _i29 = 0;
                                for (_iterator20 = _isArray20 ? _iterator20 : _iterator20[Symbol.iterator](); ;) {
                                    var _ref20;
                                    if (_isArray20) {
                                        if (_i29 >= _iterator20.length) break;
                                        _ref20 = _iterator20[_i29++];
                                    } else {
                                        if ((_i29 = _iterator20.next()).done) break;
                                        _ref20 = _i29.value;
                                    }
                                    var _region = _ref20, fcount = _region.texSubres.baseArrayLayer + _region.texSubres.layerCount;
                                    for (f = _region.texSubres.baseArrayLayer; f < fcount; ++f) {
                                        var mcount = _region.texSubres.baseMipLevel + _region.texSubres.levelCount;
                                        for (m = _region.texSubres.baseMipLevel; m < mcount; ++m) gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region.texOffset.x, _region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                                    }
                                }
                                break;

                              default:
                                console.error("Unsupported GL texture type, copy buffer to texture failed.");
                            }
                            gpuTexture.flags & GFXTextureFlagBit.GEN_MIPMAP && gl.generateMipmap(gpuTexture.glTarget);
                        }(this, texImages, texture.gpuTexture, regions);
                    }
                }, {
                    key: "copyFramebufferToBuffer",
                    value: function copyFramebufferToBuffer(srcFramebuffer, dstBuffer, regions) {
                        var gl = this._webGL2RC, gpuFramebuffer = srcFramebuffer.gpuFramebuffer, curFBO = this.stateCache.glFramebuffer;
                        this.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer), 
                        this.stateCache.glFramebuffer = gpuFramebuffer.glFramebuffer);
                        var view = new Uint8Array(dstBuffer), _iterator2 = regions, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            var region = _ref2, buffOffset = region.buffOffset + region.buffTexHeight * region.buffStride, w = region.texExtent.width, h = region.texExtent.height, memSize = GFXFormatSize(GFXFormat.RGBA8, w, h, 1), data = view.subarray(buffOffset, buffOffset + memSize);
                            gl.readPixels(region.texOffset.x, region.texOffset.y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, data);
                        }
                        this.stateCache.glFramebuffer !== curFBO && (gl.bindFramebuffer(gl.FRAMEBUFFER, curFBO), 
                        this.stateCache.glFramebuffer = curFBO);
                    }
                }, {
                    key: "blitFramebuffer",
                    value: function blitFramebuffer(src, dst, srcRect, dstRect, filter) {
                        !function WebGL2CmdFuncBlitFramebuffer(device, src, dst, srcRect, dstRect, filter) {
                            var gl = device.gl;
                            device.stateCache.glReadFramebuffer !== src.glFramebuffer && (gl.bindFramebuffer(gl.READ_FRAMEBUFFER, src.glFramebuffer), 
                            device.stateCache.glReadFramebuffer = src.glFramebuffer);
                            var rebindFBO = dst.glFramebuffer !== device.stateCache.glFramebuffer;
                            rebindFBO && gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dst.glFramebuffer);
                            var mask = 0;
                            0 < src.gpuColorViews.length && (mask |= gl.COLOR_BUFFER_BIT), src.gpuDepthStencilView && (mask |= gl.DEPTH_BUFFER_BIT, 
                            GFXFormatInfos[src.gpuDepthStencilView.format].hasStencil && (mask |= gl.STENCIL_BUFFER_BIT));
                            var glFilter = filter === GFXFilter.LINEAR || filter === GFXFilter.ANISOTROPIC ? gl.LINEAR : gl.NEAREST;
                            gl.blitFramebuffer(srcRect.x, srcRect.y, srcRect.x + srcRect.width, srcRect.y + srcRect.height, dstRect.x, dstRect.y, dstRect.x + dstRect.width, dstRect.y + dstRect.height, mask, glFilter), 
                            rebindFBO && gl.bindFramebuffer(gl.FRAMEBUFFER, device.stateCache.glFramebuffer);
                        }(this, src.gpuFramebuffer, dst.gpuFramebuffer, srcRect, dstRect, filter);
                    }
                }, {
                    key: "getExtension",
                    value: function getExtension(ext) {
                        for (var prefixes = [ "", "WEBKIT_", "MOZ_" ], i = 0; i < prefixes.length; ++i) {
                            var _ext = this._webGL2RC.getExtension(prefixes[i] + ext);
                            if (_ext) return _ext;
                        }
                        return null;
                    }
                }, {
                    key: "initStates",
                    value: function initStates(gl) {
                        gl.activeTexture(gl.TEXTURE0), gl.pixelStorei(gl.PACK_ALIGNMENT, 1), gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1), 
                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0), gl.bindFramebuffer(gl.FRAMEBUFFER, null), 
                        gl.enable(gl.CULL_FACE), gl.cullFace(gl.BACK), gl.frontFace(gl.CCW), gl.polygonOffset(0, 0), 
                        gl.enable(gl.DEPTH_TEST), gl.depthMask(!0), gl.depthFunc(gl.LESS), gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 4294967295), 
                        gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP), gl.stencilMaskSeparate(gl.FRONT, 4294967295), 
                        gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 4294967295), gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP), 
                        gl.stencilMaskSeparate(gl.BACK, 4294967295), gl.disable(gl.STENCIL_TEST), gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE), 
                        gl.disable(gl.BLEND), gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO), 
                        gl.colorMask(!0, !0, !0, !0), gl.blendColor(0, 0, 0, 0);
                    }
                } ]), WebGL2GFXDevice;
            }();
            cc.WebGL2GFXDevice = WebGL2GFXDevice;
            var _dec$V, _dec2$x, _dec3$i, _dec4$f, _dec5$e, _dec6$b, _dec7$8, _dec8$3, _dec9$3, _dec10$3, _dec11$2, _class$W, _class2$K, _descriptor$H, _descriptor2$x, _descriptor3$m, _descriptor4$h, _descriptor5$d, _descriptor6$6, _descriptor7$5, _descriptor8$5, _descriptor9$4, _class3$i, _temp$Q, SpriteType, FillType, SizeMode, vec3_temp = new Vec3(), _worldMatrix$1 = new Mat4();
            function fillMeshVertices3D(node, renderer, renderData, color) {
                var datas = renderData.datas, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
                buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
                vertexId = indiceOffset = vertexCount = 0);
                var vbuf = buffer.vData, ibuf = buffer.iData;
                node.getWorldMatrix(_worldMatrix$1);
                for (var i = 0; i < vertexCount; i++) {
                    var vert = datas[i];
                    Vec3.set(vec3_temp, vert.x, vert.y, 0), Vec3.transformMat4(vec3_temp, vec3_temp, _worldMatrix$1), 
                    vbuf[vertexOffset++] = vec3_temp.x, vbuf[vertexOffset++] = vec3_temp.y, vbuf[vertexOffset++] = vec3_temp.z, 
                    vbuf[vertexOffset++] = vert.u, vbuf[vertexOffset++] = vert.v, Color.toArray(vbuf, color, vertexOffset), 
                    vertexOffset += 4;
                }
                for (var _i2 = 0, count = vertexCount / 4; _i2 < count; _i2++) {
                    var start = vertexId + 4 * _i2;
                    ibuf[indiceOffset++] = start, ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 2, 
                    ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 3, ibuf[indiceOffset++] = start + 2;
                }
            }
            !function(SpriteType) {
                SpriteType[SpriteType.SIMPLE = 0] = "SIMPLE", SpriteType[SpriteType.SLICED = 1] = "SLICED", 
                SpriteType[SpriteType.FILLED = 3] = "FILLED";
            }(SpriteType = SpriteType || {}), ccenum(SpriteType), function(FillType) {
                FillType[FillType.HORIZONTAL = 0] = "HORIZONTAL", FillType[FillType.VERTICAL = 1] = "VERTICAL", 
                FillType[FillType.RADIAL = 2] = "RADIAL";
            }(FillType = FillType || {}), ccenum(FillType), function(SizeMode) {
                SizeMode[SizeMode.CUSTOM = 0] = "CUSTOM", SizeMode[SizeMode.TRIMMED = 1] = "TRIMMED", 
                SizeMode[SizeMode.RAW = 2] = "RAW";
            }(SizeMode = SizeMode || {}), ccenum(SizeMode);
            var _dec$W, _dec2$y, _dec3$j, _dec4$g, _dec5$f, _dec6$c, _dec7$9, _dec8$4, _dec9$4, _dec10$4, _dec11$3, _dec12$2, _class$X, _class2$L, _descriptor$I, _descriptor2$y, _descriptor3$n, _descriptor4$i, _descriptor5$e, _descriptor6$7, _descriptor7$6, _descriptor8$6, _descriptor9$5, _descriptor10$3, _descriptor11$2, _descriptor12$2, _descriptor13$2, _descriptor14$2, _class3$j, _temp$R, Transition, State, SpriteComponent = exports("SpriteComponent", (_dec$V = ccclass("cc.SpriteComponent"), 
            _dec2$x = executionOrder(110), _dec3$i = menu("UI/Render/Sprite"), _dec4$f = property({
                type: SpriteAtlas,
                displayOrder: 4
            }), _dec5$e = property({
                type: SpriteFrame,
                displayOrder: 5
            }), _dec6$b = property({
                type: SpriteType,
                displayOrder: 6
            }), _dec7$8 = property({
                type: FillType
            }), _dec8$3 = property({
                range: [ 0, 1, .1 ]
            }), _dec9$3 = property({
                range: [ 0, 1, .1 ]
            }), _dec10$3 = property({
                displayOrder: 8
            }), _dec11$2 = property({
                type: SizeMode,
                displayOrder: 7
            }), _dec$V(_class$W = _dec2$x(_class$W = _dec3$i((_temp$Q = _class3$i = function() {
                function SpriteComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, SpriteComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SpriteComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_spriteFrame", _descriptor$H, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_type", _descriptor2$x, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_fillType", _descriptor3$m, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_sizeMode", _descriptor4$h, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_fillCenter", _descriptor5$d, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_fillStart", _descriptor6$6, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_fillRange", _descriptor7$5, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_isTrimmedMode", _descriptor8$5, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_atlas", _descriptor9$4, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(SpriteComponent, UIRenderComponent), _createClass(SpriteComponent, [ {
                    key: "__preload",
                    value: function __preload() {
                        _get(_getPrototypeOf(SpriteComponent.prototype), "__preload", this) && _get(_getPrototypeOf(SpriteComponent.prototype), "__preload", this).call(this), 
                        this._spriteFrame && (this._spriteFrame.on("load", this._markForUpdateUvDirty, this), 
                        this._markForUpdateUvDirty());
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        _get(_getPrototypeOf(SpriteComponent.prototype), "onEnable", this).call(this), this._activateMaterial();
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        _get(_getPrototypeOf(SpriteComponent.prototype), "onDestroy", this).call(this), 
                        this.destroyRenderData(), this._spriteFrame && this._spriteFrame.off("load");
                    }
                }, {
                    key: "_render",
                    value: function _render(render) {
                        render.commitComp(this, this._spriteFrame.getGFXTextureView(), this._assembler);
                    }
                }, {
                    key: "_canRender",
                    value: function _canRender() {
                        if (!_get(_getPrototypeOf(SpriteComponent.prototype), "_canRender", this).call(this)) return !1;
                        var spriteFrame = this._spriteFrame;
                        return !(!spriteFrame || !spriteFrame.textureLoaded());
                    }
                }, {
                    key: "_flushAssembler",
                    value: function _flushAssembler() {
                        var assembler = SpriteComponent.Assembler.getAssembler(this);
                        this._assembler !== assembler && (this.destroyRenderData(), this._assembler = assembler), 
                        this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), 
                        this._renderData.material = this._material, this.markForUpdateRenderData(), this._updateColor());
                    }
                }, {
                    key: "_applySpriteSize",
                    value: function _applySpriteSize() {
                        if (this._spriteFrame) {
                            if (SizeMode.RAW === this._sizeMode) {
                                var size = this._spriteFrame.originalSize;
                                this.node.setContentSize(size);
                            } else if (SizeMode.TRIMMED === this._sizeMode) {
                                var rect = this._spriteFrame.getRect();
                                this.node.setContentSize(rect.width, rect.height);
                            }
                            this._activateMaterial();
                        }
                    }
                }, {
                    key: "_resized",
                    value: function _resized() {
                    }
                }, {
                    key: "_activateMaterial",
                    value: function _activateMaterial() {
                        var spriteFrame = this._spriteFrame, material = this._material;
                        cc.game.renderType !== cc.game.RENDER_TYPE_CANVAS ? (spriteFrame && material && (material.setProperty("mainTexture", spriteFrame), 
                        this.markForUpdateRenderData()), this._renderData && (this._renderData.material = material)) : this.markForUpdateRenderData();
                    }
                }, {
                    key: "_applyAtlas",
                    value: function _applyAtlas() {
                    }
                }, {
                    key: "_onTextureLoaded",
                    value: function _onTextureLoaded() {
                        this.isValid && this._applySpriteSize();
                    }
                }, {
                    key: "_applySpriteFrame",
                    value: function _applySpriteFrame(oldFrame) {
                        var spriteFrame = this._spriteFrame;
                        this._renderData && (oldFrame && oldFrame.off("load", this._markForUpdateUvDirty), 
                        spriteFrame && spriteFrame.on("load", this._markForUpdateUvDirty, this), this._renderData.uvDirty || (this._renderData.uvDirty = !oldFrame || !spriteFrame || oldFrame.uvHash !== spriteFrame.uvHash), 
                        this._renderDataFlag = this._renderData.uvDirty), spriteFrame && (oldFrame && spriteFrame === oldFrame || (spriteFrame.loaded ? this._onTextureLoaded() : spriteFrame.once("load", this._onTextureLoaded, this)));
                    }
                }, {
                    key: "_markForUpdateUvDirty",
                    value: function _markForUpdateUvDirty() {
                        this._renderData && (this._renderData.uvDirty = !0, this._renderDataFlag = !0);
                    }
                }, {
                    key: "spriteAtlas",
                    get: function get() {
                        return this._atlas;
                    },
                    set: function set(value) {
                        this._atlas !== value && (this._atlas = value, this.spriteFrame = null);
                    }
                }, {
                    key: "spriteFrame",
                    get: function get() {
                        return this._spriteFrame;
                    },
                    set: function set(value) {
                        if (this._spriteFrame !== value) {
                            var lastSprite = this._spriteFrame;
                            this._spriteFrame = value, this.markForUpdateRenderData(!1), this._applySpriteFrame(lastSprite);
                        }
                    }
                }, {
                    key: "type",
                    get: function get() {
                        return this._type;
                    },
                    set: function set(value) {
                        this._type !== value && (this._type = value, this._flushAssembler());
                    }
                }, {
                    key: "fillType",
                    get: function get() {
                        return this._fillType;
                    },
                    set: function set(value) {
                        this._fillType !== value && (value === FillType.RADIAL || this._fillType === FillType.RADIAL ? (this.destroyRenderData(), 
                        this._renderData = null) : this._renderData && this.markForUpdateRenderData(!0)), 
                        this._fillType = value, this._flushAssembler();
                    }
                }, {
                    key: "fillCenter",
                    get: function get() {
                        return this._fillCenter;
                    },
                    set: function set(value) {
                        this._fillCenter.x = value.x, this._fillCenter.y = value.y, this._type === SpriteType.FILLED && this._renderData && this.markForUpdateRenderData();
                    }
                }, {
                    key: "fillStart",
                    get: function get() {
                        return this._fillStart;
                    },
                    set: function set(value) {
                        this._fillStart = clamp(value, -1, 1), this._type === SpriteType.FILLED && this._renderData && (this.markForUpdateRenderData(), 
                        this._renderData.uvDirty = !0);
                    }
                }, {
                    key: "fillRange",
                    get: function get() {
                        return this._fillRange;
                    },
                    set: function set(value) {
                        this._fillRange = clamp(value, 0, 1), this._type === SpriteType.FILLED && this._renderData && (this.markForUpdateRenderData(), 
                        this._renderData.uvDirty = !0);
                    }
                }, {
                    key: "trim",
                    get: function get() {
                        return this._isTrimmedMode;
                    },
                    set: function set(value) {
                        this._isTrimmedMode !== value && (this._isTrimmedMode = value, this._type === SpriteType.SIMPLE && this._renderData && this.markForUpdateRenderData(!0));
                    }
                }, {
                    key: "sizeMode",
                    get: function get() {
                        return this._sizeMode;
                    },
                    set: function set(value) {
                        this._sizeMode !== value && (this._sizeMode = value) !== SizeMode.CUSTOM && this._applySpriteSize();
                    }
                } ]), SpriteComponent;
            }(), _class3$i.FillType = FillType, _class3$i.Type = SpriteType, _class3$i.SizeMode = SizeMode, 
            _applyDecoratedDescriptor((_class2$K = _temp$Q).prototype, "spriteAtlas", [ _dec4$f ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "spriteAtlas"), _class2$K.prototype), 
            _applyDecoratedDescriptor(_class2$K.prototype, "spriteFrame", [ _dec5$e ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "spriteFrame"), _class2$K.prototype), 
            _applyDecoratedDescriptor(_class2$K.prototype, "type", [ _dec6$b ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "type"), _class2$K.prototype), 
            _applyDecoratedDescriptor(_class2$K.prototype, "fillType", [ _dec7$8 ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "fillType"), _class2$K.prototype), 
            _applyDecoratedDescriptor(_class2$K.prototype, "fillCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "fillCenter"), _class2$K.prototype), 
            _applyDecoratedDescriptor(_class2$K.prototype, "fillStart", [ _dec8$3 ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "fillStart"), _class2$K.prototype), 
            _applyDecoratedDescriptor(_class2$K.prototype, "fillRange", [ _dec9$3 ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "fillRange"), _class2$K.prototype), 
            _applyDecoratedDescriptor(_class2$K.prototype, "trim", [ _dec10$3 ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "trim"), _class2$K.prototype), 
            _applyDecoratedDescriptor(_class2$K.prototype, "sizeMode", [ _dec11$2 ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "sizeMode"), _class2$K.prototype), 
            _descriptor$H = _applyDecoratedDescriptor(_class2$K.prototype, "_spriteFrame", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor2$x = _applyDecoratedDescriptor(_class2$K.prototype, "_type", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return SpriteType.SIMPLE;
                }
            }), _descriptor3$m = _applyDecoratedDescriptor(_class2$K.prototype, "_fillType", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return FillType.HORIZONTAL;
                }
            }), _descriptor4$h = _applyDecoratedDescriptor(_class2$K.prototype, "_sizeMode", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return SizeMode.TRIMMED;
                }
            }), _descriptor5$d = _applyDecoratedDescriptor(_class2$K.prototype, "_fillCenter", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec2(0, 0);
                }
            }), _descriptor6$6 = _applyDecoratedDescriptor(_class2$K.prototype, "_fillStart", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor7$5 = _applyDecoratedDescriptor(_class2$K.prototype, "_fillRange", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor8$5 = _applyDecoratedDescriptor(_class2$K.prototype, "_isTrimmedMode", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor9$4 = _applyDecoratedDescriptor(_class2$K.prototype, "_atlas", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _class$W = _class2$K)) || _class$W) || _class$W) || _class$W));
            cc.SpriteComponent = SpriteComponent, function(Transition) {
                Transition[Transition.NONE = 0] = "NONE", Transition[Transition.COLOR = 1] = "COLOR", 
                Transition[Transition.SPRITE = 2] = "SPRITE", Transition[Transition.SCALE = 3] = "SCALE";
            }(Transition = Transition || {}), ccenum(Transition), function(State) {
                State.NORMAL = "normal", State.HOVER = "hover", State.PRESSED = "pressed", State.DISABLED = "disabled";
            }(State = State || {});
            var ButtonComponent = exports("ButtonComponent", (_dec$W = ccclass("cc.ButtonComponent"), 
            _dec2$y = executionOrder(110), _dec3$j = menu("UI/Button"), _dec4$g = property({
                displayOrder: 1
            }), _dec5$f = property({
                type: Transition,
                displayOrder: 2
            }), _dec6$c = property({
                min: 0,
                max: 10
            }), _dec7$9 = property({
                type: SpriteFrame
            }), _dec8$4 = property({
                type: SpriteFrame
            }), _dec9$4 = property({
                type: SpriteFrame
            }), _dec10$4 = property({
                type: SpriteFrame
            }), _dec11$3 = property({
                type: Node$1,
                displayOrder: 0
            }), _dec12$2 = property({
                type: [ EventHandler ],
                displayOrder: 3
            }), _dec$W(_class$X = _dec2$y(_class$X = _dec3$j((_temp$R = _class3$j = function() {
                function ButtonComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, ButtonComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ButtonComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "clickEvents", _descriptor$I, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_interactable", _descriptor2$y, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_transition", _descriptor3$n, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_normalColor", _descriptor4$i, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_hoverColor", _descriptor5$e, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_pressColor", _descriptor6$7, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_disabledColor", _descriptor7$6, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_normalSprite", _descriptor8$6, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_hoverSprite", _descriptor9$5, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_pressedSprite", _descriptor10$3, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_disabledSprite", _descriptor11$2, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_duration", _descriptor12$2, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_zoomScale", _descriptor13$2, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_target", _descriptor14$2, _assertThisInitialized(_this)), 
                    _this._pressed = !1, _this._hovered = !1, _this._fromColor = new Color(), _this._toColor = new Color(), 
                    _this._time = 0, _this._transitionFinished = !0, _this._fromScale = new Vec3(), 
                    _this._toScale = new Vec3(), _this._originalScale = new Vec3(), _this._sprite = null, 
                    _this._targetScale = new Vec3(), _this;
                }
                return _inherits(ButtonComponent, Component), _createClass(ButtonComponent, [ {
                    key: "__preload",
                    value: function __preload() {
                        this.target || (this.target = this.node);
                        var sprite = this.node.getComponent(SpriteComponent);
                        sprite && (this._normalSprite = sprite.spriteFrame), this._applyTarget(), this._updateState();
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        this._registerEvent();
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this._resetState(), this.node.off(SystemEventType.TOUCH_START, this._onTouchBegan, this), 
                        this.node.off(SystemEventType.TOUCH_MOVE, this._onTouchMove, this), this.node.off(SystemEventType.TOUCH_END, this._onTouchEnded, this), 
                        this.node.off(SystemEventType.TOUCH_CANCEL, this._onTouchCancel, this), this.node.off(SystemEventType.MOUSE_ENTER, this._onMouseMoveIn, this), 
                        this.node.off(SystemEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
                    }
                }, {
                    key: "update",
                    value: function update(dt) {
                        var target = this._target ? this._target : this.node;
                        if (!this._transitionFinished && (this._transition === Transition.COLOR || this._transition === Transition.SCALE)) {
                            this._time += dt;
                            var ratio = 1;
                            0 < this._duration && (ratio = this._time / this._duration), 1 <= ratio && (ratio = 1, 
                            this._transitionFinished = !0);
                            var renderComp = target.getComponent(UIRenderComponent);
                            renderComp && (this._transition === Transition.COLOR ? Color.lerp(renderComp.color, this._fromColor, this._toColor, ratio) : this.transition === Transition.SCALE && (target.getScale(this._targetScale), 
                            this._targetScale.x = lerp(this._fromScale.x, this._toScale.x, ratio), this._targetScale.y = lerp(this._fromScale.y, this._toScale.y, ratio), 
                            target.setScale(this._targetScale)));
                        }
                    }
                }, {
                    key: "_resizeNodeToTargetNode",
                    value: function _resizeNodeToTargetNode() {
                        0;
                    }
                }, {
                    key: "_resetState",
                    value: function _resetState() {
                        this._pressed = !1, this._hovered = !1;
                        var target = this._target;
                        if (target) {
                            var renderComp = target.getComponent(UIRenderComponent);
                            if (renderComp) {
                                var transition = this._transition;
                                transition === Transition.COLOR && this._interactable ? renderComp.color = this._normalColor : transition === Transition.SCALE && target.setScale(this._originalScale), 
                                this._transitionFinished = !0;
                            }
                        }
                    }
                }, {
                    key: "_registerEvent",
                    value: function _registerEvent() {
                        this.node.on(SystemEventType.TOUCH_START, this._onTouchBegan, this), this.node.on(SystemEventType.TOUCH_MOVE, this._onTouchMove, this), 
                        this.node.on(SystemEventType.TOUCH_END, this._onTouchEnded, this), this.node.on(SystemEventType.TOUCH_CANCEL, this._onTouchCancel, this), 
                        this.node.on(SystemEventType.MOUSE_ENTER, this._onMouseMoveIn, this), this.node.on(SystemEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
                    }
                }, {
                    key: "_getTargetSprite",
                    value: function _getTargetSprite(target) {
                        var sprite = null;
                        return target && (sprite = target.getComponent(SpriteComponent)), sprite;
                    }
                }, {
                    key: "_applyTarget",
                    value: function _applyTarget() {
                        this._sprite = this._getTargetSprite(this._target), this._target && Vec3.copy(this._originalScale, this._target.getScale());
                    }
                }, {
                    key: "_onTouchBegan",
                    value: function _onTouchBegan(event) {
                        this._interactable && this.enabledInHierarchy && (this._pressed = !0, this._updateState(), 
                        event && (event.propagationStopped = !0));
                    }
                }, {
                    key: "_onTouchMove",
                    value: function _onTouchMove(event) {
                        if (this._interactable && this.enabledInHierarchy && this._pressed) {
                            if (!event) return !1;
                            var touch = event.touch;
                            if (!touch) return !1;
                            var state, hit = this.node.uiTransfromComp.isHit(touch.getUILocation());
                            if (this._transition === Transition.SCALE && this._target) hit ? (Vec3.copy(this._fromScale, this._originalScale), 
                            Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale), this._transitionFinished = !1) : (this._time = 0, 
                            this._transitionFinished = !0, this._target && this._target.setScale(this._originalScale)); else state = hit ? State.PRESSED : State.NORMAL, 
                            this._applyTransition(state);
                            event && (event.propagationStopped = !0);
                        }
                    }
                }, {
                    key: "_onTouchEnded",
                    value: function _onTouchEnded(event) {
                        this._interactable && this.enabledInHierarchy && (this._pressed && (EventHandler.emitEvents(this.clickEvents, event), 
                        this.node.emit("click", this)), this._pressed = !1, this._updateState(), event && (event.propagationStopped = !0));
                    }
                }, {
                    key: "_onTouchCancel",
                    value: function _onTouchCancel() {
                        this._interactable && this.enabledInHierarchy && (this._pressed = !1, this._updateState());
                    }
                }, {
                    key: "_onMouseMoveIn",
                    value: function _onMouseMoveIn() {
                        !this._pressed && this.interactable && this.enabledInHierarchy && (this._transition === Transition.SPRITE && !this._hoverSprite || this._hovered || (this._hovered = !0, 
                        this._updateState()));
                    }
                }, {
                    key: "_onMouseMoveOut",
                    value: function _onMouseMoveOut() {
                        this._hovered && (this._hovered = !1, this._updateState());
                    }
                }, {
                    key: "_updateState",
                    value: function _updateState() {
                        var state = this._getButtonState();
                        this._applyTransition(state);
                    }
                }, {
                    key: "_getButtonState",
                    value: function _getButtonState() {
                        var state = State.NORMAL;
                        return this._interactable ? this._pressed ? state = State.PRESSED : this._hovered && (state = State.HOVER) : state = State.DISABLED, 
                        state.toString();
                    }
                }, {
                    key: "_updateColorTransition",
                    value: function _updateColorTransition(state) {
                        var color = this[state + "Color"], target = this._target;
                        if (target) {
                            var renderComp = target.getComponent(UIRenderComponent);
                            renderComp && (state === State.DISABLED ? renderComp.color = color : (this._fromColor = renderComp.color.clone(), 
                            this._toColor = color, this._time = 0, this._transitionFinished = !1));
                        }
                    }
                }, {
                    key: "_updateSpriteTransition",
                    value: function _updateSpriteTransition(state) {
                        var sprite = this[state + "Sprite"];
                        this._sprite && sprite && (this._sprite.spriteFrame = sprite);
                    }
                }, {
                    key: "_updateScaleTransition",
                    value: function _updateScaleTransition(state) {
                        this._interactable && (state === State.PRESSED ? this._zoomUp() : this._zoomBack());
                    }
                }, {
                    key: "_zoomUp",
                    value: function _zoomUp() {
                        Vec3.copy(this._fromScale, this._originalScale), Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale), 
                        this._time = 0, this._transitionFinished = !1;
                    }
                }, {
                    key: "_zoomBack",
                    value: function _zoomBack() {
                        this._target && (Vec3.copy(this._fromScale, this._target.getScale()), Vec3.copy(this._toScale, this._originalScale), 
                        this._time = 0, this._transitionFinished = !1);
                    }
                }, {
                    key: "_applyTransition",
                    value: function _applyTransition(state) {
                        var transition = this._transition;
                        transition === Transition.COLOR ? this._updateColorTransition(state) : transition === Transition.SPRITE ? this._updateSpriteTransition(state) : transition === Transition.SCALE && this._updateScaleTransition(state);
                    }
                }, {
                    key: "interactable",
                    get: function get() {
                        return this._interactable;
                    },
                    set: function set(value) {
                        this._interactable = value, this._updateState(), this._interactable || this._resetState();
                    }
                }, {
                    key: "_resizeToTarget",
                    set: function set(value) {
                        value && this._resizeNodeToTargetNode();
                    }
                }, {
                    key: "transition",
                    get: function get() {
                        return this._transition;
                    },
                    set: function set(value) {
                        this._transition !== value && (this._transition = value);
                    }
                }, {
                    key: "normalColor",
                    get: function get() {
                        return this._normalColor;
                    },
                    set: function set(value) {
                        this._normalColor !== value && (this._normalColor.set(value), this._updateState());
                    }
                }, {
                    key: "pressedColor",
                    get: function get() {
                        return this._pressColor;
                    },
                    set: function set(value) {
                        this._pressColor !== value && this._pressColor.set(value);
                    }
                }, {
                    key: "hoverColor",
                    get: function get() {
                        return this._hoverColor;
                    },
                    set: function set(value) {
                        this._hoverColor !== value && this._hoverColor.set(value);
                    }
                }, {
                    key: "disabledColor",
                    get: function get() {
                        return this._disabledColor;
                    },
                    set: function set(value) {
                        this._disabledColor !== value && (this._disabledColor.set(value), this._updateState());
                    }
                }, {
                    key: "duration",
                    get: function get() {
                        return this._duration;
                    },
                    set: function set(value) {
                        this._duration !== value && (this._duration = value);
                    }
                }, {
                    key: "zoomScale",
                    get: function get() {
                        return this._zoomScale;
                    },
                    set: function set(value) {
                        this._zoomScale !== value && (this._zoomScale = value);
                    }
                }, {
                    key: "normalSprite",
                    get: function get() {
                        return this._normalSprite;
                    },
                    set: function set(value) {
                        if (this._normalSprite !== value) {
                            this._normalSprite = value;
                            var sprite = this.node.getComponent(SpriteComponent);
                            sprite && (sprite.spriteFrame = value), this._updateState();
                        }
                    }
                }, {
                    key: "pressedSprite",
                    get: function get() {
                        return this._pressedSprite;
                    },
                    set: function set(value) {
                        this._pressedSprite !== value && (this._pressedSprite = value, this._updateState());
                    }
                }, {
                    key: "hoverSprite",
                    get: function get() {
                        return this._hoverSprite;
                    },
                    set: function set(value) {
                        this._hoverSprite !== value && (this._hoverSprite = value, this._updateState());
                    }
                }, {
                    key: "disabledSprite",
                    get: function get() {
                        return this._disabledSprite;
                    },
                    set: function set(value) {
                        this._disabledSprite !== value && (this._disabledSprite = value, this._updateState());
                    }
                }, {
                    key: "target",
                    get: function get() {
                        return this._target;
                    },
                    set: function set(value) {
                        this._target !== value && (this._target = value, this._applyTarget());
                    }
                } ]), ButtonComponent;
            }(), _class3$j.Transition = Transition, _applyDecoratedDescriptor((_class2$L = _temp$R).prototype, "interactable", [ _dec4$g ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "interactable"), _class2$L.prototype), 
            _applyDecoratedDescriptor(_class2$L.prototype, "transition", [ _dec5$f ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "transition"), _class2$L.prototype), 
            _applyDecoratedDescriptor(_class2$L.prototype, "normalColor", [ property ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "normalColor"), _class2$L.prototype), 
            _applyDecoratedDescriptor(_class2$L.prototype, "pressedColor", [ property ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "pressedColor"), _class2$L.prototype), 
            _applyDecoratedDescriptor(_class2$L.prototype, "hoverColor", [ property ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "hoverColor"), _class2$L.prototype), 
            _applyDecoratedDescriptor(_class2$L.prototype, "disabledColor", [ property ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "disabledColor"), _class2$L.prototype), 
            _applyDecoratedDescriptor(_class2$L.prototype, "duration", [ _dec6$c ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "duration"), _class2$L.prototype), 
            _applyDecoratedDescriptor(_class2$L.prototype, "zoomScale", [ property ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "zoomScale"), _class2$L.prototype), 
            _applyDecoratedDescriptor(_class2$L.prototype, "normalSprite", [ _dec7$9 ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "normalSprite"), _class2$L.prototype), 
            _applyDecoratedDescriptor(_class2$L.prototype, "pressedSprite", [ _dec8$4 ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "pressedSprite"), _class2$L.prototype), 
            _applyDecoratedDescriptor(_class2$L.prototype, "hoverSprite", [ _dec9$4 ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "hoverSprite"), _class2$L.prototype), 
            _applyDecoratedDescriptor(_class2$L.prototype, "disabledSprite", [ _dec10$4 ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "disabledSprite"), _class2$L.prototype), 
            _applyDecoratedDescriptor(_class2$L.prototype, "target", [ _dec11$3 ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "target"), _class2$L.prototype), 
            _descriptor$I = _applyDecoratedDescriptor(_class2$L.prototype, "clickEvents", [ _dec12$2 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor2$y = _applyDecoratedDescriptor(_class2$L.prototype, "_interactable", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor3$n = _applyDecoratedDescriptor(_class2$L.prototype, "_transition", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Transition.NONE;
                }
            }), _descriptor4$i = _applyDecoratedDescriptor(_class2$L.prototype, "_normalColor", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Color(214, 214, 214, 255);
                }
            }), _descriptor5$e = _applyDecoratedDescriptor(_class2$L.prototype, "_hoverColor", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Color(211, 211, 211, 255);
                }
            }), _descriptor6$7 = _applyDecoratedDescriptor(_class2$L.prototype, "_pressColor", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Color.WHITE.clone();
                }
            }), _descriptor7$6 = _applyDecoratedDescriptor(_class2$L.prototype, "_disabledColor", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Color(124, 124, 124, 255);
                }
            }), _descriptor8$6 = _applyDecoratedDescriptor(_class2$L.prototype, "_normalSprite", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor9$5 = _applyDecoratedDescriptor(_class2$L.prototype, "_hoverSprite", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor10$3 = _applyDecoratedDescriptor(_class2$L.prototype, "_pressedSprite", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor11$2 = _applyDecoratedDescriptor(_class2$L.prototype, "_disabledSprite", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor12$2 = _applyDecoratedDescriptor(_class2$L.prototype, "_duration", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return .1;
                }
            }), _descriptor13$2 = _applyDecoratedDescriptor(_class2$L.prototype, "_zoomScale", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1.2;
                }
            }), _descriptor14$2 = _applyDecoratedDescriptor(_class2$L.prototype, "_target", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _class$X = _class2$L)) || _class$X) || _class$X) || _class$X));
            cc.ButtonComponent = ButtonComponent;
            var _dec$X, _dec2$z, _dec3$k, _dec4$h, _dec5$g, _dec6$d, _dec7$a, _dec8$5, _dec9$5, _dec10$5, _dec11$4, _dec12$3, _dec13$1, _dec14$1, _dec15$1, _dec16$1, _dec17$1, _dec18$1, _class$Y, _class2$M, _descriptor$J, _descriptor2$z, _descriptor3$o, _descriptor4$j, _descriptor5$f, _descriptor6$8, _descriptor7$7, _descriptor8$7, _descriptor9$6, _descriptor10$4, _descriptor11$3, _descriptor12$3, _descriptor13$3, _descriptor14$3, _descriptor15, _descriptor16, _class3$k, _temp$S, HorizontalTextAlignment, VerticalTextAlignment, Overflow, CacheMode, CanvasPool = exports("CanvasPool", function() {
                function CanvasPool() {
                    _classCallCheck(this, CanvasPool), this.pool = [];
                }
                return _createClass(CanvasPool, [ {
                    key: "get",
                    value: function get() {
                        var data = this.pool.pop();
                        if (!data) {
                            var canvas = document.createElement("canvas"), context = canvas.getContext("2d");
                            data = {
                                canvas: canvas,
                                context: context
                            };
                        }
                        return data;
                    }
                }, {
                    key: "put",
                    value: function put(canvas) {
                        32 <= this.pool.length || this.pool.push(canvas);
                    }
                } ]), CanvasPool;
            }());
            !function(HorizontalTextAlignment) {
                HorizontalTextAlignment[HorizontalTextAlignment.LEFT = 0] = "LEFT", HorizontalTextAlignment[HorizontalTextAlignment.CENTER = 1] = "CENTER", 
                HorizontalTextAlignment[HorizontalTextAlignment.RIGHT = 2] = "RIGHT";
            }(HorizontalTextAlignment = HorizontalTextAlignment || exports("HorizontalTextAlignment", {})), 
            ccenum(HorizontalTextAlignment), function(VerticalTextAlignment) {
                VerticalTextAlignment[VerticalTextAlignment.TOP = 0] = "TOP", VerticalTextAlignment[VerticalTextAlignment.CENTER = 1] = "CENTER", 
                VerticalTextAlignment[VerticalTextAlignment.BOTTOM = 2] = "BOTTOM";
            }(VerticalTextAlignment = VerticalTextAlignment || exports("VerticalTextAlignment", {})), 
            ccenum(VerticalTextAlignment), function(Overflow) {
                Overflow[Overflow.NONE = 0] = "NONE", Overflow[Overflow.CLAMP = 1] = "CLAMP", Overflow[Overflow.SHRINK = 2] = "SHRINK", 
                Overflow[Overflow.RESIZE_HEIGHT = 3] = "RESIZE_HEIGHT";
            }(Overflow = Overflow || exports("Overflow", {})), ccenum(Overflow), function(CacheMode) {
                CacheMode[CacheMode.NONE = 0] = "NONE", CacheMode[CacheMode.BITMAP = 1] = "BITMAP", 
                CacheMode[CacheMode.CHAR = 2] = "CHAR";
            }(CacheMode = CacheMode || {}), ccenum(CacheMode);
            var KeyboardReturnType, InputMode, InputFlag, _class$Z, LabelComponent = exports("LabelComponent", (_dec$X = ccclass("cc.LabelComponent"), 
            _dec2$z = executionOrder(110), _dec3$k = menu("UI/Render/Label"), _dec4$h = property({
                displayOrder: 4,
                multiline: !0
            }), _dec5$g = property({
                type: HorizontalTextAlignment,
                displayOrder: 5
            }), _dec6$d = property({
                type: VerticalTextAlignment,
                displayOrder: 6
            }), _dec7$a = property({
                readonly: !0,
                displayName: "Actual Font Size",
                visible: !1
            }), _dec8$5 = property({
                displayOrder: 7
            }), _dec9$5 = property({
                displayOrder: 8
            }), _dec10$5 = property({
                displayOrder: 8
            }), _dec11$4 = property({
                type: Overflow,
                displayOrder: 9
            }), _dec12$3 = property({
                displayOrder: 10
            }), _dec13$1 = property({
                type: Font,
                displayOrder: 11
            }), _dec14$1 = property({
                displayOrder: 12
            }), _dec15$1 = property({
                type: CacheMode,
                displayOrder: 13
            }), _dec16$1 = property({
                displayOrder: 15
            }), _dec17$1 = property({
                displayOrder: 16
            }), _dec18$1 = property({
                displayOrder: 17
            }), _dec$X(_class$Y = _dec2$z(_class$Y = _dec3$k((_temp$S = _class3$k = function() {
                function LabelComponent() {
                    var _this;
                    return _classCallCheck(this, LabelComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(LabelComponent).call(this)), "_useOriginalSize", _descriptor$J, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_string", _descriptor2$z, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_horizontalAlign", _descriptor3$o, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_verticalAlign", _descriptor4$j, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_actualFontSize", _descriptor5$f, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_fontSize", _descriptor6$8, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_fontFamily", _descriptor7$7, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_lineHeight", _descriptor8$7, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_overflow", _descriptor9$6, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_enableWrapText", _descriptor10$4, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_font", _descriptor11$3, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_isSystemFontUsed", _descriptor12$3, _assertThisInitialized(_this)), 
                    _this._spacingX = 0, _initializerDefineProperty(_this, "_isItalic", _descriptor13$3, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_isBold", _descriptor14$3, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_isUnderline", _descriptor15, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_cacheMode", _descriptor16, _assertThisInitialized(_this)), 
                    _this._N$file = null, _this._texture = null, _this._ttfSpriteFrame = null, _this._userDefinedFont = null, 
                    _this._assemblerData = null, _this._fontAtlas = null, _this._letterTexture = null, 
                    _this._ttfSpriteFrame = null, _this;
                }
                return _inherits(LabelComponent, UIRenderComponent), _createClass(LabelComponent, [ {
                    key: "string",
                    get: function get() {
                        return this._string;
                    },
                    set: function set(value) {
                        value = value.toString(), this._string !== value && (this._string = value, this.updateRenderData());
                    }
                }, {
                    key: "horizontalAlign",
                    get: function get() {
                        return this._horizontalAlign;
                    },
                    set: function set(value) {
                        this._horizontalAlign !== value && (this._horizontalAlign = value, this.updateRenderData());
                    }
                }, {
                    key: "verticalAlign",
                    get: function get() {
                        return this._verticalAlign;
                    },
                    set: function set(value) {
                        this._verticalAlign !== value && (this._verticalAlign = value, this.updateRenderData());
                    }
                }, {
                    key: "actualFontSize",
                    get: function get() {
                        return this._actualFontSize;
                    },
                    set: function set(value) {
                        this._actualFontSize = value;
                    }
                }, {
                    key: "fontSize",
                    get: function get() {
                        return this._fontSize;
                    },
                    set: function set(value) {
                        this._fontSize !== value && (this._fontSize = value, this.updateRenderData());
                    }
                }, {
                    key: "fontFamily",
                    get: function get() {
                        return this._fontFamily;
                    },
                    set: function set(value) {
                        this._fontFamily !== value && (this._fontFamily = value, this.updateRenderData());
                    }
                }, {
                    key: "lineHeight",
                    get: function get() {
                        return this._lineHeight;
                    },
                    set: function set(value) {
                        this._lineHeight !== value && (this._lineHeight = value, this.updateRenderData());
                    }
                }, {
                    key: "overflow",
                    get: function get() {
                        return this._overflow;
                    },
                    set: function set(value) {
                        this._overflow !== value && (this._overflow = value, this.updateRenderData());
                    }
                }, {
                    key: "enableWrapText",
                    get: function get() {
                        return this._enableWrapText;
                    },
                    set: function set(value) {
                        this._enableWrapText !== value && (this._enableWrapText = value, this.updateRenderData());
                    }
                }, {
                    key: "font",
                    get: function get() {
                        return this._font;
                    },
                    set: function set(value) {
                        this._font !== value && (this._isSystemFontUsed = !value, "string" == typeof (this._font = value) && warnID(4e3), 
                        this._renderData && (this.destroyRenderData(), this._renderData = null), this._fontAtlas = null, 
                        this.updateRenderData(!0));
                    }
                }, {
                    key: "useSystemFont",
                    get: function get() {
                        return this._isSystemFontUsed;
                    },
                    set: function set(value) {
                        this._isSystemFontUsed !== value && (this.destroyRenderData(), this._renderData = null, 
                        this._isSystemFontUsed = !!value, value && (this.font = null, this._flushAssembler(), 
                        this.updateRenderData()));
                    }
                }, {
                    key: "cacheMode",
                    get: function get() {
                        return this._cacheMode;
                    },
                    set: function set(value) {
                        this._cacheMode !== value && (this._cacheMode === CacheMode.CHAR && (this._ttfSpriteFrame = null), 
                        this._cacheMode = value, this.updateRenderData(!0));
                    }
                }, {
                    key: "spriteFrame",
                    get: function get() {
                        return this._texture;
                    }
                }, {
                    key: "isBold",
                    get: function get() {
                        return this._isBold;
                    },
                    set: function set(value) {
                        this._isBold !== value && (this._isBold = value, this.updateRenderData());
                    }
                }, {
                    key: "isItalic",
                    get: function get() {
                        return this._isItalic;
                    },
                    set: function set(value) {
                        this._isItalic !== value && (this._isItalic = value, this.updateRenderData());
                    }
                }, {
                    key: "isUnderline",
                    get: function get() {
                        return this._isUnderline;
                    },
                    set: function set(value) {
                        this._isUnderline !== value && (this._isUnderline = value, this.updateRenderData());
                    }
                }, {
                    key: "assemblerData",
                    get: function get() {
                        return this._assemblerData;
                    }
                }, {
                    key: "fontAtlas",
                    get: function get() {
                        return this._fontAtlas;
                    },
                    set: function set(value) {
                        this._fontAtlas = value;
                    }
                }, {
                    key: "spacingX",
                    get: function get() {
                        return this._spacingX;
                    },
                    set: function set(value) {
                        this._spacingX !== value && (this._spacingX = value, this.updateRenderData());
                    }
                }, {
                    key: "_bmFontOriginalSize",
                    get: function get() {
                        return this._font instanceof BitmapFont ? this._font.fontSize : -1;
                    }
                } ]), _createClass(LabelComponent, [ {
                    key: "onEnable",
                    value: function onEnable() {
                        _get(_getPrototypeOf(LabelComponent.prototype), "onEnable", this).call(this), this._font || this._isSystemFontUsed || (this.useSystemFont = !0), 
                        this._isSystemFontUsed && !this._fontFamily && (this.fontFamily = "Arial"), this.updateRenderData(!0);
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        _get(_getPrototypeOf(LabelComponent.prototype), "onDisable", this).call(this);
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        if (this._assembler && this._assembler.resetAssemblerData && this._assembler.resetAssemblerData(this._assemblerData), 
                        this._assemblerData = null, this._ttfSpriteFrame) {
                            var tex = this._ttfSpriteFrame.texture;
                            if (tex) {
                                var tex2d = tex;
                                tex2d.image && tex2d.image.destroy(), tex.destroy();
                            }
                            this._ttfSpriteFrame = null;
                        }
                        this._letterTexture && (this._letterTexture.destroy(), this._letterTexture = null), 
                        _get(_getPrototypeOf(LabelComponent.prototype), "onDestroy", this).call(this);
                    }
                }, {
                    key: "updateRenderData",
                    value: function updateRenderData(argument_0) {
                        var force = 0 < arguments.length && void 0 !== argument_0 && argument_0;
                        this.markForUpdateRenderData(), force && (this._flushAssembler(), this._applyFontTexture(force));
                    }
                }, {
                    key: "_render",
                    value: function _render(render) {
                        render.commitComp(this, this._texture.getGFXTextureView(), this._assembler);
                    }
                }, {
                    key: "_updateColor",
                    value: function _updateColor() {
                        this._font instanceof BitmapFont ? _get(_getPrototypeOf(LabelComponent.prototype), "_updateColor", this).call(this) : this.updateRenderData(!1);
                    }
                }, {
                    key: "_canRender",
                    value: function _canRender() {
                        if (!_get(_getPrototypeOf(LabelComponent.prototype), "_canRender", this).call(this) || !this._string) return !1;
                        var font = this._font;
                        if (font && font instanceof BitmapFont) {
                            var spriteFrame = font.spriteFrame;
                            if (!spriteFrame || !spriteFrame.textureLoaded()) return !1;
                        }
                        return !0;
                    }
                }, {
                    key: "_flushAssembler",
                    value: function _flushAssembler() {
                        var assembler = LabelComponent.Assembler.getAssembler(this);
                        this._assembler !== assembler && (this.destroyRenderData(), this._assembler = assembler), 
                        this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), 
                        this._renderData.material = this._material);
                    }
                }, {
                    key: "_flushMaterial",
                    value: function _flushMaterial() {
                        var material = this._material;
                        material && material.setProperty("mainTexture", this._texture), this._updateMaterial(material);
                    }
                }, {
                    key: "_applyFontTexture",
                    value: function _applyFontTexture(force) {
                        var _this2 = this, font = this._font;
                        if (font instanceof BitmapFont) {
                            var spriteFrame = font.spriteFrame, self = this;
                            spriteFrame && spriteFrame.loaded && function onBMFontTextureLoaded() {
                                self._texture = spriteFrame, self._flushMaterial(), force && _this2._renderFlag && _this2._assembler && _this2._renderData && _this2._assembler.updateRenderData(_this2);
                            }();
                        } else {
                            if (this.cacheMode === CacheMode.CHAR && sys.browserType !== sys.BROWSER_TYPE_WECHAT_GAME_SUB) this._letterTexture = this._assembler.getAssemblerData(), 
                            this._texture = this._letterTexture; else if (!this._ttfSpriteFrame) {
                                this._ttfSpriteFrame = new SpriteFrame(), this._assemblerData = this._assembler.getAssemblerData();
                                var tex = new ImageAsset(this._assemblerData.canvas)._texture;
                                this._ttfSpriteFrame.texture = tex;
                            }
                            this.cacheMode !== CacheMode.CHAR && (this._texture = this._ttfSpriteFrame), this._flushMaterial();
                        }
                        force && this._renderFlag && this._assembler && this._renderData && this._assembler.updateRenderData(this);
                    }
                } ]), LabelComponent;
            }(), _class3$k.HorizontalAlign = HorizontalTextAlignment, _class3$k.VerticalAlign = VerticalTextAlignment, 
            _class3$k.Overflow = Overflow, _class3$k.CacheMode = CacheMode, _class3$k.CanvasPool = new CanvasPool(), 
            _applyDecoratedDescriptor((_class2$M = _temp$S).prototype, "string", [ _dec4$h ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "string"), _class2$M.prototype), 
            _applyDecoratedDescriptor(_class2$M.prototype, "horizontalAlign", [ _dec5$g ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "horizontalAlign"), _class2$M.prototype), 
            _applyDecoratedDescriptor(_class2$M.prototype, "verticalAlign", [ _dec6$d ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "verticalAlign"), _class2$M.prototype), 
            _applyDecoratedDescriptor(_class2$M.prototype, "actualFontSize", [ _dec7$a ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "actualFontSize"), _class2$M.prototype), 
            _applyDecoratedDescriptor(_class2$M.prototype, "fontSize", [ _dec8$5 ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "fontSize"), _class2$M.prototype), 
            _applyDecoratedDescriptor(_class2$M.prototype, "fontFamily", [ _dec9$5 ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "fontFamily"), _class2$M.prototype), 
            _applyDecoratedDescriptor(_class2$M.prototype, "lineHeight", [ _dec10$5 ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "lineHeight"), _class2$M.prototype), 
            _applyDecoratedDescriptor(_class2$M.prototype, "overflow", [ _dec11$4 ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "overflow"), _class2$M.prototype), 
            _applyDecoratedDescriptor(_class2$M.prototype, "enableWrapText", [ _dec12$3 ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "enableWrapText"), _class2$M.prototype), 
            _applyDecoratedDescriptor(_class2$M.prototype, "font", [ _dec13$1 ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "font"), _class2$M.prototype), 
            _applyDecoratedDescriptor(_class2$M.prototype, "useSystemFont", [ _dec14$1 ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "useSystemFont"), _class2$M.prototype), 
            _applyDecoratedDescriptor(_class2$M.prototype, "cacheMode", [ _dec15$1 ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "cacheMode"), _class2$M.prototype), 
            _applyDecoratedDescriptor(_class2$M.prototype, "isBold", [ _dec16$1 ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "isBold"), _class2$M.prototype), 
            _applyDecoratedDescriptor(_class2$M.prototype, "isItalic", [ _dec17$1 ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "isItalic"), _class2$M.prototype), 
            _applyDecoratedDescriptor(_class2$M.prototype, "isUnderline", [ _dec18$1 ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "isUnderline"), _class2$M.prototype), 
            _descriptor$J = _applyDecoratedDescriptor(_class2$M.prototype, "_useOriginalSize", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor2$z = _applyDecoratedDescriptor(_class2$M.prototype, "_string", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return "label";
                }
            }), _descriptor3$o = _applyDecoratedDescriptor(_class2$M.prototype, "_horizontalAlign", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return HorizontalTextAlignment.CENTER;
                }
            }), _descriptor4$j = _applyDecoratedDescriptor(_class2$M.prototype, "_verticalAlign", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return VerticalTextAlignment.CENTER;
                }
            }), _descriptor5$f = _applyDecoratedDescriptor(_class2$M.prototype, "_actualFontSize", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor6$8 = _applyDecoratedDescriptor(_class2$M.prototype, "_fontSize", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 40;
                }
            }), _descriptor7$7 = _applyDecoratedDescriptor(_class2$M.prototype, "_fontFamily", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return "Arial";
                }
            }), _descriptor8$7 = _applyDecoratedDescriptor(_class2$M.prototype, "_lineHeight", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 40;
                }
            }), _descriptor9$6 = _applyDecoratedDescriptor(_class2$M.prototype, "_overflow", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Overflow.NONE;
                }
            }), _descriptor10$4 = _applyDecoratedDescriptor(_class2$M.prototype, "_enableWrapText", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor11$3 = _applyDecoratedDescriptor(_class2$M.prototype, "_font", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor12$3 = _applyDecoratedDescriptor(_class2$M.prototype, "_isSystemFontUsed", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor13$3 = _applyDecoratedDescriptor(_class2$M.prototype, "_isItalic", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor14$3 = _applyDecoratedDescriptor(_class2$M.prototype, "_isBold", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor15 = _applyDecoratedDescriptor(_class2$M.prototype, "_isUnderline", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor16 = _applyDecoratedDescriptor(_class2$M.prototype, "_cacheMode", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return CacheMode.NONE;
                }
            }), _class$Y = _class2$M)) || _class$Y) || _class$Y) || _class$Y));
            cc.LabelComponent = LabelComponent, function(KeyboardReturnType) {
                KeyboardReturnType[KeyboardReturnType.DEFAULT = 0] = "DEFAULT", KeyboardReturnType[KeyboardReturnType.DONE = 1] = "DONE", 
                KeyboardReturnType[KeyboardReturnType.SEND = 2] = "SEND", KeyboardReturnType[KeyboardReturnType.SEARCH = 3] = "SEARCH", 
                KeyboardReturnType[KeyboardReturnType.GO = 4] = "GO", KeyboardReturnType[KeyboardReturnType.NEXT = 5] = "NEXT";
            }(KeyboardReturnType = KeyboardReturnType || {}), Enum(KeyboardReturnType), function(InputMode) {
                InputMode[InputMode.ANY = 0] = "ANY", InputMode[InputMode.EMAIL_ADDR = 1] = "EMAIL_ADDR", 
                InputMode[InputMode.NUMERIC = 2] = "NUMERIC", InputMode[InputMode.PHONE_NUMBER = 3] = "PHONE_NUMBER", 
                InputMode[InputMode.URL = 4] = "URL", InputMode[InputMode.DECIMAL = 5] = "DECIMAL", 
                InputMode[InputMode.SINGLE_LINE = 6] = "SINGLE_LINE";
            }(InputMode = InputMode || {}), Enum(InputMode), function(InputFlag) {
                InputFlag[InputFlag.PASSWORD = 0] = "PASSWORD", InputFlag[InputFlag.SENSITIVE = 1] = "SENSITIVE", 
                InputFlag[InputFlag.INITIAL_CAPS_WORD = 2] = "INITIAL_CAPS_WORD", InputFlag[InputFlag.INITIAL_CAPS_SENTENCE = 3] = "INITIAL_CAPS_SENTENCE", 
                InputFlag[InputFlag.INITIAL_CAPS_ALL_CHARACTERS = 4] = "INITIAL_CAPS_ALL_CHARACTERS", 
                InputFlag[InputFlag.DEFAULT = 5] = "DEFAULT";
            }(InputFlag = InputFlag || {}), Enum(InputFlag);
            var _matrix$1 = new Mat4(), _matrix_temp = new Mat4(), _vec3 = new Vec3(), _currentEditBoxImpl = null, polyfill = {
                zoomInvalid: !1
            };
            sys.OS_ANDROID !== sys.os || sys.browserType !== sys.BROWSER_TYPE_SOUGOU && sys.browserType !== sys.BROWSER_TYPE_360 || (polyfill.zoomInvalid = !0);
            var _dec$Y, _dec2$A, _dec3$l, _dec4$i, _dec5$h, _dec6$e, _dec7$b, _dec8$6, _dec9$6, _dec10$6, _dec11$5, _dec12$4, _class$_, _class2$N, _descriptor$K, _descriptor2$A, _descriptor3$p, _descriptor4$k, _descriptor5$g, _descriptor6$9, _descriptor7$8, _descriptor8$8, _descriptor9$7, _descriptor10$5, _descriptor11$4, _descriptor12$4, _descriptor13$4, _descriptor14$4, _descriptor15$1, _descriptor16$1, _descriptor17, _descriptor18, _descriptor19, _class3$l, _temp$U, EditBoxImpl = ccclass(_class$Z = function() {
                function EditBoxImpl() {
                    _classCallCheck(this, EditBoxImpl), this._delegate = null, this._inputMode = -1, 
                    this._inputFlag = -1, this._returnType = KeyboardReturnType.DEFAULT, this._maxLength = 50, 
                    this._text = "", this._placeholderText = "", this._alwaysOnTop = !1, this._size = new Size(), 
                    this._node = null, this._editing = !1, this.__eventListeners = {}, this.__fullscreen = !1, 
                    this.__autoResize = !1, this.__rotateScreen = !1, this.__orientationChanged = void 0, 
                    this._edTxt = null, this._textColor = Color.WHITE.clone(), this._edFontSize = 14, 
                    this._isTextArea = !1;
                }
                return _createClass(EditBoxImpl, [ {
                    key: "onEnable",
                    value: function onEnable() {
                        this._edTxt && (this._alwaysOnTop ? this._edTxt.style.display = "" : this._edTxt.style.display = "none");
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this._edTxt && (this._edTxt.style.display = "none");
                    }
                }, {
                    key: "setTabIndex",
                    value: function setTabIndex(index) {
                        this._edTxt && (this._edTxt.tabIndex = index);
                    }
                }, {
                    key: "setFocus",
                    value: function setFocus() {
                        this._beginEditing();
                    }
                }, {
                    key: "isFocused",
                    value: function isFocused() {
                        return this._edTxt ? document.activeElement === this._edTxt : (warnID(4700), !1);
                    }
                }, {
                    key: "stayOnTop",
                    value: function stayOnTop(flag) {
                        this._alwaysOnTop !== flag && this._edTxt && (this._alwaysOnTop = flag, this._edTxt.style.display = flag ? "" : "none");
                    }
                }, {
                    key: "setMaxLength",
                    value: function setMaxLength(maxLength) {
                        isNaN(maxLength) || (maxLength < 0 && (maxLength = 65535), this._maxLength = maxLength, 
                        this._edTxt && (this._edTxt.maxLength = maxLength));
                    }
                }, {
                    key: "setString",
                    value: function setString(text) {
                        this._text = text, this._edTxt && (this._edTxt.value = text);
                    }
                }, {
                    key: "getString",
                    value: function getString() {
                        return this._text;
                    }
                }, {
                    key: "setPlaceholderText",
                    value: function setPlaceholderText(text) {
                        this._placeholderText = text;
                    }
                }, {
                    key: "getPlaceholderText",
                    value: function getPlaceholderText() {
                        return this._placeholderText;
                    }
                }, {
                    key: "setDelegate",
                    value: function setDelegate(delegate) {
                        this._delegate = delegate;
                    }
                }, {
                    key: "setInputMode",
                    value: function setInputMode(inputMode) {
                        this._inputMode !== inputMode && (this._inputMode = inputMode, this.createInput(), 
                        this._updateDomInputType(), this._updateSize(this._size.width, this._size.height));
                    }
                }, {
                    key: "setInputFlag",
                    value: function setInputFlag(inputFlag) {
                        if (this._inputFlag !== inputFlag) {
                            this._inputFlag = inputFlag, this._updateDomInputType();
                            var textTransform = "none";
                            inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? textTransform = "uppercase" : inputFlag === InputFlag.INITIAL_CAPS_WORD && (textTransform = "capitalize"), 
                            this._edTxt && (this._edTxt.style.textTransform = textTransform, this._edTxt.value = this._text);
                        }
                    }
                }, {
                    key: "setReturnType",
                    value: function setReturnType(returnType) {
                        this._returnType = returnType, this._updateDomInputType();
                    }
                }, {
                    key: "setFontSize",
                    value: function setFontSize(fontSize) {
                        this._edFontSize = fontSize || this._edFontSize, this._edTxt && (this._edTxt.style.fontSize = this._edFontSize + "px");
                    }
                }, {
                    key: "setFontColor",
                    value: function setFontColor(color) {
                        this._textColor = color, this._edTxt && (this._edTxt.style.color = color.toCSS("rgba"));
                    }
                }, {
                    key: "setSize",
                    value: function setSize(width, height) {
                        this._size.width = width, this._size.height = height, this._updateSize(width, height);
                    }
                }, {
                    key: "setNode",
                    value: function setNode(node) {
                        this._node = node;
                    }
                }, {
                    key: "update",
                    value: function update() {
                        this._updateMatrix();
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        this._node = null, this.setDelegate(null), this.removeDom();
                    }
                }, {
                    key: "_onTouchBegan",
                    value: function _onTouchBegan() {}
                }, {
                    key: "_onTouchEnded",
                    value: function _onTouchEnded() {
                        this._beginEditing();
                    }
                }, {
                    key: "_beginEditing",
                    value: function _beginEditing() {
                        sys.isMobile && !this._editing && this._beginEditingOnMobile();
                        var self = this;
                        function startFocus() {
                            self._edTxt && self._edTxt.focus();
                        }
                        this._edTxt && (this._edTxt.style.display = "", sys.browserType === sys.BROWSER_TYPE_UC ? setTimeout(startFocus, 400) : sys.browserType === sys.BROWSER_TYPE_FIREFOX ? setTimeout(startFocus, 0) : startFocus()), 
                        this._editing = !0;
                    }
                }, {
                    key: "_endEditing",
                    value: function _endEditing() {
                        function hideDomInputAndShowLabel() {
                            !self._alwaysOnTop && self._edTxt && (self._edTxt.style.display = "none"), self._delegate && self._delegate.editBoxEditingDidEnded && self._delegate.editBoxEditingDidEnded();
                        }
                        var self = this;
                        this._editing && (sys.isMobile ? setTimeout(function() {
                            self._endEditingOnMobile(), hideDomInputAndShowLabel();
                        }, 400) : hideDomInputAndShowLabel()), this._editing = !1;
                    }
                }, {
                    key: "_updateDomInputType",
                    value: function _updateDomInputType() {
                        var inputMode = this._inputMode, edTxt = this._edTxt;
                        if (edTxt) {
                            if (this._isTextArea) {
                                edTxt = edTxt;
                                var textTransform = "none";
                                return this._inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? textTransform = "uppercase" : this._inputFlag === InputFlag.INITIAL_CAPS_WORD && (textTransform = "capitalize"), 
                                void (edTxt.style.textTransform = textTransform);
                            }
                            if (edTxt = edTxt, this._inputFlag !== InputFlag.PASSWORD) {
                                var type = edTxt.type;
                                inputMode === InputMode.EMAIL_ADDR ? type = "email" : inputMode === InputMode.NUMERIC || inputMode === InputMode.DECIMAL ? type = "number" : inputMode === InputMode.PHONE_NUMBER ? (type = "number", 
                                edTxt.pattern = "[0-9]*") : inputMode === InputMode.URL ? type = "url" : (type = "text", 
                                this._returnType === KeyboardReturnType.SEARCH && (type = "search")), edTxt.type = type;
                            } else edTxt.type = "password";
                        }
                    }
                }, {
                    key: "_updateSize",
                    value: function _updateSize(newWidth, newHeight) {
                        var edTxt = this._edTxt;
                        edTxt && (edTxt.style.width = newWidth + "px", edTxt.style.height = newHeight + "px");
                    }
                }, {
                    key: "_updateMatrix",
                    value: function _updateMatrix() {
                        if (this._edTxt) {
                            var node = this._node, scaleX = view.getScaleX(), scaleY = view.getScaleY(), viewport = view.getViewportRect(), dpr = view.getDevicePixelRatio();
                            node.getWorldMatrix(_matrix$1);
                            var transform = node.uiTransfromComp;
                            transform && Vec3.set(_vec3, -transform.anchorX * transform.width, -transform.anchorY * transform.height, _vec3.z), 
                            Mat4.transform(_matrix$1, _matrix$1, _vec3);
                            var renderComp = node.getComponent(UIRenderComponent);
                            if (!renderComp) return !1;
                            var canvas = director.root.ui.getScreen(renderComp.visibility);
                            if (canvas) {
                                canvas.node.getWorldRT(_matrix_temp);
                                var m12 = _matrix_temp.m12, m13 = _matrix_temp.m13, center = visibleRect.center;
                                _matrix_temp.m12 = center.x - (_matrix_temp.m00 * m12 + _matrix_temp.m04 * m13), 
                                _matrix_temp.m13 = center.y - (_matrix_temp.m01 * m12 + _matrix_temp.m05 * m13), 
                                Mat4.multiply(_matrix_temp, _matrix_temp, _matrix$1), scaleX /= dpr, scaleY /= dpr;
                                var container = game.container, a = _matrix_temp.m00 * scaleX, b = _matrix$1.m01, c = _matrix$1.m04, d = _matrix_temp.m05 * scaleY, offsetX = parseInt(container && container.style.paddingLeft || "0");
                                offsetX += viewport.x / dpr;
                                var offsetY = parseInt(container && container.style.paddingBottom || "0");
                                offsetY += viewport.y / dpr;
                                var tx = _matrix_temp.m12 * scaleX + offsetX, ty = _matrix_temp.m13 * scaleY + offsetY;
                                polyfill.zoomInvalid && (this._updateSize(this._size.width * a, this._size.height * d), 
                                d = a = 1);
                                var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
                                this._edTxt.style.transform = matrix, this._edTxt.style["-webkit-transform"] = matrix, 
                                this._edTxt.style["transform-origin"] = "0px 100% 0px", this._edTxt.style["-webkit-transform-origin"] = "0px 100% 0px";
                            }
                        }
                    }
                }, {
                    key: "_adjustEditBoxPosition",
                    value: function _adjustEditBoxPosition() {
                        this._node.getWorldMatrix(_matrix$1);
                        var y = _matrix$1.m13, windowHeight = visibleRect.height, windowWidth = visibleRect.width, factor = .5;
                        windowHeight < windowWidth && (factor = .7), setTimeout(function() {
                            if (window.scrollY < 40 && y < windowHeight * factor) {
                                var scrollOffset = windowHeight * factor - y - window.scrollY;
                                scrollOffset < 35 && (scrollOffset = 35), 320 < scrollOffset && (scrollOffset = 320), 
                                window.scrollTo(0, scrollOffset);
                            }
                        }, 400);
                    }
                }, {
                    key: "createInput",
                    value: function createInput() {
                        this._isTextArea = !1, this._inputMode === InputMode.ANY ? (this._isTextArea = !0, 
                        this._createDomTextArea()) : this._createDomInput();
                    }
                }, {
                    key: "_beginEditingOnMobile",
                    value: function _beginEditingOnMobile() {
                        var self = this;
                        this.__orientationChanged = function() {
                            self._adjustEditBoxPosition();
                        }, window.addEventListener("orientationchange", this.__orientationChanged), view.isAutoFullScreenEnabled() ? (this.__fullscreen = !0, 
                        view.enableAutoFullScreen(!1), screen$1.exitFullScreen()) : this.__fullscreen = !1, 
                        this.__autoResize = view._resizeWithBrowserSize, view.resizeWithBrowserSize(!1), 
                        _currentEditBoxImpl = this;
                    }
                }, {
                    key: "_endEditingOnMobile",
                    value: function _endEditingOnMobile() {
                        if (this.__rotateScreen) {
                            game.container && (game.container.style["-webkit-transform"] = "rotate(90deg)", 
                            game.container.style.transform = "rotate(90deg)");
                            var width = view._originalDesignResolutionSize.width, height = view._originalDesignResolutionSize.height;
                            0 < width && view.setDesignResolutionSize(width, height, view.getResolutionPolicy()), 
                            this.__rotateScreen = !1;
                        }
                        this.__orientationChanged && window.removeEventListener("orientationchange", this.__orientationChanged), 
                        this.__fullscreen && view.enableAutoFullScreen(!0), this.__autoResize && _currentEditBoxImpl === this && view.resizeWithBrowserSize(!0);
                    }
                }, {
                    key: "_createDomInput",
                    value: function _createDomInput() {
                        this.removeDom();
                        var tmpEdTxt = this._edTxt = document.createElement("input");
                        return tmpEdTxt.type = "text", tmpEdTxt.style.fontSize = this._edFontSize + "px", 
                        tmpEdTxt.style.color = "#000000", tmpEdTxt.style.border = "0px", tmpEdTxt.style.background = "transparent", 
                        tmpEdTxt.style.width = "100%", tmpEdTxt.style.height = "100%", tmpEdTxt.style.outline = "medium", 
                        tmpEdTxt.style.padding = "0", tmpEdTxt.style.textTransform = "uppercase", tmpEdTxt.style.display = "none", 
                        tmpEdTxt.style.position = "absolute", tmpEdTxt.style.bottom = "0px", tmpEdTxt.style.left = "2px", 
                        tmpEdTxt.style["-moz-appearance"] = "textfield", tmpEdTxt.className = "cocosEditBox", 
                        tmpEdTxt.style.fontFamily = "Arial", registerInputEventListener(tmpEdTxt, this), 
                        tmpEdTxt;
                    }
                }, {
                    key: "_createDomTextArea",
                    value: function _createDomTextArea() {
                        this.removeDom();
                        var tmpEdTxt = this._edTxt = document.createElement("textarea");
                        return tmpEdTxt.style.fontSize = this._edFontSize + "px", tmpEdTxt.style.color = "#000000", 
                        tmpEdTxt.style.border = "0", tmpEdTxt.style.background = "transparent", tmpEdTxt.style.width = "100%", 
                        tmpEdTxt.style.height = "100%", tmpEdTxt.style.outline = "medium", tmpEdTxt.style.padding = "0", 
                        tmpEdTxt.style.resize = "none", tmpEdTxt.style.textTransform = "uppercase", tmpEdTxt.style.overflowY = "scroll", 
                        tmpEdTxt.style.display = "none", tmpEdTxt.style.position = "absolute", tmpEdTxt.style.bottom = "0px", 
                        tmpEdTxt.style.left = "2px", tmpEdTxt.className = "cocosEditBox", tmpEdTxt.style.fontFamily = "Arial", 
                        registerInputEventListener(tmpEdTxt, this, !0), tmpEdTxt;
                    }
                }, {
                    key: "_addDomToGameContainer",
                    value: function _addDomToGameContainer() {
                        game.container && this._edTxt && game.container.appendChild(this._edTxt);
                    }
                }, {
                    key: "removeDom",
                    value: function removeDom() {
                        var edTxt = this._edTxt;
                        if (edTxt) {
                            var cbs = this.__eventListeners;
                            edTxt.removeEventListener("compositionstart", cbs.compositionstart), edTxt.removeEventListener("compositionend", cbs.compositionend), 
                            edTxt.removeEventListener("input", cbs.input), edTxt.removeEventListener("focus", cbs.focus), 
                            edTxt.removeEventListener("keypress", cbs.keypress), edTxt.removeEventListener("blur", cbs.blur), 
                            cbs.compositionstart = null, cbs.compositionend = null, cbs.input = null, cbs.focus = null, 
                            cbs.keypress = null, cbs.blur = null, contains$1(game.container, edTxt) && game.container && game.container.removeChild(edTxt);
                        }
                        this._edTxt = null;
                    }
                }, {
                    key: "text",
                    get: function get() {
                        return this._text;
                    },
                    set: function set(value) {
                        this._text = value;
                    }
                }, {
                    key: "textColor",
                    get: function get() {
                        return this._textColor;
                    }
                }, {
                    key: "fontSize",
                    get: function get() {
                        return this._edFontSize;
                    }
                }, {
                    key: "returnType",
                    set: function set(value) {
                        this._returnType = value;
                    }
                }, {
                    key: "alwayOnTop",
                    get: function get() {
                        return this._alwaysOnTop;
                    }
                }, {
                    key: "editing",
                    get: function get() {
                        return this._editing;
                    },
                    set: function set(value) {
                        this._editing = value;
                    }
                }, {
                    key: "delegate",
                    get: function get() {
                        return this._delegate;
                    }
                }, {
                    key: "eventListeners",
                    get: function get() {
                        return this.__eventListeners;
                    }
                } ]), EditBoxImpl;
            }()) || _class$Z;
            function _inputValueHandle(input, editBoxImpl) {
                input.value.length > editBoxImpl._maxLength && (input.value = input.value.slice(0, editBoxImpl._maxLength)), 
                editBoxImpl._delegate && editBoxImpl._delegate.editBoxTextChanged && editBoxImpl._text !== input.value && (editBoxImpl._text = input.value, 
                editBoxImpl._delegate.editBoxTextChanged(editBoxImpl._text));
            }
            function registerInputEventListener(tmpEdTxt, editBoxImpl, argument_2) {
                var isTextarea = 2 < arguments.length && void 0 !== argument_2 && argument_2, inputLock = !1, cbs = editBoxImpl.eventListeners;
                cbs.compositionstart = function() {
                    inputLock = !0;
                }, tmpEdTxt.addEventListener("compositionstart", cbs.compositionstart), cbs.compositionend = function() {
                    inputLock = !1, _inputValueHandle(this, editBoxImpl);
                }, tmpEdTxt.addEventListener("compositionend", cbs.compositionend), cbs.input = function() {
                    inputLock || _inputValueHandle(this, editBoxImpl);
                }, tmpEdTxt.addEventListener("input", cbs.input), cbs.focus = function() {
                    this.style.fontSize = editBoxImpl.fontSize + "px", this.style.color = editBoxImpl.textColor.toCSS("rgba"), 
                    editBoxImpl.alwayOnTop && (editBoxImpl.editing = !0), sys.isMobile && editBoxImpl._beginEditingOnMobile(), 
                    editBoxImpl.delegate && editBoxImpl.delegate.editBoxEditingDidBegan && editBoxImpl.delegate.editBoxEditingDidBegan();
                }, tmpEdTxt.addEventListener("focus", cbs.focus), cbs.keypress = function(e) {
                    e.keyCode === macro.KEY.enter && (e.propagationStopped = !0, editBoxImpl.delegate && editBoxImpl.delegate.editBoxEditingReturn && editBoxImpl.delegate.editBoxEditingReturn(), 
                    isTextarea || (editBoxImpl.text = this.value, editBoxImpl._endEditing(), game.canvas && game.canvas.focus()));
                }, tmpEdTxt.addEventListener("keypress", cbs.keypress), cbs.blur = function() {
                    editBoxImpl.text = this.value, editBoxImpl._endEditing();
                }, tmpEdTxt.addEventListener("blur", cbs.blur), editBoxImpl._addDomToGameContainer();
            }
            var _dec$Z, _dec2$B, _dec3$m, _dec4$j, _dec5$i, _dec6$f, _dec7$c, _dec8$7, _class$$, _class2$O, _descriptor$L, _descriptor2$B, _descriptor3$q, _descriptor4$l, _descriptor5$h, _descriptor6$a, _descriptor7$9, _descriptor8$9, _descriptor9$8, _descriptor10$6, _descriptor11$5, _descriptor12$5, _descriptor13$5, _descriptor14$5, _class3$m, _temp$V, EditBoxComponent = exports("EditBoxComponent", (_dec$Y = ccclass("cc.EditBoxComponent"), 
            _dec2$A = executionOrder(100), _dec3$l = menu("UI/EditBox"), _dec4$i = property({
                type: SpriteFrame
            }), _dec5$h = property({
                type: KeyboardReturnType
            }), _dec6$e = property({
                type: InputFlag
            }), _dec7$b = property({
                type: InputMode
            }), _dec8$6 = property({
                type: Color
            }), _dec9$6 = property({
                type: [ EventHandler ]
            }), _dec10$6 = property({
                type: [ EventHandler ]
            }), _dec11$5 = property({
                type: [ EventHandler ]
            }), _dec12$4 = property({
                type: [ EventHandler ]
            }), _dec$Y(_class$_ = _dec2$A(_class$_ = _dec3$l(_class$_ = executeInEditMode((_temp$U = _class3$l = function() {
                function EditBoxComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, EditBoxComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EditBoxComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "editingDidBegan", _descriptor$K, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "textChanged", _descriptor2$A, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "editingDidEnded", _descriptor3$p, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "editingReturn", _descriptor4$k, _assertThisInitialized(_this)), 
                    _this._impl = null, _this._textLabel = null, _this._placeholderLabel = null, _this._background = null, 
                    _initializerDefineProperty(_this, "_returnType", _descriptor5$g, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_useOriginalSize", _descriptor6$9, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_string", _descriptor7$8, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_tabIndex", _descriptor8$8, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_backgroundImage", _descriptor9$7, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_inputFlag", _descriptor10$5, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_inputMode", _descriptor11$4, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_fontSize", _descriptor12$4, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_lineHeight", _descriptor13$4, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_maxLength", _descriptor14$4, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_fontColor", _descriptor15$1, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_placeholder", _descriptor16$1, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_placeholderFontSize", _descriptor17, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_placeholderFontColor", _descriptor18, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_stayOnTop", _descriptor19, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(EditBoxComponent, Component), _createClass(EditBoxComponent, [ {
                    key: "onEnable",
                    value: function onEnable() {
                        this._impl && this._impl.onEnable();
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this._impl && this._impl.onDisable();
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this._impl && this._impl.clear();
                    }
                }, {
                    key: "_init",
                    value: function _init() {
                        this._createBackgroundSprite(), this._createLabels(), this.node.on(SystemEventType.SIZE_CHANGED, this._resizeChildNodes, this);
                        var impl = this._impl = new EditBoxImpl();
                        impl.setDelegate(this), impl.setNode(this.node), impl.setInputMode(this._inputMode), 
                        impl.setMaxLength(this._maxLength), impl.setInputFlag(this._inputFlag), impl.setReturnType(this._returnType), 
                        impl.setTabIndex(this._tabIndex), impl.setFontColor(this._fontColor), impl.setFontSize(this._fontSize), 
                        impl.setPlaceholderText(this._placeholder), this._updateStayOnTop(), this._updateString(this._string), 
                        this._syncSize();
                    }
                }, {
                    key: "__preload",
                    value: function __preload() {
                        this._registerEvent(), this._init();
                    }
                }, {
                    key: "_registerEvent",
                    value: function _registerEvent() {
                        this.node.on(SystemEventType.TOUCH_START, this._onTouchBegan, this), this.node.on(SystemEventType.TOUCH_END, this._onTouchEnded, this);
                    }
                }, {
                    key: "_updateStayOnTop",
                    value: function _updateStayOnTop() {
                        this.stayOnTop ? this._hideLabels() : this._showLabels(), this._impl && this._impl.stayOnTop(this.stayOnTop);
                    }
                }, {
                    key: "_syncSize",
                    value: function _syncSize() {
                        var size = this.node.getContentSize();
                        this._background && (this._background.node.setAnchorPoint(this.node.getAnchorPoint()), 
                        this._background.node.setContentSize(size)), this._updateLabelPosition(size), this._impl && this._impl.setSize(size.width, size.height);
                    }
                }, {
                    key: "_updateLabelPosition",
                    value: function _updateLabelPosition(size) {
                        var node = this.node, offx = -node.anchorX * node.width, offy = -node.anchorY * node.height, placeholderLabel = this._placeholderLabel, textLabel = this._textLabel;
                        textLabel && (textLabel.node.setContentSize(size.width - 2, size.height), textLabel.node.setPosition(2 + offx, offy + size.height, textLabel.node.getPosition().z), 
                        textLabel.verticalAlign = this._inputMode === InputMode.ANY ? VerticalTextAlignment.TOP : VerticalTextAlignment.CENTER, 
                        textLabel.enableWrapText = this._inputMode === InputMode.ANY), placeholderLabel && (placeholderLabel.node.setContentSize(size.width - 2, size.height), 
                        placeholderLabel.lineHeight = size.height, placeholderLabel.node.setPosition(2 + offx, offy + size.height, placeholderLabel.node.getPosition().z), 
                        placeholderLabel.verticalAlign = this._inputMode === InputMode.ANY ? VerticalTextAlignment.TOP : VerticalTextAlignment.CENTER, 
                        placeholderLabel.enableWrapText = this._inputMode === InputMode.ANY);
                    }
                }, {
                    key: "_createBackgroundSprite",
                    value: function _createBackgroundSprite() {
                        this._background || (this._background = this.node.getComponent(SpriteComponent), 
                        this._background || (this._background = this.node.addComponent(SpriteComponent))), 
                        this._background.type = SpriteComponent.Type.SLICED, this._background.spriteFrame = this._backgroundImage;
                    }
                }, {
                    key: "_createLabels",
                    value: function _createLabels() {
                        if (!this._textLabel) {
                            var node = this.node.getChildByName("TEXT_LABEL"), textLabel = (node = node || new Node$1("TEXT_LABEL")).getComponent(LabelComponent);
                            node.parent = this.node, textLabel = textLabel || node.addComponent(LabelComponent), 
                            node.getComponent(UITransformComponent).setAnchorPoint(0, 1), textLabel.color = this._fontColor, 
                            textLabel.overflow = LabelComponent.Overflow.CLAMP, textLabel.fontSize = this._fontSize, 
                            textLabel.lineHeight = this.lineHeight, this._textLabel = textLabel;
                        }
                        if (!this._placeholderLabel) {
                            var _node = this.node.getChildByName("PLACEHOLDER_LABEL"), placeholderLabel = (_node = _node || new Node$1("PLACEHOLDER_LABEL")).getComponent(LabelComponent);
                            placeholderLabel = placeholderLabel || _node.addComponent(LabelComponent);
                            var transform = _node.getComponent(UITransformComponent);
                            _node.parent = this.node, placeholderLabel.color = this._placeholderFontColor, transform.setAnchorPoint(0, 1), 
                            placeholderLabel.overflow = LabelComponent.Overflow.CLAMP, placeholderLabel.fontSize = this._placeholderFontSize, 
                            placeholderLabel.string = this._placeholder, this._placeholderLabel = placeholderLabel;
                        }
                    }
                }, {
                    key: "_resizeChildNodes",
                    value: function _resizeChildNodes() {
                        var textLabelNode = this._textLabel && this._textLabel.node;
                        textLabelNode && (textLabelNode.setPosition(-this.node.width / 2, this.node.height / 2, textLabelNode.getPosition().z), 
                        textLabelNode.width = this.node.width, textLabelNode.height = this.node.height);
                        var placeholderLabelNode = this._placeholderLabel && this._placeholderLabel.node;
                        placeholderLabelNode && (placeholderLabelNode.setPosition(-this.node.width / 2, this.node.height / 2, placeholderLabelNode.getPosition().z), 
                        placeholderLabelNode.width = this.node.width, placeholderLabelNode.height = this.node.height);
                        var backgroundNode = this._background && this._background.node;
                        backgroundNode && (backgroundNode.width = this.node.width, backgroundNode.height = this.node.height);
                    }
                }, {
                    key: "_showLabels",
                    value: function _showLabels() {
                        if (this._textLabel) {
                            var displayText = this._textLabel.string;
                            this._textLabel.node.active = "" !== displayText, this._placeholderLabel && (this._placeholderLabel.node.active = "" === displayText);
                        }
                    }
                }, {
                    key: "_hideLabels",
                    value: function _hideLabels() {
                        this._textLabel && (this._textLabel.node.active = !1), this._placeholderLabel && (this._placeholderLabel.node.active = !1);
                    }
                }, {
                    key: "_updateString",
                    value: function _updateString(text) {
                        var textLabel = this._textLabel;
                        if (textLabel) {
                            var displayText = text;
                            displayText = displayText && this._updateLabelStringStyle(displayText), textLabel.string = displayText, 
                            this._impl && (this._impl.setString(text), this._impl.editing || this.stayOnTop || this._showLabels());
                        }
                    }
                }, {
                    key: "_updateLabelStringStyle",
                    value: function _updateLabelStringStyle(text, argument_1) {
                        var ignorePassword = 1 < arguments.length && void 0 !== argument_1 && argument_1, inputFlag = this._inputFlag;
                        if (ignorePassword || inputFlag !== InputFlag.PASSWORD) inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? text = text.toUpperCase() : inputFlag === InputFlag.INITIAL_CAPS_WORD ? text = function capitalize(string) {
                            return string.replace(/(?:^|\s)\S/g, function(a) {
                                return a.toUpperCase();
                            });
                        }(text) : inputFlag === InputFlag.INITIAL_CAPS_SENTENCE && (text = function capitalizeFirstLetter(string) {
                            return string.charAt(0).toUpperCase() + string.slice(1);
                        }(text)); else {
                            for (var passwordString = "", len = text.length, i = 0; i < len; ++i) passwordString += "●";
                            text = passwordString;
                        }
                        return text;
                    }
                }, {
                    key: "editBoxEditingDidBegan",
                    value: function editBoxEditingDidBegan() {
                        this._hideLabels(), EventHandler.emitEvents(this.editingDidBegan, this), this.node.emit("editing-did-began", this);
                    }
                }, {
                    key: "editBoxEditingDidEnded",
                    value: function editBoxEditingDidEnded() {
                        this.stayOnTop || this._showLabels(), EventHandler.emitEvents(this.editingDidEnded, this), 
                        this.node.emit("editing-did-ended", this);
                    }
                }, {
                    key: "editBoxTextChanged",
                    value: function editBoxTextChanged(text) {
                        text = this._updateLabelStringStyle(text, !0), this.string = text, EventHandler.emitEvents(this.textChanged, text, this), 
                        this.node.emit("text-changed", this);
                    }
                }, {
                    key: "editBoxEditingReturn",
                    value: function editBoxEditingReturn() {
                        EventHandler.emitEvents(this.editingReturn, this), this.node.emit("editing-return", this);
                    }
                }, {
                    key: "_onTouchBegan",
                    value: function _onTouchBegan(event) {
                        this._impl && this._impl._onTouchBegan(event.touch), event.propagationStopped = !0;
                    }
                }, {
                    key: "_onTouchEnded",
                    value: function _onTouchEnded(event) {
                        this._impl && this._impl._onTouchEnded(), event.propagationStopped = !0;
                    }
                }, {
                    key: "setFocus",
                    value: function setFocus() {
                        this._impl && this._impl.setFocus();
                    }
                }, {
                    key: "isFocused",
                    value: function isFocused() {
                        var isFocused = !1;
                        return this._impl && (isFocused = this._impl.isFocused()), isFocused;
                    }
                }, {
                    key: "update",
                    value: function update() {
                        this._impl && this._impl.update();
                    }
                }, {
                    key: "string",
                    get: function get() {
                        return this._string;
                    },
                    set: function set(value) {
                        0 <= this._maxLength && value.length >= this._maxLength && (value = value.slice(0, this._maxLength)), 
                        this._string = value, this._impl && this._updateString(value);
                    }
                }, {
                    key: "backgroundImage",
                    get: function get() {
                        return this._backgroundImage;
                    },
                    set: function set(value) {
                        this._backgroundImage !== value && (this._backgroundImage = value, this._createBackgroundSprite());
                    }
                }, {
                    key: "returnType",
                    get: function get() {
                        return this._returnType;
                    },
                    set: function set(value) {
                        this._returnType = value, this._impl && (this._impl.returnType = this._returnType);
                    }
                }, {
                    key: "inputFlag",
                    get: function get() {
                        return this._inputFlag;
                    },
                    set: function set(value) {
                        this._inputFlag = value, this._impl && (this._impl.setInputFlag(this._inputFlag), 
                        this._updateString(this._string));
                    }
                }, {
                    key: "inputMode",
                    get: function get() {
                        return this._inputMode;
                    },
                    set: function set(value) {
                        this._inputMode = value, this._impl && this._impl.setInputMode(this._inputMode);
                    }
                }, {
                    key: "fontSize",
                    get: function get() {
                        return this._fontSize;
                    },
                    set: function set(value) {
                        this._fontSize !== value && (this._fontSize = value, this._textLabel && (this._textLabel.fontSize = this._fontSize), 
                        this._impl && this._impl.setFontSize(this._fontSize));
                    }
                }, {
                    key: "lineHeight",
                    get: function get() {
                        return this._lineHeight;
                    },
                    set: function set(value) {
                        this._lineHeight !== value && (this._lineHeight = value, this._textLabel && (this._textLabel.lineHeight = this._lineHeight));
                    }
                }, {
                    key: "fontColor",
                    get: function get() {
                        return this._fontColor;
                    },
                    set: function set(value) {
                        if (this._fontColor !== value) {
                            if (this._fontColor.set(value), this._textLabel) {
                                var renderComp = this._textLabel.node.getComponent(UIRenderComponent);
                                renderComp && (renderComp.color = this._fontColor);
                            }
                            this._impl && this._impl.setFontColor(this._fontColor);
                        }
                    }
                }, {
                    key: "placeholder",
                    get: function get() {
                        return this._placeholder;
                    },
                    set: function set(value) {
                        this._placeholder !== value && (this._placeholder = value, this._placeholderLabel && (this._placeholderLabel.string = this._placeholder), 
                        this._impl && this._impl.setPlaceholderText(this._placeholder));
                    }
                }, {
                    key: "placeholderFontSize",
                    get: function get() {
                        return this._placeholderFontSize;
                    },
                    set: function set(value) {
                        this._placeholderFontSize !== value && (this._placeholderFontSize = value, this._placeholderLabel && (this._placeholderLabel.fontSize = this._placeholderFontSize));
                    }
                }, {
                    key: "placeholderFontColor",
                    get: function get() {
                        return this._placeholderFontColor;
                    },
                    set: function set(value) {
                        if (this._placeholderFontColor !== value && (this._placeholderFontColor = value, 
                        this._placeholderLabel)) {
                            var comp = this._placeholderLabel.node.getComponent(UIRenderComponent);
                            comp && (comp.color = this._placeholderFontColor);
                        }
                    }
                }, {
                    key: "maxLength",
                    get: function get() {
                        return this._maxLength;
                    },
                    set: function set(value) {
                        this._maxLength !== value && (this._maxLength = value, this._impl && this._impl.setMaxLength(this._maxLength));
                    }
                }, {
                    key: "stayOnTop",
                    get: function get() {
                        return this._stayOnTop;
                    },
                    set: function set(value) {
                        this._stayOnTop = value, this._impl && this._updateStayOnTop();
                    }
                }, {
                    key: "tabIndex",
                    get: function get() {
                        return this._tabIndex;
                    },
                    set: function set(value) {
                        this._tabIndex = value, this._impl && this._impl.setTabIndex(value);
                    }
                } ]), EditBoxComponent;
            }(), _class3$l._EditBoxImpl = EditBoxImpl, _class3$l.KeyboardReturnType = KeyboardReturnType, 
            _class3$l.InputFlag = InputFlag, _class3$l.InputMode = InputMode, _applyDecoratedDescriptor((_class2$N = _temp$U).prototype, "string", [ property ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "string"), _class2$N.prototype), 
            _applyDecoratedDescriptor(_class2$N.prototype, "backgroundImage", [ _dec4$i ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "backgroundImage"), _class2$N.prototype), 
            _applyDecoratedDescriptor(_class2$N.prototype, "returnType", [ _dec5$h ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "returnType"), _class2$N.prototype), 
            _applyDecoratedDescriptor(_class2$N.prototype, "inputFlag", [ _dec6$e ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "inputFlag"), _class2$N.prototype), 
            _applyDecoratedDescriptor(_class2$N.prototype, "inputMode", [ _dec7$b ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "inputMode"), _class2$N.prototype), 
            _applyDecoratedDescriptor(_class2$N.prototype, "fontSize", [ property ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "fontSize"), _class2$N.prototype), 
            _applyDecoratedDescriptor(_class2$N.prototype, "lineHeight", [ property ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "lineHeight"), _class2$N.prototype), 
            _applyDecoratedDescriptor(_class2$N.prototype, "fontColor", [ _dec8$6 ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "fontColor"), _class2$N.prototype), 
            _applyDecoratedDescriptor(_class2$N.prototype, "placeholder", [ property ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "placeholder"), _class2$N.prototype), 
            _applyDecoratedDescriptor(_class2$N.prototype, "placeholderFontSize", [ property ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "placeholderFontSize"), _class2$N.prototype), 
            _applyDecoratedDescriptor(_class2$N.prototype, "placeholderFontColor", [ property ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "placeholderFontColor"), _class2$N.prototype), 
            _applyDecoratedDescriptor(_class2$N.prototype, "maxLength", [ property ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "maxLength"), _class2$N.prototype), 
            _applyDecoratedDescriptor(_class2$N.prototype, "stayOnTop", [ property ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "stayOnTop"), _class2$N.prototype), 
            _applyDecoratedDescriptor(_class2$N.prototype, "tabIndex", [ property ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "tabIndex"), _class2$N.prototype), 
            _descriptor$K = _applyDecoratedDescriptor(_class2$N.prototype, "editingDidBegan", [ _dec9$6 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor2$A = _applyDecoratedDescriptor(_class2$N.prototype, "textChanged", [ _dec10$6 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor3$p = _applyDecoratedDescriptor(_class2$N.prototype, "editingDidEnded", [ _dec11$5 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor4$k = _applyDecoratedDescriptor(_class2$N.prototype, "editingReturn", [ _dec12$4 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor5$g = _applyDecoratedDescriptor(_class2$N.prototype, "_returnType", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return KeyboardReturnType.DEFAULT;
                }
            }), _descriptor6$9 = _applyDecoratedDescriptor(_class2$N.prototype, "_useOriginalSize", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor7$8 = _applyDecoratedDescriptor(_class2$N.prototype, "_string", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return "";
                }
            }), _descriptor8$8 = _applyDecoratedDescriptor(_class2$N.prototype, "_tabIndex", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor9$7 = _applyDecoratedDescriptor(_class2$N.prototype, "_backgroundImage", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor10$5 = _applyDecoratedDescriptor(_class2$N.prototype, "_inputFlag", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return InputFlag.DEFAULT;
                }
            }), _descriptor11$4 = _applyDecoratedDescriptor(_class2$N.prototype, "_inputMode", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return InputMode.ANY;
                }
            }), _descriptor12$4 = _applyDecoratedDescriptor(_class2$N.prototype, "_fontSize", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 20;
                }
            }), _descriptor13$4 = _applyDecoratedDescriptor(_class2$N.prototype, "_lineHeight", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 40;
                }
            }), _descriptor14$4 = _applyDecoratedDescriptor(_class2$N.prototype, "_maxLength", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 20;
                }
            }), _descriptor15$1 = _applyDecoratedDescriptor(_class2$N.prototype, "_fontColor", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Color.WHITE.clone();
                }
            }), _descriptor16$1 = _applyDecoratedDescriptor(_class2$N.prototype, "_placeholder", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return "Enter text here...";
                }
            }), _descriptor17 = _applyDecoratedDescriptor(_class2$N.prototype, "_placeholderFontSize", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 20;
                }
            }), _descriptor18 = _applyDecoratedDescriptor(_class2$N.prototype, "_placeholderFontColor", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Color.GRAY.clone();
                }
            }), _descriptor19 = _applyDecoratedDescriptor(_class2$N.prototype, "_stayOnTop", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _class$_ = _class2$N)) || _class$_) || _class$_) || _class$_) || _class$_));
            cc.EditBoxComponent = EditBoxComponent;
            var Type, ResizeMode, AxisDirection, VerticalDirection, HorizontalDirection, NodeEvent = SystemEventType;
            !function(Type) {
                Type[Type.NONE = 0] = "NONE", Type[Type.HORIZONTAL = 1] = "HORIZONTAL", Type[Type.VERTICAL = 2] = "VERTICAL", 
                Type[Type.GRID = 3] = "GRID";
            }(Type = Type || {}), ccenum(Type), function(ResizeMode) {
                ResizeMode[ResizeMode.NONE = 0] = "NONE", ResizeMode[ResizeMode.CONTAINER = 1] = "CONTAINER", 
                ResizeMode[ResizeMode.CHILDREN = 2] = "CHILDREN";
            }(ResizeMode = ResizeMode || {}), ccenum(ResizeMode), function(AxisDirection) {
                AxisDirection[AxisDirection.HORIZONTAL = 0] = "HORIZONTAL", AxisDirection[AxisDirection.VERTICAL = 1] = "VERTICAL";
            }(AxisDirection = AxisDirection || {}), ccenum(AxisDirection), function(VerticalDirection) {
                VerticalDirection[VerticalDirection.BOTTOM_TO_TOP = 0] = "BOTTOM_TO_TOP", VerticalDirection[VerticalDirection.TOP_TO_BOTTOM = 1] = "TOP_TO_BOTTOM";
            }(VerticalDirection = VerticalDirection || {}), ccenum(VerticalDirection), function(HorizontalDirection) {
                HorizontalDirection[HorizontalDirection.LEFT_TO_RIGHT = 0] = "LEFT_TO_RIGHT", HorizontalDirection[HorizontalDirection.RIGHT_TO_LEFT = 1] = "RIGHT_TO_LEFT";
            }(HorizontalDirection = HorizontalDirection || {}), ccenum(HorizontalDirection);
            var LineCap, LineJoin, PointFlags, _dec$_, _dec2$C, _dec3$n, _dec4$k, _dec5$j, _dec6$g, _class$10, _class2$P, _descriptor$M, _descriptor2$C, _descriptor3$r, _descriptor4$m, _descriptor5$i, _descriptor6$b, _class3$n, _temp$W, _tempPos = new Vec3(), _tempScale = new Vec3(), LayoutComponent = exports("LayoutComponent", (_dec$Z = ccclass("cc.LayoutComponent"), 
            _dec2$B = executionOrder(110), _dec3$m = menu("UI/Layout"), _dec4$j = property({
                type: Type
            }), _dec5$i = property({
                type: ResizeMode
            }), _dec6$f = property({
                type: AxisDirection
            }), _dec7$c = property({
                type: VerticalDirection
            }), _dec8$7 = property({
                type: HorizontalDirection
            }), _dec$Z(_class$$ = _dec2$B(_class$$ = _dec3$m(_class$$ = executeInEditMode((_temp$V = _class3$m = function() {
                function LayoutComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, LayoutComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(LayoutComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._layoutDirty = !0, 
                    _initializerDefineProperty(_this, "_resizeMode", _descriptor$L, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_N$layoutType", _descriptor2$B, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_N$padding", _descriptor3$q, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_cellSize", _descriptor4$l, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_startAxis", _descriptor5$h, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_paddingLeft", _descriptor6$a, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_paddingRight", _descriptor7$9, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_paddingTop", _descriptor8$9, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_paddingBottom", _descriptor9$8, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_spacingX", _descriptor10$6, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_spacingY", _descriptor11$5, _assertThisInitialized(_this)), 
                    _this._layoutSize = new Size(300, 200), _initializerDefineProperty(_this, "_verticalDirection", _descriptor12$5, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_horizontalDirection", _descriptor13$5, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_affectedByScale", _descriptor14$5, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(LayoutComponent, Component), _createClass(LayoutComponent, [ {
                    key: "updateLayout",
                    value: function updateLayout() {
                        this._layoutDirty && 0 < this.node.children.length && (this._doLayout(), this._layoutDirty = !1);
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        this._addEventListeners(), this.node.getContentSize().equals(new Size()) && this.node.setContentSize(this._layoutSize), 
                        0 !== this._N$padding && this._migratePaddingData(), this._doLayoutDirty();
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this._removeEventListeners();
                    }
                }, {
                    key: "_migratePaddingData",
                    value: function _migratePaddingData() {
                        this._paddingLeft = this._N$padding, this._paddingRight = this._N$padding, this._paddingTop = this._N$padding, 
                        this._paddingBottom = this._N$padding, this._N$padding = 0;
                    }
                }, {
                    key: "_addEventListeners",
                    value: function _addEventListeners() {
                        director.on(Director.EVENT_AFTER_UPDATE, this.updateLayout, this), this.node.on(NodeEvent.SIZE_CHANGED, this._resized, this), 
                        this.node.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), this.node.on(NodeEvent.CHILD_ADDED, this._childAdded, this), 
                        this.node.on(NodeEvent.CHILD_REMOVED, this._childRemoved, this), this._addChildrenEventListeners();
                    }
                }, {
                    key: "_removeEventListeners",
                    value: function _removeEventListeners() {
                        director.off(Director.EVENT_AFTER_UPDATE, this.updateLayout, this), this.node.off(NodeEvent.SIZE_CHANGED, this._resized, this), 
                        this.node.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), this.node.off(NodeEvent.CHILD_ADDED, this._childAdded, this), 
                        this.node.off(NodeEvent.CHILD_REMOVED, this._childRemoved, this), this._removeChildrenEventListeners();
                    }
                }, {
                    key: "_addChildrenEventListeners",
                    value: function _addChildrenEventListeners() {
                        var _iterator = this.node.children, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var child = _ref;
                            child.on(NodeEvent.SCALE_PART, this._doScaleDirty, this), child.on(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
                            child.on(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this), child.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
                            child.on("active-in-hierarchy-changed", this._doLayoutDirty, this);
                        }
                    }
                }, {
                    key: "_removeChildrenEventListeners",
                    value: function _removeChildrenEventListeners() {
                        var _iterator2 = this.node.children, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            var child = _ref2;
                            child.off(NodeEvent.SCALE_PART, this._doScaleDirty, this), child.off(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
                            child.off(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this), child.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
                            child.off("active-in-hierarchy-changed", this._doLayoutDirty, this);
                        }
                    }
                }, {
                    key: "_childAdded",
                    value: function _childAdded(child) {
                        child.on(NodeEvent.SCALE_PART, this._doScaleDirty, this), child.on(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
                        child.on(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this), child.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
                        child.on("active-in-hierarchy-changed", this._doLayoutDirty, this), this._doLayoutDirty();
                    }
                }, {
                    key: "_childRemoved",
                    value: function _childRemoved(child) {
                        child.off(NodeEvent.SCALE_PART, this._doScaleDirty, this), child.off(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
                        child.off(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this), child.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
                        child.off("active-in-hierarchy-changed", this._doLayoutDirty, this), this._doLayoutDirty();
                    }
                }, {
                    key: "_resized",
                    value: function _resized() {
                        this._layoutSize = this.node.getContentSize(), this._doLayoutDirty();
                    }
                }, {
                    key: "_doLayoutHorizontally",
                    value: function _doLayoutHorizontally(baseWidth, rowBreak, fnPositionY, applyChildren) {
                        var layoutAnchor = this.node.getAnchorPoint(), children = this.node.children, sign = 1, paddingX = this._paddingLeft, startPos = -layoutAnchor.x * baseWidth;
                        this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (sign = -1, startPos = (1 - layoutAnchor.x) * baseWidth, 
                        paddingX = this._paddingRight);
                        var nextX = startPos + sign * paddingX - sign * this._spacingX, rowMaxHeight = 0, tempMaxHeight = 0, secondMaxHeight = 0, row = 0, containerResizeBoundary = 0, maxHeightChildAnchorY = 0, activeChildCount = 0, _iterator3 = children, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i3 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i3++];
                            } else {
                                if ((_i3 = _iterator3.next()).done) break;
                                _ref3 = _i3.value;
                            }
                            _ref3.activeInHierarchy && activeChildCount++;
                        }
                        var newChildWidth = this._cellSize.width;
                        this._N$layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN && (newChildWidth = (baseWidth - (this._paddingLeft + this._paddingRight) - (activeChildCount - 1) * this._spacingX) / activeChildCount);
                        var _iterator4 = children, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                        for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                            var _ref4;
                            if (_isArray4) {
                                if (_i4 >= _iterator4.length) break;
                                _ref4 = _iterator4[_i4++];
                            } else {
                                if ((_i4 = _iterator4.next()).done) break;
                                _ref4 = _i4.value;
                            }
                            var _child = _ref4;
                            if (_child.activeInHierarchy) {
                                _child.getScale(_tempScale);
                                var childScaleX = this._getUsedScaleValue(_tempScale.x), childScaleY = this._getUsedScaleValue(_tempScale.y);
                                this._resizeMode === ResizeMode.CHILDREN && (_child.width = newChildWidth / childScaleX, 
                                this._N$layoutType === Type.GRID && (_child.height = this._cellSize.height / childScaleY));
                                var anchorX = _child.anchorX, childBoundingBoxWidth = _child.width * childScaleX, childBoundingBoxHeight = _child.height * childScaleY;
                                tempMaxHeight < secondMaxHeight && (tempMaxHeight = secondMaxHeight), tempMaxHeight <= childBoundingBoxHeight && (secondMaxHeight = tempMaxHeight, 
                                tempMaxHeight = childBoundingBoxHeight, maxHeightChildAnchorY = _child.getAnchorPoint().y), 
                                this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (anchorX = 1 - _child.anchorX), 
                                nextX = nextX + sign * anchorX * childBoundingBoxWidth + sign * this._spacingX;
                                var rightBoundaryOfChild = sign * (1 - anchorX) * childBoundingBoxWidth;
                                if (rowBreak) {
                                    var rowBreakBoundary = nextX + rightBoundaryOfChild + sign * (0 < sign ? this._paddingRight : this._paddingLeft), leftToRightRowBreak = !1;
                                    this._horizontalDirection === HorizontalDirection.LEFT_TO_RIGHT && rowBreakBoundary > (1 - layoutAnchor.x) * baseWidth && (leftToRightRowBreak = !0);
                                    var rightToLeftRowBreak = !1;
                                    this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && rowBreakBoundary < -layoutAnchor.x * baseWidth && (rightToLeftRowBreak = !0), 
                                    (leftToRightRowBreak || rightToLeftRowBreak) && (tempMaxHeight <= childBoundingBoxHeight ? (0 === secondMaxHeight && (secondMaxHeight = tempMaxHeight), 
                                    rowMaxHeight += secondMaxHeight, secondMaxHeight = tempMaxHeight) : (rowMaxHeight += tempMaxHeight, 
                                    secondMaxHeight = childBoundingBoxHeight, tempMaxHeight = 0), nextX = startPos + sign * (paddingX + anchorX * childBoundingBoxWidth), 
                                    row++);
                                }
                                var finalPositionY = fnPositionY(_child, rowMaxHeight, row);
                                baseWidth >= childBoundingBoxWidth + this._paddingLeft + this._paddingRight && applyChildren && (_child.getPosition(_tempPos), 
                                _child.setPosition(nextX, finalPositionY, _tempPos.z));
                                var signX = 1, tempFinalPositionY = void 0, topMarign = 0 === tempMaxHeight ? childBoundingBoxHeight : tempMaxHeight;
                                this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM ? (containerResizeBoundary = containerResizeBoundary || this.node.getContentSize().height, 
                                (tempFinalPositionY = finalPositionY + (signX = -1) * (topMarign * maxHeightChildAnchorY + this._paddingBottom)) < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY)) : (containerResizeBoundary = containerResizeBoundary || -this.node.getContentSize().height) < (tempFinalPositionY = finalPositionY + signX * (topMarign * maxHeightChildAnchorY + this._paddingTop)) && (containerResizeBoundary = tempFinalPositionY), 
                                nextX += rightBoundaryOfChild;
                            }
                        }
                        return containerResizeBoundary;
                    }
                }, {
                    key: "_doLayoutVertically",
                    value: function _doLayoutVertically(baseHeight, columnBreak, fnPositionX, applyChildren) {
                        var layoutAnchor = this.node.getAnchorPoint(), children = this.node.children, sign = 1, paddingY = this._paddingBottom, bottomBoundaryOfLayout = -layoutAnchor.y * baseHeight;
                        this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (sign = -1, bottomBoundaryOfLayout = (1 - layoutAnchor.y) * baseHeight, 
                        paddingY = this._paddingTop);
                        var nextY = bottomBoundaryOfLayout + sign * paddingY - sign * this._spacingY, columnMaxWidth = 0, tempMaxWidth = 0, secondMaxWidth = 0, column = 0, containerResizeBoundary = 0, maxWidthChildAnchorX = 0, activeChildCount = 0, _iterator5 = children, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                            var _ref5;
                            if (_isArray5) {
                                if (_i5 >= _iterator5.length) break;
                                _ref5 = _iterator5[_i5++];
                            } else {
                                if ((_i5 = _iterator5.next()).done) break;
                                _ref5 = _i5.value;
                            }
                            _ref5.activeInHierarchy && activeChildCount++;
                        }
                        var newChildHeight = this._cellSize.height;
                        this._N$layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN && (newChildHeight = (baseHeight - (this._paddingTop + this._paddingBottom) - (activeChildCount - 1) * this._spacingY) / activeChildCount);
                        var _iterator6 = children, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                        for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                            var _ref6;
                            if (_isArray6) {
                                if (_i6 >= _iterator6.length) break;
                                _ref6 = _iterator6[_i6++];
                            } else {
                                if ((_i6 = _iterator6.next()).done) break;
                                _ref6 = _i6.value;
                            }
                            var _child2 = _ref6;
                            if (_child2) {
                                var scale = _child2.getScale(), childScaleX = this._getUsedScaleValue(scale.x), childScaleY = this._getUsedScaleValue(scale.y);
                                if (_child2.activeInHierarchy) {
                                    this._resizeMode === ResizeMode.CHILDREN && (_child2.height = newChildHeight / childScaleY, 
                                    this._N$layoutType === Type.GRID && (_child2.width = this._cellSize.width / childScaleX));
                                    var anchorY = _child2.anchorY, childBoundingBoxWidth = _child2.width * childScaleX, childBoundingBoxHeight = _child2.height * childScaleY;
                                    tempMaxWidth < secondMaxWidth && (tempMaxWidth = secondMaxWidth), tempMaxWidth <= childBoundingBoxWidth && (secondMaxWidth = tempMaxWidth, 
                                    tempMaxWidth = childBoundingBoxWidth, maxWidthChildAnchorX = _child2.getAnchorPoint().x), 
                                    this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (anchorY = 1 - _child2.anchorY), 
                                    nextY = nextY + sign * anchorY * childBoundingBoxHeight + sign * this._spacingY;
                                    var topBoundaryOfChild = sign * (1 - anchorY) * childBoundingBoxHeight;
                                    if (columnBreak) {
                                        var columnBreakBoundary = nextY + topBoundaryOfChild + sign * (0 < sign ? this._paddingTop : this._paddingBottom), bottomToTopColumnBreak = !1;
                                        this._verticalDirection === VerticalDirection.BOTTOM_TO_TOP && columnBreakBoundary > (1 - layoutAnchor.y) * baseHeight && (bottomToTopColumnBreak = !0);
                                        var topToBottomColumnBreak = !1;
                                        this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && columnBreakBoundary < -layoutAnchor.y * baseHeight && (topToBottomColumnBreak = !0), 
                                        (bottomToTopColumnBreak || topToBottomColumnBreak) && (tempMaxWidth <= childBoundingBoxWidth ? (0 === secondMaxWidth && (secondMaxWidth = tempMaxWidth), 
                                        columnMaxWidth += secondMaxWidth, secondMaxWidth = tempMaxWidth) : (columnMaxWidth += tempMaxWidth, 
                                        secondMaxWidth = childBoundingBoxWidth, tempMaxWidth = 0), nextY = bottomBoundaryOfLayout + sign * (paddingY + anchorY * childBoundingBoxHeight), 
                                        column++);
                                    }
                                    var finalPositionX = fnPositionX(_child2, columnMaxWidth, column);
                                    baseHeight >= childBoundingBoxHeight + (this._paddingTop + this._paddingBottom) && applyChildren && (_child2.getPosition(_tempPos), 
                                    _child2.setPosition(finalPositionX, nextY, _tempPos.z));
                                    var signX = 1, tempFinalPositionX = void 0, rightMarign = 0 === tempMaxWidth ? childBoundingBoxWidth : tempMaxWidth;
                                    this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT ? (signX = -1, containerResizeBoundary = containerResizeBoundary || this.node.getContentSize().width, 
                                    (tempFinalPositionX = finalPositionX + signX * (rightMarign * maxWidthChildAnchorX + this._paddingLeft)) < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX)) : (containerResizeBoundary = containerResizeBoundary || -this.node.getContentSize().width) < (tempFinalPositionX = finalPositionX + signX * (rightMarign * maxWidthChildAnchorX + this._paddingRight)) && (containerResizeBoundary = tempFinalPositionX), 
                                    nextY += topBoundaryOfChild;
                                }
                            }
                        }
                        return containerResizeBoundary;
                    }
                }, {
                    key: "_doLayoutBasic",
                    value: function _doLayoutBasic() {
                        var allChildrenBoundingBox = null, _iterator7 = this.node.children, _isArray7 = Array.isArray(_iterator7), _i7 = 0;
                        for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                            var _ref7;
                            if (_isArray7) {
                                if (_i7 >= _iterator7.length) break;
                                _ref7 = _iterator7[_i7++];
                            } else {
                                if ((_i7 = _iterator7.next()).done) break;
                                _ref7 = _i7.value;
                            }
                            var child = _ref7, childTransform = child.getComponent(UITransformComponent);
                            childTransform && child.activeInHierarchy && (allChildrenBoundingBox ? Rect.union(allChildrenBoundingBox, allChildrenBoundingBox, childTransform.getBoundingBoxToWorld()) : allChildrenBoundingBox = childTransform.getBoundingBoxToWorld());
                        }
                        if (allChildrenBoundingBox) {
                            var parentTransform = this.node.parent.getComponent(UITransformComponent);
                            if (!parentTransform) return;
                            Vec3.set(_tempPos, allChildrenBoundingBox.x, allChildrenBoundingBox.y, 0);
                            var leftBottomInParentSpace = new Vec3();
                            parentTransform.convertToNodeSpaceAR(_tempPos, leftBottomInParentSpace), Vec3.set(leftBottomInParentSpace, leftBottomInParentSpace.x - this._paddingLeft, leftBottomInParentSpace.y - this._paddingBottom, leftBottomInParentSpace.z), 
                            Vec3.set(_tempPos, allChildrenBoundingBox.x + allChildrenBoundingBox.width, allChildrenBoundingBox.y + allChildrenBoundingBox.height, 0);
                            var rightTopInParentSpace = new Vec3();
                            parentTransform.convertToNodeSpaceAR(_tempPos, rightTopInParentSpace), Vec3.set(rightTopInParentSpace, rightTopInParentSpace.x + this._paddingRight, rightTopInParentSpace.y + this._paddingTop, rightTopInParentSpace.z);
                            var newSize = cc.size(parseFloat((rightTopInParentSpace.x - leftBottomInParentSpace.x).toFixed(2)), parseFloat((rightTopInParentSpace.y - leftBottomInParentSpace.y).toFixed(2)));
                            if (this.node.getPosition(_tempPos), 0 !== newSize.width) {
                                var newAnchorX = (_tempPos.x - leftBottomInParentSpace.x) / newSize.width;
                                this.node.anchorX = parseFloat(newAnchorX.toFixed(2));
                            }
                            if (0 !== newSize.height) {
                                var newAnchorY = (_tempPos.y - leftBottomInParentSpace.y) / newSize.height;
                                this.node.anchorY = parseFloat(newAnchorY.toFixed(2));
                            }
                            this.node.setContentSize(newSize);
                        }
                    }
                }, {
                    key: "_doLayoutGridAxisHorizontal",
                    value: function _doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) {
                        var _this2 = this, baseWidth = layoutSize.width, sign = 1, bottomBoundaryOfLayout = -layoutAnchor.y * layoutSize.height, paddingY = this._paddingBottom;
                        this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (sign = -1, bottomBoundaryOfLayout = (1 - layoutAnchor.y) * layoutSize.height, 
                        paddingY = this._paddingTop);
                        function fnPositionY(child, topOffset, row) {
                            return bottomBoundaryOfLayout + sign * (topOffset + child.anchorY * child.height * self._getUsedScaleValue(child.getScale().y) + paddingY + row * _this2._spacingY);
                        }
                        var self = this, newHeight = 0;
                        if (this._resizeMode === ResizeMode.CONTAINER) {
                            var boundary = this._doLayoutHorizontally(baseWidth, !0, fnPositionY, !1);
                            (newHeight = bottomBoundaryOfLayout - boundary) < 0 && (newHeight *= -1), bottomBoundaryOfLayout = -layoutAnchor.y * newHeight, 
                            this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (sign = -1, bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight);
                        }
                        this._doLayoutHorizontally(baseWidth, !0, fnPositionY, !0), this._resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(baseWidth, newHeight);
                    }
                }, {
                    key: "_doLayoutGridAxisVertical",
                    value: function _doLayoutGridAxisVertical(layoutAnchor, layoutSize) {
                        var _this3 = this, baseHeight = layoutSize.height, sign = 1, leftBoundaryOfLayout = -layoutAnchor.x * layoutSize.width, paddingX = this._paddingLeft;
                        this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (sign = -1, leftBoundaryOfLayout = (1 - layoutAnchor.x) * layoutSize.width, 
                        paddingX = this._paddingRight);
                        function fnPositionX(child, leftOffset, column) {
                            return leftBoundaryOfLayout + sign * (leftOffset + child.anchorX * child.width * self._getUsedScaleValue(child.getScale().x) + paddingX + column * _this3._spacingX);
                        }
                        var self = this, newWidth = 0;
                        if (this._resizeMode === ResizeMode.CONTAINER) {
                            var boundary = this._doLayoutVertically(baseHeight, !0, fnPositionX, !1);
                            (newWidth = leftBoundaryOfLayout - boundary) < 0 && (newWidth *= -1), leftBoundaryOfLayout = -layoutAnchor.x * newWidth, 
                            this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (sign = -1, leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth);
                        }
                        this._doLayoutVertically(baseHeight, !0, fnPositionX, !0), this._resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(newWidth, baseHeight);
                    }
                }, {
                    key: "_doLayoutGrid",
                    value: function _doLayoutGrid() {
                        var layoutAnchor = this.node.getAnchorPoint(), layoutSize = this.node.getContentSize();
                        this.startAxis === AxisDirection.HORIZONTAL ? this._doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) : this.startAxis === AxisDirection.VERTICAL && this._doLayoutGridAxisVertical(layoutAnchor, layoutSize);
                    }
                }, {
                    key: "_getHorizontalBaseWidth",
                    value: function _getHorizontalBaseWidth(children) {
                        var newWidth = 0, activeChildCount = 0;
                        if (this._resizeMode === ResizeMode.CONTAINER) {
                            var _iterator8 = children, _isArray8 = Array.isArray(_iterator8), _i8 = 0;
                            for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                                var _ref8;
                                if (_isArray8) {
                                    if (_i8 >= _iterator8.length) break;
                                    _ref8 = _iterator8[_i8++];
                                } else {
                                    if ((_i8 = _iterator8.next()).done) break;
                                    _ref8 = _i8.value;
                                }
                                var child = _ref8;
                                child.getScale(_tempScale), child.activeInHierarchy && (activeChildCount++, newWidth += child.width * this._getUsedScaleValue(_tempScale.x));
                            }
                            newWidth += (activeChildCount - 1) * this._spacingX + this._paddingLeft + this._paddingRight;
                        } else newWidth = this.node.getContentSize().width;
                        return newWidth;
                    }
                }, {
                    key: "_getVerticalBaseHeight",
                    value: function _getVerticalBaseHeight(children) {
                        var newHeight = 0, activeChildCount = 0;
                        if (this._resizeMode === ResizeMode.CONTAINER) {
                            var _iterator9 = children, _isArray9 = Array.isArray(_iterator9), _i9 = 0;
                            for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                                var _ref9;
                                if (_isArray9) {
                                    if (_i9 >= _iterator9.length) break;
                                    _ref9 = _iterator9[_i9++];
                                } else {
                                    if ((_i9 = _iterator9.next()).done) break;
                                    _ref9 = _i9.value;
                                }
                                var child = _ref9;
                                child.getScale(_tempScale), child.activeInHierarchy && (activeChildCount++, newHeight += child.height * this._getUsedScaleValue(_tempScale.y));
                            }
                            newHeight += (activeChildCount - 1) * this._spacingY + this._paddingBottom + this._paddingTop;
                        } else newHeight = this.node.getContentSize().height;
                        return newHeight;
                    }
                }, {
                    key: "_doLayout",
                    value: function _doLayout() {
                        if (this._N$layoutType === Type.HORIZONTAL) {
                            var newWidth = this._getHorizontalBaseWidth(this.node.children);
                            this._doLayoutHorizontally(newWidth, !1, function fnPositionY(child) {
                                return child.getPosition(_tempPos), _tempPos.y;
                            }, !0), this.node.width = newWidth;
                        } else if (this._N$layoutType === Type.VERTICAL) {
                            var newHeight = this._getVerticalBaseHeight(this.node.children);
                            this._doLayoutVertically(newHeight, !1, function fnPositionX(child) {
                                return child.getPosition(_tempPos), _tempPos.x;
                            }, !0), this.node.height = newHeight;
                        } else this._N$layoutType === Type.NONE ? this._resizeMode === ResizeMode.CONTAINER && this._doLayoutBasic() : this._N$layoutType === Type.GRID && this._doLayoutGrid();
                    }
                }, {
                    key: "_getUsedScaleValue",
                    value: function _getUsedScaleValue(value) {
                        return this._affectedByScale ? Math.abs(value) : 1;
                    }
                }, {
                    key: "_transformDirty",
                    value: function _transformDirty(type) {
                        type === SystemEventType.POSITION_PART && this._doLayoutDirty();
                    }
                }, {
                    key: "_doLayoutDirty",
                    value: function _doLayoutDirty() {
                        this._layoutDirty = !0;
                    }
                }, {
                    key: "_doScaleDirty",
                    value: function _doScaleDirty() {
                        this._layoutDirty = this._layoutDirty || this._affectedByScale;
                    }
                }, {
                    key: "type",
                    get: function get() {
                        return this._N$layoutType;
                    },
                    set: function set(value) {
                        this._N$layoutType = value, this._doLayoutDirty();
                    }
                }, {
                    key: "resizeMode",
                    get: function get() {
                        return this._resizeMode;
                    },
                    set: function set(value) {
                        this._N$layoutType === Type.NONE && value === ResizeMode.CHILDREN || (this._resizeMode = value, 
                        this._doLayoutDirty());
                    }
                }, {
                    key: "cellSize",
                    get: function get() {
                        return this._cellSize;
                    },
                    set: function set(value) {
                        this._cellSize !== value && (this._cellSize.set(value), this._doLayoutDirty());
                    }
                }, {
                    key: "startAxis",
                    get: function get() {
                        return this._startAxis;
                    },
                    set: function set(value) {
                        this._startAxis !== value && (this._startAxis = value, this._doLayoutDirty());
                    }
                }, {
                    key: "paddingLeft",
                    get: function get() {
                        return this._paddingLeft;
                    },
                    set: function set(value) {
                        this._paddingLeft !== value && (this._paddingLeft = value, this._doLayoutDirty());
                    }
                }, {
                    key: "paddingRight",
                    get: function get() {
                        return this._paddingRight;
                    },
                    set: function set(value) {
                        this._paddingRight !== value && (this._paddingRight = value, this._doLayoutDirty());
                    }
                }, {
                    key: "paddingTop",
                    get: function get() {
                        return this._paddingTop;
                    },
                    set: function set(value) {
                        this._paddingTop !== value && (this._paddingTop = value, this._doLayoutDirty());
                    }
                }, {
                    key: "paddingBottom",
                    get: function get() {
                        return this._paddingBottom;
                    },
                    set: function set(value) {
                        this._paddingBottom !== value && (this._paddingBottom = value, this._doLayoutDirty());
                    }
                }, {
                    key: "spacingX",
                    get: function get() {
                        return this._spacingX;
                    },
                    set: function set(value) {
                        this._spacingX !== value && (this._spacingX = value, this._doLayoutDirty());
                    }
                }, {
                    key: "spacingY",
                    get: function get() {
                        return this._spacingY;
                    },
                    set: function set(value) {
                        this._spacingY !== value && (this._spacingY = value, this._doLayoutDirty());
                    }
                }, {
                    key: "verticalDirection",
                    get: function get() {
                        return this._verticalDirection;
                    },
                    set: function set(value) {
                        this._verticalDirection !== value && (this._verticalDirection = value, this._doLayoutDirty());
                    }
                }, {
                    key: "horizontalDirection",
                    get: function get() {
                        return this._horizontalDirection;
                    },
                    set: function set(value) {
                        this._horizontalDirection !== value && (this._horizontalDirection = value, this._doLayoutDirty());
                    }
                }, {
                    key: "padding",
                    get: function get() {
                        return this._paddingLeft;
                    },
                    set: function set(value) {
                        this._N$padding = value, this._migratePaddingData(), this._doLayoutDirty();
                    }
                }, {
                    key: "affectedByScale",
                    get: function get() {
                        return this._affectedByScale;
                    },
                    set: function set(value) {
                        this._affectedByScale = value, this._doLayoutDirty();
                    }
                } ]), LayoutComponent;
            }(), _class3$m.Type = Type, _class3$m.VerticalDirection = VerticalDirection, _class3$m.HorizontalDirection = HorizontalDirection, 
            _class3$m.ResizeMode = ResizeMode, _class3$m.AxisDirection = AxisDirection, _applyDecoratedDescriptor((_class2$O = _temp$V).prototype, "type", [ _dec4$j ], Object.getOwnPropertyDescriptor(_class2$O.prototype, "type"), _class2$O.prototype), 
            _applyDecoratedDescriptor(_class2$O.prototype, "resizeMode", [ _dec5$i ], Object.getOwnPropertyDescriptor(_class2$O.prototype, "resizeMode"), _class2$O.prototype), 
            _applyDecoratedDescriptor(_class2$O.prototype, "cellSize", [ property ], Object.getOwnPropertyDescriptor(_class2$O.prototype, "cellSize"), _class2$O.prototype), 
            _applyDecoratedDescriptor(_class2$O.prototype, "startAxis", [ _dec6$f ], Object.getOwnPropertyDescriptor(_class2$O.prototype, "startAxis"), _class2$O.prototype), 
            _applyDecoratedDescriptor(_class2$O.prototype, "paddingLeft", [ property ], Object.getOwnPropertyDescriptor(_class2$O.prototype, "paddingLeft"), _class2$O.prototype), 
            _applyDecoratedDescriptor(_class2$O.prototype, "paddingRight", [ property ], Object.getOwnPropertyDescriptor(_class2$O.prototype, "paddingRight"), _class2$O.prototype), 
            _applyDecoratedDescriptor(_class2$O.prototype, "paddingTop", [ property ], Object.getOwnPropertyDescriptor(_class2$O.prototype, "paddingTop"), _class2$O.prototype), 
            _applyDecoratedDescriptor(_class2$O.prototype, "paddingBottom", [ property ], Object.getOwnPropertyDescriptor(_class2$O.prototype, "paddingBottom"), _class2$O.prototype), 
            _applyDecoratedDescriptor(_class2$O.prototype, "spacingX", [ property ], Object.getOwnPropertyDescriptor(_class2$O.prototype, "spacingX"), _class2$O.prototype), 
            _applyDecoratedDescriptor(_class2$O.prototype, "spacingY", [ property ], Object.getOwnPropertyDescriptor(_class2$O.prototype, "spacingY"), _class2$O.prototype), 
            _applyDecoratedDescriptor(_class2$O.prototype, "verticalDirection", [ _dec7$c ], Object.getOwnPropertyDescriptor(_class2$O.prototype, "verticalDirection"), _class2$O.prototype), 
            _applyDecoratedDescriptor(_class2$O.prototype, "horizontalDirection", [ _dec8$7 ], Object.getOwnPropertyDescriptor(_class2$O.prototype, "horizontalDirection"), _class2$O.prototype), 
            _applyDecoratedDescriptor(_class2$O.prototype, "padding", [ property ], Object.getOwnPropertyDescriptor(_class2$O.prototype, "padding"), _class2$O.prototype), 
            _applyDecoratedDescriptor(_class2$O.prototype, "affectedByScale", [ property ], Object.getOwnPropertyDescriptor(_class2$O.prototype, "affectedByScale"), _class2$O.prototype), 
            _descriptor$L = _applyDecoratedDescriptor(_class2$O.prototype, "_resizeMode", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return ResizeMode.NONE;
                }
            }), _descriptor2$B = _applyDecoratedDescriptor(_class2$O.prototype, "_N$layoutType", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Type.NONE;
                }
            }), _descriptor3$q = _applyDecoratedDescriptor(_class2$O.prototype, "_N$padding", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor4$l = _applyDecoratedDescriptor(_class2$O.prototype, "_cellSize", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Size(40, 40);
                }
            }), _descriptor5$h = _applyDecoratedDescriptor(_class2$O.prototype, "_startAxis", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return AxisDirection.HORIZONTAL;
                }
            }), _descriptor6$a = _applyDecoratedDescriptor(_class2$O.prototype, "_paddingLeft", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor7$9 = _applyDecoratedDescriptor(_class2$O.prototype, "_paddingRight", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor8$9 = _applyDecoratedDescriptor(_class2$O.prototype, "_paddingTop", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor9$8 = _applyDecoratedDescriptor(_class2$O.prototype, "_paddingBottom", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor10$6 = _applyDecoratedDescriptor(_class2$O.prototype, "_spacingX", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor11$5 = _applyDecoratedDescriptor(_class2$O.prototype, "_spacingY", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor12$5 = _applyDecoratedDescriptor(_class2$O.prototype, "_verticalDirection", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return VerticalDirection.TOP_TO_BOTTOM;
                }
            }), _descriptor13$5 = _applyDecoratedDescriptor(_class2$O.prototype, "_horizontalDirection", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return HorizontalDirection.LEFT_TO_RIGHT;
                }
            }), _descriptor14$5 = _applyDecoratedDescriptor(_class2$O.prototype, "_affectedByScale", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _class$$ = _class2$O)) || _class$$) || _class$$) || _class$$) || _class$$));
            cc.LayoutComponent = LayoutComponent, function(LineCap) {
                LineCap[LineCap.BUTT = 0] = "BUTT", LineCap[LineCap.ROUND = 1] = "ROUND", LineCap[LineCap.SQUARE = 2] = "SQUARE";
            }(LineCap = LineCap || {}), ccenum(LineCap), function(LineJoin) {
                LineJoin[LineJoin.BEVEL = 0] = "BEVEL", LineJoin[LineJoin.ROUND = 1] = "ROUND", 
                LineJoin[LineJoin.MITER = 2] = "MITER";
            }(LineJoin = LineJoin || {}), ccenum(LineJoin), function(PointFlags) {
                PointFlags[PointFlags.PT_CORNER = 1] = "PT_CORNER", PointFlags[PointFlags.PT_LEFT = 2] = "PT_LEFT", 
                PointFlags[PointFlags.PT_BEVEL = 4] = "PT_BEVEL", PointFlags[PointFlags.PT_INNERBEVEL = 8] = "PT_INNERBEVEL";
            }(PointFlags = PointFlags || {}), ccenum(PointFlags);
            var _dec$$, _dec2$D, _dec3$o, _dec4$l, _dec5$k, _dec6$h, _dec7$d, _class$11, _class2$Q, _descriptor$N, _descriptor2$D, _class3$o, _temp$X, GraphicsComponent = exports("GraphicsComponent", (_dec$_ = ccclass("cc.GraphicsComponent"), 
            _dec2$C = executionOrder(110), _dec3$n = menu("UI/Render/Graphics"), _dec4$k = property({
                type: LineJoin
            }), _dec5$j = property({
                type: LineCap
            }), _dec6$g = property({
                override: !0,
                visible: !1
            }), _dec$_(_class$10 = _dec2$C(_class$10 = _dec3$n((_temp$W = _class3$n = function() {
                function GraphicsComponent() {
                    var _this;
                    return _classCallCheck(this, GraphicsComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GraphicsComponent).call(this))).impl = null, 
                    _this.model = null, _initializerDefineProperty(_this, "_lineWidth", _descriptor$M, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_strokeColor", _descriptor2$C, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_lineJoin", _descriptor3$r, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_lineCap", _descriptor4$m, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_fillColor", _descriptor5$i, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_miterLimit", _descriptor6$b, _assertThisInitialized(_this)), 
                    _this._instanceMaterialType = InstanceMaterialType.ADDCOLOR, _this;
                }
                return _inherits(GraphicsComponent, UIRenderComponent), _createClass(GraphicsComponent, [ {
                    key: "lineWidth",
                    get: function get() {
                        return this._lineWidth;
                    },
                    set: function set(value) {
                        this._lineWidth = value, this.impl && (this.impl.lineWidth = value);
                    }
                }, {
                    key: "lineJoin",
                    get: function get() {
                        return this._lineJoin;
                    },
                    set: function set(value) {
                        this._lineJoin = value, this.impl && (this.impl.lineJoin = value);
                    }
                }, {
                    key: "lineCap",
                    get: function get() {
                        return this._lineCap;
                    },
                    set: function set(value) {
                        this._lineCap = value, this.impl && (this.impl.lineCap = value);
                    }
                }, {
                    key: "strokeColor",
                    get: function get() {
                        return this._strokeColor;
                    },
                    set: function set(value) {
                        this.impl && (this._strokeColor.set(value), this.impl.strokeColor = this._strokeColor);
                    }
                }, {
                    key: "fillColor",
                    get: function get() {
                        return this._fillColor;
                    },
                    set: function set(value) {
                        this.impl && (this._fillColor.set(value), this.impl.fillColor = this._fillColor);
                    }
                }, {
                    key: "miterLimit",
                    get: function get() {
                        return this._miterLimit;
                    },
                    set: function set(value) {
                        this._miterLimit = value;
                    }
                }, {
                    key: "color",
                    get: function get() {
                        return this._color;
                    }
                } ]), _createClass(GraphicsComponent, [ {
                    key: "onRestore",
                    value: function onRestore() {
                        this.impl || this._flushAssembler();
                    }
                }, {
                    key: "__preload",
                    value: function __preload() {
                        _get(_getPrototypeOf(GraphicsComponent.prototype), "__preload", this) && _get(_getPrototypeOf(GraphicsComponent.prototype), "__preload", this).call(this), 
                        this.impl = this._assembler && this._assembler.createImpl(this);
                    }
                }, {
                    key: "onLoad",
                    value: function onLoad() {
                        this._sceneGetter = director.root.ui.getRenderSceneGetter();
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        _get(_getPrototypeOf(GraphicsComponent.prototype), "onEnable", this).call(this), 
                        this.model && (this.model.enabled = !0), this._activateMaterial();
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this.model && (this.model.enabled = !1);
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        _get(_getPrototypeOf(GraphicsComponent.prototype), "onDestroy", this).call(this), 
                        this._sceneGetter = null, this.model && (this._getRenderScene().destroyModel(this.model), 
                        this.model = null), this.impl && (this.impl.clear(), this.impl = null);
                    }
                }, {
                    key: "_activateMaterial",
                    value: function _activateMaterial() {
                        this._material && this._updateMaterial(this._material);
                    }
                }, {
                    key: "moveTo",
                    value: function moveTo(x, y) {
                        this.impl && this.impl.moveTo(x, y);
                    }
                }, {
                    key: "lineTo",
                    value: function lineTo(x, y) {
                        this.impl && this.impl.lineTo(x, y);
                    }
                }, {
                    key: "bezierCurveTo",
                    value: function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
                        this.impl && this.impl.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                    }
                }, {
                    key: "quadraticCurveTo",
                    value: function quadraticCurveTo(cx, cy, x, y) {
                        this.impl && this.impl.quadraticCurveTo(cx, cy, x, y);
                    }
                }, {
                    key: "arc",
                    value: function arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
                        this.impl && this.impl.arc(cx, cy, r, startAngle, endAngle, counterclockwise);
                    }
                }, {
                    key: "ellipse",
                    value: function ellipse(cx, cy, rx, ry) {
                        this.impl && this.impl.ellipse(cx, cy, rx, ry);
                    }
                }, {
                    key: "circle",
                    value: function circle(cx, cy, r) {
                        this.impl && this.impl.circle(cx, cy, r);
                    }
                }, {
                    key: "rect",
                    value: function rect(x, y, w, h) {
                        this.impl && this.impl.rect(x, y, w, h);
                    }
                }, {
                    key: "roundRect",
                    value: function roundRect(x, y, w, h, r) {
                        this.impl && this.impl.roundRect(x, y, w, h, r);
                    }
                }, {
                    key: "fillRect",
                    value: function fillRect(x, y, w, h) {
                        this.rect(x, y, w, h), this.fill();
                    }
                }, {
                    key: "clear",
                    value: function clear(argument_0) {
                        var clean = 0 < arguments.length && void 0 !== argument_0 && argument_0;
                        this.impl && (this.impl.clear(clean), this.model && (this.model.scene.destroyModel(this.model), 
                        this.model = null), this.markForUpdateRenderData());
                    }
                }, {
                    key: "close",
                    value: function close() {
                        this.impl && this.impl.close();
                    }
                }, {
                    key: "stroke",
                    value: function stroke() {
                        this._assembler.stroke(this);
                    }
                }, {
                    key: "fill",
                    value: function fill() {
                        this._assembler.fill(this);
                    }
                }, {
                    key: "helpInstanceMaterial",
                    value: function helpInstanceMaterial() {
                        var mat = null;
                        this._sharedMaterial ? mat = Material.getInstantiatedMaterial(this._sharedMaterial, new RenderableComponent(), !1) : ((mat = Material.getInstantiatedMaterial(builtinResMgr.get("ui-base-material"), new RenderableComponent(), !1)).recompileShaders({
                            USE_LOCAL: !0
                        }), mat.onLoaded()), this._updateMaterial(mat), this.impl || (this._flushAssembler(), 
                        this.impl = this._assembler && this._assembler.createImpl(this));
                    }
                }, {
                    key: "_render",
                    value: function _render(render) {
                        render.commitModel(this, this.model, this._material);
                    }
                }, {
                    key: "_instanceMaterial",
                    value: function _instanceMaterial() {
                        this.helpInstanceMaterial();
                    }
                }, {
                    key: "_flushAssembler",
                    value: function _flushAssembler() {
                        var assembler = GraphicsComponent.Assembler.getAssembler(this);
                        this._assembler !== assembler && (this._assembler = assembler);
                    }
                }, {
                    key: "_canRender",
                    value: function _canRender() {
                        return !!_get(_getPrototypeOf(GraphicsComponent.prototype), "_canRender", this).call(this) && !!this.model;
                    }
                } ]), GraphicsComponent;
            }(), _class3$n.LineJoin = LineJoin, _class3$n.LineCap = LineCap, _applyDecoratedDescriptor((_class2$P = _temp$W).prototype, "lineJoin", [ _dec4$k ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "lineJoin"), _class2$P.prototype), 
            _applyDecoratedDescriptor(_class2$P.prototype, "lineCap", [ _dec5$j ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "lineCap"), _class2$P.prototype), 
            _applyDecoratedDescriptor(_class2$P.prototype, "strokeColor", [ property ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "strokeColor"), _class2$P.prototype), 
            _applyDecoratedDescriptor(_class2$P.prototype, "fillColor", [ property ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "fillColor"), _class2$P.prototype), 
            _applyDecoratedDescriptor(_class2$P.prototype, "miterLimit", [ property ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "miterLimit"), _class2$P.prototype), 
            _applyDecoratedDescriptor(_class2$P.prototype, "color", [ _dec6$g ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "color"), _class2$P.prototype), 
            _descriptor$M = _applyDecoratedDescriptor(_class2$P.prototype, "_lineWidth", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _descriptor2$C = _applyDecoratedDescriptor(_class2$P.prototype, "_strokeColor", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Color.BLACK.clone();
                }
            }), _descriptor3$r = _applyDecoratedDescriptor(_class2$P.prototype, "_lineJoin", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return LineJoin.MITER;
                }
            }), _descriptor4$m = _applyDecoratedDescriptor(_class2$P.prototype, "_lineCap", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return LineCap.BUTT;
                }
            }), _descriptor5$i = _applyDecoratedDescriptor(_class2$P.prototype, "_fillColor", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Color.WHITE.clone();
                }
            }), _descriptor6$b = _applyDecoratedDescriptor(_class2$P.prototype, "_miterLimit", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 10;
                }
            }), _class$10 = _class2$P)) || _class$10) || _class$10) || _class$10));
            cc.GraphicsComponent = GraphicsComponent;
            var MaskType, _worldMatrix$2 = new Mat4(), _vec2_temp = new Vec2(), _mat4_temp$1 = new Mat4(), _circlepoints = [];
            !function(MaskType) {
                MaskType[MaskType.RECT = 0] = "RECT", MaskType[MaskType.ELLIPSE = 1] = "ELLIPSE";
            }(MaskType = MaskType || {}), ccenum(MaskType);
            var _dec$10, _dec2$E, _dec3$p, _dec4$m, _dec5$l, _dec6$i, _class$12, _class2$R, _descriptor$O, _descriptor2$E, _descriptor3$s, _descriptor4$n, _descriptor5$j, _class3$p, _temp$Y, Mode, MaskComponent = exports("MaskComponent", (_dec$$ = ccclass("cc.MaskComponent"), 
            _dec2$D = executionOrder(110), _dec3$o = menu("UI/Render/Mask"), _dec4$l = property({
                type: MaskType,
                displayOrder: 4
            }), _dec5$k = property({
                visible: !1,
                override: !0
            }), _dec6$h = property({
                visible: !1,
                override: !0
            }), _dec7$d = property({
                visible: !1,
                override: !0
            }), _dec$$(_class$11 = _dec2$D(_class$11 = _dec3$o((_temp$X = _class3$o = function() {
                function MaskComponent() {
                    var _this;
                    return _classCallCheck(this, MaskComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(MaskComponent).call(this)), "_type", _descriptor$N, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_segments", _descriptor2$D, _assertThisInitialized(_this)), 
                    _this._graphics = null, _this._clearGraphics = null, _this._instanceMaterialType = InstanceMaterialType.ADDCOLOR, 
                    _this;
                }
                return _inherits(MaskComponent, UIRenderComponent), _createClass(MaskComponent, [ {
                    key: "type",
                    get: function get() {
                        return this._type;
                    },
                    set: function set(value) {
                        this._type !== value && (this._type = value, this._updateGraphics(), this._renderData && (this.destroyRenderData(), 
                        this._renderData = null), this._activateMaterial());
                    }
                }, {
                    key: "segments",
                    get: function get() {
                        return this._segments;
                    },
                    set: function set(value) {
                        this._segments = clamp(value, 3, 1e4), this._updateGraphics();
                    }
                }, {
                    key: "graphics",
                    get: function get() {
                        return this._graphics;
                    }
                }, {
                    key: "clearGraphics",
                    get: function get() {
                        return this._clearGraphics;
                    }
                }, {
                    key: "dstBlendFactor",
                    get: function get() {
                        return this._dstBlendFactor;
                    },
                    set: function set(value) {
                        this._dstBlendFactor !== value && (this._dstBlendFactor = value, this._updateBlendFunc());
                    }
                }, {
                    key: "srcBlendFactor",
                    get: function get() {
                        return this._srcBlendFactor;
                    },
                    set: function set(value) {
                        this._srcBlendFactor !== value && (this._srcBlendFactor = value, this._updateBlendFunc());
                    }
                }, {
                    key: "color",
                    get: function get() {
                        return this._color;
                    },
                    set: function set(value) {
                        this._color !== value && (this._color.set(value), this.markForUpdateRenderData());
                    }
                } ]), _createClass(MaskComponent, [ {
                    key: "onLoad",
                    value: function onLoad() {
                        this._createGraphics();
                    }
                }, {
                    key: "onRestore",
                    value: function onRestore() {
                        this._createGraphics(), this._updateGraphics();
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        _get(_getPrototypeOf(MaskComponent.prototype), "onEnable", this).call(this), this._flushVisibility(), 
                        this._clearGraphics && this._clearGraphics.onEnable(), this._updateGraphics(), this._activateMaterial(), 
                        this.node.on(SystemEventType.TRANSFORM_CHANGED, this._nodeStateChange, this), view.on("design-resolution-changed", this._updateClearGraphics, this);
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        _get(_getPrototypeOf(MaskComponent.prototype), "onDisable", this).call(this), this._disableGraphics(), 
                        this.node.off(SystemEventType.TRANSFORM_CHANGED, this._nodeStateChange), view.off("design-resolution-changed", this._updateClearGraphics);
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        _get(_getPrototypeOf(MaskComponent.prototype), "onDestroy", this).call(this), this._removeGraphics();
                    }
                }, {
                    key: "isHit",
                    value: function isHit(cameraPt) {
                        var node = this.node, size = node.getContentSize(), w = size.width, h = size.height, testPt = _vec2_temp;
                        this.node.getWorldMatrix(_worldMatrix$2), Mat4.invert(_mat4_temp$1, _worldMatrix$2), 
                        Vec2.transformMat4(testPt, cameraPt, _mat4_temp$1);
                        var ap = node.getAnchorPoint();
                        testPt.x += ap.x * w, testPt.y += ap.y * h;
                        var result = !1;
                        if (this.type === MaskType.RECT) result = 0 <= testPt.x && 0 <= testPt.y && testPt.x <= w && testPt.y <= h; else if (this.type === MaskType.ELLIPSE) {
                            var rx = w / 2, ry = h / 2, px = testPt.x - .5 * w, py = testPt.y - .5 * h;
                            result = px * px / (rx * rx) + py * py / (ry * ry) < 1;
                        }
                        return result;
                    }
                }, {
                    key: "_resizeNodeToTargetNode",
                    value: function _resizeNodeToTargetNode() {}
                }, {
                    key: "_render",
                    value: function _render(render) {
                        render.commitComp(this, null, this._assembler);
                    }
                }, {
                    key: "_postRender",
                    value: function _postRender(render) {
                        this._postAssembler && render.commitComp(this, null, this._postAssembler);
                    }
                }, {
                    key: "_nodeStateChange",
                    value: function _nodeStateChange(type) {
                        type !== SystemEventType.POSITION_PART && (_get(_getPrototypeOf(MaskComponent.prototype), "_nodeStateChange", this).call(this, type), 
                        this._updateGraphics());
                    }
                }, {
                    key: "_resolutionChanged",
                    value: function _resolutionChanged() {
                        this._updateClearGraphics();
                    }
                }, {
                    key: "_canRender",
                    value: function _canRender() {
                        return !!_get(_getPrototypeOf(MaskComponent.prototype), "_canRender", this).call(this) && (null !== this._clearGraphics && null !== this._graphics);
                    }
                }, {
                    key: "_flushAssembler",
                    value: function _flushAssembler() {
                        var assembler = MaskComponent.Assembler.getAssembler(this), posAssembler = MaskComponent.PostAssembler.getAssembler(this);
                        this._assembler !== assembler && (this.destroyRenderData(), this._assembler = assembler), 
                        this._postAssembler !== posAssembler && (this._postAssembler = posAssembler), this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), 
                        this._renderData.material = this.sharedMaterial, this.markForUpdateRenderData());
                    }
                }, {
                    key: "_parentChanged",
                    value: function _parentChanged(node) {
                        return !!_get(_getPrototypeOf(MaskComponent.prototype), "_parentChanged", this).call(this, node) && (this._flushVisibility(), 
                        !0);
                    }
                }, {
                    key: "_onTextureLoaded",
                    value: function _onTextureLoaded() {
                        this._renderData && (this._renderData.uvDirty = !0, this._renderData.vertDirty = !0), 
                        this.enabledInHierarchy && this._activateMaterial();
                    }
                }, {
                    key: "_applySpriteFrame",
                    value: function _applySpriteFrame() {}
                }, {
                    key: "_createGraphics",
                    value: function _createGraphics() {
                        if (!this._clearGraphics) {
                            var clearGraphics = this._clearGraphics = new GraphicsComponent();
                            clearGraphics.node = new Node$1("clear-graphics"), clearGraphics.helpInstanceMaterial(), 
                            clearGraphics._activateMaterial(), clearGraphics.lineWidth = 0;
                            var color = Color.WHITE.clone();
                            color.a = 0, clearGraphics.fillColor = color, clearGraphics.simulate = !0, this._updateClearGraphics();
                        }
                        if (!this._graphics) {
                            var graphics = this._graphics = new GraphicsComponent();
                            graphics.node = this.node, graphics.node.getWorldMatrix(), graphics.helpInstanceMaterial(), 
                            graphics.lineWidth = 0;
                            var _color = Color.WHITE.clone();
                            _color.a = 0, graphics.fillColor = _color;
                        }
                    }
                }, {
                    key: "_updateClearGraphics",
                    value: function _updateClearGraphics() {
                        if (this._clearGraphics) {
                            var size = visibleRect;
                            this._clearGraphics.node.setWorldPosition(size.width / 2, size.height / 2, 0), this._clearGraphics.clear(), 
                            this._clearGraphics.rect(-size.width / 2, -size.height / 2, size.width, size.height), 
                            this._clearGraphics.fill();
                        }
                    }
                }, {
                    key: "_updateGraphics",
                    value: function _updateGraphics() {
                        if (this._graphics) {
                            var node = this.node, graphics = this._graphics;
                            graphics.clear();
                            var size = node.getContentSize(), width = size.width, height = size.height, ap = node.getAnchorPoint(), x = -width * ap.x, y = -height * ap.y;
                            if (this._type === MaskType.RECT) graphics.rect(x, y, width, height); else if (this._type === MaskType.ELLIPSE) {
                                for (var points = function _calculateCircle(center, radius, segements) {
                                    _circlepoints.length = 0;
                                    for (var anglePerStep = 2 * Math.PI / segements, step = 0; step < segements; ++step) _circlepoints.push(new Vec3(radius.x * Math.cos(anglePerStep * step) + center.x, radius.y * Math.sin(anglePerStep * step) + center.y, 0));
                                    return _circlepoints;
                                }(new Vec3(x + width / 2, y + height / 2, 0), new Vec3(width / 2, height / 2, 0), this._segments), i = 0; i < points.length; ++i) {
                                    var point = points[i];
                                    0 === i ? graphics.moveTo(point.x, point.y) : graphics.lineTo(point.x, point.y);
                                }
                                graphics.close();
                            }
                            graphics.fill();
                        }
                    }
                }, {
                    key: "_disableGraphics",
                    value: function _disableGraphics() {
                        this._graphics && this._graphics.onDisable(), this._clearGraphics && this._clearGraphics.onDisable();
                    }
                }, {
                    key: "_removeGraphics",
                    value: function _removeGraphics() {
                        this._graphics && this._graphics.destroy(), this._clearGraphics && this._clearGraphics.destroy();
                    }
                }, {
                    key: "_flushVisibility",
                    value: function _flushVisibility() {
                        this._clearGraphics && this._clearGraphics._setScreen(this._screen), this._graphics && this._graphics._setScreen(this._screen);
                    }
                }, {
                    key: "_activateMaterial",
                    value: function _activateMaterial() {}
                } ]), MaskComponent;
            }(), _class3$o.Type = MaskType, _applyDecoratedDescriptor((_class2$Q = _temp$X).prototype, "type", [ _dec4$l ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "type"), _class2$Q.prototype), 
            _applyDecoratedDescriptor(_class2$Q.prototype, "segments", [ property ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "segments"), _class2$Q.prototype), 
            _applyDecoratedDescriptor(_class2$Q.prototype, "dstBlendFactor", [ _dec5$k ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "dstBlendFactor"), _class2$Q.prototype), 
            _applyDecoratedDescriptor(_class2$Q.prototype, "srcBlendFactor", [ _dec6$h ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "srcBlendFactor"), _class2$Q.prototype), 
            _applyDecoratedDescriptor(_class2$Q.prototype, "color", [ _dec7$d ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "color"), _class2$Q.prototype), 
            _descriptor$N = _applyDecoratedDescriptor(_class2$Q.prototype, "_type", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return MaskType.RECT;
                }
            }), _descriptor2$D = _applyDecoratedDescriptor(_class2$Q.prototype, "_segments", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 64;
                }
            }), _class$11 = _class2$Q)) || _class$11) || _class$11) || _class$11));
            cc.MaskComponent = MaskComponent, function(Mode) {
                Mode[Mode.HORIZONTAL = 0] = "HORIZONTAL", Mode[Mode.VERTICAL = 1] = "VERTICAL", 
                Mode[Mode.FILLED = 2] = "FILLED";
            }(Mode = Mode || {}), Enum(Mode);
            var _class$13, _class2$S, _descriptor$P, _descriptor2$F, ProgressBarComponent = exports("ProgressBarComponent", (_dec$10 = ccclass("cc.ProgressBarComponent"), 
            _dec2$E = executionOrder(110), _dec3$p = menu("UI/ProgressBar"), _dec4$m = property({
                type: SpriteComponent
            }), _dec5$l = property({
                type: Mode
            }), _dec6$i = property({
                range: [ 0, 1, .1 ],
                slide: !0
            }), _dec$10(_class$12 = _dec2$E(_class$12 = _dec3$p((_temp$Y = _class3$p = function() {
                function ProgressBarComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, ProgressBarComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ProgressBarComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_barSprite", _descriptor$O, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_mode", _descriptor2$E, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_totalLength", _descriptor3$s, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_progress", _descriptor4$n, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_reverse", _descriptor5$j, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(ProgressBarComponent, Component), _createClass(ProgressBarComponent, [ {
                    key: "_initBarSprite",
                    value: function _initBarSprite() {
                        if (this._barSprite) {
                            var entity = this._barSprite.node;
                            if (!entity) return;
                            var nodeSize = this.node.getContentSize(), nodeAnchor = this.node.getAnchorPoint(), barSpriteSize = entity.getContentSize();
                            if (this._barSprite.fillType === SpriteComponent.FillType.RADIAL && (this._mode = Mode.FILLED), 
                            this._mode === Mode.HORIZONTAL ? this.totalLength = barSpriteSize.width : this._mode === Mode.VERTICAL ? this.totalLength = barSpriteSize.height : this.totalLength = this._barSprite.fillRange, 
                            entity.parent === this.node) {
                                var x = -nodeSize.width * nodeAnchor.x;
                                entity.setPosition(x, 0, 0);
                            }
                        }
                    }
                }, {
                    key: "_updateBarStatus",
                    value: function _updateBarStatus() {
                        if (this._barSprite) {
                            var entity = this._barSprite.node;
                            if (!entity) return;
                            var entityAnchorPoint = entity.getAnchorPoint(), entitySize = entity.getContentSize(), entityPosition = entity.getPosition(), anchorPoint = new Vec2(0, .5), progress = clamp01(this._progress), actualLenth = this._totalLength * progress, finalContentSize = entitySize, totalWidth = 0, totalHeight = 0;
                            switch (this._mode) {
                              case Mode.HORIZONTAL:
                                this._reverse && (anchorPoint = new Vec2(1, .5)), finalContentSize = new Size(actualLenth, entitySize.height), 
                                totalWidth = this._totalLength, totalHeight = entitySize.height;
                                break;

                              case Mode.VERTICAL:
                                anchorPoint = this._reverse ? new Vec2(.5, 1) : new Vec2(.5, 0), finalContentSize = new Size(entitySize.width, actualLenth), 
                                totalWidth = entitySize.width, totalHeight = this._totalLength;
                            }
                            if (this._mode === Mode.FILLED) this._barSprite.type !== SpriteComponent.Type.FILLED ? warn("ProgressBar FILLED mode only works when barSprite's Type is FILLED!") : (this._reverse && (actualLenth *= -1), 
                            this._barSprite.fillRange = actualLenth); else if (this._barSprite.type !== SpriteComponent.Type.FILLED) {
                                var anchorOffsetX = anchorPoint.x - entityAnchorPoint.x, anchorOffsetY = anchorPoint.y - entityAnchorPoint.y, finalPosition = new Vec3(totalWidth * anchorOffsetX, totalHeight * anchorOffsetY, 0);
                                entity.setPosition(entityPosition.x + finalPosition.x, entityPosition.y + finalPosition.y, entityPosition.z), 
                                entity.setAnchorPoint(anchorPoint), entity.setContentSize(finalContentSize);
                            } else warn("ProgressBar non-FILLED mode only works when barSprite's Type is non-FILLED!");
                        }
                    }
                }, {
                    key: "barSprite",
                    get: function get() {
                        return this._barSprite;
                    },
                    set: function set(value) {
                        this._barSprite !== value && (this._barSprite = value, this._initBarSprite());
                    }
                }, {
                    key: "mode",
                    get: function get() {
                        return this._mode;
                    },
                    set: function set(value) {
                        if (this._mode !== value && (this._mode = value, this._barSprite)) {
                            var entity = this._barSprite.node;
                            if (!entity) return;
                            var entitySize = entity.getContentSize();
                            this._mode === Mode.HORIZONTAL ? this.totalLength = entitySize.width : this._mode === Mode.VERTICAL ? this.totalLength = entitySize.height : this._mode === Mode.FILLED && (this.totalLength = this._barSprite.fillRange);
                        }
                    }
                }, {
                    key: "totalLength",
                    get: function get() {
                        return this._totalLength;
                    },
                    set: function set(value) {
                        this._mode === Mode.FILLED && (value = clamp01(value)), this._totalLength = value, 
                        this._updateBarStatus();
                    }
                }, {
                    key: "progress",
                    get: function get() {
                        return this._progress;
                    },
                    set: function set(value) {
                        this._progress !== value && (this._progress = value, this._updateBarStatus());
                    }
                }, {
                    key: "reverse",
                    get: function get() {
                        return this._reverse;
                    },
                    set: function set(value) {
                        this._reverse !== value && (this._reverse = value, this._barSprite && (this._barSprite.fillStart = 1 - this._barSprite.fillStart), 
                        this._updateBarStatus());
                    }
                } ]), ProgressBarComponent;
            }(), _class3$p.Mode = Mode, _applyDecoratedDescriptor((_class2$R = _temp$Y).prototype, "barSprite", [ _dec4$m ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "barSprite"), _class2$R.prototype), 
            _applyDecoratedDescriptor(_class2$R.prototype, "mode", [ _dec5$l ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "mode"), _class2$R.prototype), 
            _applyDecoratedDescriptor(_class2$R.prototype, "totalLength", [ property ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "totalLength"), _class2$R.prototype), 
            _applyDecoratedDescriptor(_class2$R.prototype, "progress", [ _dec6$i ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "progress"), _class2$R.prototype), 
            _applyDecoratedDescriptor(_class2$R.prototype, "reverse", [ property ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "reverse"), _class2$R.prototype), 
            _descriptor$O = _applyDecoratedDescriptor(_class2$R.prototype, "_barSprite", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor2$E = _applyDecoratedDescriptor(_class2$R.prototype, "_mode", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Mode.HORIZONTAL;
                }
            }), _descriptor3$s = _applyDecoratedDescriptor(_class2$R.prototype, "_totalLength", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _descriptor4$n = _applyDecoratedDescriptor(_class2$R.prototype, "_progress", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return .1;
                }
            }), _descriptor5$j = _applyDecoratedDescriptor(_class2$R.prototype, "_reverse", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _class$12 = _class2$R)) || _class$12) || _class$12) || _class$12));
            cc.ProgressBarComponent = ProgressBarComponent;
            var _dec$12, _dec2$G, _dec3$r, _dec4$n, _dec5$m, _dec6$j, _dec7$e, _class$14, _class2$T, _descriptor$Q, _descriptor2$G, _descriptor3$t, _descriptor4$o, _descriptor5$k, _descriptor6$c, _descriptor7$a, _descriptor8$a, _class3$q, _temp$_, LabelOutlineComponent = exports("LabelOutlineComponent", ccclass("cc.LabelOutlineComponent")(_class$13 = executionOrder(110)(_class$13 = menu("UI/Render/LabelOutline")((_descriptor$P = _applyDecoratedDescriptor((_class2$S = function() {
                function LabelOutlineComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, LabelOutlineComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(LabelOutlineComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_color", _descriptor$P, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_width", _descriptor2$F, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(LabelOutlineComponent, Component), _createClass(LabelOutlineComponent, [ {
                    key: "_updateRenderData",
                    value: function _updateRenderData() {
                        var label = this.node.getComponent(LabelComponent);
                        label && label.updateRenderData(!0);
                    }
                }, {
                    key: "color",
                    get: function get() {
                        return this._color;
                    },
                    set: function set(value) {
                        this._color !== value && (this._color.set(value), this._updateRenderData());
                    }
                }, {
                    key: "width",
                    get: function get() {
                        return this._width;
                    },
                    set: function set(value) {
                        this._width !== value && (this._width = value, this._updateRenderData());
                    }
                } ]), LabelOutlineComponent;
            }()).prototype, "_color", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Color(255, 255, 255, 255);
                }
            }), _descriptor2$F = _applyDecoratedDescriptor(_class2$S.prototype, "_width", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _applyDecoratedDescriptor(_class2$S.prototype, "color", [ property ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "color"), _class2$S.prototype), 
            _applyDecoratedDescriptor(_class2$S.prototype, "width", [ property ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "width"), _class2$S.prototype), 
            _class$13 = _class2$S)) || _class$13) || _class$13) || _class$13);
            cc.LabelOutlineComponent = LabelOutlineComponent;
            var _htmlTextParser = new HtmlTextParser();
            var pool$1 = new Pool(function(labelSeg) {
                return !!cc.isValid(labelSeg.node) && !labelSeg.node.getComponent(LabelOutlineComponent);
            }, 20);
            pool$1.get = function(str, richtext) {
                var labelSeg = this._get(), labelNode = (labelSeg = labelSeg || {
                    node: new PrivateNode("RICHTEXT_CHILD"),
                    comp: null,
                    lineCount: 0,
                    styleIndex: 0,
                    clickHandler: ""
                }).node, labelComponent = (labelNode = labelNode || new PrivateNode("RICHTEXT_CHILD")).getComponent(LabelComponent);
                return labelComponent = labelComponent = labelComponent || labelNode.addComponent(LabelComponent), 
                labelNode.setPosition(0, 0, 0), labelNode.setAnchorPoint(.5, .5), labelNode.setContentSize(128, 128), 
                "string" != typeof str && (str = "" + str), richtext.font instanceof Font ? labelComponent.font = richtext.font : labelComponent.fontFamily = "Arial", 
                labelComponent.string = str, labelComponent.horizontalAlign = HorizontalTextAlignment.LEFT, 
                labelComponent.verticalAlign = VerticalTextAlignment.TOP, labelComponent.fontSize = richtext.fontSize || 40, 
                labelComponent.overflow = 0, labelComponent.enableWrapText = !0, labelComponent.lineHeight = 40, 
                labelComponent.isBold = !1, labelComponent.isItalic = !1, labelComponent.isUnderline = !1, 
                {
                    node: labelNode,
                    comp: labelComponent,
                    lineCount: 0,
                    clickHandler: "",
                    styleIndex: 0
                };
            };
            var _dec$13, _dec2$H, _dec3$s, _dec4$o, _dec5$n, _class$15, _class2$U, _descriptor$R, _descriptor2$H, _descriptor3$u, _descriptor4$p, _descriptor5$l, _class3$r, _temp$$, RichTextComponent = exports("RichTextComponent", (_dec$12 = ccclass("cc.RichTextComponent"), 
            _dec2$G = executionOrder(110), _dec3$r = menu("UI/Render/RichText"), _dec4$n = property({
                multiline: !0
            }), _dec5$m = property({
                type: HorizontalTextAlignment
            }), _dec6$j = property({
                type: TTFFont
            }), _dec7$e = property({
                type: SpriteAtlas
            }), _dec$12(_class$14 = _dec2$G(_class$14 = _dec3$r(_class$14 = executeInEditMode((_temp$_ = _class3$q = function() {
                function RichTextComponent() {
                    var _this;
                    return _classCallCheck(this, RichTextComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(RichTextComponent).call(this)), "_lineHeight", _descriptor$Q, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_string", _descriptor2$G, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_horizontalAlign", _descriptor3$t, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_fontSize", _descriptor4$o, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_maxWidth", _descriptor5$k, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_font", _descriptor6$c, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_imageAtlas", _descriptor7$a, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_handleTouchEvent", _descriptor8$a, _assertThisInitialized(_this)), 
                    _this._textArray = [], _this._labelSegments = [], _this._labelSegmentsCache = [], 
                    _this._linesWidth = [], _this._lineCount = 1, _this._labelWidth = 0, _this._labelHeight = 0, 
                    _this._layoutDirty = !0, _this._lineOffsetX = 0, _this._updateRichTextStatus = void 0, 
                    _this._updateRichTextStatus = _this._updateRichText, _this;
                }
                return _inherits(RichTextComponent, UIComponent), _createClass(RichTextComponent, [ {
                    key: "string",
                    get: function get() {
                        return this._string;
                    },
                    set: function set(value) {
                        this._string !== value && (this._string = value, this._updateRichTextStatus());
                    }
                }, {
                    key: "horizontalAlign",
                    get: function get() {
                        return this._horizontalAlign;
                    },
                    set: function set(value) {
                        this.horizontalAlign !== value && (this._horizontalAlign = value, this._layoutDirty = !0, 
                        this._updateRichTextStatus());
                    }
                }, {
                    key: "fontSize",
                    get: function get() {
                        return this._fontSize;
                    },
                    set: function set(value) {
                        this._fontSize !== value && (this._fontSize = value, this._layoutDirty = !0, this._updateRichTextStatus());
                    }
                }, {
                    key: "font",
                    get: function get() {
                        return this._font;
                    },
                    set: function set(value) {
                        this._font !== value && (this._font = value, this._layoutDirty = !0, this._font && this._onTTFLoaded(), 
                        this._updateRichTextStatus());
                    }
                }, {
                    key: "maxWidth",
                    get: function get() {
                        return this._maxWidth;
                    },
                    set: function set(value) {
                        this._maxWidth !== value && (this._maxWidth = value, this._layoutDirty = !0, this._updateRichTextStatus());
                    }
                }, {
                    key: "lineHeight",
                    get: function get() {
                        return this._lineHeight;
                    },
                    set: function set(value) {
                        this._lineHeight !== value && (this._lineHeight = value, this._layoutDirty = !0, 
                        this._updateRichTextStatus());
                    }
                }, {
                    key: "imageAtlas",
                    get: function get() {
                        return this._imageAtlas;
                    },
                    set: function set(value) {
                        this._imageAtlas !== value && (this._imageAtlas = value, this._layoutDirty = !0, 
                        this._updateRichTextStatus());
                    }
                }, {
                    key: "handleTouchEvent",
                    get: function get() {
                        return this._handleTouchEvent;
                    },
                    set: function set(value) {
                        this._handleTouchEvent !== value && (this._handleTouchEvent = value, this.enabledInHierarchy && (this.handleTouchEvent ? this._addEventListeners() : this._removeEventListeners()));
                    }
                } ]), _createClass(RichTextComponent, [ {
                    key: "onEnable",
                    value: function onEnable() {
                        this.handleTouchEvent && this._addEventListeners(), this._updateRichText(), this._activateChildren(!0);
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this.handleTouchEvent && this._removeEventListeners(), this._activateChildren(!1);
                    }
                }, {
                    key: "start",
                    value: function start() {
                        this._onTTFLoaded();
                    }
                }, {
                    key: "onRestore",
                    value: function onRestore() {
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        var _iterator = this._labelSegments, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var seg = _ref;
                            seg.node.removeFromParent(), pool$1.put(seg);
                        }
                    }
                }, {
                    key: "_addEventListeners",
                    value: function _addEventListeners() {
                        this.node.on(Node$1.EventType.TOUCH_END, this._onTouchEnded, this);
                    }
                }, {
                    key: "_removeEventListeners",
                    value: function _removeEventListeners() {
                        this.node.off(Node$1.EventType.TOUCH_END, this._onTouchEnded, this);
                    }
                }, {
                    key: "_updateLabelSegmentTextAttributes",
                    value: function _updateLabelSegmentTextAttributes() {
                        var _this2 = this;
                        this._labelSegments.forEach(function(item) {
                            _this2._applyTextAttribute(item);
                        });
                    }
                }, {
                    key: "_createFontLabel",
                    value: function _createFontLabel(str) {
                        return pool$1.get(str, this);
                    }
                }, {
                    key: "_onTTFLoaded",
                    value: function _onTTFLoaded() {
                        if (this._font instanceof TTFFont) if (this._font._nativeAsset) this._layoutDirty = !0, 
                        this._updateRichText(); else {
                            var self = this;
                            loader.load(this._font.nativeUrl, function(err, fontFamily) {
                                self._layoutDirty = !0, self._updateRichText();
                            });
                        } else this._layoutDirty = !0, this._updateRichText();
                    }
                }, {
                    key: "_measureText",
                    value: function _measureText(styleIndex, string) {
                        function func(s) {
                            var label;
                            return 0 === self._labelSegmentsCache.length ? (label = self._createFontLabel(s), 
                            self._labelSegmentsCache.push(label)) : (label = self._labelSegmentsCache[0]).node.getComponent(LabelComponent).string = s, 
                            label.styleIndex = styleIndex, self._applyTextAttribute(label), label.node.getContentSize().width;
                        }
                        var self = this;
                        return string ? func(string) : func;
                    }
                }, {
                    key: "_onTouchEnded",
                    value: function _onTouchEnded(event) {
                        var _this3 = this, components = this.node.getComponents(UIComponent), self = this, _loop = function _loop() {
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) return "break";
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) return "break";
                                _ref2 = _i2.value;
                            }
                            var seg = _ref2, clickHandler = seg.clickHandler;
                            clickHandler && _this3._containsTouchLocation(seg, event.touch.getUILocation()) && (components.forEach(function(component) {
                                var func = component[clickHandler];
                                component.enabledInHierarchy && func && func.call(self, event);
                            }), event.propagationStopped = !0);
                        }, _iterator2 = this._labelSegments, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if ("break" === _loop()) break;
                        }
                    }
                }, {
                    key: "_containsTouchLocation",
                    value: function _containsTouchLocation(label, point) {
                        var comp = label.node.getComponent(UITransformComponent);
                        return !!comp && comp.getBoundingBoxToWorld().contains(point);
                    }
                }, {
                    key: "_resetState",
                    value: function _resetState() {
                        for (var _this4 = this, children = this.node.children, _loop2 = function _loop2(i) {
                            var child = children[i];
                            if (("RICHTEXT_CHILD" === child.name || "RICHTEXT_Image_CHILD" === child.name) && (child.parent === _this4.node ? child.parent = null : children.splice(i, 1), 
                            "RICHTEXT_CHILD" === child.name)) {
                                var index = _this4._labelSegments.findIndex(function(seg) {
                                    return seg.node === child;
                                });
                                -1 !== index && pool$1.put(_this4._labelSegments[index]);
                            }
                        }, i = children.length - 1; 0 <= i; i--) _loop2(i);
                        this._labelSegments.length = 0, this._labelSegmentsCache.length = 0, this._linesWidth.length = 0, 
                        this._lineOffsetX = 0, this._lineCount = 1, this._labelWidth = 0, this._labelHeight = 0, 
                        this._layoutDirty = !0;
                    }
                }, {
                    key: "_activateChildren",
                    value: function _activateChildren(active) {
                        for (var i = this.node.children.length - 1; 0 <= i; i--) {
                            var child = this.node.children[i];
                            "RICHTEXT_CHILD" !== child.name && "RICHTEXT_Image_CHILD" !== child.name || (child.active = active);
                        }
                    }
                }, {
                    key: "_addLabelSegment",
                    value: function _addLabelSegment(stringToken, styleIndex) {
                        var labelSegment;
                        if (0 === this._labelSegmentsCache.length) labelSegment = this._createFontLabel(stringToken); else {
                            var label = (labelSegment = this._labelSegmentsCache.pop()).node.getComponent(LabelComponent);
                            label && (label.string = stringToken);
                        }
                        return labelSegment.styleIndex = styleIndex, labelSegment.lineCount = this._lineCount, 
                        labelSegment.node.setAnchorPoint(0, 0), this._applyTextAttribute(labelSegment), 
                        this.node.addChild(labelSegment.node), this._labelSegments.push(labelSegment), labelSegment;
                    }
                }, {
                    key: "_updateRichTextWithMaxWidth",
                    value: function _updateRichTextWithMaxWidth(labelString, labelWidth, styleIndex) {
                        var fragmentWidth = labelWidth;
                        if (0 < this._lineOffsetX && fragmentWidth + this._lineOffsetX > this.maxWidth) for (var checkStartIndex = 0; this._lineOffsetX <= this.maxWidth; ) {
                            var checkEndIndex = this._getFirstWordLen(labelString, checkStartIndex, labelString.length), checkString = labelString.substr(checkStartIndex, checkEndIndex), checkStringWidth = this._measureText(styleIndex, checkString);
                            if (!(this._lineOffsetX + checkStringWidth <= this.maxWidth)) {
                                if (0 < checkStartIndex) {
                                    var remainingString = labelString.substr(0, checkStartIndex);
                                    this._addLabelSegment(remainingString, styleIndex), labelString = labelString.substr(checkStartIndex, labelString.length), 
                                    fragmentWidth = this._measureText(styleIndex, labelString);
                                }
                                this._updateLineInfo();
                                break;
                            }
                            this._lineOffsetX += checkStringWidth, checkStartIndex += checkEndIndex;
                        }
                        if (fragmentWidth > this.maxWidth) for (var fragments = fragmentText(labelString, fragmentWidth, this.maxWidth, this._measureText(styleIndex)), k = 0; k < fragments.length; ++k) {
                            var splitString = fragments[k], labelSize = this._addLabelSegment(splitString, styleIndex).node.getContentSize();
                            this._lineOffsetX += labelSize.width, 1 < fragments.length && k < fragments.length - 1 && this._updateLineInfo();
                        } else this._lineOffsetX += fragmentWidth, this._addLabelSegment(labelString, styleIndex);
                    }
                }, {
                    key: "_isLastComponentCR",
                    value: function _isLastComponentCR(stringToken) {
                        return stringToken.length - 1 === stringToken.lastIndexOf("\n");
                    }
                }, {
                    key: "_updateLineInfo",
                    value: function _updateLineInfo() {
                        this._linesWidth.push(this._lineOffsetX), this._lineOffsetX = 0, this._lineCount++;
                    }
                }, {
                    key: "_needsUpdateTextLayout",
                    value: function _needsUpdateTextLayout(newTextArray) {
                        if (this._layoutDirty || !this._textArray || !newTextArray) return !0;
                        if (this._textArray.length !== newTextArray.length) return !0;
                        for (var i = 0; i < this._textArray.length; i++) {
                            var oldItem = this._textArray[i], newItem = newTextArray[i];
                            if (oldItem.text !== newItem.text) return !0;
                            if (oldItem.style) {
                                if (newItem.style) {
                                    if (!!newItem.style.outline != !!oldItem.style.outline) return !0;
                                    if (oldItem.style.size !== newItem.style.size || oldItem.style.italic !== newItem.style.italic || oldItem.style.isImage !== newItem.style.isImage) return !0;
                                    if (oldItem.style.isImage === newItem.style.isImage && oldItem.style.src !== newItem.style.src) return !0;
                                } else if (oldItem.style.size || oldItem.style.italic || oldItem.style.isImage || oldItem.style.outline) return !0;
                            } else if (newItem.style && (newItem.style.size || newItem.style.italic || newItem.style.isImage || newItem.style.outline)) return !0;
                        }
                        return !1;
                    }
                }, {
                    key: "_addRichTextImageElement",
                    value: function _addRichTextImageElement(richTextElement) {
                        if (richTextElement.style) {
                            var spriteFrameName = richTextElement.style.src, spriteFrame = this._imageAtlas && spriteFrameName && this._imageAtlas.getSpriteFrame(spriteFrameName);
                            if (spriteFrame) {
                                var spriteNode = new PrivateNode("RICHTEXT_Image_CHILD"), spriteComponent = spriteNode.addComponent(SpriteComponent);
                                spriteNode.setAnchorPoint(0, 0), spriteComponent.type = SpriteComponent.Type.SLICED, 
                                spriteComponent.sizeMode = SpriteComponent.SizeMode.CUSTOM, this.node.addChild(spriteNode);
                                var obj = {
                                    node: spriteNode,
                                    comp: spriteComponent,
                                    lineCount: 0,
                                    clickHandler: "",
                                    styleIndex: 0
                                };
                                this._labelSegments.push(obj);
                                var spriteRect = spriteFrame.getRect(), scaleFactor = 1, spriteWidth = spriteRect.width, spriteHeight = spriteRect.height, expectWidth = richTextElement.style.imageWidth, expectHeight = richTextElement.style.imageHeight;
                                if (void 0 !== expectHeight && 0 < expectHeight && expectHeight < this.lineHeight ? spriteWidth *= scaleFactor = expectHeight / spriteHeight : spriteWidth *= scaleFactor = this.lineHeight / spriteHeight, 
                                spriteHeight *= scaleFactor, void 0 !== expectWidth && 0 < expectWidth && (spriteWidth = expectWidth), 
                                0 < this.maxWidth ? (this._lineOffsetX + spriteWidth > this.maxWidth && this._updateLineInfo(), 
                                this._lineOffsetX += spriteWidth) : (this._lineOffsetX += spriteWidth, this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX)), 
                                spriteComponent.spriteFrame = spriteFrame, spriteNode.setContentSize(spriteWidth, spriteHeight), 
                                obj.lineCount = this._lineCount, richTextElement.style.event) {
                                    var c = "click";
                                    richTextElement.style.event[c] && (obj.clickHandler = richTextElement.style.event[c]);
                                }
                            } else warnID(4400);
                        }
                    }
                }, {
                    key: "_updateRichText",
                    value: function _updateRichText() {
                        if (this.enabled) {
                            var newTextArray = _htmlTextParser.parse(this._string);
                            if (!this._needsUpdateTextLayout(newTextArray)) return this._textArray = newTextArray.slice(), 
                            void this._updateLabelSegmentTextAttributes();
                            this._textArray = newTextArray.slice(), this._resetState();
                            for (var labelSize, lastEmptyLine = !1, i = 0; i < this._textArray.length; ++i) {
                                var richTextElement = this._textArray[i], text = richTextElement.text;
                                if (void 0 !== text) {
                                    if ("" === text) {
                                        if (richTextElement.style && richTextElement.style.isNewLine) {
                                            this._updateLineInfo();
                                            continue;
                                        }
                                        if (richTextElement.style && richTextElement.style.isImage && this.imageAtlas) {
                                            this._addRichTextImageElement(richTextElement);
                                            continue;
                                        }
                                    }
                                    for (var multilineTexts = text.split("\n"), j = 0; j < multilineTexts.length; ++j) {
                                        var labelString = multilineTexts[j];
                                        if ("" !== labelString) if (lastEmptyLine = !1, 0 < this.maxWidth) {
                                            var labelWidth = this._measureText(i, labelString);
                                            this._updateRichTextWithMaxWidth(labelString, labelWidth, i), 1 < multilineTexts.length && j < multilineTexts.length - 1 && this._updateLineInfo();
                                        } else labelSize = this._addLabelSegment(labelString, i).node.getContentSize(), 
                                        this._lineOffsetX += labelSize.width, this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX), 
                                        1 < multilineTexts.length && j < multilineTexts.length - 1 && this._updateLineInfo(); else {
                                            if (this._isLastComponentCR(text) && j === multilineTexts.length - 1) continue;
                                            this._updateLineInfo(), lastEmptyLine = !0;
                                        }
                                    }
                                }
                            }
                            lastEmptyLine || this._linesWidth.push(this._lineOffsetX), 0 < this.maxWidth && (this._labelWidth = this.maxWidth), 
                            this._labelHeight = this._lineCount * this.lineHeight, this.node.setContentSize(this._labelWidth, this._labelHeight), 
                            this._updateRichTextPosition(), this._layoutDirty = !1;
                        }
                    }
                }, {
                    key: "_getFirstWordLen",
                    value: function _getFirstWordLen(text, startIndex, textLen) {
                        var character = text.charAt(startIndex);
                        if (isUnicodeCJK(character) || isUnicodeSpace(character)) return 1;
                        for (var len = 1, index = startIndex + 1; index < textLen && (!isUnicodeSpace(character = text.charAt(index)) && !isUnicodeCJK(character)); ++index) len++;
                        return len;
                    }
                }, {
                    key: "_updateRichTextPosition",
                    value: function _updateRichTextPosition() {
                        var nextTokenX = 0, nextLineIndex = 1, totalLineCount = this._lineCount, _iterator3 = this._labelSegments, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i3 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i3++];
                            } else {
                                if ((_i3 = _iterator3.next()).done) break;
                                _ref3 = _i3.value;
                            }
                            var label = _ref3, lineCount = label.lineCount;
                            nextLineIndex < lineCount && (nextTokenX = 0, nextLineIndex = lineCount);
                            var lineOffsetX = 0;
                            switch (this.horizontalAlign) {
                              case HorizontalTextAlignment.LEFT:
                                lineOffsetX = -this._labelWidth / 2;
                                break;

                              case HorizontalTextAlignment.CENTER:
                                lineOffsetX = -this._linesWidth[lineCount - 1] / 2;
                                break;

                              case HorizontalTextAlignment.RIGHT:
                                lineOffsetX = this._labelWidth / 2 - this._linesWidth[lineCount - 1];
                            }
                            var labelSize = label.node.getContentSize(), pos = label.node.getPosition();
                            label.node.setPosition(nextTokenX + lineOffsetX, this.lineHeight * (totalLineCount - lineCount) - this._labelHeight / 2, pos.z), 
                            lineCount === nextLineIndex && (nextTokenX += labelSize.width);
                        }
                    }
                }, {
                    key: "_convertLiteralColorValue",
                    value: function _convertLiteralColorValue(color) {
                        var colorValue = color.toUpperCase();
                        return Color[colorValue] ? Color[colorValue] : new Color().fromHEX(color);
                    }
                }, {
                    key: "_applyTextAttribute",
                    value: function _applyTextAttribute(labelSeg) {
                        var labelComponent = labelSeg.node.getComponent(LabelComponent);
                        if (labelComponent) {
                            var textStyle, index = labelSeg.styleIndex;
                            labelComponent.lineHeight = this.lineHeight, labelComponent.horizontalAlign = HorizontalTextAlignment.LEFT, 
                            labelComponent.verticalAlign = VerticalTextAlignment.CENTER, this._textArray[index] && (textStyle = this._textArray[index].style);
                            var labelComp = labelSeg.node.getComponent(LabelComponent);
                            if (labelComp && (textStyle && textStyle.color ? labelComp.color = this._convertLiteralColorValue(textStyle.color) : labelComp.color = this._convertLiteralColorValue("white")), 
                            labelComponent.isBold = !(!textStyle || !textStyle.bold), labelComponent.isItalic = !(!textStyle || !textStyle.italic), 
                            labelComponent.isUnderline = !(!textStyle || !textStyle.underline), textStyle && textStyle.outline) {
                                var labelOutlineComponent = labelSeg.node.getComponent(LabelOutlineComponent);
                                (labelOutlineComponent = labelOutlineComponent || labelSeg.node.addComponent(LabelOutlineComponent)).color = this._convertLiteralColorValue(textStyle.outline.color), 
                                labelOutlineComponent.width = textStyle.outline.width;
                            }
                            if (textStyle && textStyle.size ? labelComponent.fontSize = textStyle.size : labelComponent.fontSize = this._fontSize, 
                            labelComponent.updateRenderData(!0), textStyle && textStyle.event) {
                                var c = "click";
                                textStyle.event[c] && (labelSeg.clickHandler = textStyle.event[c]);
                            }
                        }
                    }
                } ]), RichTextComponent;
            }(), _class3$q.HorizontalAlign = HorizontalTextAlignment, _class3$q.VerticalAlign = VerticalTextAlignment, 
            _applyDecoratedDescriptor((_class2$T = _temp$_).prototype, "string", [ _dec4$n ], Object.getOwnPropertyDescriptor(_class2$T.prototype, "string"), _class2$T.prototype), 
            _applyDecoratedDescriptor(_class2$T.prototype, "horizontalAlign", [ _dec5$m ], Object.getOwnPropertyDescriptor(_class2$T.prototype, "horizontalAlign"), _class2$T.prototype), 
            _applyDecoratedDescriptor(_class2$T.prototype, "fontSize", [ property ], Object.getOwnPropertyDescriptor(_class2$T.prototype, "fontSize"), _class2$T.prototype), 
            _applyDecoratedDescriptor(_class2$T.prototype, "font", [ _dec6$j ], Object.getOwnPropertyDescriptor(_class2$T.prototype, "font"), _class2$T.prototype), 
            _applyDecoratedDescriptor(_class2$T.prototype, "maxWidth", [ property ], Object.getOwnPropertyDescriptor(_class2$T.prototype, "maxWidth"), _class2$T.prototype), 
            _applyDecoratedDescriptor(_class2$T.prototype, "lineHeight", [ property ], Object.getOwnPropertyDescriptor(_class2$T.prototype, "lineHeight"), _class2$T.prototype), 
            _applyDecoratedDescriptor(_class2$T.prototype, "imageAtlas", [ _dec7$e ], Object.getOwnPropertyDescriptor(_class2$T.prototype, "imageAtlas"), _class2$T.prototype), 
            _applyDecoratedDescriptor(_class2$T.prototype, "handleTouchEvent", [ property ], Object.getOwnPropertyDescriptor(_class2$T.prototype, "handleTouchEvent"), _class2$T.prototype), 
            _descriptor$Q = _applyDecoratedDescriptor(_class2$T.prototype, "_lineHeight", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 40;
                }
            }), _descriptor2$G = _applyDecoratedDescriptor(_class2$T.prototype, "_string", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return "<color=#00ff00>Rich</c><color=#0fffff>Text</color>";
                }
            }), _descriptor3$t = _applyDecoratedDescriptor(_class2$T.prototype, "_horizontalAlign", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return HorizontalTextAlignment.LEFT;
                }
            }), _descriptor4$o = _applyDecoratedDescriptor(_class2$T.prototype, "_fontSize", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 40;
                }
            }), _descriptor5$k = _applyDecoratedDescriptor(_class2$T.prototype, "_maxWidth", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor6$c = _applyDecoratedDescriptor(_class2$T.prototype, "_font", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor7$a = _applyDecoratedDescriptor(_class2$T.prototype, "_imageAtlas", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor8$a = _applyDecoratedDescriptor(_class2$T.prototype, "_handleTouchEvent", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _class$14 = _class2$T)) || _class$14) || _class$14) || _class$14) || _class$14));
            cc.RichTextComponent = RichTextComponent;
            var Direction, ZERO = new Vec3(), _tempPos_1 = new Vec3(), _tempPos_2 = new Vec3(), defaultAnchor = new Vec2(), _tempColor = new Color();
            !function(Direction) {
                Direction[Direction.HORIZONTAL = 0] = "HORIZONTAL", Direction[Direction.VERTICAL = 1] = "VERTICAL";
            }(Direction = Direction || {}), ccenum(Direction);
            var _class$16, ScrollBarComponent = exports("ScrollBarComponent", (_dec$13 = ccclass("cc.ScrollBarComponent"), 
            _dec2$H = executionOrder(110), _dec3$s = menu("UI/ScrollBar"), _dec4$o = property({
                type: SpriteComponent
            }), _dec5$n = property({
                type: Direction
            }), _dec$13(_class$15 = _dec2$H(_class$15 = _dec3$s((_temp$$ = _class3$r = function() {
                function ScrollBarComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, ScrollBarComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ScrollBarComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_scrollView", _descriptor$R, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_handle", _descriptor2$H, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_direction", _descriptor3$u, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_enableAutoHide", _descriptor4$p, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_autoHideTime", _descriptor5$l, _assertThisInitialized(_this)), 
                    _this._touching = !1, _this._opacity = 255, _this._autoHideRemainingTime = 0, _this;
                }
                return _inherits(ScrollBarComponent, Component), _createClass(ScrollBarComponent, [ {
                    key: "hide",
                    value: function hide() {
                        this._autoHideRemainingTime = 0, this._setOpacity(0);
                    }
                }, {
                    key: "show",
                    value: function show() {
                        this._autoHideRemainingTime = this._autoHideTime, this._setOpacity(this._opacity);
                    }
                }, {
                    key: "onScroll",
                    value: function onScroll(outOfBoundary) {
                        if (this._scrollView) {
                            var content = this._scrollView.content;
                            if (content) {
                                var contentSize = content.getContentSize(), scrollViewSize = this._scrollView.node.getContentSize(), barSize = this.node.getContentSize();
                                if (!this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                                    this._enableAutoHide && (this._autoHideRemainingTime = this._autoHideTime, this._setOpacity(this._opacity));
                                    var contentMeasure = 0, scrollViewMeasure = 0, outOfBoundaryValue = 0, contentPosition = 0, handleNodeMeasure = 0;
                                    this._direction === Direction.HORIZONTAL ? (contentMeasure = contentSize.width, 
                                    scrollViewMeasure = scrollViewSize.width, handleNodeMeasure = barSize.width, outOfBoundaryValue = outOfBoundary.x, 
                                    contentPosition = -this._convertToScrollViewSpace(content).x) : this._direction === Direction.VERTICAL && (contentMeasure = contentSize.height, 
                                    scrollViewMeasure = scrollViewSize.height, handleNodeMeasure = barSize.height, outOfBoundaryValue = outOfBoundary.y, 
                                    contentPosition = -this._convertToScrollViewSpace(content).y);
                                    var length = this._calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundaryValue), position = this._calculatePosition(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundaryValue, length);
                                    this._updateLength(length), this._updateHanlderPosition(position);
                                }
                            }
                        }
                    }
                }, {
                    key: "setScrollView",
                    value: function setScrollView(scrollView) {
                        this._scrollView = scrollView;
                    }
                }, {
                    key: "onTouchBegan",
                    value: function onTouchBegan() {
                        this._enableAutoHide && (this._touching = !0);
                    }
                }, {
                    key: "onTouchEnded",
                    value: function onTouchEnded() {
                        if (this._enableAutoHide && (this._touching = !1, !(this._autoHideTime <= 0))) {
                            if (this._scrollView) {
                                var content = this._scrollView.content;
                                if (content) {
                                    var contentSize = content.getContentSize(), scrollViewSize = this._scrollView.node.getContentSize();
                                    if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) return;
                                }
                            }
                            this._autoHideRemainingTime = this._autoHideTime;
                        }
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        var renderComp = this.node.getComponent(SpriteComponent);
                        renderComp && (this._opacity = renderComp.color.a);
                    }
                }, {
                    key: "start",
                    value: function start() {
                        this._enableAutoHide && this._setOpacity(0);
                    }
                }, {
                    key: "update",
                    value: function update(dt) {
                        this._processAutoHide(dt);
                    }
                }, {
                    key: "_convertToScrollViewSpace",
                    value: function _convertToScrollViewSpace(content) {
                        if (!this._scrollView) return ZERO;
                        var ap = content.getAnchorPoint(), contentSize = content.getContentSize(), scrollViewSpacePos = new Vec3(-ap.x * contentSize.width, -ap.y * contentSize.height, 0);
                        return content.uiTransfromComp.convertToWorldSpaceAR(scrollViewSpacePos, scrollViewSpacePos), 
                        ap = this._scrollView.node.getAnchorPoint(), contentSize = this._scrollView.node.getContentSize(), 
                        scrollViewSpacePos.x += ap.x * contentSize.width, scrollViewSpacePos.y += ap.y * contentSize.height, 
                        this._scrollView.node.uiTransfromComp.convertToNodeSpaceAR(scrollViewSpacePos, scrollViewSpacePos), 
                        scrollViewSpacePos;
                    }
                }, {
                    key: "_setOpacity",
                    value: function _setOpacity(opacity) {
                        if (this._handle) {
                            var renderComp = this.node.getComponent(SpriteComponent);
                            renderComp && (_tempColor.set(renderComp.color), _tempColor.a = opacity, renderComp.color = _tempColor), 
                            (renderComp = this._handle.getComponent(SpriteComponent)) && (_tempColor.set(renderComp.color), 
                            _tempColor.a = opacity, renderComp.color = _tempColor);
                        }
                    }
                }, {
                    key: "_updateHanlderPosition",
                    value: function _updateHanlderPosition(position) {
                        if (this._handle) {
                            var oldPosition = this._fixupHandlerPosition();
                            this._handle.node.setPosition(position.x + oldPosition.x, position.y + oldPosition.y, oldPosition.z);
                        }
                    }
                }, {
                    key: "_fixupHandlerPosition",
                    value: function _fixupHandlerPosition() {
                        var barSize = this.node.getContentSize(), barAnchor = this.node.getAnchorPoint(), handleSize = this.handle.node.getContentSize(), handleParent = this.handle.node.parent;
                        Vec3.set(_tempPos_1, -barSize.width * barAnchor.x, -barSize.height * barAnchor.y, 0);
                        var leftBottomWorldPosition = this.node.uiTransfromComp.convertToWorldSpaceAR(_tempPos_1, _tempPos_2), fixupPosition = new Vec3();
                        return handleParent.uiTransfromComp.convertToNodeSpaceAR(leftBottomWorldPosition, fixupPosition), 
                        this.direction === Direction.HORIZONTAL ? fixupPosition = new Vec3(fixupPosition.x, fixupPosition.y + (barSize.height - handleSize.height) / 2, 0) : this.direction === Direction.VERTICAL && (fixupPosition = new Vec3(fixupPosition.x + (barSize.width - handleSize.width) / 2, fixupPosition.y, 0)), 
                        this.handle.node.setPosition(fixupPosition), fixupPosition;
                    }
                }, {
                    key: "_conditionalDisableScrollBar",
                    value: function _conditionalDisableScrollBar(contentSize, scrollViewSize) {
                        return contentSize.width <= scrollViewSize.width && this._direction === Direction.HORIZONTAL || contentSize.height <= scrollViewSize.height && this._direction === Direction.VERTICAL;
                    }
                }, {
                    key: "_calculateLength",
                    value: function _calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundary) {
                        var denominatorValue = contentMeasure;
                        return outOfBoundary && (denominatorValue += 20 * (0 < outOfBoundary ? outOfBoundary : -outOfBoundary)), 
                        handleNodeMeasure * (scrollViewMeasure / denominatorValue);
                    }
                }, {
                    key: "_calculatePosition",
                    value: function _calculatePosition(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundary, actualLenth) {
                        var denominatorValue = contentMeasure - scrollViewMeasure;
                        outOfBoundary && (denominatorValue += Math.abs(outOfBoundary));
                        var positionRatio = 0;
                        denominatorValue && (positionRatio = clamp01(positionRatio = contentPosition / denominatorValue));
                        var position = (handleNodeMeasure - actualLenth) * positionRatio;
                        return this._direction === Direction.VERTICAL ? new Vec3(0, position, 0) : new Vec3(position, 0, 0);
                    }
                }, {
                    key: "_updateLength",
                    value: function _updateLength(length) {
                        if (this._handle) {
                            var handleNode = this._handle.node, handleNodeSize = handleNode.getContentSize(), anchor = handleNode.getAnchorPoint();
                            anchor.x === defaultAnchor.x && anchor.y === defaultAnchor.y || handleNode.setAnchorPoint(defaultAnchor), 
                            this._direction === Direction.HORIZONTAL ? handleNode.setContentSize(length, handleNodeSize.height) : handleNode.setContentSize(handleNodeSize.width, length);
                        }
                    }
                }, {
                    key: "_processAutoHide",
                    value: function _processAutoHide(deltaTime) {
                        if (this._enableAutoHide && !(this._autoHideRemainingTime <= 0) && !this._touching && (this._autoHideRemainingTime -= deltaTime, 
                        this._autoHideRemainingTime <= this._autoHideTime)) {
                            this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
                            var opacity = this._opacity * (this._autoHideRemainingTime / this._autoHideTime);
                            this._setOpacity(opacity);
                        }
                    }
                }, {
                    key: "handle",
                    get: function get() {
                        return this._handle;
                    },
                    set: function set(value) {
                        this._handle !== value && (this._handle = value, this.onScroll(new Vec3(0, 0, 0)));
                    }
                }, {
                    key: "direction",
                    get: function get() {
                        return this._direction;
                    },
                    set: function set(value) {
                        this._direction !== value && (this._direction = value, this.onScroll(new Vec3()));
                    }
                }, {
                    key: "enableAutoHide",
                    get: function get() {
                        return this._enableAutoHide;
                    },
                    set: function set(value) {
                        this._enableAutoHide !== value && (this._enableAutoHide = value, this._enableAutoHide && this._setOpacity(0));
                    }
                }, {
                    key: "autoHideTime",
                    get: function get() {
                        return this._autoHideTime;
                    },
                    set: function set(value) {
                        this._autoHideTime !== value && (this._autoHideTime = value);
                    }
                } ]), ScrollBarComponent;
            }(), _class3$r.Direction = Direction, _applyDecoratedDescriptor((_class2$U = _temp$$).prototype, "handle", [ _dec4$o ], Object.getOwnPropertyDescriptor(_class2$U.prototype, "handle"), _class2$U.prototype), 
            _applyDecoratedDescriptor(_class2$U.prototype, "direction", [ _dec5$n ], Object.getOwnPropertyDescriptor(_class2$U.prototype, "direction"), _class2$U.prototype), 
            _applyDecoratedDescriptor(_class2$U.prototype, "enableAutoHide", [ property ], Object.getOwnPropertyDescriptor(_class2$U.prototype, "enableAutoHide"), _class2$U.prototype), 
            _applyDecoratedDescriptor(_class2$U.prototype, "autoHideTime", [ property ], Object.getOwnPropertyDescriptor(_class2$U.prototype, "autoHideTime"), _class2$U.prototype), 
            _descriptor$R = _applyDecoratedDescriptor(_class2$U.prototype, "_scrollView", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor2$H = _applyDecoratedDescriptor(_class2$U.prototype, "_handle", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor3$u = _applyDecoratedDescriptor(_class2$U.prototype, "_direction", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Direction.HORIZONTAL;
                }
            }), _descriptor4$p = _applyDecoratedDescriptor(_class2$U.prototype, "_enableAutoHide", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor5$l = _applyDecoratedDescriptor(_class2$U.prototype, "_autoHideTime", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _class$15 = _class2$U)) || _class$15) || _class$15) || _class$15));
            cc.ScrollBarComponent = ScrollBarComponent;
            var _dec$15, _dec2$J, _dec3$t, _dec4$p, _dec5$o, _dec6$k, _dec7$f, _dec8$8, _dec9$7, _class$17, _class2$V, _descriptor$S, _descriptor2$I, _descriptor3$v, _descriptor4$q, _descriptor5$m, _descriptor6$d, _descriptor7$b, _descriptor8$b, _descriptor9$9, _descriptor10$7, _descriptor11$6, _class3$s, _temp$10, ViewGroupComponent = exports("ViewGroupComponent", ccclass("cc.ViewGroupComponent")(_class$16 = executionOrder(110)(_class$16 = function() {
                function ViewGroupComponent() {
                    return _classCallCheck(this, ViewGroupComponent), _possibleConstructorReturn(this, _getPrototypeOf(ViewGroupComponent).apply(this, arguments));
                }
                return _inherits(ViewGroupComponent, Component), ViewGroupComponent;
            }()) || _class$16) || _class$16);
            cc.ViewGroupComponent = ViewGroupComponent;
            function getTimeInMilliseconds() {
                return new Date().getMilliseconds();
            }
            var ScrollViewEventType, NodeEvent$1 = SystemEventType, ZERO$1 = new Vec3(), _tempPos$1 = new Vec3();
            !function(ScrollViewEventType) {
                ScrollViewEventType[ScrollViewEventType.SCROLL_TO_TOP = 0] = "SCROLL_TO_TOP", ScrollViewEventType[ScrollViewEventType.SCROLL_TO_BOTTOM = 1] = "SCROLL_TO_BOTTOM", 
                ScrollViewEventType[ScrollViewEventType.SCROLL_TO_LEFT = 2] = "SCROLL_TO_LEFT", 
                ScrollViewEventType[ScrollViewEventType.SCROLL_TO_RIGHT = 3] = "SCROLL_TO_RIGHT", 
                ScrollViewEventType[ScrollViewEventType.SCROLLING = 4] = "SCROLLING", ScrollViewEventType[ScrollViewEventType.BOUNCE_TOP = 5] = "BOUNCE_TOP", 
                ScrollViewEventType[ScrollViewEventType.BOUNCE_BOTTOM = 6] = "BOUNCE_BOTTOM", ScrollViewEventType[ScrollViewEventType.BOUNCE_LEFT = 7] = "BOUNCE_LEFT", 
                ScrollViewEventType[ScrollViewEventType.BOUNCE_RIGHT = 8] = "BOUNCE_RIGHT", ScrollViewEventType[ScrollViewEventType.SCROLL_ENDED = 9] = "SCROLL_ENDED", 
                ScrollViewEventType[ScrollViewEventType.TOUCH_UP = 10] = "TOUCH_UP", ScrollViewEventType[ScrollViewEventType.AUTOSCROLL_ENDED_WITH_THRESHOLD = 11] = "AUTOSCROLL_ENDED_WITH_THRESHOLD", 
                ScrollViewEventType[ScrollViewEventType.SCROLL_BEGAN = 12] = "SCROLL_BEGAN";
            }(ScrollViewEventType = ScrollViewEventType || {}), ccenum(ScrollViewEventType);
            var _dec$16, _dec2$K, _dec3$u, _dec4$q, _dec5$p, _dec6$l, _dec7$g, _class$18, _class2$W, _descriptor$T, _descriptor2$J, _descriptor3$w, _descriptor4$r, _class3$t, _temp$11, eventMap = {
                "scroll-to-top": ScrollViewEventType.SCROLL_TO_TOP,
                "scroll-to-bottom": ScrollViewEventType.SCROLL_TO_BOTTOM,
                "scroll-to-left": ScrollViewEventType.SCROLL_TO_LEFT,
                "scroll-to-right": ScrollViewEventType.SCROLL_TO_RIGHT,
                scrolling: ScrollViewEventType.SCROLLING,
                "bounce-bottom": ScrollViewEventType.BOUNCE_BOTTOM,
                "bounce-left": ScrollViewEventType.BOUNCE_LEFT,
                "bounce-right": ScrollViewEventType.BOUNCE_RIGHT,
                "bounce-top": ScrollViewEventType.BOUNCE_TOP,
                "scroll-ended": ScrollViewEventType.SCROLL_ENDED,
                "touch-up": ScrollViewEventType.TOUCH_UP,
                "scroll-ended-with-threshold": ScrollViewEventType.AUTOSCROLL_ENDED_WITH_THRESHOLD,
                "scroll-began": ScrollViewEventType.SCROLL_BEGAN
            }, ScrollViewComponent = exports("ScrollViewComponent", (_dec$15 = ccclass("cc.ScrollViewComponent"), 
            _dec2$J = executionOrder(110), _dec3$t = menu("UI/ScrollView"), _dec4$p = property({
                type: Node$1
            }), _dec5$o = property({
                type: ScrollBarComponent
            }), _dec6$k = property({
                type: ScrollBarComponent
            }), _dec7$f = property({
                range: [ 0, 1, .1 ]
            }), _dec8$8 = property({
                range: [ 0, 10 ]
            }), _dec9$7 = property({
                type: [ EventHandler ]
            }), _dec$15(_class$17 = _dec2$J(_class$17 = _dec3$t((_temp$10 = _class3$s = function() {
                function ScrollViewComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, ScrollViewComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ScrollViewComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "horizontal", _descriptor$S, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "vertical", _descriptor2$I, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "inertia", _descriptor3$v, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "brake", _descriptor4$q, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "elastic", _descriptor5$m, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "bounceDuration", _descriptor6$d, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "scrollEvents", _descriptor7$b, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "cancelInnerEvents", _descriptor8$b, _assertThisInitialized(_this)), 
                    _this._autoScrolling = !1, _this._scrolling = !1, _initializerDefineProperty(_this, "_content", _descriptor9$9, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_horizontalScrollBar", _descriptor10$7, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_verticalScrollBar", _descriptor11$6, _assertThisInitialized(_this)), 
                    _this._topBoundary = 0, _this._bottomBoundary = 0, _this._leftBoundary = 0, _this._rightBoundary = 0, 
                    _this._touchMoveDisplacements = [], _this._touchMoveTimeDeltas = [], _this._touchMovePreviousTimestamp = 0, 
                    _this._touchMoved = !1, _this._autoScrollAttenuate = !1, _this._autoScrollStartPosition = new Vec3(), 
                    _this._autoScrollTargetDelta = new Vec3(), _this._autoScrollTotalTime = 0, _this._autoScrollAccumulatedTime = 0, 
                    _this._autoScrollCurrentlyOutOfBoundary = !1, _this._autoScrollBraking = !1, _this._autoScrollBrakingStartPosition = new Vec3(), 
                    _this._outOfBoundaryAmount = new Vec3(), _this._outOfBoundaryAmountDirty = !0, _this._stopMouseWheel = !1, 
                    _this._mouseWheelEventElapsedTime = 0, _this._isScrollEndedWithThresholdEventFired = !1, 
                    _this._scrollEventEmitMask = 0, _this._isBouncing = !1, _this._contentPos = new Vec3(), 
                    _this._deltaPos = new Vec3(), _this;
                }
                return _inherits(ScrollViewComponent, ViewGroupComponent), _createClass(ScrollViewComponent, [ {
                    key: "scrollToBottom",
                    value: function scrollToBottom(timeInSecond, attenuated) {
                        var moveDelta = this._calculateMovePercentDelta({
                            anchor: new Vec2(0, 0),
                            applyToHorizontal: !1,
                            applyToVertical: !0
                        });
                        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta, !0);
                    }
                }, {
                    key: "scrollToTop",
                    value: function scrollToTop(timeInSecond, attenuated) {
                        var moveDelta = this._calculateMovePercentDelta({
                            anchor: new Vec2(0, 1),
                            applyToHorizontal: !1,
                            applyToVertical: !0
                        });
                        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
                    }
                }, {
                    key: "scrollToLeft",
                    value: function scrollToLeft(timeInSecond, attenuated) {
                        var moveDelta = this._calculateMovePercentDelta({
                            anchor: new Vec2(0, 0),
                            applyToHorizontal: !0,
                            applyToVertical: !1
                        });
                        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
                    }
                }, {
                    key: "scrollToRight",
                    value: function scrollToRight(timeInSecond, attenuated) {
                        var moveDelta = this._calculateMovePercentDelta({
                            anchor: new Vec2(1, 0),
                            applyToHorizontal: !0,
                            applyToVertical: !1
                        });
                        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
                    }
                }, {
                    key: "scrollToTopLeft",
                    value: function scrollToTopLeft(timeInSecond, attenuated) {
                        var moveDelta = this._calculateMovePercentDelta({
                            anchor: new Vec2(0, 1),
                            applyToHorizontal: !0,
                            applyToVertical: !0
                        });
                        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
                    }
                }, {
                    key: "scrollToTopRight",
                    value: function scrollToTopRight(timeInSecond, attenuated) {
                        var moveDelta = this._calculateMovePercentDelta({
                            anchor: new Vec2(1, 1),
                            applyToHorizontal: !0,
                            applyToVertical: !0
                        });
                        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
                    }
                }, {
                    key: "scrollToBottomLeft",
                    value: function scrollToBottomLeft(timeInSecond, attenuated) {
                        var moveDelta = this._calculateMovePercentDelta({
                            anchor: new Vec2(0, 0),
                            applyToHorizontal: !0,
                            applyToVertical: !0
                        });
                        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
                    }
                }, {
                    key: "scrollToBottomRight",
                    value: function scrollToBottomRight(timeInSecond, attenuated) {
                        var moveDelta = this._calculateMovePercentDelta({
                            anchor: new Vec2(1, 0),
                            applyToHorizontal: !0,
                            applyToVertical: !0
                        });
                        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
                    }
                }, {
                    key: "scrollToOffset",
                    value: function scrollToOffset(offset, timeInSecond, attenuated) {
                        var maxScrollOffset = this.getMaxScrollOffset(), anchor = new Vec2(0, 0);
                        0 === maxScrollOffset.x ? anchor.x = 0 : anchor.x = offset.x / maxScrollOffset.x, 
                        0 === maxScrollOffset.y ? anchor.y = 1 : anchor.y = (maxScrollOffset.y - offset.y) / maxScrollOffset.y, 
                        this.scrollTo(anchor, timeInSecond, attenuated);
                    }
                }, {
                    key: "getScrollOffset",
                    value: function getScrollOffset() {
                        var topDelta = this._getContentTopBoundary() - this._topBoundary, leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
                        return new Vec3(leftDeta, topDelta, 0);
                    }
                }, {
                    key: "getMaxScrollOffset",
                    value: function getMaxScrollOffset() {
                        var scrollSize = this.node.getContentSize(), contentSize = this._content.getContentSize(), horizontalMaximizeOffset = contentSize.width - scrollSize.width, verticalMaximizeOffset = contentSize.height - scrollSize.height;
                        return new Vec3(horizontalMaximizeOffset = 0 <= horizontalMaximizeOffset ? horizontalMaximizeOffset : 0, verticalMaximizeOffset = 0 <= verticalMaximizeOffset ? verticalMaximizeOffset : 0, 0);
                    }
                }, {
                    key: "scrollToPercentHorizontal",
                    value: function scrollToPercentHorizontal(percent, timeInSecond, attenuated) {
                        var moveDelta = this._calculateMovePercentDelta({
                            anchor: new Vec2(percent, 0),
                            applyToHorizontal: !0,
                            applyToVertical: !1
                        });
                        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
                    }
                }, {
                    key: "scrollTo",
                    value: function scrollTo(anchor, timeInSecond, attenuated) {
                        var moveDelta = this._calculateMovePercentDelta({
                            anchor: new Vec2(anchor),
                            applyToHorizontal: !0,
                            applyToVertical: !0
                        });
                        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, attenuated) : this._moveContent(moveDelta);
                    }
                }, {
                    key: "scrollToPercentVertical",
                    value: function scrollToPercentVertical(percent, timeInSecond, attenuated) {
                        var moveDelta = this._calculateMovePercentDelta({
                            anchor: new Vec2(0, percent),
                            applyToHorizontal: !1,
                            applyToVertical: !0
                        });
                        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, attenuated) : this._moveContent(moveDelta);
                    }
                }, {
                    key: "stopAutoScroll",
                    value: function stopAutoScroll() {
                        this._autoScrolling = !1, this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
                    }
                }, {
                    key: "setContentPosition",
                    value: function setContentPosition(position) {
                        position.equals(this.getContentPosition(), 1e-4) || (this._content.setPosition(position), 
                        this._outOfBoundaryAmountDirty = !0);
                    }
                }, {
                    key: "getContentPosition",
                    value: function getContentPosition() {
                        return this._content ? (this._content.getPosition(this._contentPos), this._contentPos) : ZERO$1;
                    }
                }, {
                    key: "isScrolling",
                    value: function isScrolling() {
                        return this._scrolling;
                    }
                }, {
                    key: "isAutoScrolling",
                    value: function isAutoScrolling() {
                        return this._autoScrolling;
                    }
                }, {
                    key: "getScrollEndedEventTiming",
                    value: function getScrollEndedEventTiming() {
                        return 1e-4;
                    }
                }, {
                    key: "start",
                    value: function start() {
                        this._calculateBoundary(), this._content && director.once(Director.EVENT_BEFORE_DRAW, this._adjustContentOutOfBoundary, this);
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        this._registerEvent(), this.content && (this.content.on(NodeEvent$1.SIZE_CHANGED, this._calculateBoundary, this), 
                        this.content.on(NodeEvent$1.SCALE_PART, this._calculateBoundary, this), this.view && (this.view.on(NodeEvent$1.POSITION_PART, this._calculateBoundary, this), 
                        this.view.on(NodeEvent$1.SCALE_PART, this._calculateBoundary, this), this.view.on(NodeEvent$1.SIZE_CHANGED, this._calculateBoundary, this))), 
                        this._showScrollbar();
                    }
                }, {
                    key: "update",
                    value: function update(dt) {
                        this._autoScrolling && this._processAutoScrolling(dt);
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this._unregisterEvent(), this.content && (this.content.off(NodeEvent$1.SIZE_CHANGED, this._calculateBoundary, this), 
                        this.content.off(NodeEvent$1.SCALE_PART, this._calculateBoundary, this), this.view && (this.view.off(NodeEvent$1.POSITION_PART, this._calculateBoundary, this), 
                        this.view.off(NodeEvent$1.SCALE_PART, this._calculateBoundary, this), this.view.off(NodeEvent$1.SIZE_CHANGED, this._calculateBoundary, this))), 
                        this._hideScrollbar(), this.stopAutoScroll();
                    }
                }, {
                    key: "_registerEvent",
                    value: function _registerEvent() {
                        this.node.on(NodeEvent$1.TOUCH_START, this._onTouchBegan, this, !0), this.node.on(NodeEvent$1.TOUCH_MOVE, this._onTouchMoved, this, !0), 
                        this.node.on(NodeEvent$1.TOUCH_END, this._onTouchEnded, this, !0), this.node.on(NodeEvent$1.TOUCH_CANCEL, this._onTouchCancelled, this, !0), 
                        this.node.on(NodeEvent$1.MOUSE_WHEEL, this._onMouseWheel, this, !0);
                    }
                }, {
                    key: "_unregisterEvent",
                    value: function _unregisterEvent() {
                        this.node.off(NodeEvent$1.TOUCH_START, this._onTouchBegan, this, !0), this.node.off(NodeEvent$1.TOUCH_MOVE, this._onTouchMoved, this, !0), 
                        this.node.off(NodeEvent$1.TOUCH_END, this._onTouchEnded, this, !0), this.node.off(NodeEvent$1.TOUCH_CANCEL, this._onTouchCancelled, this, !0), 
                        this.node.off(NodeEvent$1.MOUSE_WHEEL, this._onMouseWheel, this, !0);
                    }
                }, {
                    key: "_onMouseWheel",
                    value: function _onMouseWheel(event, captureListeners) {
                        if (this.enabledInHierarchy && !this._hasNestedViewGroup(event, captureListeners)) {
                            var deltaMove = new Vec3();
                            this.vertical ? deltaMove = new Vec3(0, -.1 * event.getScrollY(), 0) : this.horizontal && (deltaMove = new Vec3(-.1 * event.getScrollY(), 0, 0)), 
                            this._mouseWheelEventElapsedTime = 0, this._processDeltaMove(deltaMove), this._stopMouseWheel || (this._handlePressLogic(), 
                            this.schedule(this._checkMouseWheel, 1 / 60, NaN, 0), this._stopMouseWheel = !0), 
                            this._stopPropagationIfTargetIsMe(event);
                        }
                    }
                }, {
                    key: "_onTouchBegan",
                    value: function _onTouchBegan(event, captureListeners) {
                        this.enabledInHierarchy && this._content && (this._hasNestedViewGroup(event, captureListeners) || (this._content && this._handlePressLogic(), 
                        this._touchMoved = !1, this._stopPropagationIfTargetIsMe(event)));
                    }
                }, {
                    key: "_onTouchMoved",
                    value: function _onTouchMoved(event, captureListeners) {
                        if (this.enabledInHierarchy && this._content && !this._hasNestedViewGroup(event, captureListeners) && event && event.touch) {
                            var touch = event.touch;
                            if (this._content && this._handleMoveLogic(touch), this.cancelInnerEvents) {
                                var deltaMove = new Vec2(touch.getUILocation());
                                if (deltaMove.subtract(touch.getUIStartLocation()), 7 < deltaMove.length() && !this._touchMoved && event.target !== this.node) {
                                    var cancelEvent = new EventTouch(event.getTouches(), event.bubbles);
                                    cancelEvent.type = NodeEvent$1.TOUCH_CANCEL, cancelEvent.touch = event.touch, cancelEvent.simulate = !0, 
                                    event.target.dispatchEvent(cancelEvent), this._touchMoved = !0;
                                }
                                this._stopPropagationIfTargetIsMe(event);
                            }
                        }
                    }
                }, {
                    key: "_onTouchEnded",
                    value: function _onTouchEnded(event, captureListeners) {
                        if (this.enabledInHierarchy && this._content && event && !this._hasNestedViewGroup(event, captureListeners)) {
                            this._dispatchEvent("touch-up");
                            var touch = event.touch;
                            this._content && this._handleReleaseLogic(touch), this._touchMoved ? event.propagationStopped = !0 : this._stopPropagationIfTargetIsMe(event);
                        }
                    }
                }, {
                    key: "_onTouchCancelled",
                    value: function _onTouchCancelled(event, captureListeners) {
                        if (this.enabledInHierarchy && this._content && !this._hasNestedViewGroup(event, captureListeners)) {
                            if (event && !event.simulate) {
                                var touch = event.touch;
                                this._content && this._handleReleaseLogic(touch);
                            }
                            this._stopPropagationIfTargetIsMe(event);
                        }
                    }
                }, {
                    key: "_calculateBoundary",
                    value: function _calculateBoundary() {
                        if (this.content) {
                            var layout = this.content.getComponent(LayoutComponent);
                            layout && layout.enabledInHierarchy && layout.updateLayout();
                            var viewSize = this.view.getContentSize(), anchorX = viewSize.width * this.view.anchorX, anchorY = viewSize.height * this.view.anchorY;
                            this._leftBoundary = -anchorX, this._bottomBoundary = -anchorY, this._rightBoundary = this._leftBoundary + viewSize.width, 
                            this._topBoundary = this._bottomBoundary + viewSize.height, this._moveContentToTopLeft(viewSize);
                        }
                    }
                }, {
                    key: "_hasNestedViewGroup",
                    value: function _hasNestedViewGroup(event, captureListeners) {
                        if (event && event.eventPhase === Event.CAPTURING_PHASE) {
                            if (captureListeners) {
                                var _iterator = captureListeners, _isArray = Array.isArray(_iterator), _i = 0;
                                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                    var _ref;
                                    if (_isArray) {
                                        if (_i >= _iterator.length) break;
                                        _ref = _iterator[_i++];
                                    } else {
                                        if ((_i = _iterator.next()).done) break;
                                        _ref = _i.value;
                                    }
                                    var item = _ref;
                                    if (this.node === item) return !(!event.target || !event.target.getComponent(ViewGroupComponent));
                                    if (item.getComponent(ViewGroupComponent)) return !0;
                                }
                            }
                            return !1;
                        }
                    }
                }, {
                    key: "_handleReleaseLogic",
                    value: function _handleReleaseLogic(touch) {
                        var delta = touch.getUIDelta();
                        Vec3.set(this._deltaPos, delta.x, delta.y, 0), this._gatherTouchMove(this._deltaPos), 
                        this._processInertiaScroll(), this._scrolling && (this._scrolling = !1, this._autoScrolling || this._dispatchEvent("scroll-ended"));
                    }
                }, {
                    key: "_startInertiaScroll",
                    value: function _startInertiaScroll(touchMoveVelocity) {
                        var inertiaTotalMovement = new Vec3(touchMoveVelocity);
                        inertiaTotalMovement.multiplyScalar(.7), this._startAttenuatingAutoScroll(inertiaTotalMovement, touchMoveVelocity);
                    }
                }, {
                    key: "_calculateAttenuatedFactor",
                    value: function _calculateAttenuatedFactor(distance) {
                        return this.brake <= 0 ? 1 - this.brake : (1 - this.brake) * (1 / (1 + 14e-6 * distance + distance * distance * 8e-9));
                    }
                }, {
                    key: "_startAttenuatingAutoScroll",
                    value: function _startAttenuatingAutoScroll(deltaMove, initialVelocity) {
                        var time = this._calculateAutoScrollTimeByInitalSpeed(initialVelocity.length()), targetDelta = new Vec3(deltaMove);
                        targetDelta.normalize();
                        var contentSize = this._content.getContentSize(), scrollviewSize = this.node.getContentSize(), totalMoveWidth = contentSize.width - scrollviewSize.width, totalMoveHeight = contentSize.height - scrollviewSize.height, attenuatedFactorX = this._calculateAttenuatedFactor(totalMoveWidth), attenuatedFactorY = this._calculateAttenuatedFactor(totalMoveHeight);
                        targetDelta.x = targetDelta.x * totalMoveWidth * (1 - this.brake) * attenuatedFactorX, 
                        targetDelta.y = targetDelta.y * totalMoveHeight * attenuatedFactorY * (1 - this.brake), 
                        targetDelta.z = 0;
                        var originalMoveLength = deltaMove.length(), factor = targetDelta.length() / originalMoveLength;
                        if (targetDelta.add(deltaMove), 0 < this.brake && 7 < factor) {
                            factor = Math.sqrt(factor);
                            var a = new Vec3(deltaMove);
                            a.multiplyScalar(factor), targetDelta.set(a), targetDelta.add(deltaMove);
                        }
                        0 < this.brake && 3 < factor && (time *= factor = 3), 0 === this.brake && 1 < factor && (time *= factor), 
                        this._startAutoScroll(targetDelta, time, !0);
                    }
                }, {
                    key: "_calculateAutoScrollTimeByInitalSpeed",
                    value: function _calculateAutoScrollTimeByInitalSpeed(initalSpeed) {
                        return Math.sqrt(Math.sqrt(initalSpeed / 5));
                    }
                }, {
                    key: "_startAutoScroll",
                    value: function _startAutoScroll(deltaMove, timeInSecond, argument_2) {
                        var attenuated = 2 < arguments.length && void 0 !== argument_2 && argument_2, adjustedDeltaMove = this._flattenVectorByDirection(deltaMove);
                        this._autoScrolling = !0, this._autoScrollTargetDelta = adjustedDeltaMove, this._autoScrollAttenuate = attenuated, 
                        Vec3.copy(this._autoScrollStartPosition, this.getContentPosition()), this._autoScrollTotalTime = timeInSecond, 
                        this._autoScrollAccumulatedTime = 0, this._autoScrollBraking = !1, this._isScrollEndedWithThresholdEventFired = !1, 
                        this._autoScrollBrakingStartPosition = new Vec3(), this._getHowMuchOutOfBoundary().equals(ZERO$1, 1e-4) || (this._autoScrollCurrentlyOutOfBoundary = !0);
                    }
                }, {
                    key: "_calculateTouchMoveVelocity",
                    value: function _calculateTouchMoveVelocity() {
                        var totalTime = 0;
                        if ((totalTime = this._touchMoveTimeDeltas.reduce(function(a, b) {
                            return a + b;
                        }, totalTime)) <= 0 || .5 <= totalTime) return new Vec3();
                        var totalMovement = new Vec3();
                        return totalMovement = this._touchMoveDisplacements.reduce(function(a, b) {
                            return a.add(b), a;
                        }, totalMovement), new Vec3(totalMovement.x * (1 - this.brake) / totalTime, totalMovement.y * (1 - this.brake) / totalTime, 0);
                    }
                }, {
                    key: "_flattenVectorByDirection",
                    value: function _flattenVectorByDirection(vector) {
                        var result = vector;
                        return result.x = this.horizontal ? result.x : 0, result.y = this.vertical ? result.y : 0, 
                        result;
                    }
                }, {
                    key: "_moveContent",
                    value: function _moveContent(deltaMove, canStartBounceBack) {
                        var adjustedMove = this._flattenVectorByDirection(deltaMove);
                        _tempPos$1.set(this.getContentPosition()), _tempPos$1.add(adjustedMove), this.setContentPosition(_tempPos$1);
                        var outOfBoundary = this._getHowMuchOutOfBoundary();
                        this._updateScrollBar(outOfBoundary), this.elastic && canStartBounceBack && this._startBounceBackIfNeeded();
                    }
                }, {
                    key: "_getContentLeftBoundary",
                    value: function _getContentLeftBoundary() {
                        return this.getContentPosition().x - this._content.getAnchorPoint().x * this._content.getContentSize().width;
                    }
                }, {
                    key: "_getContentRightBoundary",
                    value: function _getContentRightBoundary() {
                        var contentSize = this._content.getContentSize();
                        return this._getContentLeftBoundary() + contentSize.width;
                    }
                }, {
                    key: "_getContentTopBoundary",
                    value: function _getContentTopBoundary() {
                        var contentSize = this._content.getContentSize();
                        return this._getContentBottomBoundary() + contentSize.height;
                    }
                }, {
                    key: "_getContentBottomBoundary",
                    value: function _getContentBottomBoundary() {
                        return this.getContentPosition().y - this._content.getAnchorPoint().y * this._content.getContentSize().height;
                    }
                }, {
                    key: "_getHowMuchOutOfBoundary",
                    value: function _getHowMuchOutOfBoundary(addition) {
                        if ((addition = addition || new Vec3()).equals(ZERO$1, 1e-4) && !this._outOfBoundaryAmountDirty) return this._outOfBoundaryAmount;
                        var outOfBoundaryAmount = new Vec3();
                        return this._getContentLeftBoundary() + addition.x > this._leftBoundary ? outOfBoundaryAmount.x = this._leftBoundary - (this._getContentLeftBoundary() + addition.x) : this._getContentRightBoundary() + addition.x < this._rightBoundary && (outOfBoundaryAmount.x = this._rightBoundary - (this._getContentRightBoundary() + addition.x)), 
                        this._getContentTopBoundary() + addition.y < this._topBoundary ? outOfBoundaryAmount.y = this._topBoundary - (this._getContentTopBoundary() + addition.y) : this._getContentBottomBoundary() + addition.y > this._bottomBoundary && (outOfBoundaryAmount.y = this._bottomBoundary - (this._getContentBottomBoundary() + addition.y)), 
                        addition.equals(ZERO$1, 1e-4) && (this._outOfBoundaryAmount = outOfBoundaryAmount, 
                        this._outOfBoundaryAmountDirty = !1), outOfBoundaryAmount = this._clampDelta(outOfBoundaryAmount);
                    }
                }, {
                    key: "_updateScrollBar",
                    value: function _updateScrollBar(outOfBoundary) {
                        this._horizontalScrollBar && this._horizontalScrollBar.onScroll(outOfBoundary), 
                        this.verticalScrollBar && this.verticalScrollBar.onScroll(outOfBoundary);
                    }
                }, {
                    key: "_onScrollBarTouchBegan",
                    value: function _onScrollBarTouchBegan() {
                        this._horizontalScrollBar && this._horizontalScrollBar.onTouchBegan(), this.verticalScrollBar && this.verticalScrollBar.onTouchBegan();
                    }
                }, {
                    key: "_onScrollBarTouchEnded",
                    value: function _onScrollBarTouchEnded() {
                        this._horizontalScrollBar && this._horizontalScrollBar.onTouchEnded(), this.verticalScrollBar && this.verticalScrollBar.onTouchEnded();
                    }
                }, {
                    key: "_dispatchEvent",
                    value: function _dispatchEvent(event) {
                        if ("scroll-ended" === event) this._scrollEventEmitMask = 0; else if ("scroll-to-top" === event || "scroll-to-bottom" === event || "scroll-to-left" === event || "scroll-to-right" === event) {
                            var flag = 1 << eventMap[event];
                            if (this._scrollEventEmitMask & flag) return;
                            this._scrollEventEmitMask |= flag;
                        }
                        EventHandler.emitEvents(this.scrollEvents, this, eventMap[event]), this.node.emit(event, this);
                    }
                }, {
                    key: "_adjustContentOutOfBoundary",
                    value: function _adjustContentOutOfBoundary() {
                        if (this._content && (this._outOfBoundaryAmountDirty = !0, this._isOutOfBoundary())) {
                            var outOfBoundary = this._getHowMuchOutOfBoundary(new Vec3()), newPosition = new Vec3(this.getContentPosition());
                            newPosition.add(outOfBoundary), this._content && (this._content.setPosition(newPosition), 
                            this._updateScrollBar(ZERO$1));
                        }
                    }
                }, {
                    key: "_hideScrollbar",
                    value: function _hideScrollbar() {
                        this._horizontalScrollBar && this._horizontalScrollBar.hide(), this.verticalScrollBar && this.verticalScrollBar.hide();
                    }
                }, {
                    key: "_showScrollbar",
                    value: function _showScrollbar() {
                        this._horizontalScrollBar && this._horizontalScrollBar.show(), this.verticalScrollBar && this.verticalScrollBar.show();
                    }
                }, {
                    key: "_stopPropagationIfTargetIsMe",
                    value: function _stopPropagationIfTargetIsMe(event) {
                        event && event.eventPhase === Event.AT_TARGET && event.target === this.node && (event.propagationStopped = !0);
                    }
                }, {
                    key: "_processDeltaMove",
                    value: function _processDeltaMove(deltaMove) {
                        this._scrollChildren(deltaMove), this._gatherTouchMove(deltaMove);
                    }
                }, {
                    key: "_handleMoveLogic",
                    value: function _handleMoveLogic(touch) {
                        var delta = touch.getUIDelta();
                        Vec3.set(this._deltaPos, delta.x, delta.y, 0), this._processDeltaMove(this._deltaPos);
                    }
                }, {
                    key: "_scrollChildren",
                    value: function _scrollChildren(deltaMove) {
                        var outOfBoundary, realMove = deltaMove = this._clampDelta(deltaMove);
                        this.elastic && (outOfBoundary = this._getHowMuchOutOfBoundary(), realMove.x *= 0 === outOfBoundary.x ? 1 : .5, 
                        realMove.y *= 0 === outOfBoundary.y ? 1 : .5), this.elastic || (outOfBoundary = this._getHowMuchOutOfBoundary(realMove), 
                        realMove.add(outOfBoundary));
                        var scrollEventType = "", pos = new Vec3();
                        if (this._content.getPosition(pos), 0 < realMove.y) pos.y - this._content.anchorY * this._content.height + realMove.y > this._bottomBoundary && (scrollEventType = "scroll-to-bottom"); else if (realMove.y < 0) {
                            pos.y - this._content.anchorY * this._content.height + this._content.height + realMove.y <= this._topBoundary && (scrollEventType = "scroll-to-top");
                        } else if (realMove.x < 0) {
                            pos.x - this._content.anchorX * this._content.width + this._content.width + realMove.x <= this._rightBoundary && (scrollEventType = "scroll-to-right");
                        } else if (0 < realMove.x) {
                            pos.x - this._content.anchorX * this._content.width + realMove.x >= this._leftBoundary && (scrollEventType = "scroll-to-left");
                        }
                        this._moveContent(realMove, !1), 0 === realMove.x && 0 === realMove.y || (this._scrolling || (this._scrolling = !0, 
                        this._dispatchEvent("scroll-began")), this._dispatchEvent("scrolling")), 0 < scrollEventType.length && this._dispatchEvent(scrollEventType);
                    }
                }, {
                    key: "_handlePressLogic",
                    value: function _handlePressLogic() {
                        this._autoScrolling && this._dispatchEvent("scroll-ended"), this._autoScrolling = !1, 
                        this._isBouncing = !1, this._touchMovePreviousTimestamp = getTimeInMilliseconds(), 
                        this._touchMoveDisplacements.length = 0, this._touchMoveTimeDeltas.length = 0, this._onScrollBarTouchBegan();
                    }
                }, {
                    key: "_clampDelta",
                    value: function _clampDelta(delta) {
                        var contentSize = this._content.getContentSize(), scrollViewSize = this.node.getContentSize();
                        return contentSize.width < scrollViewSize.width && (delta.x = 0), contentSize.height < scrollViewSize.height && (delta.y = 0), 
                        delta;
                    }
                }, {
                    key: "_gatherTouchMove",
                    value: function _gatherTouchMove(delta) {
                        for (delta = this._clampDelta(delta); 5 <= this._touchMoveDisplacements.length; ) this._touchMoveDisplacements.shift(), 
                        this._touchMoveTimeDeltas.shift();
                        this._touchMoveDisplacements.push(delta);
                        var timeStamp = getTimeInMilliseconds();
                        this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1e3), 
                        this._touchMovePreviousTimestamp = timeStamp;
                    }
                }, {
                    key: "_startBounceBackIfNeeded",
                    value: function _startBounceBackIfNeeded() {
                        if (!this.elastic) return !1;
                        var bounceBackAmount = this._getHowMuchOutOfBoundary();
                        if ((bounceBackAmount = this._clampDelta(bounceBackAmount)).equals(ZERO$1, 1e-4)) return !1;
                        var bounceBackTime = Math.max(this.bounceDuration, 0);
                        return this._startAutoScroll(bounceBackAmount, bounceBackTime, !0), this._isBouncing || (0 < bounceBackAmount.y && this._dispatchEvent("bounce-top"), 
                        bounceBackAmount.y < 0 && this._dispatchEvent("bounce-bottom"), 0 < bounceBackAmount.x && this._dispatchEvent("bounce-right"), 
                        bounceBackAmount.x < 0 && this._dispatchEvent("bounce-left"), this._isBouncing = !0), 
                        !0;
                    }
                }, {
                    key: "_processInertiaScroll",
                    value: function _processInertiaScroll() {
                        if (!this._startBounceBackIfNeeded() && this.inertia) {
                            var touchMoveVelocity = this._calculateTouchMoveVelocity();
                            !touchMoveVelocity.equals(_tempPos$1, 1e-4) && this.brake < 1 && this._startInertiaScroll(touchMoveVelocity);
                        }
                        this._onScrollBarTouchEnded();
                    }
                }, {
                    key: "_isOutOfBoundary",
                    value: function _isOutOfBoundary() {
                        return !this._getHowMuchOutOfBoundary().equals(ZERO$1, 1e-4);
                    }
                }, {
                    key: "_isNecessaryAutoScrollBrake",
                    value: function _isNecessaryAutoScrollBrake() {
                        if (this._autoScrollBraking) return !0;
                        if (this._isOutOfBoundary()) {
                            if (!this._autoScrollCurrentlyOutOfBoundary) return this._autoScrollCurrentlyOutOfBoundary = !0, 
                            this._autoScrollBraking = !0, this._autoScrollBrakingStartPosition = this.getContentPosition(), 
                            !0;
                        } else this._autoScrollCurrentlyOutOfBoundary = !1;
                        return !1;
                    }
                }, {
                    key: "_processAutoScrolling",
                    value: function _processAutoScrolling(dt) {
                        var isAutoScrollBrake = this._isNecessaryAutoScrollBrake(), brakingFactor = isAutoScrollBrake ? .05 : 1;
                        this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
                        var percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);
                        this._autoScrollAttenuate && (percentage = function quintEaseOut(time) {
                            return (time -= 1) * time * time * time * time + 1;
                        }(percentage));
                        var a = new Vec3(this._autoScrollTargetDelta);
                        a.multiplyScalar(percentage);
                        var newPosition = new Vec3(this._autoScrollStartPosition);
                        newPosition.add(a);
                        var reachedEnd = Math.abs(percentage - 1) <= 1e-4;
                        if (Math.abs(percentage - 1) <= this.getScrollEndedEventTiming() && !this._isScrollEndedWithThresholdEventFired && (this._dispatchEvent("scroll-ended-with-threshold"), 
                        this._isScrollEndedWithThresholdEventFired = !0), this.elastic) {
                            var brakeOffsetPosition = new Vec3(newPosition);
                            brakeOffsetPosition.subtract(this._autoScrollBrakingStartPosition), isAutoScrollBrake && brakeOffsetPosition.multiplyScalar(brakingFactor), 
                            newPosition.set(this._autoScrollBrakingStartPosition), newPosition.add(brakeOffsetPosition);
                        } else {
                            var moveDelta = new Vec3(newPosition);
                            moveDelta.subtract(this.getContentPosition());
                            var outOfBoundary = this._getHowMuchOutOfBoundary(moveDelta);
                            outOfBoundary.equals(ZERO$1, 1e-4) || (newPosition.add(outOfBoundary), reachedEnd = !0);
                        }
                        reachedEnd && (this._autoScrolling = !1);
                        var deltaMove = new Vec3(newPosition);
                        deltaMove.subtract(this.getContentPosition()), this._moveContent(this._clampDelta(deltaMove), reachedEnd), 
                        this._dispatchEvent("scrolling"), this._autoScrolling || (this._isBouncing = !1, 
                        this._scrolling = !1, this._dispatchEvent("scroll-ended"));
                    }
                }, {
                    key: "_checkMouseWheel",
                    value: function _checkMouseWheel(dt) {
                        if (!this._getHowMuchOutOfBoundary().equals(ZERO$1, 1e-4)) return this._processInertiaScroll(), 
                        this.unschedule(this._checkMouseWheel), void (this._stopMouseWheel = !1);
                        this._mouseWheelEventElapsedTime += dt, .1 < this._mouseWheelEventElapsedTime && (this._onScrollBarTouchEnded(), 
                        this.unschedule(this._checkMouseWheel), this._stopMouseWheel = !1);
                    }
                }, {
                    key: "_calculateMovePercentDelta",
                    value: function _calculateMovePercentDelta(options) {
                        var anchor = options.anchor, applyToHorizontal = options.applyToHorizontal, applyToVertical = options.applyToVertical;
                        this._calculateBoundary(), anchor.clampf(new Vec2(0, 0), new Vec2(1, 1));
                        var scrollSize = this.node.getContentSize(), contentSize = this._content.getContentSize(), bottomDeta = this._getContentBottomBoundary() - this._bottomBoundary;
                        bottomDeta = -bottomDeta;
                        var leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
                        leftDeta = -leftDeta;
                        var moveDelta = new Vec3(), totalScrollDelta = 0;
                        return applyToHorizontal && (totalScrollDelta = contentSize.width - scrollSize.width, 
                        moveDelta.x = leftDeta - totalScrollDelta * anchor.x), applyToVertical && (totalScrollDelta = contentSize.height - scrollSize.height, 
                        moveDelta.y = bottomDeta - totalScrollDelta * anchor.y), moveDelta;
                    }
                }, {
                    key: "_moveContentToTopLeft",
                    value: function _moveContentToTopLeft(scrollViewSize) {
                        var contentSize = this._content.getContentSize(), bottomDeta = this._getContentBottomBoundary() - this._bottomBoundary;
                        bottomDeta = -bottomDeta;
                        var moveDelta = new Vec3(), totalScrollDelta = 0, leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
                        leftDeta = -leftDeta, contentSize.height < scrollViewSize.height ? (totalScrollDelta = contentSize.height - scrollViewSize.height, 
                        moveDelta.y = bottomDeta - totalScrollDelta, this.verticalScrollBar && this.verticalScrollBar.hide()) : this.verticalScrollBar && this.verticalScrollBar.show(), 
                        contentSize.width < scrollViewSize.width ? (totalScrollDelta = contentSize.width - scrollViewSize.width, 
                        moveDelta.x = leftDeta, this._horizontalScrollBar && this._horizontalScrollBar.hide()) : this._horizontalScrollBar && this._horizontalScrollBar.show(), 
                        this._moveContent(moveDelta), this._adjustContentOutOfBoundary();
                    }
                }, {
                    key: "content",
                    get: function get() {
                        return this._content;
                    },
                    set: function set(value) {
                        this._content !== value && (this._content = value, this._calculateBoundary());
                    }
                }, {
                    key: "horizontalScrollBar",
                    get: function get() {
                        return this._horizontalScrollBar;
                    },
                    set: function set(value) {
                        this._horizontalScrollBar !== value && (this._horizontalScrollBar = value, this._horizontalScrollBar && (this._horizontalScrollBar.setScrollView(this), 
                        this._updateScrollBar(ZERO$1)));
                    }
                }, {
                    key: "verticalScrollBar",
                    get: function get() {
                        return this._verticalScrollBar;
                    },
                    set: function set(value) {
                        this._verticalScrollBar !== value && (this._verticalScrollBar = value, this._verticalScrollBar && (this._verticalScrollBar.setScrollView(this), 
                        this._updateScrollBar(ZERO$1)));
                    }
                }, {
                    key: "view",
                    get: function get() {
                        return this._content ? this._content.parent : null;
                    }
                } ]), ScrollViewComponent;
            }(), _class3$s.EventType = ScrollViewEventType, _applyDecoratedDescriptor((_class2$V = _temp$10).prototype, "content", [ _dec4$p ], Object.getOwnPropertyDescriptor(_class2$V.prototype, "content"), _class2$V.prototype), 
            _applyDecoratedDescriptor(_class2$V.prototype, "horizontalScrollBar", [ _dec5$o ], Object.getOwnPropertyDescriptor(_class2$V.prototype, "horizontalScrollBar"), _class2$V.prototype), 
            _applyDecoratedDescriptor(_class2$V.prototype, "verticalScrollBar", [ _dec6$k ], Object.getOwnPropertyDescriptor(_class2$V.prototype, "verticalScrollBar"), _class2$V.prototype), 
            _descriptor$S = _applyDecoratedDescriptor(_class2$V.prototype, "horizontal", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor2$I = _applyDecoratedDescriptor(_class2$V.prototype, "vertical", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor3$v = _applyDecoratedDescriptor(_class2$V.prototype, "inertia", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor4$q = _applyDecoratedDescriptor(_class2$V.prototype, "brake", [ _dec7$f ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return .5;
                }
            }), _descriptor5$m = _applyDecoratedDescriptor(_class2$V.prototype, "elastic", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor6$d = _applyDecoratedDescriptor(_class2$V.prototype, "bounceDuration", [ _dec8$8 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _descriptor7$b = _applyDecoratedDescriptor(_class2$V.prototype, "scrollEvents", [ _dec9$7 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor8$b = _applyDecoratedDescriptor(_class2$V.prototype, "cancelInnerEvents", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor9$9 = _applyDecoratedDescriptor(_class2$V.prototype, "_content", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor10$7 = _applyDecoratedDescriptor(_class2$V.prototype, "_horizontalScrollBar", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor11$6 = _applyDecoratedDescriptor(_class2$V.prototype, "_verticalScrollBar", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _class$17 = _class2$V)) || _class$17) || _class$17) || _class$17));
            cc.ScrollViewComponent = ScrollViewComponent;
            var Direction$1, _tempPos$2 = new Vec3();
            !function(Direction) {
                Direction[Direction.Horizontal = 0] = "Horizontal", Direction[Direction.Vertical = 1] = "Vertical";
            }(Direction$1 = Direction$1 || {}), ccenum(Direction$1);
            var _dec$17, _dec2$L, _dec3$v, _dec4$r, _class$19, _class2$X, _descriptor$U, _descriptor2$K, SliderComponent = exports("SliderComponent", (_dec$16 = ccclass("cc.SliderComponent"), 
            _dec2$K = executionOrder(110), _dec3$u = menu("UI/Slider"), _dec4$q = property({
                type: SpriteComponent
            }), _dec5$p = property({
                type: Direction$1
            }), _dec6$l = property({
                slide: !0,
                range: [ 0, 1, .01 ]
            }), _dec7$g = property({
                type: EventHandler
            }), _dec$16(_class$18 = _dec2$K(_class$18 = _dec3$u((_temp$11 = _class3$t = function() {
                function SliderComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, SliderComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SliderComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "slideEvents", _descriptor$T, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_handle", _descriptor2$J, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_direction", _descriptor3$w, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_progress", _descriptor4$r, _assertThisInitialized(_this)), 
                    _this._offset = new Vec3(), _this._dragging = !1, _this._touchHandle = !1, _this._handlelocalPos = new Vec3(), 
                    _this._touchPos = new Vec3(), _this;
                }
                return _inherits(SliderComponent, Component), _createClass(SliderComponent, [ {
                    key: "__preload",
                    value: function __preload() {
                        this._updateHandlePosition();
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        this._updateHandlePosition(), this.node.on(SystemEventType.TOUCH_START, this._onTouchBegan, this), 
                        this.node.on(SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), this.node.on(SystemEventType.TOUCH_END, this._onTouchEnded, this), 
                        this.node.on(SystemEventType.TOUCH_CANCEL, this._onTouchCancelled, this), this._handle && this._handle.isValid && (this._handle.node.on(SystemEventType.TOUCH_START, this._onHandleDragStart, this), 
                        this._handle.node.on(SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), this._handle.node.on(SystemEventType.TOUCH_END, this._onTouchEnded, this));
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this.node.off(SystemEventType.TOUCH_START, this._onTouchBegan, this), this.node.off(SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), 
                        this.node.off(SystemEventType.TOUCH_END, this._onTouchEnded, this), this.node.off(SystemEventType.TOUCH_CANCEL, this._onTouchCancelled, this), 
                        this._handle && this._handle.isValid && (this._handle.node.off(SystemEventType.TOUCH_START, this._onHandleDragStart, this), 
                        this._handle.node.off(SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), this._handle.node.off(SystemEventType.TOUCH_END, this._onTouchEnded, this));
                    }
                }, {
                    key: "_onHandleDragStart",
                    value: function _onHandleDragStart(event) {
                        if (event && this._handle && this._handle.node.uiTransfromComp) {
                            this._dragging = !0, this._touchHandle = !0;
                            var touhPos = event.touch.getUILocation();
                            Vec3.set(this._touchPos, touhPos.x, touhPos.y, 0), this._handle.node.uiTransfromComp.convertToNodeSpaceAR(this._touchPos, this._offset), 
                            event.propagationStopped = !0;
                        }
                    }
                }, {
                    key: "_onTouchBegan",
                    value: function _onTouchBegan(event) {
                        this._handle && event && (this._dragging = !0, this._touchHandle || this._handleSliderLogic(event.touch), 
                        event.propagationStopped = !0);
                    }
                }, {
                    key: "_onTouchMoved",
                    value: function _onTouchMoved(event) {
                        this._dragging && event && (this._handleSliderLogic(event.touch), event.propagationStopped = !0);
                    }
                }, {
                    key: "_onTouchEnded",
                    value: function _onTouchEnded(event) {
                        this._dragging = !1, this._touchHandle = !1, this._offset = new Vec3(), event && (event.propagationStopped = !0);
                    }
                }, {
                    key: "_onTouchCancelled",
                    value: function _onTouchCancelled(event) {
                        this._dragging = !1, event && (event.propagationStopped = !0);
                    }
                }, {
                    key: "_handleSliderLogic",
                    value: function _handleSliderLogic(touch) {
                        this._updateProgress(touch), this._emitSlideEvent();
                    }
                }, {
                    key: "_emitSlideEvent",
                    value: function _emitSlideEvent() {
                        EventHandler.emitEvents(this.slideEvents, this), this.node.emit("slide", this);
                    }
                }, {
                    key: "_updateProgress",
                    value: function _updateProgress(touch) {
                        if (this._handle && touch) {
                            var touchPos = touch.getUILocation();
                            Vec3.set(this._touchPos, touchPos.x, touchPos.y, 0);
                            var localTouchPos = this.node.uiTransfromComp.convertToNodeSpaceAR(this._touchPos, _tempPos$2);
                            this.direction === Direction$1.Horizontal ? this.progress = clamp01(.5 + (localTouchPos.x - this._offset.x) / this.node.width) : this.progress = clamp01(.5 + (localTouchPos.y - this._offset.y) / this.node.height);
                        }
                    }
                }, {
                    key: "_updateHandlePosition",
                    value: function _updateHandlePosition() {
                        this._handle && (this._handlelocalPos.set(this._handle.node.getPosition()), this._direction === Direction$1.Horizontal ? this._handlelocalPos.x = -this.node.width * this.node.anchorX + this.progress * this.node.width : this._handlelocalPos.y = -this.node.height * this.node.anchorY + this.progress * this.node.height, 
                        this._handle.node.setPosition(this._handlelocalPos));
                    }
                }, {
                    key: "_changeLayout",
                    value: function _changeLayout() {
                        var contentSize = this.node.getContentSize();
                        if (this.node.setContentSize(contentSize.height, contentSize.width), this._handle) {
                            var pos = this._handle.node.position;
                            this._direction === Direction$1.Horizontal ? this._handle.node.setPosition(pos.x, 0, pos.z) : this._handle.node.setPosition(0, pos.y, pos.z), 
                            this._updateHandlePosition();
                        }
                    }
                }, {
                    key: "handle",
                    get: function get() {
                        return this._handle;
                    },
                    set: function set(value) {
                        this._handle !== value && (this._handle = value);
                    }
                }, {
                    key: "direction",
                    get: function get() {
                        return this._direction;
                    },
                    set: function set(value) {
                        this._direction !== value && (this._direction = value, this._changeLayout());
                    }
                }, {
                    key: "progress",
                    get: function get() {
                        return this._progress;
                    },
                    set: function set(value) {
                        this._progress !== value && (this._progress = value, this._updateHandlePosition());
                    }
                } ]), SliderComponent;
            }(), _class3$t.Direction = Direction$1, _applyDecoratedDescriptor((_class2$W = _temp$11).prototype, "handle", [ _dec4$q ], Object.getOwnPropertyDescriptor(_class2$W.prototype, "handle"), _class2$W.prototype), 
            _applyDecoratedDescriptor(_class2$W.prototype, "direction", [ _dec5$p ], Object.getOwnPropertyDescriptor(_class2$W.prototype, "direction"), _class2$W.prototype), 
            _applyDecoratedDescriptor(_class2$W.prototype, "progress", [ _dec6$l ], Object.getOwnPropertyDescriptor(_class2$W.prototype, "progress"), _class2$W.prototype), 
            _descriptor$T = _applyDecoratedDescriptor(_class2$W.prototype, "slideEvents", [ _dec7$g ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor2$J = _applyDecoratedDescriptor(_class2$W.prototype, "_handle", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor3$w = _applyDecoratedDescriptor(_class2$W.prototype, "_direction", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Direction$1.Horizontal;
                }
            }), _descriptor4$r = _applyDecoratedDescriptor(_class2$W.prototype, "_progress", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return .1;
                }
            }), _class$18 = _class2$W)) || _class$18) || _class$18) || _class$18));
            cc.SliderComponent = SliderComponent;
            var _dec$18, _dec2$M, _dec3$w, _dec4$s, _dec5$q, _dec6$m, _class$1a, _class2$Y, _descriptor$V, _descriptor2$L, _descriptor3$x, _descriptor4$s, ToggleContainerComponent = exports("ToggleContainerComponent", (_dec$17 = ccclass("cc.ToggleContainerComponent"), 
            _dec2$L = executionOrder(110), _dec3$v = menu("UI/ToggleContainer"), _dec4$r = property({
                type: [ EventHandler ]
            }), _dec$17(_class$19 = _dec2$L(_class$19 = _dec3$v(_class$19 = executeInEditMode((_descriptor$U = _applyDecoratedDescriptor((_class2$X = function() {
                function ToggleContainerComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, ToggleContainerComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ToggleContainerComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "checkEvents", _descriptor$U, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_allowSwitchOff", _descriptor2$K, _assertThisInitialized(_this)), 
                    _this._toggleItems = [], _this;
                }
                return _inherits(ToggleContainerComponent, Component), _createClass(ToggleContainerComponent, [ {
                    key: "start",
                    value: function start() {
                        this._makeAtLeastOneToggleChecked();
                    }
                }, {
                    key: "updateToggles",
                    value: function updateToggles(toggle) {
                        this.enabledInHierarchy && toggle.isChecked && (this.toggleItems.forEach(function(item) {
                            item !== toggle && item.isChecked && item.enabled && (item.isChecked = !1);
                        }), this.checkEvents && EventHandler.emitEvents(this.checkEvents, toggle));
                    }
                }, {
                    key: "addToggle",
                    value: function addToggle(toggle) {
                        -1 === this._toggleItems.indexOf(toggle) && this._toggleItems.push(toggle), this._allowOnlyOneToggleChecked();
                    }
                }, {
                    key: "removeToggle",
                    value: function removeToggle(toggle) {
                        var index = this._toggleItems.indexOf(toggle);
                        -1 < index && this._toggleItems.splice(index, 1), this._makeAtLeastOneToggleChecked();
                    }
                }, {
                    key: "_allowOnlyOneToggleChecked",
                    value: function _allowOnlyOneToggleChecked() {
                        var isChecked = !1;
                        return this._toggleItems.forEach(function(item) {
                            isChecked && item.enabled && (item.isChecked = !1), item.isChecked && item.enabled && (isChecked = !0);
                        }), isChecked;
                    }
                }, {
                    key: "_makeAtLeastOneToggleChecked",
                    value: function _makeAtLeastOneToggleChecked() {
                        this._allowOnlyOneToggleChecked() || this._allowSwitchOff || 0 < this._toggleItems.length && (this._toggleItems[0].isChecked = !0);
                    }
                }, {
                    key: "allowSwitchOff",
                    get: function get() {
                        return this._allowSwitchOff;
                    },
                    set: function set(value) {
                        this._allowSwitchOff = value;
                    }
                }, {
                    key: "toggleItems",
                    get: function get() {
                        return this._toggleItems;
                    }
                } ]), ToggleContainerComponent;
            }()).prototype, "checkEvents", [ _dec4$r ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor2$K = _applyDecoratedDescriptor(_class2$X.prototype, "_allowSwitchOff", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _applyDecoratedDescriptor(_class2$X.prototype, "allowSwitchOff", [ property ], Object.getOwnPropertyDescriptor(_class2$X.prototype, "allowSwitchOff"), _class2$X.prototype), 
            _class$19 = _class2$X)) || _class$19) || _class$19) || _class$19) || _class$19));
            cc.ToggleContainerComponent = ToggleContainerComponent;
            var _class$1b, ToggleComponent = exports("ToggleComponent", (_dec$18 = ccclass("cc.ToggleComponent"), 
            _dec2$M = executionOrder(110), _dec3$w = menu("UI/Toggle"), _dec4$s = property({
                type: ToggleContainerComponent
            }), _dec5$q = property({
                type: SpriteComponent
            }), _dec6$m = property({
                type: [ EventHandler ]
            }), _dec$18(_class$1a = _dec2$M(_class$1a = _dec3$w(_class$1a = executeInEditMode((_applyDecoratedDescriptor((_class2$Y = function() {
                function ToggleComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, ToggleComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ToggleComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "checkEvents", _descriptor$V, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_isChecked", _descriptor2$L, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_toggleGroup", _descriptor3$x, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_checkMark", _descriptor4$s, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(ToggleComponent, ButtonComponent), _createClass(ToggleComponent, [ {
                    key: "onEnable",
                    value: function onEnable() {
                        _get(_getPrototypeOf(ToggleComponent.prototype), "onEnable", this).call(this), this._registerToggleEvent(), 
                        this._toggleGroup && this._toggleGroup.enabled && this._toggleGroup.addToggle(this);
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        _get(_getPrototypeOf(ToggleComponent.prototype), "onDisable", this).call(this), 
                        this._unregisterToggleEvent(), this._toggleGroup && this._toggleGroup.enabled && this._toggleGroup.removeToggle(this);
                    }
                }, {
                    key: "toggle",
                    value: function toggle() {
                        var group = this.toggleGroup || this._toggleContainer;
                        group && group.enabled && this.isChecked && !group.allowSwitchOff || (this.isChecked = !this.isChecked, 
                        group && group.enabled && group.updateToggles(this), this._emitToggleEvents());
                    }
                }, {
                    key: "check",
                    value: function check() {
                        var group = this.toggleGroup || this._toggleContainer;
                        group && group.enabled && this.isChecked && !group.allowSwitchOff || (this.isChecked = !0, 
                        group && group.enabled && group.updateToggles(this), this._emitToggleEvents());
                    }
                }, {
                    key: "uncheck",
                    value: function uncheck() {
                        var group = this.toggleGroup || this._toggleContainer;
                        group && group.enabled && this.isChecked && !group.allowSwitchOff || (this.isChecked = !1, 
                        this._emitToggleEvents());
                    }
                }, {
                    key: "_updateCheckMark",
                    value: function _updateCheckMark() {
                        this._checkMark && (this._checkMark.node.active = !!this.isChecked);
                    }
                }, {
                    key: "_registerToggleEvent",
                    value: function _registerToggleEvent() {
                        this.node.on("click", this.toggle, this);
                    }
                }, {
                    key: "_unregisterToggleEvent",
                    value: function _unregisterToggleEvent() {
                        this.node.off("click", this.toggle, this);
                    }
                }, {
                    key: "_emitToggleEvents",
                    value: function _emitToggleEvents() {
                        this.node.emit("toggle", this), this.checkEvents && EventHandler.emitEvents(this.checkEvents, this);
                    }
                }, {
                    key: "isChecked",
                    get: function get() {
                        return this._isChecked;
                    },
                    set: function set(value) {
                        this._isChecked !== value && (this._isChecked = value, this._updateCheckMark());
                    }
                }, {
                    key: "toggleGroup",
                    get: function get() {
                        return this._toggleGroup;
                    },
                    set: function set(value) {
                        this._toggleGroup !== value && (this._toggleGroup && this._toggleGroup.removeToggle(this), 
                        this._toggleGroup = value, this._toggleGroup && this._toggleGroup.enabled && this._toggleGroup.addToggle(this));
                    }
                }, {
                    key: "checkMark",
                    get: function get() {
                        return this._checkMark;
                    },
                    set: function set(value) {
                        this._checkMark !== value && (this._checkMark = value);
                    }
                }, {
                    key: "_resizeToTarget",
                    set: function set(value) {
                        value && this._resizeNodeToTargetNode();
                    }
                }, {
                    key: "_toggleContainer",
                    get: function get() {
                        this.node.parent;
                        return null;
                    }
                } ]), ToggleComponent;
            }()).prototype, "isChecked", [ property ], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "isChecked"), _class2$Y.prototype), 
            _applyDecoratedDescriptor(_class2$Y.prototype, "toggleGroup", [ _dec4$s ], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "toggleGroup"), _class2$Y.prototype), 
            _applyDecoratedDescriptor(_class2$Y.prototype, "checkMark", [ _dec5$q ], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "checkMark"), _class2$Y.prototype), 
            _descriptor$V = _applyDecoratedDescriptor(_class2$Y.prototype, "checkEvents", [ _dec6$m ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor2$L = _applyDecoratedDescriptor(_class2$Y.prototype, "_isChecked", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor3$x = _applyDecoratedDescriptor(_class2$Y.prototype, "_toggleGroup", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor4$s = _applyDecoratedDescriptor(_class2$Y.prototype, "_checkMark", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _class$1a = _class2$Y)) || _class$1a) || _class$1a) || _class$1a) || _class$1a));
            cc.ToggleComponent = ToggleComponent;
            var _class$1c, _class2$Z, _temp$15, UIModelComponent = exports("UIModelComponent", ccclass("cc.UIModelComponent")(_class$1b = executionOrder(110)(_class$1b = menu("UI/Model")(_class$1b = function() {
                function UIModelComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, UIModelComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIModelComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._modelComponent = null, 
                    _this;
                }
                return _inherits(UIModelComponent, UIComponent), _createClass(UIModelComponent, [ {
                    key: "onLoad",
                    value: function onLoad() {
                        this._modelComponent = this.getComponent("cc.RenderableComponent"), this._modelComponent ? (this._modelComponent._sceneGetter = director.root.ui.getRenderSceneGetter(), 
                        this._modelComponent.recreateModel()) : console.warn("Use this component on a node（".concat(this.node && this.node.name, "） that has a model component"));
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this._modelComponent = this.getComponent("cc.RenderableComponent"), this._modelComponent && (this._modelComponent._sceneGetter = null, 
                        cc.isValid(this.node, !0) && this._modelComponent.recreateModel());
                    }
                }, {
                    key: "updateAssembler",
                    value: function updateAssembler(render) {
                        return !!this._modelComponent && (render.commitModel.call(render, this, this._modelComponent._getModel(), this._modelComponent.material), 
                        !0);
                    }
                }, {
                    key: "update",
                    value: function update() {
                        this._fitUIRenderQueue();
                    }
                }, {
                    key: "_fitUIRenderQueue",
                    value: function _fitUIRenderQueue() {
                        if (this._modelComponent) {
                            for (var matNum = this._modelComponent.sharedMaterials.length, i = 0; i < matNum; i++) {
                                var material = this._modelComponent.getMaterial(i);
                                if (null != material) {
                                    for (var passes = material.passes, ea = material.effectAsset, techIdx = material.technique, passNum = passes.length, needReconstruct = !1, j = 0; j < passNum; j++) {
                                        if (!passes[j].blendState.targets[0].blend) needReconstruct = !0, passes[j].blendState.targets[0].blend = !0, 
                                        passes[j].overridePipelineStates(ea.techniques[techIdx].passes[j], {
                                            blendState: passes[j].blendState
                                        });
                                    }
                                    needReconstruct && material._onPassesChange();
                                }
                            }
                            for (var _i = 0; _i < matNum; _i++) {
                                var _material = this._modelComponent.getMaterial(_i);
                                if (null != _material) {
                                    var _iterator = _material.passes, _isArray = Array.isArray(_iterator), _i2 = 0;
                                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                        var _ref;
                                        if (_isArray) {
                                            if (_i2 >= _iterator.length) break;
                                            _ref = _iterator[_i2++];
                                        } else {
                                            if ((_i2 = _iterator.next()).done) break;
                                            _ref = _i2.value;
                                        }
                                        _ref._priority = RenderPriority.MAX - 11;
                                    }
                                }
                            }
                        }
                    }
                }, {
                    key: "modelComponent",
                    get: function get() {
                        return this._modelComponent;
                    }
                } ]), UIModelComponent;
            }()) || _class$1b) || _class$1b) || _class$1b);
            cc.UIModelComponent = UIModelComponent;
            var WebViewEventType, _mat4_temp$2 = new Mat4();
            !function(WebViewEventType) {
                WebViewEventType[WebViewEventType.LOADING = 0] = "LOADING", WebViewEventType[WebViewEventType.LOADED = 1] = "LOADED", 
                WebViewEventType[WebViewEventType.ERROR = 2] = "ERROR", WebViewEventType[WebViewEventType.JS_EVALUATED = 3] = "JS_EVALUATED";
            }(WebViewEventType = WebViewEventType || {});
            var polyfill$1 = {
                devicePixelRatio: !1,
                enableDiv: !1
            };
            sys.os === sys.OS_IOS && (polyfill$1.enableDiv = !0), sys.isMobile ? sys.browserType === sys.BROWSER_TYPE_FIREFOX && (polyfill$1.enableBG = !0) : sys.browserType === sys.BROWSER_TYPE_IE && (polyfill$1.closeHistory = !0);
            var _dec$1b, _dec2$O, _dec3$y, _dec4$t, _class$1d, _class2$_, _descriptor$W, _descriptor2$M, _class3$u, _temp$16, WebViewImpl = ccclass("cc.WebviewImpl")((_temp$15 = _class2$Z = function() {
                function WebViewImpl() {
                    _classCallCheck(this, WebViewImpl), this._EventList = new Map(), this._visible = !1, 
                    this._div = null, this._iframe = null, this._forceUpdate = !0, this._m00 = 0, this._m01 = 0, 
                    this._m04 = 0, this._m05 = 0, this._m12 = 0, this._m13 = 0, this._w = 0, this._h = 0, 
                    this._eventListeners = {
                        load: function load() {},
                        error: function error() {}
                    };
                }
                return _createClass(WebViewImpl, [ {
                    key: "createDomElementIfNeeded",
                    value: function createDomElementIfNeeded(w, h) {
                        this._div ? this._updateSize(w, h) : this._createNativeControl(w, h);
                    }
                }, {
                    key: "removeDom",
                    value: function removeDom() {
                        var div = this._div;
                        div && (contains$1(cc.game.container, div) && cc.game.container.removeChild(div), 
                        this._div = null);
                        var iframe = this._iframe;
                        if (iframe) {
                            var cbs = this._eventListeners;
                            iframe.removeEventListener("load", cbs.load), iframe.removeEventListener("error", cbs.error), 
                            cbs.load = null, cbs.error = null, this._iframe = null;
                        }
                    }
                }, {
                    key: "loadURL",
                    value: function loadURL(url) {
                        var iframe = this._iframe;
                        if (iframe) {
                            iframe.src = url;
                            var self = this;
                            iframe.addEventListener("load", function cb() {
                                self._updateVisibility(), iframe.removeEventListener("load", cb);
                            }), this._dispatchEvent(WebViewImpl.EventType.LOADING);
                        }
                    }
                }, {
                    key: "stopLoading",
                    value: function stopLoading() {
                        logID(7800);
                    }
                }, {
                    key: "reload",
                    value: function reload() {
                        var iframe = this._iframe;
                        if (iframe) {
                            var win = iframe.contentWindow;
                            win && win.location && win.location.reload();
                        }
                    }
                }, {
                    key: "canGoBack",
                    value: function canGoBack() {
                        return logID(7801), !0;
                    }
                }, {
                    key: "canGoForward",
                    value: function canGoForward() {
                        return logID(7802), !0;
                    }
                }, {
                    key: "goBack",
                    value: function goBack() {
                        try {
                            if (WebViewImpl.Polyfill.closeHistory) return logID(7803);
                            var iframe = this._iframe;
                            if (iframe) {
                                var win = iframe.contentWindow;
                                win && win.location && win.history.back.call(win);
                            }
                        } catch (err) {
                            log(err);
                        }
                    }
                }, {
                    key: "goForward",
                    value: function goForward() {
                        try {
                            if (WebViewImpl.Polyfill.closeHistory) return logID(7804);
                            var iframe = this._iframe;
                            if (iframe) {
                                var win = iframe.contentWindow;
                                win && win.location && win.history.forward.call(win);
                            }
                        } catch (err) {
                            log(err);
                        }
                    }
                }, {
                    key: "evaluateJS",
                    value: function evaluateJS() {
                        var iframe = this._iframe;
                        if (iframe) iframe.contentWindow;
                    }
                }, {
                    key: "setScalesPageToFit",
                    value: function setScalesPageToFit() {
                        logID(7805);
                    }
                }, {
                    key: "setEventListener",
                    value: function setEventListener(event, callback) {
                        this._EventList[event] = callback;
                    }
                }, {
                    key: "removeEventListener",
                    value: function removeEventListener(event) {
                        this._EventList[event] = null;
                    }
                }, {
                    key: "_dispatchEvent",
                    value: function _dispatchEvent(event) {
                        var callback = this._EventList[event];
                        callback && this._iframe && callback.call(this, this, this._iframe.src);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.removeDom();
                    }
                }, {
                    key: "setVisible",
                    value: function setVisible(visible) {
                        this._visible !== visible && (this._visible = !!visible, this._updateVisibility());
                    }
                }, {
                    key: "updateMatrix",
                    value: function updateMatrix(node) {
                        if (this._div && this._visible) {
                            node.getWorldMatrix(_mat4_temp$2);
                            var contentSize = node.getContentSize();
                            if (this._forceUpdate || this._m00 !== _mat4_temp$2.m00 || this._m01 !== _mat4_temp$2.m01 || this._m04 !== _mat4_temp$2.m04 || this._m05 !== _mat4_temp$2.m05 || this._m12 !== _mat4_temp$2.m12 || this._m13 !== _mat4_temp$2.m13 || this._w !== contentSize.width || this._h !== contentSize.height) {
                                this._m00 = _mat4_temp$2.m00, this._m01 = _mat4_temp$2.m01, this._m04 = _mat4_temp$2.m04, 
                                this._m05 = _mat4_temp$2.m05, this._m12 = _mat4_temp$2.m12, this._m13 = _mat4_temp$2.m13, 
                                this._w = contentSize.width, this._h = contentSize.height;
                                var scaleX = view.getScaleX(), scaleY = view.getScaleY(), dpr = view.getDevicePixelRatio();
                                scaleX /= dpr, scaleY /= dpr;
                                var container = cc.game.container, a = _mat4_temp$2.m00 * scaleX, b = _mat4_temp$2.m01, c = _mat4_temp$2.m04, d = _mat4_temp$2.m05 * scaleY, offsetX = container && container.style.paddingLeft ? parseInt(container.style.paddingLeft) : 0, offsetY = container && container.style.paddingBottom ? parseInt(container.style.paddingBottom) : 0;
                                this._updateSize(this._w, this._h);
                                var w = this._div.clientWidth * scaleX, h = this._div.clientHeight * scaleY, ap = node.getAnchorPoint(), appx = w * _mat4_temp$2.m00 * ap.x, appy = h * _mat4_temp$2.m05 * ap.y, matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + (_mat4_temp$2.m12 * scaleX - appx + offsetX) + "," + -(_mat4_temp$2.m13 * scaleY - appy + offsetY) + ")";
                                this._div.style.transform = matrix, this._div.style["-webkit-transform"] = matrix, 
                                this._div.style["transform-origin"] = "0px 100% 0px", this._div.style["-webkit-transform-origin"] = "0px 100% 0px";
                                var renderComp = node.getComponent(UIRenderComponent);
                                renderComp && this._setOpacity(renderComp.color.a);
                            }
                        }
                    }
                }, {
                    key: "setOnJSCallback",
                    value: function setOnJSCallback() {}
                }, {
                    key: "setJavascriptInterfaceScheme",
                    value: function setJavascriptInterfaceScheme() {}
                }, {
                    key: "loadData",
                    value: function loadData() {}
                }, {
                    key: "loadHTMLString",
                    value: function loadHTMLString() {}
                }, {
                    key: "_updateVisibility",
                    value: function _updateVisibility() {
                        if (this._div) {
                            var div = this._div;
                            this._visible ? div.style.visibility = "visible" : div.style.visibility = "hidden", 
                            this._forceUpdate = !0;
                        }
                    }
                }, {
                    key: "_updateSize",
                    value: function _updateSize(w, h) {
                        var div = this._div;
                        div && (div.style.width = w + "px", div.style.height = h + "px");
                    }
                }, {
                    key: "_initEvent",
                    value: function _initEvent() {
                        var iframe = this._iframe;
                        if (iframe) {
                            var cbs = this._eventListeners, self = this;
                            cbs.load = function() {
                                self._dispatchEvent(WebViewImpl.EventType.LOADED);
                            }, cbs.error = function() {
                                self._dispatchEvent(WebViewImpl.EventType.ERROR);
                            }, iframe.addEventListener("load", cbs.load), iframe.addEventListener("error", cbs.error);
                        }
                    }
                }, {
                    key: "_initStyle",
                    value: function _initStyle() {
                        if (this._div) {
                            var div = this._div;
                            div.style.position = "absolute", div.style.bottom = "0px", div.style.left = "0px";
                        }
                    }
                }, {
                    key: "_setOpacity",
                    value: function _setOpacity(opacity) {
                        var iframe = this._iframe;
                        iframe && iframe.style && (iframe.style.opacity = (opacity / 255).toString());
                    }
                }, {
                    key: "_createDom",
                    value: function _createDom(w, h) {
                        WebViewImpl.Polyfill.enableDiv ? (this._div = document.createElement("div"), this._div.style["-webkit-overflow"] = "auto", 
                        this._div.style["-webkit-overflow-scrolling"] = "touch", this._iframe = document.createElement("iframe"), 
                        this._div.appendChild(this._iframe), this._iframe.style.width = "100%", this._iframe.style.height = "100%") : this._div = this._iframe = document.createElement("iframe"), 
                        WebViewImpl.Polyfill.enableBG && (this._div.style.background = "#FFF"), this._div.style.background = "#FFF", 
                        this._div.style.height = h + "px", this._div.style.width = w + "px", this._div.style.overflow = "scroll", 
                        this._iframe.style.border = "none", cc.game.container.appendChild(this._div), this._updateVisibility();
                    }
                }, {
                    key: "_createNativeControl",
                    value: function _createNativeControl(w, h) {
                        this._createDom(w, h), this._initStyle(), this._initEvent();
                    }
                } ]), WebViewImpl;
            }(), _class2$Z.Polyfill = polyfill$1, _class2$Z.EventType = WebViewEventType, _class$1c = _temp$15)) || _class$1c, EventType$1 = WebViewEventType;
            function emptyCallback() {}
            var _dec$1c, _dec2$P, _dec3$z, _dec4$u, _dec5$r, _dec6$n, _dec7$h, _dec8$9, _class$1e, _class2$$, _descriptor$X, _descriptor2$N, _descriptor3$y, _descriptor4$t, _descriptor5$n, _descriptor6$e, _descriptor7$c, _descriptor8$c, _descriptor9$a, _descriptor10$8, _descriptor11$7, _descriptor12$6, _descriptor13$6, _descriptor14$6, _descriptor15$2, _descriptor16$2, _descriptor17$1, _class3$v, _temp$17, WebviewComponent = exports("WebviewComponent", (_dec$1b = ccclass("cc.WebviewComponent"), 
            _dec2$O = menu("UI/WebView"), _dec3$y = executionOrder(100), _dec4$t = property({
                type: EventHandler
            }), _dec$1b(_class$1d = _dec2$O(_class$1d = _dec3$y((_temp$16 = _class3$u = function() {
                function WebviewComponent() {
                    var _this;
                    return _classCallCheck(this, WebviewComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(WebviewComponent).call(this)), "webviewEvents", _descriptor$W, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_url", _descriptor2$M, _assertThisInitialized(_this)), 
                    _this._impl = null, _this._impl = new WebViewImpl(), _this;
                }
                return _inherits(WebviewComponent, UIComponent), _createClass(WebviewComponent, [ {
                    key: "url",
                    get: function get() {
                        return this._url;
                    },
                    set: function set(url) {
                        this._url = url;
                        var impl = this._impl;
                        impl && impl.loadURL(url);
                    }
                } ]), _createClass(WebviewComponent, [ {
                    key: "onRestore",
                    value: function onRestore() {
                        this._impl || (this._impl = new WebViewImpl());
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        if (this._impl) {
                            var impl = this._impl;
                            impl.createDomElementIfNeeded(this.node.width, this.node.height), impl.loadURL(this._url), 
                            impl.setVisible(!0), impl.setEventListener(EventType$1.LOADED, this._onWebViewLoaded.bind(this)), 
                            impl.setEventListener(EventType$1.LOADING, this._onWebViewLoading.bind(this)), impl.setEventListener(EventType$1.ERROR, this._onWebViewLoadError.bind(this));
                        }
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        if (this._impl) {
                            var impl = this._impl;
                            impl.setVisible(!1), impl.setEventListener(EventType$1.LOADED, emptyCallback), impl.setEventListener(EventType$1.LOADING, emptyCallback), 
                            impl.setEventListener(EventType$1.ERROR, emptyCallback);
                        }
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this._impl && (this._impl.destroy(), this._impl = null);
                    }
                }, {
                    key: "update",
                    value: function update() {
                        this._impl && this._impl.updateMatrix(this.node);
                    }
                }, {
                    key: "setJavascriptInterfaceScheme",
                    value: function setJavascriptInterfaceScheme(scheme) {
                        this._impl && this._impl.setJavascriptInterfaceScheme(scheme);
                    }
                }, {
                    key: "setOnJSCallback",
                    value: function setOnJSCallback(callback) {
                        this._impl && this._impl.setOnJSCallback(callback);
                    }
                }, {
                    key: "evaluateJS",
                    value: function evaluateJS(str) {
                        this._impl && this._impl.evaluateJS(str);
                    }
                }, {
                    key: "_onWebViewLoaded",
                    value: function _onWebViewLoaded() {
                        EventHandler.emitEvents(this.webviewEvents, this, EventType$1.LOADED), this.node.emit("loaded", this);
                    }
                }, {
                    key: "_onWebViewLoading",
                    value: function _onWebViewLoading() {
                        return EventHandler.emitEvents(this.webviewEvents, this, EventType$1.LOADING), this.node.emit("loading", this), 
                        !0;
                    }
                }, {
                    key: "_onWebViewLoadError",
                    value: function _onWebViewLoadError() {
                        EventHandler.emitEvents(this.webviewEvents, this, EventType$1.ERROR), this.node.emit("error", this);
                    }
                } ]), WebviewComponent;
            }(), _class3$u.EventType = EventType$1, _applyDecoratedDescriptor((_class2$_ = _temp$16).prototype, "url", [ property ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "url"), _class2$_.prototype), 
            _descriptor$W = _applyDecoratedDescriptor(_class2$_.prototype, "webviewEvents", [ _dec4$t ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor2$M = _applyDecoratedDescriptor(_class2$_.prototype, "_url", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return "";
                }
            }), _class$1d = _class2$_)) || _class$1d) || _class$1d) || _class$1d));
            cc.WebviewComponent = WebviewComponent;
            var AlignMode, AlignFlags, _zeroVec3 = new Vec3();
            function getReadonlyNodeSize(parent) {
                return parent instanceof Scene ? visibleRect : parent.getContentSize();
            }
            function computeInverseTransForTarget(widgetNode, target, out_inverseTranslate, out_inverseScale) {
                for (var scale = widgetNode.parent ? widgetNode.parent.getScale() : _zeroVec3, scaleX = scale.x, scaleY = scale.y, translateX = 0, translateY = 0, node = widgetNode.parent; ;) {
                    if (!node) return out_inverseTranslate.x = out_inverseTranslate.y = 0, void (out_inverseScale.x = out_inverseScale.y = 1);
                    var pos = node.getPosition();
                    if (translateX += pos.x, translateY += pos.y, (node = node.parent) === target) break;
                    var sx = (scale = node ? node.getScale() : _zeroVec3).x, sy = scale.y;
                    translateX *= sx, translateY *= sy, scaleX *= sx, scaleY *= sy;
                }
                out_inverseScale.x = 0 !== scaleX ? 1 / scaleX : 1, out_inverseScale.y = 0 !== scaleY ? 1 / scaleY : 1, 
                out_inverseTranslate.x = -translateX, out_inverseTranslate.y = -translateY;
            }
            !function(AlignMode) {
                AlignMode[AlignMode.ONCE = 0] = "ONCE", AlignMode[AlignMode.ALWAYS = 1] = "ALWAYS";
            }(AlignMode = AlignMode || {}), ccenum(AlignMode), function(AlignFlags) {
                AlignFlags[AlignFlags.TOP = 1] = "TOP", AlignFlags[AlignFlags.MID = 2] = "MID", 
                AlignFlags[AlignFlags.BOT = 4] = "BOT", AlignFlags[AlignFlags.LEFT = 8] = "LEFT", 
                AlignFlags[AlignFlags.CENTER = 16] = "CENTER", AlignFlags[AlignFlags.RIGHT = 32] = "RIGHT", 
                AlignFlags[AlignFlags.HORIZONTAL = 56] = "HORIZONTAL", AlignFlags[AlignFlags.VERTICAL = 7] = "VERTICAL";
            }(AlignFlags = AlignFlags || {});
            var _class$1f, TOP_BOT = AlignFlags.TOP | AlignFlags.BOT, LEFT_RIGHT = AlignFlags.LEFT | AlignFlags.RIGHT, WidgetComponent = exports("WidgetComponent", (_dec$1c = ccclass("cc.WidgetComponent"), 
            _dec2$P = executionOrder(110), _dec3$z = menu("UI/Widget"), _dec4$u = requireComponent(UITransformComponent), 
            _dec5$r = property({
                type: Node$1
            }), _dec6$n = property({
                visible: !1
            }), _dec7$h = property({
                visible: !1
            }), _dec8$9 = property({
                type: AlignMode
            }), _dec$1c(_class$1e = _dec2$P(_class$1e = _dec3$z(_class$1e = _dec4$u(_class$1e = executeInEditMode((_temp$17 = _class3$v = function() {
                function WidgetComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, WidgetComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WidgetComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._lastPos = new Vec3(), 
                    _this._lastSize = new Size(), _this._dirty = !0, _initializerDefineProperty(_this, "_alignFlags", _descriptor$X, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_target", _descriptor2$N, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_left", _descriptor3$y, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_right", _descriptor4$t, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_top", _descriptor5$n, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_bottom", _descriptor6$e, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_horizontalCenter", _descriptor7$c, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_verticalCenter", _descriptor8$c, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_isAbsLeft", _descriptor9$a, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_isAbsRight", _descriptor10$8, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_isAbsTop", _descriptor11$7, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_isAbsBottom", _descriptor12$6, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_isAbsHorizontalCenter", _descriptor13$6, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_isAbsVerticalCenter", _descriptor14$6, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_originalWidth", _descriptor15$2, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_originalHeight", _descriptor16$2, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_alignMode", _descriptor17$1, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(WidgetComponent, Component), _createClass(WidgetComponent, [ {
                    key: "updateAlignment",
                    value: function updateAlignment() {
                        cc._widgetManager.updateAlignment(this.node);
                    }
                }, {
                    key: "_validateTargetInDEV",
                    value: function _validateTargetInDEV() {
                    }
                }, {
                    key: "setDirty",
                    value: function setDirty() {
                        this._recursiveDirty();
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        this.node.getPosition(this._lastPos), this.node.getContentSize(this._lastSize), 
                        cc._widgetManager.add(this), this._registerEvent(), this._registerTargetEvents();
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        cc._widgetManager.remove(this), this._unregisterEvent(), this._unregisterTargetEvents();
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this._removeParentEvent();
                    }
                }, {
                    key: "_adjustWidgetToAllowMovingInEditor",
                    value: function _adjustWidgetToAllowMovingInEditor(eventType) {
                        if (eventType === SystemEventType.POSITION_PART && !cc._widgetManager.isAligning) {
                            var newPos = this.node.getPosition(), oldPos = this._lastPos, delta = new Vec3(newPos);
                            delta.subtract(oldPos);
                            var target = this.node.parent, inverseScale = new Vec3(1, 1, 1);
                            if (this.target && (target = this.target, computeInverseTransForTarget(this.node, target, new Vec3(), inverseScale)), 
                            target) {
                                var targetSize = getReadonlyNodeSize(target), deltaInPercent = new Vec3();
                                0 !== targetSize.width && 0 !== targetSize.height && Vec3.set(deltaInPercent, delta.x / targetSize.width * 100, delta.y / targetSize.height * 100, deltaInPercent.z), 
                                this.isAlignTop && (this.top -= (this.isAbsoluteTop ? delta.y : deltaInPercent.y) * inverseScale.y), 
                                this.isAlignBottom && (this.bottom += (this.isAbsoluteBottom ? delta.y : deltaInPercent.y) * inverseScale.y), 
                                this.isAlignLeft && (this.left += (this.isAbsoluteLeft ? delta.x : deltaInPercent.x) * inverseScale.x), 
                                this.isAlignRight && (this.right -= (this.isAbsoluteRight ? delta.x : deltaInPercent.x) * inverseScale.x), 
                                this.isAlignHorizontalCenter && (this.horizontalCenter += (this.isAbsoluteHorizontalCenter ? delta.x : deltaInPercent.x) * inverseScale.x), 
                                this.isAlignVerticalCenter && (this.verticalCenter += (this.isAbsoluteVerticalCenter ? delta.y : deltaInPercent.y) * inverseScale.y);
                            }
                        }
                    }
                }, {
                    key: "_adjustWidgetToAllowResizingInEditor",
                    value: function _adjustWidgetToAllowResizingInEditor() {
                        if (!cc._widgetManager.isAligning) {
                            this.setDirty();
                            var newSize = this.node.getContentSize(), oldSize = this._lastSize, delta = new Vec3(newSize.width - oldSize.width, newSize.height - oldSize.height, 0), target = this.node.parent, inverseScale = new Vec3(1, 1, 1);
                            if (this.target && (target = this.target, computeInverseTransForTarget(this.node, target, new Vec3(), inverseScale)), 
                            target) {
                                var targetSize = getReadonlyNodeSize(target), deltaInPercent = new Vec3();
                                0 !== targetSize.width && 0 !== targetSize.height && Vec3.set(deltaInPercent, delta.x / targetSize.width * 100, delta.y / targetSize.height * 100, deltaInPercent.z);
                                var anchor = this.node.getAnchorPoint();
                                this.isAlignTop && (this.top -= (this.isAbsoluteTop ? delta.y : deltaInPercent.y) * (1 - anchor.y) * inverseScale.y), 
                                this.isAlignBottom && (this.bottom -= (this.isAbsoluteBottom ? delta.y : deltaInPercent.y) * anchor.y * inverseScale.y), 
                                this.isAlignLeft && (this.left -= (this.isAbsoluteLeft ? delta.x : deltaInPercent.x) * anchor.x * inverseScale.x), 
                                this.isAlignRight && (this.right -= (this.isAbsoluteRight ? delta.x : deltaInPercent.x) * (1 - anchor.x) * inverseScale.x);
                            }
                        }
                    }
                }, {
                    key: "_adjustWidgetToAnchorChanged",
                    value: function _adjustWidgetToAnchorChanged() {
                        this.setDirty();
                    }
                }, {
                    key: "_adjustTargetToParentChanged",
                    value: function _adjustTargetToParentChanged(oldParent) {
                        oldParent && this._unregisterOldParentEvents(oldParent), this.node.getParent() && this._registerTargetEvents();
                    }
                }, {
                    key: "_registerEvent",
                    value: function _registerEvent() {
                        this.node.on(SystemEventType.TRANSFORM_CHANGED, this._adjustWidgetToAllowMovingInEditor, this), 
                        this.node.on(SystemEventType.SIZE_CHANGED, this._adjustWidgetToAllowResizingInEditor, this), 
                        this.node.on(SystemEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this), 
                        this.node.on(SystemEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
                    }
                }, {
                    key: "_unregisterEvent",
                    value: function _unregisterEvent() {
                        this.node.off(SystemEventType.TRANSFORM_CHANGED, this._adjustWidgetToAllowMovingInEditor, this), 
                        this.node.off(SystemEventType.SIZE_CHANGED, this._adjustWidgetToAllowResizingInEditor, this), 
                        this.node.off(SystemEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this);
                    }
                }, {
                    key: "_removeParentEvent",
                    value: function _removeParentEvent() {
                        this.node.off(SystemEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
                    }
                }, {
                    key: "_autoChangedValue",
                    value: function _autoChangedValue(flag, isAbs) {
                        if (0 < (this._alignFlags & flag) && this.node.parent && this.node.parent.uiTransfromComp) {
                            var size = this.node.parent.getContentSize();
                            this.isAlignLeft && flag === AlignFlags.LEFT ? this._left = isAbs ? this._left / 100 * size.width : 100 * this._left / size.width : this.isAlignRight && flag === AlignFlags.RIGHT ? this._right = isAbs ? this._right / 100 * size.width : 100 * this._right / size.width : this.isAlignHorizontalCenter && flag === AlignFlags.CENTER ? this._horizontalCenter = isAbs ? this._horizontalCenter / 100 * size.width : 100 * this._horizontalCenter / size.width : this.isAlignTop && flag === AlignFlags.TOP ? this._top = isAbs ? this._top / 100 * size.height : 100 * this._top / size.height : this.isAlignBottom && flag === AlignFlags.BOT ? this._bottom = isAbs ? this._bottom / 100 * size.height : 100 * this._bottom / size.height : this.isAbsoluteVerticalCenter && flag === AlignFlags.MID && (this._verticalCenter = isAbs ? this._verticalCenter / 100 * size.height : 100 * this._verticalCenter / size.height), 
                            this._recursiveDirty();
                        }
                    }
                }, {
                    key: "_registerTargetEvents",
                    value: function _registerTargetEvents() {
                        var target = this._target || this.node.parent;
                        target && (target.getComponent(UITransformComponent) ? (target.on(SystemEventType.TRANSFORM_CHANGED, this._targetChangedOperation, this), 
                        target.on(SystemEventType.SIZE_CHANGED, this._targetChangedOperation, this)) : cc.warnID(6501, this.node.name));
                    }
                }, {
                    key: "_unregisterTargetEvents",
                    value: function _unregisterTargetEvents() {
                        var target = this._target || this.node.parent;
                        target && (target.off(SystemEventType.TRANSFORM_CHANGED, this._targetChangedOperation, this), 
                        target.off(SystemEventType.SIZE_CHANGED, this._targetChangedOperation, this));
                    }
                }, {
                    key: "_unregisterOldParentEvents",
                    value: function _unregisterOldParentEvents(oldParent) {
                        var target = this._target || oldParent;
                        target && (target.off(SystemEventType.TRANSFORM_CHANGED, this._targetChangedOperation, this), 
                        target.off(SystemEventType.SIZE_CHANGED, this._targetChangedOperation, this));
                    }
                }, {
                    key: "_targetChangedOperation",
                    value: function _targetChangedOperation() {
                        this._recursiveDirty();
                    }
                }, {
                    key: "_setAlign",
                    value: function _setAlign(flag, isAlign) {
                        if (isAlign !== 0 < (this._alignFlags & flag)) {
                            var isHorizontal = 0 < (flag & LEFT_RIGHT);
                            isAlign ? (this._alignFlags |= flag, isHorizontal ? (this.isAlignHorizontalCenter = !1, 
                            this.isStretchWidth && (this._originalWidth = this.node.width)) : (this.isAlignVerticalCenter = !1, 
                            this.isStretchHeight && (this._originalHeight = this.node.height))) : (isHorizontal ? this.isStretchWidth && (this.node.width = this._originalWidth) : this.isStretchHeight && (this.node.height = this._originalHeight), 
                            this._alignFlags &= ~flag);
                        }
                    }
                }, {
                    key: "_recursiveDirty",
                    value: function _recursiveDirty() {
                        this._dirty || (this._dirty = !0);
                    }
                }, {
                    key: "target",
                    get: function get() {
                        return this._target;
                    },
                    set: function set(value) {
                        this._target !== value && (this._unregisterTargetEvents(), this._target = value, 
                        this._registerTargetEvents(), this._validateTargetInDEV(), this._recursiveDirty());
                    }
                }, {
                    key: "isAlignTop",
                    get: function get() {
                        return 0 < (this._alignFlags & AlignFlags.TOP);
                    },
                    set: function set(value) {
                        this._setAlign(AlignFlags.TOP, value), this._recursiveDirty();
                    }
                }, {
                    key: "isAlignBottom",
                    get: function get() {
                        return 0 < (this._alignFlags & AlignFlags.BOT);
                    },
                    set: function set(value) {
                        this._setAlign(AlignFlags.BOT, value), this._recursiveDirty();
                    }
                }, {
                    key: "isAlignLeft",
                    get: function get() {
                        return 0 < (this._alignFlags & AlignFlags.LEFT);
                    },
                    set: function set(value) {
                        this._setAlign(AlignFlags.LEFT, value), this._recursiveDirty();
                    }
                }, {
                    key: "isAlignRight",
                    get: function get() {
                        return 0 < (this._alignFlags & AlignFlags.RIGHT);
                    },
                    set: function set(value) {
                        this._setAlign(AlignFlags.RIGHT, value), this._recursiveDirty();
                    }
                }, {
                    key: "isAlignVerticalCenter",
                    get: function get() {
                        return 0 < (this._alignFlags & AlignFlags.MID);
                    },
                    set: function set(value) {
                        value ? (this.isAlignTop = !1, this.isAlignBottom = !1, this._alignFlags |= AlignFlags.MID) : this._alignFlags &= ~AlignFlags.MID, 
                        this._recursiveDirty();
                    }
                }, {
                    key: "isAlignHorizontalCenter",
                    get: function get() {
                        return 0 < (this._alignFlags & AlignFlags.CENTER);
                    },
                    set: function set(value) {
                        value ? (this.isAlignLeft = !1, this.isAlignRight = !1, this._alignFlags |= AlignFlags.CENTER) : this._alignFlags &= ~AlignFlags.CENTER, 
                        this._recursiveDirty();
                    }
                }, {
                    key: "isStretchWidth",
                    get: function get() {
                        return (this._alignFlags & LEFT_RIGHT) == LEFT_RIGHT;
                    }
                }, {
                    key: "isStretchHeight",
                    get: function get() {
                        return (this._alignFlags & TOP_BOT) == TOP_BOT;
                    }
                }, {
                    key: "top",
                    get: function get() {
                        return this._top;
                    },
                    set: function set(value) {
                        this._top = value, this._recursiveDirty();
                    }
                }, {
                    key: "bottom",
                    get: function get() {
                        return this._bottom;
                    },
                    set: function set(value) {
                        this._bottom = value, this._recursiveDirty();
                    }
                }, {
                    key: "left",
                    get: function get() {
                        return this._left;
                    },
                    set: function set(value) {
                        this._left = value, this._recursiveDirty();
                    }
                }, {
                    key: "right",
                    get: function get() {
                        return this._right;
                    },
                    set: function set(value) {
                        this._right = value, this._recursiveDirty();
                    }
                }, {
                    key: "horizontalCenter",
                    get: function get() {
                        return this._horizontalCenter;
                    },
                    set: function set(value) {
                        this._horizontalCenter = value, this._recursiveDirty();
                    }
                }, {
                    key: "verticalCenter",
                    get: function get() {
                        return this._verticalCenter;
                    },
                    set: function set(value) {
                        this._verticalCenter = value, this._recursiveDirty();
                    }
                }, {
                    key: "isAbsoluteTop",
                    get: function get() {
                        return this._isAbsTop;
                    },
                    set: function set(value) {
                        this._isAbsTop !== value && (this._isAbsTop = value, this._autoChangedValue(AlignFlags.TOP, this._isAbsTop));
                    }
                }, {
                    key: "isAbsoluteBottom",
                    get: function get() {
                        return this._isAbsBottom;
                    },
                    set: function set(value) {
                        this._isAbsBottom !== value && (this._isAbsBottom = value, this._autoChangedValue(AlignFlags.BOT, this._isAbsBottom));
                    }
                }, {
                    key: "isAbsoluteLeft",
                    get: function get() {
                        return this._isAbsLeft;
                    },
                    set: function set(value) {
                        this._isAbsLeft !== value && (this._isAbsLeft = value, this._autoChangedValue(AlignFlags.LEFT, this._isAbsLeft));
                    }
                }, {
                    key: "isAbsoluteRight",
                    get: function get() {
                        return this._isAbsRight;
                    },
                    set: function set(value) {
                        this._isAbsRight !== value && (this._isAbsRight = value, this._autoChangedValue(AlignFlags.RIGHT, this._isAbsRight));
                    }
                }, {
                    key: "alignMode",
                    get: function get() {
                        return this._alignMode;
                    },
                    set: function set(value) {
                        this._alignMode = value, this._recursiveDirty();
                    }
                }, {
                    key: "isAbsoluteHorizontalCenter",
                    get: function get() {
                        return this._isAbsHorizontalCenter;
                    },
                    set: function set(value) {
                        this._isAbsHorizontalCenter !== value && (this._isAbsHorizontalCenter = value, this._autoChangedValue(AlignFlags.CENTER, this._isAbsHorizontalCenter));
                    }
                }, {
                    key: "isAbsoluteVerticalCenter",
                    get: function get() {
                        return this._isAbsVerticalCenter;
                    },
                    set: function set(value) {
                        this._isAbsVerticalCenter !== value && (this._isAbsVerticalCenter = value, this._autoChangedValue(AlignFlags.MID, this._isAbsVerticalCenter));
                    }
                }, {
                    key: "alignFlags",
                    get: function get() {
                        return this._alignFlags;
                    },
                    set: function set(value) {
                        this._alignFlags !== value && (this._alignFlags = value, this._recursiveDirty());
                    }
                } ]), WidgetComponent;
            }(), _class3$v.AlignMode = AlignMode, _applyDecoratedDescriptor((_class2$$ = _temp$17).prototype, "target", [ _dec5$r ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "target"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "isAlignTop", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "isAlignTop"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "isAlignBottom", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "isAlignBottom"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "isAlignLeft", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "isAlignLeft"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "isAlignRight", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "isAlignRight"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "isAlignVerticalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "isAlignVerticalCenter"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "isAlignHorizontalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "isAlignHorizontalCenter"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "isStretchWidth", [ _dec6$n ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "isStretchWidth"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "isStretchHeight", [ _dec7$h ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "isStretchHeight"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "top", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "top"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "bottom", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "bottom"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "left", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "left"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "right", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "right"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "horizontalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "horizontalCenter"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "verticalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "verticalCenter"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "isAbsoluteTop", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "isAbsoluteTop"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "isAbsoluteBottom", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "isAbsoluteBottom"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "isAbsoluteLeft", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "isAbsoluteLeft"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "isAbsoluteRight", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "isAbsoluteRight"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "alignMode", [ _dec8$9 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "alignMode"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "isAbsoluteHorizontalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "isAbsoluteHorizontalCenter"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "isAbsoluteVerticalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "isAbsoluteVerticalCenter"), _class2$$.prototype), 
            _applyDecoratedDescriptor(_class2$$.prototype, "alignFlags", [ property ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "alignFlags"), _class2$$.prototype), 
            _descriptor$X = _applyDecoratedDescriptor(_class2$$.prototype, "_alignFlags", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor2$N = _applyDecoratedDescriptor(_class2$$.prototype, "_target", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor3$y = _applyDecoratedDescriptor(_class2$$.prototype, "_left", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor4$t = _applyDecoratedDescriptor(_class2$$.prototype, "_right", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor5$n = _applyDecoratedDescriptor(_class2$$.prototype, "_top", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor6$e = _applyDecoratedDescriptor(_class2$$.prototype, "_bottom", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor7$c = _applyDecoratedDescriptor(_class2$$.prototype, "_horizontalCenter", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor8$c = _applyDecoratedDescriptor(_class2$$.prototype, "_verticalCenter", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor9$a = _applyDecoratedDescriptor(_class2$$.prototype, "_isAbsLeft", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor10$8 = _applyDecoratedDescriptor(_class2$$.prototype, "_isAbsRight", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor11$7 = _applyDecoratedDescriptor(_class2$$.prototype, "_isAbsTop", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor12$6 = _applyDecoratedDescriptor(_class2$$.prototype, "_isAbsBottom", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor13$6 = _applyDecoratedDescriptor(_class2$$.prototype, "_isAbsHorizontalCenter", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor14$6 = _applyDecoratedDescriptor(_class2$$.prototype, "_isAbsVerticalCenter", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor15$2 = _applyDecoratedDescriptor(_class2$$.prototype, "_originalWidth", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor16$2 = _applyDecoratedDescriptor(_class2$$.prototype, "_originalHeight", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor17$1 = _applyDecoratedDescriptor(_class2$$.prototype, "_alignMode", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return AlignMode.ALWAYS;
                }
            }), _class$1e = _class2$$)) || _class$1e) || _class$1e) || _class$1e) || _class$1e) || _class$1e));
            cc.WidgetComponent = WidgetComponent;
            var _dec$1e, _dec2$R, _dec3$B, _dec4$v, _dec5$s, _dec6$o, _class$1g, _class2$10, _descriptor$Y, _descriptor2$O, _descriptor3$z, _descriptor4$u, _class3$w, _temp$18, UIReorderComponent = exports("UIReorderComponent", ccclass("cc.UIReorderComponent")(_class$1f = menu("UI/Reorder")(_class$1f = executionOrder(110)(_class$1f = disallowMultiple(_class$1f = executeInEditMode(_class$1f = function() {
                function UIReorderComponent() {
                    return _classCallCheck(this, UIReorderComponent), _possibleConstructorReturn(this, _getPrototypeOf(UIReorderComponent).apply(this, arguments));
                }
                return _inherits(UIReorderComponent, UIComponent), UIReorderComponent;
            }()) || _class$1f) || _class$1f) || _class$1f) || _class$1f) || _class$1f);
            cc.UIReorderComponent = UIReorderComponent;
            var Direction$2, _color = new Color();
            !function(Direction) {
                Direction[Direction.HORIZONTAL = 0] = "HORIZONTAL", Direction[Direction.VERTICAL = 1] = "VERTICAL";
            }(Direction$2 = Direction$2 || {}), ccenum(Direction$2);
            var _dec$1f, _dec2$S, _dec3$C, _dec4$w, _dec5$t, _dec6$p, _dec7$i, _dec8$a, _dec9$8, _dec10$7, _dec11$6, _dec12$5, _dec13$2, _dec14$2, _dec15$2, _class$1h, _class2$11, _descriptor$Z, _descriptor2$P, _descriptor3$A, _descriptor4$v, _descriptor5$o, _descriptor6$f, _descriptor7$d, _descriptor8$d, _descriptor9$b, _descriptor10$9, _descriptor11$8, _descriptor12$7, _class3$x, _temp$19, PageViewIndicatorComponent = exports("PageViewIndicatorComponent", (_dec$1e = ccclass("cc.PageViewIndicatorComponent"), 
            _dec2$R = executionOrder(110), _dec3$B = menu("UI/PageViewIndicator"), _dec4$v = property({
                type: SpriteFrame
            }), _dec5$s = property({
                type: Direction$2
            }), _dec6$o = property({
                type: Size
            }), _dec$1e(_class$1g = _dec2$R(_class$1g = _dec3$B((_temp$18 = _class3$w = function() {
                function PageViewIndicatorComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, PageViewIndicatorComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(PageViewIndicatorComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "spacing", _descriptor$Y, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_spriteFrame", _descriptor2$O, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_direction", _descriptor3$z, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_cellSize", _descriptor4$u, _assertThisInitialized(_this)), 
                    _this._layout = null, _this._pageView = null, _this._indicators = [], _this;
                }
                return _inherits(PageViewIndicatorComponent, Component), _createClass(PageViewIndicatorComponent, [ {
                    key: "onLoad",
                    value: function onLoad() {
                        this._updateLayout();
                    }
                }, {
                    key: "setPageView",
                    value: function setPageView(target) {
                        this._pageView = target, this._refresh();
                    }
                }, {
                    key: "_updateLayout",
                    value: function _updateLayout() {
                        this._layout = this.getComponent(LayoutComponent), this._layout || (this._layout = this.addComponent(LayoutComponent));
                        var layout = this._layout;
                        this.direction === Direction$2.HORIZONTAL ? (layout.type = LayoutComponent.Type.HORIZONTAL, 
                        layout.spacingX = this.spacing) : this.direction === Direction$2.VERTICAL && (layout.type = LayoutComponent.Type.VERTICAL, 
                        layout.spacingY = this.spacing), layout.resizeMode = LayoutComponent.ResizeMode.CONTAINER;
                    }
                }, {
                    key: "_createIndicator",
                    value: function _createIndicator() {
                        var node = new Node$1();
                        return node.addComponent(SpriteComponent).spriteFrame = this.spriteFrame, node.parent = this.node, 
                        node.width = this.cellSize.width, node.height = this.cellSize.height, node;
                    }
                }, {
                    key: "_changedState",
                    value: function _changedState() {
                        var indicators = this._indicators;
                        if (0 !== indicators.length && this._pageView) {
                            var idx = this._pageView.curPageIdx;
                            if (!(idx >= indicators.length)) {
                                for (var i = 0; i < indicators.length; ++i) {
                                    var node = indicators[i];
                                    if (node._uiComp) {
                                        var uiComp = node._uiComp;
                                        _color.set(uiComp.color), _color.a = 127.5, uiComp.color = _color;
                                    }
                                }
                                if (indicators[idx]._uiComp) {
                                    var comp = indicators[idx]._uiComp;
                                    _color.set(comp.color), _color.a = 255, comp.color = _color;
                                }
                            }
                        }
                    }
                }, {
                    key: "_refresh",
                    value: function _refresh() {
                        if (this._pageView) {
                            var indicators = this._indicators, pages = this._pageView.getPages();
                            if (pages.length !== indicators.length) {
                                var i = 0;
                                if (pages.length > indicators.length) for (i = 0; i < pages.length; ++i) indicators[i] || (indicators[i] = this._createIndicator()); else for (i = indicators.length - pages.length; 0 < i; --i) {
                                    var node = indicators[i - 1];
                                    this.node.removeChild(node), indicators.splice(i - 1, 1);
                                }
                                this._layout && this._layout.enabledInHierarchy && this._layout.updateLayout(), 
                                this._changedState();
                            }
                        }
                    }
                }, {
                    key: "spriteFrame",
                    get: function get() {
                        return this._spriteFrame;
                    },
                    set: function set(value) {
                        this._spriteFrame !== value && (this._spriteFrame = value);
                    }
                }, {
                    key: "direction",
                    get: function get() {
                        return this._direction;
                    },
                    set: function set(value) {
                        this._direction !== value && (this._direction = value);
                    }
                }, {
                    key: "cellSize",
                    get: function get() {
                        return this._cellSize;
                    },
                    set: function set(value) {
                        this._cellSize !== value && (this._cellSize = value);
                    }
                } ]), PageViewIndicatorComponent;
            }(), _class3$w.Direction = Direction$2, _applyDecoratedDescriptor((_class2$10 = _temp$18).prototype, "spriteFrame", [ _dec4$v ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "spriteFrame"), _class2$10.prototype), 
            _applyDecoratedDescriptor(_class2$10.prototype, "direction", [ _dec5$s ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "direction"), _class2$10.prototype), 
            _applyDecoratedDescriptor(_class2$10.prototype, "cellSize", [ _dec6$o ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "cellSize"), _class2$10.prototype), 
            _descriptor$Y = _applyDecoratedDescriptor(_class2$10.prototype, "spacing", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor2$O = _applyDecoratedDescriptor(_class2$10.prototype, "_spriteFrame", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor3$z = _applyDecoratedDescriptor(_class2$10.prototype, "_direction", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Direction$2.HORIZONTAL;
                }
            }), _descriptor4$u = _applyDecoratedDescriptor(_class2$10.prototype, "_cellSize", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Size(20, 20);
                }
            }), _class$1g = _class2$10)) || _class$1g) || _class$1g) || _class$1g));
            cc.PageViewIndicatorComponent = PageViewIndicatorComponent;
            var SizeMode$1, Direction$3, PageViewEventType, _temp_vec2 = new Vec2();
            !function(SizeMode) {
                SizeMode[SizeMode.Unified = 0] = "Unified", SizeMode[SizeMode.Free = 1] = "Free";
            }(SizeMode$1 = SizeMode$1 || {}), ccenum(SizeMode$1), function(Direction) {
                Direction[Direction.Horizontal = 0] = "Horizontal", Direction[Direction.Vertical = 1] = "Vertical";
            }(Direction$3 = Direction$3 || {}), ccenum(Direction$3), function(PageViewEventType) {
                PageViewEventType[PageViewEventType.PAGE_TURNING = 0] = "PAGE_TURNING";
            }(PageViewEventType = PageViewEventType || {}), ccenum(PageViewEventType);
            var PageViewComponent = exports("PageViewComponent", (_dec$1f = ccclass("cc.PageViewComponent"), 
            _dec2$S = executionOrder(110), _dec3$C = menu("UI/PageView"), _dec4$w = property({
                type: SizeMode$1
            }), _dec5$t = property({
                type: Direction$3
            }), _dec6$p = property({
                slide: !0,
                range: [ 0, 1, .01 ]
            }), _dec7$i = property({
                slide: !0,
                range: [ 0, 1, .01 ]
            }), _dec8$a = property({
                type: PageViewIndicatorComponent
            }), _dec9$8 = property({
                type: ScrollBarComponent,
                visible: !1,
                override: !0
            }), _dec10$7 = property({
                type: ScrollBarComponent,
                visible: !1,
                override: !0
            }), _dec11$6 = property({
                visible: !1,
                override: !0
            }), _dec12$5 = property({
                visible: !1,
                override: !0
            }), _dec13$2 = property({
                visible: !1,
                override: !0
            }), _dec14$2 = property({
                visible: !1,
                override: !0,
                type: [ EventHandler ]
            }), _dec15$2 = property({
                type: [ EventHandler ]
            }), _dec$1f(_class$1h = _dec2$S(_class$1h = _dec3$C((_temp$19 = _class3$x = function() {
                function PageViewComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, PageViewComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(PageViewComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "autoPageTurningThreshold", _descriptor$Z, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "horizontal", _descriptor2$P, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "vertical", _descriptor3$A, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "cancelInnerEvents", _descriptor4$v, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "scrollEvents", _descriptor5$o, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "pageTurningSpeed", _descriptor6$f, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "pageEvents", _descriptor7$d, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_sizeMode", _descriptor8$d, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_direction", _descriptor9$b, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_scrollThreshold", _descriptor10$9, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_pageTurningEventTiming", _descriptor11$8, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_indicator", _descriptor12$7, _assertThisInitialized(_this)), 
                    _this._curPageIdx = 0, _this._lastPageIdx = 0, _this._pages = [], _this._initContentPos = new Vec3(), 
                    _this._scrollCenterOffsetX = [], _this._scrollCenterOffsetY = [], _this._touchBeganPosition = new Vec3(), 
                    _this._touchEndPosition = new Vec3(), _this;
                }
                return _inherits(PageViewComponent, ScrollViewComponent), _createClass(PageViewComponent, [ {
                    key: "__preload",
                    value: function __preload() {
                        this.node.on(SystemEventType.SIZE_CHANGED, this._updateAllPagesSize, this);
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        _get(_getPrototypeOf(PageViewComponent.prototype), "onEnable", this).call(this), 
                        this.node.on("scroll-ended-with-threshold", this._dispatchPageTurningEvent, this);
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        _get(_getPrototypeOf(PageViewComponent.prototype), "onDisable", this).call(this), 
                        this.node.off("scroll-ended-with-threshold", this._dispatchPageTurningEvent, this);
                    }
                }, {
                    key: "onLoad",
                    value: function onLoad() {
                        this._initPages(), this.indicator && this.indicator.setPageView(this);
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.node.off(SystemEventType.SIZE_CHANGED, this._updateAllPagesSize, this);
                    }
                }, {
                    key: "getCurrentPageIndex",
                    value: function getCurrentPageIndex() {
                        return this._curPageIdx;
                    }
                }, {
                    key: "setCurrentPageIndex",
                    value: function setCurrentPageIndex(index) {
                        this.scrollToPage(index, 1);
                    }
                }, {
                    key: "getPages",
                    value: function getPages() {
                        return this._pages;
                    }
                }, {
                    key: "addPage",
                    value: function addPage(page) {
                        page && -1 === this._pages.indexOf(page) && this.content && (this.content.addChild(page), 
                        this._pages.push(page), this._updatePageView());
                    }
                }, {
                    key: "insertPage",
                    value: function insertPage(page, index) {
                        index < 0 || !page || -1 !== this._pages.indexOf(page) || !this.content || (this._pages.length <= index ? this.addPage(page) : (this._pages.splice(index, 0, page), 
                        this.content.insertChild(page, index), this._updatePageView()));
                    }
                }, {
                    key: "removePage",
                    value: function removePage(page) {
                        if (page && this.content) {
                            var index = this._pages.indexOf(page);
                            -1 !== index ? this.removePageAtIndex(index) : warnID(4300, page.name);
                        }
                    }
                }, {
                    key: "removePageAtIndex",
                    value: function removePageAtIndex(index) {
                        var pageList = this._pages;
                        if (!(index < 0 || index >= pageList.length)) {
                            var page = pageList[index];
                            page && this.content && (this.content.removeChild(page), pageList.splice(index, 1), 
                            this._updatePageView());
                        }
                    }
                }, {
                    key: "removeAllPages",
                    value: function removeAllPages() {
                        if (this.content) {
                            for (var locPages = this._pages, i = 0, len = locPages.length; i < len; i++) this.content.removeChild(locPages[i]);
                            this._pages.length = 0, this._updatePageView();
                        }
                    }
                }, {
                    key: "scrollToPage",
                    value: function scrollToPage(idx, argument_1) {
                        var timeInSecond = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : 0;
                        idx < 0 || idx >= this._pages.length || (timeInSecond = void 0 !== timeInSecond ? timeInSecond : .3, 
                        this._curPageIdx = idx, this.scrollToOffset(this._moveOffsetValue(idx), timeInSecond, !0), 
                        this.indicator && this.indicator._changedState());
                    }
                }, {
                    key: "getScrollEndedEventTiming",
                    value: function getScrollEndedEventTiming() {
                        return this.pageTurningEventTiming;
                    }
                }, {
                    key: "_updatePageView",
                    value: function _updatePageView() {
                        var layout = this.content.getComponent(LayoutComponent);
                        layout && layout.enabled && layout.updateLayout();
                        var pageCount = this._pages.length;
                        this._curPageIdx >= pageCount && (this._curPageIdx = 0 === pageCount ? 0 : pageCount - 1, 
                        this._lastPageIdx = this._curPageIdx);
                        for (var contentPos = this._initContentPos, i = 0; i < pageCount; ++i) {
                            var pos = this._pages[i].position;
                            this.direction === Direction$3.Horizontal ? this._scrollCenterOffsetX[i] = Math.abs(contentPos.x + pos.x) : this._scrollCenterOffsetY[i] = Math.abs(contentPos.y + pos.y);
                        }
                        this.indicator && this.indicator._refresh();
                    }
                }, {
                    key: "_updateAllPagesSize",
                    value: function _updateAllPagesSize() {
                        if (this.content && this.view && this._sizeMode === SizeMode$1.Unified) for (var locPages = this._pages, selfSize = this.view.getContentSize(), i = 0, len = locPages.length; i < len; i++) locPages[i].setContentSize(selfSize);
                    }
                }, {
                    key: "_handleReleaseLogic",
                    value: function _handleReleaseLogic() {
                        this._autoScrollToPage(), this._scrolling && (this._scrolling = !1, this._autoScrolling || this._dispatchEvent("scroll-ended"));
                    }
                }, {
                    key: "_onTouchBegan",
                    value: function _onTouchBegan(event, captureListeners) {
                        event.touch.getUILocation(_temp_vec2), Vec3.set(this._touchBeganPosition, _temp_vec2.x, _temp_vec2.y, 0), 
                        _get(_getPrototypeOf(PageViewComponent.prototype), "_onTouchBegan", this).call(this, event, captureListeners);
                    }
                }, {
                    key: "_onTouchMoved",
                    value: function _onTouchMoved(event, captureListeners) {
                        _get(_getPrototypeOf(PageViewComponent.prototype), "_onTouchMoved", this).call(this, event, captureListeners);
                    }
                }, {
                    key: "_onTouchEnded",
                    value: function _onTouchEnded(event, captureListeners) {
                        event.touch.getUILocation(_temp_vec2), Vec3.set(this._touchEndPosition, _temp_vec2.x, _temp_vec2.y, 0), 
                        _get(_getPrototypeOf(PageViewComponent.prototype), "_onTouchEnded", this).call(this, event, captureListeners);
                    }
                }, {
                    key: "_onTouchCancelled",
                    value: function _onTouchCancelled(event, captureListeners) {
                        event.touch.getUILocation(_temp_vec2), Vec3.set(this._touchEndPosition, _temp_vec2.x, _temp_vec2.y, 0), 
                        _get(_getPrototypeOf(PageViewComponent.prototype), "_onTouchCancelled", this).call(this, event, captureListeners);
                    }
                }, {
                    key: "_onMouseWheel",
                    value: function _onMouseWheel() {}
                }, {
                    key: "_syncScrollDirection",
                    value: function _syncScrollDirection() {
                        this.horizontal = this.direction === Direction$3.Horizontal, this.vertical = this.direction === Direction$3.Vertical;
                    }
                }, {
                    key: "_syncSizeMode",
                    value: function _syncSizeMode() {
                        var view = this.view;
                        if (this.content && view) {
                            var layout = this.content.getComponent(LayoutComponent);
                            if (layout) {
                                if (this._sizeMode === SizeMode$1.Free && 0 < this._pages.length) {
                                    var lastPage = this._pages[this._pages.length - 1];
                                    this.direction === Direction$3.Horizontal ? (layout.paddingLeft = (view.width - this._pages[0].width) / 2, 
                                    layout.paddingRight = (view.width - lastPage.width) / 2) : this.direction === Direction$3.Vertical && (layout.paddingTop = (view.height - this._pages[0].height) / 2, 
                                    layout.paddingBottom = (view.height - lastPage.height) / 2);
                                }
                                layout.updateLayout();
                            }
                        }
                    }
                }, {
                    key: "_initPages",
                    value: function _initPages() {
                        if (this.content) {
                            this._initContentPos = this.content.position;
                            for (var children = this.content.children, i = 0; i < children.length; ++i) {
                                var page = children[i];
                                0 <= this._pages.indexOf(page) || this._pages.push(page);
                            }
                            this._syncScrollDirection(), this._syncSizeMode(), this._updatePageView();
                        }
                    }
                }, {
                    key: "_dispatchPageTurningEvent",
                    value: function _dispatchPageTurningEvent() {
                        this._lastPageIdx !== this._curPageIdx && (this._lastPageIdx = this._curPageIdx, 
                        EventHandler.emitEvents(this.pageEvents, this, PageViewEventType.PAGE_TURNING), 
                        this.node.emit("page-turning", this));
                    }
                }, {
                    key: "_isQuicklyScrollable",
                    value: function _isQuicklyScrollable(touchMoveVelocity) {
                        if (this.direction === Direction$3.Horizontal) {
                            if (Math.abs(touchMoveVelocity.x) > this.autoPageTurningThreshold) return !0;
                        } else if (this.direction === Direction$3.Vertical && Math.abs(touchMoveVelocity.y) > this.autoPageTurningThreshold) return !0;
                        return !1;
                    }
                }, {
                    key: "_moveOffsetValue",
                    value: function _moveOffsetValue(idx) {
                        var offset = new Vec3();
                        if (this._sizeMode === SizeMode$1.Free) this.direction === Direction$3.Horizontal ? offset.x = this._scrollCenterOffsetX[idx] : this.direction === Direction$3.Vertical && (offset.y = this._scrollCenterOffsetY[idx]); else {
                            var view = this.view;
                            if (!view) return offset;
                            this.direction === Direction$3.Horizontal ? offset.x = idx * view.width : this.direction === Direction$3.Vertical && (offset.y = idx * view.height);
                        }
                        return offset;
                    }
                }, {
                    key: "_getDragDirection",
                    value: function _getDragDirection(moveOffset) {
                        return this._direction === Direction$3.Horizontal ? 0 === moveOffset.x ? 0 : 0 < moveOffset.x ? 1 : -1 : 0 === moveOffset.y ? 0 : moveOffset.y < 0 ? 1 : -1;
                    }
                }, {
                    key: "_isScrollable",
                    value: function _isScrollable(offset, index, nextIndex) {
                        if (this._sizeMode === SizeMode$1.Free) {
                            var curPageCenter = 0, nextPageCenter = 0;
                            if (this.direction === Direction$3.Horizontal) return curPageCenter = this._scrollCenterOffsetX[index], 
                            nextPageCenter = this._scrollCenterOffsetX[nextIndex], Math.abs(offset.x) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
                            if (this.direction === Direction$3.Vertical) return curPageCenter = this._scrollCenterOffsetY[index], 
                            nextPageCenter = this._scrollCenterOffsetY[nextIndex], Math.abs(offset.y) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
                        } else {
                            var view = this.view;
                            if (!view) return;
                            if (this.direction === Direction$3.Horizontal) return Math.abs(offset.x) >= view.width * this.scrollThreshold;
                            if (this.direction === Direction$3.Vertical) return Math.abs(offset.y) >= view.height * this.scrollThreshold;
                        }
                    }
                }, {
                    key: "_autoScrollToPage",
                    value: function _autoScrollToPage() {
                        var bounceBackStarted = this._startBounceBackIfNeeded(), moveOffset = new Vec3();
                        if (Vec3.subtract(moveOffset, this._touchBeganPosition, this._touchEndPosition), 
                        bounceBackStarted) {
                            var dragDirection = this._getDragDirection(moveOffset);
                            if (0 === dragDirection) return;
                            this._curPageIdx = 0 < dragDirection ? this._pages.length - 1 : 0, this.indicator && this.indicator._changedState();
                        } else {
                            var index = this._curPageIdx, nextIndex = index + this._getDragDirection(moveOffset), timeInSecond = this.pageTurningSpeed * Math.abs(index - nextIndex);
                            if (nextIndex < this._pages.length) {
                                if (this._isScrollable(moveOffset, index, nextIndex)) return void this.scrollToPage(nextIndex, timeInSecond);
                                var touchMoveVelocity = this._calculateTouchMoveVelocity();
                                if (this._isQuicklyScrollable(touchMoveVelocity)) return void this.scrollToPage(nextIndex, timeInSecond);
                            }
                            this.scrollToPage(index, timeInSecond);
                        }
                    }
                }, {
                    key: "sizeMode",
                    get: function get() {
                        return this._sizeMode;
                    },
                    set: function set(value) {
                        this._sizeMode !== value && (this._sizeMode = value, this._syncSizeMode());
                    }
                }, {
                    key: "direction",
                    get: function get() {
                        return this._direction;
                    },
                    set: function set(value) {
                        this._direction !== value && (this._direction = value, this._syncScrollDirection());
                    }
                }, {
                    key: "scrollThreshold",
                    get: function get() {
                        return this._scrollThreshold;
                    },
                    set: function set(value) {
                        this._scrollThreshold !== value && (this._scrollThreshold = value);
                    }
                }, {
                    key: "pageTurningEventTiming",
                    get: function get() {
                        return this._pageTurningEventTiming;
                    },
                    set: function set(value) {
                        this._pageTurningEventTiming !== value && (this._pageTurningEventTiming = value);
                    }
                }, {
                    key: "indicator",
                    get: function get() {
                        return this._indicator;
                    },
                    set: function set(value) {
                        this._indicator !== value && (this._indicator = value, this.indicator && this.indicator.setPageView(this));
                    }
                }, {
                    key: "curPageIdx",
                    get: function get() {
                        return this._curPageIdx;
                    }
                }, {
                    key: "verticalScrollBar",
                    get: function get() {
                        return this._verticalScrollBar;
                    }
                }, {
                    key: "horizontalScrollBar",
                    get: function get() {
                        return this._horizontalScrollBar;
                    }
                } ]), PageViewComponent;
            }(), _class3$x.SizeMode = SizeMode$1, _class3$x.Direction = Direction$3, _class3$x.EventType = PageViewEventType, 
            _applyDecoratedDescriptor((_class2$11 = _temp$19).prototype, "sizeMode", [ _dec4$w ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "sizeMode"), _class2$11.prototype), 
            _applyDecoratedDescriptor(_class2$11.prototype, "direction", [ _dec5$t ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "direction"), _class2$11.prototype), 
            _applyDecoratedDescriptor(_class2$11.prototype, "scrollThreshold", [ _dec6$p ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "scrollThreshold"), _class2$11.prototype), 
            _applyDecoratedDescriptor(_class2$11.prototype, "pageTurningEventTiming", [ _dec7$i ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "pageTurningEventTiming"), _class2$11.prototype), 
            _applyDecoratedDescriptor(_class2$11.prototype, "indicator", [ _dec8$a ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "indicator"), _class2$11.prototype), 
            _descriptor$Z = _applyDecoratedDescriptor(_class2$11.prototype, "autoPageTurningThreshold", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 100;
                }
            }), _applyDecoratedDescriptor(_class2$11.prototype, "verticalScrollBar", [ _dec9$8 ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "verticalScrollBar"), _class2$11.prototype), 
            _applyDecoratedDescriptor(_class2$11.prototype, "horizontalScrollBar", [ _dec10$7 ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "horizontalScrollBar"), _class2$11.prototype), 
            _descriptor2$P = _applyDecoratedDescriptor(_class2$11.prototype, "horizontal", [ _dec11$6 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor3$A = _applyDecoratedDescriptor(_class2$11.prototype, "vertical", [ _dec12$5 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor4$v = _applyDecoratedDescriptor(_class2$11.prototype, "cancelInnerEvents", [ _dec13$2 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor5$o = _applyDecoratedDescriptor(_class2$11.prototype, "scrollEvents", [ _dec14$2 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor6$f = _applyDecoratedDescriptor(_class2$11.prototype, "pageTurningSpeed", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return .3;
                }
            }), _descriptor7$d = _applyDecoratedDescriptor(_class2$11.prototype, "pageEvents", [ _dec15$2 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor8$d = _applyDecoratedDescriptor(_class2$11.prototype, "_sizeMode", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return SizeMode$1.Unified;
                }
            }), _descriptor9$b = _applyDecoratedDescriptor(_class2$11.prototype, "_direction", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Direction$3.Horizontal;
                }
            }), _descriptor10$9 = _applyDecoratedDescriptor(_class2$11.prototype, "_scrollThreshold", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return .5;
                }
            }), _descriptor11$8 = _applyDecoratedDescriptor(_class2$11.prototype, "_pageTurningEventTiming", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return .1;
                }
            }), _descriptor12$7 = _applyDecoratedDescriptor(_class2$11.prototype, "_indicator", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _class$1h = _class2$11)) || _class$1h) || _class$1h) || _class$1h));
            cc.PageViewComponent = PageViewComponent;
            var _tempPos$3 = new Vec3(), _defaultAnchor = new Vec2(), tInverseTranslate = new Vec3(), tInverseScale = new Vec3(1, 1, 1);
            function align(node, widget) {
                var target, hasTarget = widget.target, inverseTranslate = tInverseTranslate, inverseScale = tInverseScale;
                if (hasTarget ? computeInverseTransForTarget(node, target = hasTarget, inverseTranslate, inverseScale) : target = node.parent, 
                target.getComponent(UITransformComponent)) {
                    var targetSize = getReadonlyNodeSize(target), isScene = target instanceof Scene, targetAnchor = isScene ? _defaultAnchor : target.getAnchorPoint(), isRoot = isScene;
                    node.getPosition(_tempPos$3);
                    var x = _tempPos$3.x, y = _tempPos$3.y, anchor = node.getAnchorPoint(), scale = node.getScale();
                    if (widget.alignFlags & AlignFlags.HORIZONTAL) {
                        var localLeft = 0, localRight = 0, targetWidth = targetSize.width;
                        localRight = isRoot ? (localLeft = visibleRect.left.x, visibleRect.right.x) : (localLeft = -targetAnchor.x * targetWidth) + targetWidth, 
                        localLeft += widget.isAbsoluteLeft ? widget.left : widget.left / 100 * targetWidth, 
                        localRight -= widget.isAbsoluteRight ? widget.right : widget.right / 100 * targetWidth, 
                        hasTarget && (localLeft += inverseTranslate.x, localLeft *= inverseScale.x, localRight += inverseTranslate.x, 
                        localRight *= inverseScale.x);
                        var width = 0, anchorX = anchor.x, scaleX = scale.x;
                        if (scaleX < 0 && (anchorX = 1 - anchorX, scaleX = -scaleX), widget.isStretchWidth) width = localRight - localLeft, 
                        0 !== scaleX && (node.width = width / scaleX), x = localLeft + anchorX * width; else if (width = node.width * scaleX, 
                        widget.isAlignHorizontalCenter) {
                            var localHorizontalCenter = widget.isAbsoluteHorizontalCenter ? widget.horizontalCenter : widget.horizontalCenter / 100 * targetWidth, targetCenter = (.5 - targetAnchor.x) * targetSize.width;
                            hasTarget && (localHorizontalCenter *= inverseScale.x, targetCenter += inverseTranslate.x, 
                            targetCenter *= inverseScale.x), x = targetCenter + (anchorX - .5) * width + localHorizontalCenter;
                        } else x = widget.isAlignLeft ? localLeft + anchorX * width : localRight + (anchorX - 1) * width;
                        widget._lastSize.width = width;
                    }
                    if (widget.alignFlags & AlignFlags.VERTICAL) {
                        var localTop = 0, localBottom = 0, targetHeight = targetSize.height;
                        localTop = isRoot ? (localBottom = visibleRect.bottom.y, visibleRect.top.y) : (localBottom = -targetAnchor.y * targetHeight) + targetHeight, 
                        localBottom += widget.isAbsoluteBottom ? widget.bottom : widget.bottom / 100 * targetHeight, 
                        localTop -= widget.isAbsoluteTop ? widget.top : widget.top / 100 * targetHeight, 
                        hasTarget && (localBottom += inverseTranslate.y, localBottom *= inverseScale.y, 
                        localTop += inverseTranslate.y, localTop *= inverseScale.y);
                        var height = 0, anchorY = anchor.y, scaleY = scale.y;
                        if (scaleY < 0 && (anchorY = 1 - anchorY, scaleY = -scaleY), widget.isStretchHeight) height = localTop - localBottom, 
                        0 !== scaleY && (node.height = height / scaleY), y = localBottom + anchorY * height; else if (height = node.height * scaleY, 
                        widget.isAlignVerticalCenter) {
                            var localVerticalCenter = widget.isAbsoluteVerticalCenter ? widget.verticalCenter : widget.verticalCenter / 100 * targetHeight, targetMiddle = (.5 - targetAnchor.y) * targetSize.height;
                            hasTarget && (localVerticalCenter *= inverseScale.y, targetMiddle += inverseTranslate.y, 
                            targetMiddle *= inverseScale.y), y = targetMiddle + (anchorY - .5) * height + localVerticalCenter;
                        } else y = widget.isAlignBottom ? localBottom + anchorY * height : localTop + (anchorY - 1) * height;
                        widget._lastSize.height = height;
                    }
                    node.setPosition(x, y, _tempPos$3.z), Vec3.set(widget._lastPos, x, y, _tempPos$3.z);
                }
            }
            function refreshScene() {
                var scene = director.getScene();
                if (scene) {
                    if (widgetManager.isAligning = !0, widgetManager._nodesOrderDirty) activeWidgets.length = 0, 
                    function visitNode$1(node) {
                        var widget = node.getComponent(WidgetComponent);
                        widget && (align(node, widget), widget.alignMode !== AlignMode.ALWAYS ? widget.enabled = !1 : activeWidgets.push(widget));
                        var _iterator = node.children, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var child = _ref;
                            child.active && visitNode$1(child);
                        }
                    }(scene), widgetManager._nodesOrderDirty = !1; else {
                        var widget = null, iterator = widgetManager._activeWidgetsIterator;
                        for (iterator.i = 0; iterator.i < activeWidgets.length; ++iterator.i) (widget = activeWidgets[iterator.i])._dirty && (align(widget.node, widget), 
                        widget._dirty = !1);
                    }
                    widgetManager.isAligning = !1;
                }
            }
            var activeWidgets = [];
            var canvasList = [], widgetManager = exports("widgetManager", cc._widgetManager = {
                isAligning: !1,
                _nodesOrderDirty: !1,
                _activeWidgetsIterator: new array.MutableForwardIterator(activeWidgets),
                animationState: null,
                init: function init(director) {
                    director.on(Director.EVENT_AFTER_UPDATE, refreshScene), sys.isMobile ? window.addEventListener("resize", this.onResized.bind(this)) : View.instance.on("design-resolution-changed", this.onResized, this);
                },
                add: function add(widget) {
                    this._nodesOrderDirty = !0;
                    var renderComp = widget.node.getComponent(UIRenderComponent);
                    if (renderComp) {
                        var canvasComp = director.root.ui.getScreen(renderComp.visibility);
                        canvasComp && -1 === canvasList.indexOf(canvasComp) && (canvasList.push(canvasComp), 
                        canvasComp.node.on("design-resolution-changed", this.onResized, this));
                    }
                },
                remove: function remove(widget) {
                    this._activeWidgetsIterator.remove(widget);
                },
                onResized: function onResized() {
                    var scene = director.getScene();
                    scene && this.refreshWidgetOnResized(scene);
                },
                refreshWidgetOnResized: function refreshWidgetOnResized(node) {
                    if (Node$1.isNode(node)) {
                        var widget = node.getComponent(WidgetComponent);
                        if (widget && widget.alignFlags === AlignMode.ALWAYS) return;
                    }
                    var _iterator2 = node.children, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        var child = _ref2;
                        this.refreshWidgetOnResized(child);
                    }
                },
                updateOffsetsToStayPut: function updateOffsetsToStayPut(widget, e) {
                    function i(t, c) {
                        return 1e-10 < Math.abs(t - c) ? c : t;
                    }
                    var widgetNode = widget.node, widgetParent = widgetNode.parent;
                    if (widgetParent) {
                        var zero = new Vec3(), one = new Vec3(1, 1, 1);
                        if (widget.target && computeInverseTransForTarget(widgetNode, widgetParent = widget.target, zero, one), 
                        !e) return;
                        if (!widgetParent.getComponent(UITransformComponent)) return void cc.warnID(6501, widget.node.name);
                        var parentAP = widgetParent.getAnchorPoint(), matchSize = getReadonlyNodeSize(widgetParent), myAP = widgetNode.getAnchorPoint(), pos = widgetNode.getPosition(), alignFlags = AlignFlags, widgetNodeScale = widgetNode.getScale(), temp = 0;
                        if (e & alignFlags.LEFT) {
                            var l = -parentAP.x * matchSize.width;
                            l += zero.x, l *= one.x, temp = pos.x - myAP.x * widgetNode.width * widgetNodeScale.x - l, 
                            widget.isAbsoluteLeft || (temp /= matchSize.width), temp /= one.x, widget.left = i(widget.left, temp);
                        }
                        if (e & alignFlags.RIGHT) {
                            var r = (1 - parentAP.x) * matchSize.width;
                            r += zero.x, temp = (r *= one.x) - (pos.x + (1 - myAP.x) * widgetNode.width * widgetNodeScale.x), 
                            widget.isAbsoluteRight || (temp /= matchSize.width), temp /= one.x, widget.right = i(widget.right, temp);
                        }
                        if (e & alignFlags.TOP) {
                            var t = (1 - parentAP.y) * matchSize.height;
                            t += zero.y, temp = (t *= one.y) - (pos.y + (1 - myAP.y) * widgetNode.height * widgetNodeScale.y), 
                            widget.isAbsoluteTop || (temp /= matchSize.height), temp /= one.y, widget.top = i(widget.top, temp);
                        }
                        if (e & alignFlags.BOT) {
                            var b = -parentAP.y * matchSize.height;
                            b += zero.y, b *= one.y, temp = pos.y - myAP.y * widgetNode.height * widgetNodeScale.y - b, 
                            widget.isAbsoluteBottom || (temp /= matchSize.height), temp /= one.y, widget.bottom = i(widget.bottom, temp);
                        }
                    }
                },
                updateAlignment: function updateAlignment(node) {
                    var parent = node.parent;
                    parent && Node$1.isNode(parent) && updateAlignment(parent);
                    var widget = node.getComponent(WidgetComponent);
                    widget && parent && align(node, widget);
                },
                AlignMode: AlignMode,
                AlignFlags: AlignFlags
            });
            director.on(Director.EVENT_INIT, function() {
                widgetManager.init(director);
            });
            var Aim = function Aim(i, x, y) {
                _classCallCheck(this, Aim), this.i = void 0, this.x = void 0, this.y = void 0, this.prev = null, 
                this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1, 
                this.i = i, this.x = x, this.y = y;
            };
            function linkedList(datas, start, end, dim, clockwise) {
                var i = 0, last = null;
                if (clockwise === 0 < function signedArea(datas, start, end, dim) {
                    for (var sum = 0, i = start, j = end - dim; i < end; i += dim) sum += (datas[j] - datas[i]) * (datas[i + 1] + datas[j + 1]), 
                    j = i;
                    return sum;
                }(datas, start, end, dim)) for (i = start; i < end; i += dim) last = insertNode(i, datas[i], datas[i + 1], last); else for (i = end - dim; start <= i; i -= dim) last = insertNode(i, datas[i], datas[i + 1], last);
                return last && equals$1(last, last.next) && (removeNode(last), last = last.next), 
                last;
            }
            function filterPoints(start, argument_1) {
                var end = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : null;
                if (!start) return start;
                end = end || start;
                var p = start, again = !1;
                do {
                    if (again = !1, p.steiner || !equals$1(p, p.next) && 0 !== area(p.prev, p, p.next)) p = p.next; else {
                        if (removeNode(p), (p = end = p.prev) === p.next) return null;
                        again = !0;
                    }
                } while (again || p !== end);
                return end;
            }
            function earcutLinked(ear, triangles, dim, minX, minY, size, argument_6) {
                var pass = 6 < arguments.length && void 0 !== argument_6 ? argument_6 : 0;
                if (ear) {
                    !pass && size && !function indexCurve(start, minX, minY, size) {
                        var p = start;
                        for (;null === p.z && (p.z = zOrder(p.x, p.y, minX, minY, size)), p.prevZ = p.prev, 
                        p.nextZ = p.next, p = p.next, p !== start; ) ;
                        p.prevZ.nextZ = null, p.prevZ = null, function sortLinked(list) {
                            var i = 0, p = null, q = null, e = null, tail = null, numMerges = 0, pSize = 0, qSize = 0, inSize = 1;
                            do {
                                for (p = list, tail = list = null, numMerges = 0; p; ) {
                                    for (numMerges++, q = p, i = pSize = 0; i < inSize && (pSize++, q = q.nextZ); i++) ;
                                    for (qSize = inSize; 0 < pSize || 0 < qSize && q; ) 0 === pSize ? (q = (e = q).nextZ, 
                                    qSize--) : 0 !== qSize && q ? p.z <= q.z ? (p = (e = p).nextZ, pSize--) : (q = (e = q).nextZ, 
                                    qSize--) : (p = (e = p).nextZ, pSize--), tail ? tail.nextZ = e : list = e, e.prevZ = tail, 
                                    tail = e;
                                    p = q;
                                }
                                tail.nextZ = null, inSize *= 2;
                            } while (1 < numMerges);
                            return list;
                        }(p);
                    }(ear, minX, minY, size);
                    for (var stop = ear, prev = null, next = null; ear.prev !== ear.next; ) if (prev = ear.prev, 
                    next = ear.next, size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) triangles.push(prev.i / dim), 
                    triangles.push(ear.i / dim), triangles.push(next.i / dim), removeNode(ear), ear = next.next, 
                    stop = next.next; else if ((ear = next) === stop) {
                        pass ? 1 === pass ? earcutLinked(ear = cureLocalIntersections(ear, triangles, dim), triangles, dim, minX, minY, size, 2) : 2 === pass && splitEarcut(ear, triangles, dim, minX, minY, size) : earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
                        break;
                    }
                }
            }
            function isEar(ear) {
                var a = ear.prev, b = ear, c = ear.next;
                if (0 <= area(a, b, c)) return !1;
                for (var p = ear.next.next; p !== ear.prev; ) {
                    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && 0 <= area(p.prev, p, p.next)) return !1;
                    p = p.next;
                }
                return !0;
            }
            function isEarHashed(ear, minX, minY, size) {
                var a = ear.prev, b = ear, c = ear.next;
                if (0 <= area(a, b, c)) return !1;
                for (var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y, minZ = zOrder(minTX, minTY, minX, minY, size), maxZ = zOrder(maxTX, maxTY, minX, minY, size), p = ear.nextZ; p && p.z <= maxZ; ) {
                    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && 0 <= area(p.prev, p, p.next)) return !1;
                    p = p.nextZ;
                }
                for (p = ear.prevZ; p && p.z >= minZ; ) {
                    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && 0 <= area(p.prev, p, p.next)) return !1;
                    p = p.prevZ;
                }
                return !0;
            }
            function cureLocalIntersections(start, triangles, dim) {
                var p = start;
                do {
                    var a = p.prev, b = p.next.next;
                    !equals$1(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a) && (triangles.push(a.i / dim), 
                    triangles.push(p.i / dim), triangles.push(b.i / dim), removeNode(p), removeNode(p.next), 
                    p = start = b), p = p.next;
                } while (p !== start);
                return p;
            }
            function splitEarcut(start, triangles, dim, minX, minY, size) {
                var a = start;
                do {
                    for (var b = a.next.next; b !== a.prev; ) {
                        if (a.i !== b.i && isValidDiagonal(a, b)) {
                            var c = splitPolygon(a, b);
                            return a = filterPoints(a, a.next), c = filterPoints(c, c.next), earcutLinked(a, triangles, dim, minX, minY, size), 
                            void earcutLinked(c, triangles, dim, minX, minY, size);
                        }
                        b = b.next;
                    }
                    a = a.next;
                } while (a !== start);
            }
            function compareX(a, b) {
                return a.x - b.x;
            }
            function eliminateHole(hole, outerNode) {
                if (outerNode = function findHoleBridge(hole, outerNode) {
                    var p = outerNode, hx = hole.x, hy = hole.y, qx = -1 / 0, m = null;
                    do {
                        if (hy <= p.y && hy >= p.next.y) {
                            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                            if (x <= hx && qx < x) {
                                if ((qx = x) === hx) {
                                    if (hy === p.y) return p;
                                    if (hy === p.next.y) return p.next;
                                }
                                m = p.x < p.next.x ? p : p.next;
                            }
                        }
                        p = p.next;
                    } while (p !== outerNode);
                    if (!m) return null;
                    if (hx === qx) return m.prev;
                    var tan, stop = m, mx = m.x, my = m.y, tanMin = 1 / 0;
                    p = m.next;
                    for (;p !== stop; ) hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y) && ((tan = Math.abs(hy - p.y) / (hx - p.x)) < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole) && (m = p, 
                    tanMin = tan), p = p.next;
                    return m;
                }(hole, outerNode)) {
                    var b = splitPolygon(outerNode, hole);
                    filterPoints(b, b.next);
                }
            }
            function zOrder(x, y, minX, minY, size) {
                return (x = 1431655765 & ((x = 858993459 & ((x = 252645135 & ((x = 16711935 & ((x = 32767 * (x - minX) / size) | x << 8)) | x << 4)) | x << 2)) | x << 1)) | (y = 1431655765 & ((y = 858993459 & ((y = 252645135 & ((y = 16711935 & ((y = 32767 * (y - minY) / size) | y << 8)) | y << 4)) | y << 2)) | y << 1)) << 1;
            }
            function getLeftmost(start) {
                for (var p = start, leftmost = start; p.x < leftmost.x && (leftmost = p), (p = p.next) !== start; ) ;
                return leftmost;
            }
            function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
                return 0 <= (cx - px) * (ay - py) - (ax - px) * (cy - py) && 0 <= (ax - px) * (by - py) - (bx - px) * (ay - py) && 0 <= (bx - px) * (cy - py) - (cx - px) * (by - py);
            }
            function isValidDiagonal(a, b) {
                return a.next.i !== b.i && a.prev.i !== b.i && !function intersectsPolygon(a, b) {
                    var p = a;
                    do {
                        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return !0;
                        p = p.next;
                    } while (p !== a);
                    return !1;
                }(a, b) && locallyInside(a, b) && locallyInside(b, a) && function middleInside(a, b) {
                    var p = a, inside = !1, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
                    for (;p.y > py != p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x && (inside = !inside), 
                    p = p.next, p !== a; ) ;
                    return inside;
                }(a, b);
            }
            function area(p, q, r) {
                return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
            }
            function equals$1(p1, p2) {
                return p1.x === p2.x && p1.y === p2.y;
            }
            function intersects(p1, q1, p2, q2) {
                return !!(equals$1(p1, q1) && equals$1(p2, q2) || equals$1(p1, q2) && equals$1(p2, q1)) || 0 < area(p1, q1, p2) != 0 < area(p1, q1, q2) && 0 < area(p2, q2, p1) != 0 < area(p2, q2, q1);
            }
            function locallyInside(a, b) {
                return area(a.prev, a, a.next) < 0 ? 0 <= area(a, b, a.next) && 0 <= area(a, a.prev, b) : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
            }
            function splitPolygon(a, b) {
                var a2 = new Aim(a.i, a.x, a.y), b2 = new Aim(b.i, b.x, b.y), an = a.next, bp = b.prev;
                return (a.next = b).prev = a, (a2.next = an).prev = a2, (b2.next = a2).prev = b2, 
                (bp.next = b2).prev = bp, b2;
            }
            function insertNode(i, x, y, last) {
                var p = new Aim(i, x, y);
                return last ? (p.next = last.next, (p.prev = last).next.prev = p, last.next = p) : (p.prev = p).next = p, 
                p;
            }
            function removeNode(p) {
                p.next.prev = p.prev, p.prev.next = p.next, p.prevZ && (p.prevZ.nextZ = p.nextZ), 
                p.nextZ && (p.nextZ.prevZ = p.prevZ);
            }
            function earcut(datas, holeIndices, dim) {
                dim = dim || 3;
                var hasHoles = holeIndices ? holeIndices.length : 0, outerLen = hasHoles ? holeIndices[0] * dim : datas.length, outerNode = linkedList(datas, 0, outerLen, dim, !0), triangles = [];
                if (!outerNode) return triangles;
                var minX = 0, minY = 0, maxX = 0, maxY = 0, x = 0, y = 0, size = 0;
                if (hasHoles && (outerNode = function eliminateHoles(datas, holeIndices, outerNode, dim) {
                    var len, queue = [], i = 0, list = null;
                    for (i = 0, len = holeIndices.length; i < len; i++) (list = linkedList(datas, holeIndices[i] * dim, i < len - 1 ? holeIndices[i + 1] * dim : datas.length, dim, !1)) && (list === list.next && (list.steiner = !0), 
                    queue.push(getLeftmost(list)));
                    if (queue.sort(compareX), !outerNode) return outerNode;
                    for (i = 0; i < queue.length; i++) eliminateHole(queue[i], outerNode), outerNode = filterPoints(outerNode, outerNode.next);
                    return outerNode;
                }(datas, holeIndices, outerNode, dim)), datas.length > 80 * dim) {
                    minX = maxX = datas[0], minY = maxY = datas[1];
                    for (var i = dim; i < outerLen; i += dim) (x = datas[i]) < minX && (minX = x), (y = datas[i + 1]) < minY && (minY = y), 
                    maxX < x && (maxX = x), maxY < y && (maxY = y);
                    size = Math.max(maxX - minX, maxY - minY);
                }
                return earcutLinked(outerNode, triangles, dim, minX, minY, size), triangles;
            }
            var PI = Math.PI, min$2 = Math.min, max$3 = Math.max, cos$1 = Math.cos, sin = Math.sin, abs$1 = Math.abs, sign$1 = Math.sign, KAPPA90 = .5522847493;
            function ellipse(ctx, cx, cy, rx, ry) {
                ctx.moveTo(cx - rx, cy), ctx.bezierCurveTo(cx - rx, cy + ry * KAPPA90, cx - rx * KAPPA90, cy + ry, cx, cy + ry), 
                ctx.bezierCurveTo(cx + rx * KAPPA90, cy + ry, cx + rx, cy + ry * KAPPA90, cx + rx, cy), 
                ctx.bezierCurveTo(cx + rx, cy - ry * KAPPA90, cx + rx * KAPPA90, cy - ry, cx, cy - ry), 
                ctx.bezierCurveTo(cx - rx * KAPPA90, cy - ry, cx - rx, cy - ry * KAPPA90, cx - rx, cy), 
                ctx.close();
            }
            for (var Point = function() {
                function Point(x, y) {
                    var _this;
                    return _classCallCheck(this, Point), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Point).call(this, x, y))).dx = 0, 
                    _this.dy = 0, _this.dmx = 0, _this.dmy = 0, _this.flags = 0, _this.len = 0, _this.reset(), 
                    _this;
                }
                return _inherits(Point, Vec2), _createClass(Point, [ {
                    key: "reset",
                    value: function reset() {
                        this.dx = 0, this.dy = 0, this.dmx = 0, this.dmy = 0, this.flags = 0, this.len = 0;
                    }
                } ]), Point;
            }(), Path = function() {
                function Path() {
                    _classCallCheck(this, Path), this.closed = !1, this.nbevel = 0, this.complex = !0, 
                    this.points = [], this.reset();
                }
                return _createClass(Path, [ {
                    key: "reset",
                    value: function reset() {
                        this.closed = !1, this.nbevel = 0, this.complex = !0, this.points ? this.points.length = 0 : this.points = [];
                    }
                } ]), Path;
            }(), Impl = function() {
                function Impl() {
                    _classCallCheck(this, Impl), this.dataOffset = 0, this.updatePathOffset = !1, this.pathLength = 0, 
                    this.pathOffset = 0, this.paths = [], this.tessTol = .25, this.distTol = .01, this.fillColor = Color.WHITE.clone(), 
                    this.lineCap = LineCap.BUTT, this.strokeColor = Color.BLACK.clone(), this.lineJoin = LineJoin.MITER, 
                    this.lineWidth = 0, this.pointsOffset = 0, this._commandx = 0, this._commandy = 0, 
                    this._points = [], this._renderDatasPool = new RecyclePool(function() {
                        return new IARenderData();
                    }, 16), this._renderDatas = [], this._curPath = null;
                }
                return _createClass(Impl, [ {
                    key: "moveTo",
                    value: function moveTo(x, y) {
                        this.updatePathOffset && (this.pathOffset = this.pathLength, this.updatePathOffset = !1), 
                        this._addPath(), this.addPoint(x, y, PointFlags.PT_CORNER), this._commandx = x, 
                        this._commandy = y;
                    }
                }, {
                    key: "lineTo",
                    value: function lineTo(x, y) {
                        this.addPoint(x, y, PointFlags.PT_CORNER), this._commandx = x, this._commandy = y;
                    }
                }, {
                    key: "bezierCurveTo",
                    value: function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
                        var path = this._curPath, last = path.points[path.points.length - 1];
                        last && (last.x !== c1x || last.y !== c1y || c2x !== x || c2y !== y ? (function tesselateBezier(ctx, x1, y1, x2, y2, x3, y3, x4, y4, level, type) {
                            var x12, y12, x23, y23, x34, y34, x123, y123, x234, y234, x1234, y1234, dx, dy, d2, d3;
                            10 < level || (x34 = .5 * (x3 + x4), y34 = .5 * (y3 + y4), x123 = .5 * ((x12 = .5 * (x1 + x2)) + (x23 = .5 * (x2 + x3))), 
                            y123 = .5 * ((y12 = .5 * (y1 + y2)) + (y23 = .5 * (y2 + y3))), ((d2 = abs$1((x2 - x4) * (dy = y4 - y1) - (y2 - y4) * (dx = x4 - x1))) + (d3 = abs$1((x3 - x4) * dy - (y3 - y4) * dx))) * (d2 + d3) < ctx.tessTol * (dx * dx + dy * dy) ? ctx.addPoint(x4, y4, 0 === type ? type | PointFlags.PT_BEVEL : type) : (tesselateBezier(ctx, x1, y1, x12, y12, x123, y123, x1234 = .5 * (x123 + (x234 = .5 * (x23 + x34))), y1234 = .5 * (y123 + (y234 = .5 * (y23 + y34))), level + 1, 0), 
                            tesselateBezier(ctx, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1, type)));
                        }(this, last.x, last.y, c1x, c1y, c2x, c2y, x, y, 0, PointFlags.PT_CORNER), this._commandx = x, 
                        this._commandy = y) : this.lineTo(x, y));
                    }
                }, {
                    key: "quadraticCurveTo",
                    value: function quadraticCurveTo(cx, cy, x, y) {
                        var x0 = this._commandx, y0 = this._commandy;
                        this.bezierCurveTo(x0 + 2 / 3 * (cx - x0), y0 + 2 / 3 * (cy - y0), x + 2 / 3 * (cx - x), y + 2 / 3 * (cy - y), x, y);
                    }
                }, {
                    key: "arc",
                    value: function arc$1(cx, cy, r, startAngle, endAngle, counterclockwise) {
                        !function arc(ctx, cx, cy, r, startAngle, endAngle, counterclockwise) {
                            var hda, ndivs, a = 0, da = 0, kappa = 0, dx = 0, dy = 0, x = 0, y = 0, tanx = 0, tany = 0, px = 0, py = 0, ptanx = 0, ptany = 0, i = 0;
                            if (da = endAngle - startAngle, counterclockwise = counterclockwise || !1) if (abs$1(da) >= 2 * PI) da = 2 * PI; else for (;da < 0; ) da += 2 * PI; else if (abs$1(da) >= 2 * PI) da = 2 * -PI; else for (;0 < da; ) da -= 2 * PI;
                            for (ndivs = 0 | max$3(1, min$2(abs$1(da) / (.5 * PI) + .5, 5)), kappa = abs$1(4 / 3 * (1 - cos$1(hda = da / ndivs / 2)) / sin(hda)), 
                            counterclockwise || (kappa = -kappa), i = 0; i <= ndivs; i++) x = cx + (dx = cos$1(a = startAngle + da * (i / ndivs))) * r, 
                            y = cy + (dy = sin(a)) * r, tanx = -dy * r * kappa, tany = dx * r * kappa, 0 === i ? ctx.moveTo(x, y) : ctx.bezierCurveTo(px + ptanx, py + ptany, x - tanx, y - tany, x, y), 
                            px = x, py = y, ptanx = tanx, ptany = tany;
                        }(this, cx, cy, r, startAngle, endAngle, counterclockwise);
                    }
                }, {
                    key: "ellipse",
                    value: function ellipse$1(cx, cy, rx, ry) {
                        ellipse(this, cx, cy, rx, ry), this._curPath.complex = !1;
                    }
                }, {
                    key: "circle",
                    value: function circle(cx, cy, r) {
                        ellipse(this, cx, cy, r, r), this._curPath.complex = !1;
                    }
                }, {
                    key: "rect",
                    value: function rect(x, y, w, h) {
                        this.moveTo(x, y), this.lineTo(x + w, y), this.lineTo(x + w, y + h), this.lineTo(x, y + h), 
                        this.close(), this._curPath.complex = !1;
                    }
                }, {
                    key: "roundRect",
                    value: function roundRect$1(x, y, w, h, r) {
                        !function roundRect(ctx, x, y, w, h, r) {
                            if (r < .1) ctx.rect(x, y, w, h); else {
                                var rx = min$2(r, .5 * abs$1(w)) * sign$1(w), ry = min$2(r, .5 * abs$1(h)) * sign$1(h);
                                ctx.moveTo(x, y + ry), ctx.lineTo(x, y + h - ry), ctx.bezierCurveTo(x, y + h - ry * (1 - KAPPA90), x + rx * (1 - KAPPA90), y + h, x + rx, y + h), 
                                ctx.lineTo(x + w - rx, y + h), ctx.bezierCurveTo(x + w - rx * (1 - KAPPA90), y + h, x + w, y + h - ry * (1 - KAPPA90), x + w, y + h - ry), 
                                ctx.lineTo(x + w, y + ry), ctx.bezierCurveTo(x + w, y + ry * (1 - KAPPA90), x + w - rx * (1 - KAPPA90), y, x + w - rx, y), 
                                ctx.lineTo(x + rx, y), ctx.bezierCurveTo(x + rx * (1 - KAPPA90), y, x, y + ry * (1 - KAPPA90), x, y + ry), 
                                ctx.close();
                            }
                        }(this, x, y, w, h, r), this._curPath.complex = !1;
                    }
                }, {
                    key: "clear",
                    value: function clear(argument_0) {
                        var clean = 0 < arguments.length && void 0 !== argument_0 && argument_0;
                        this.pathLength = 0, this.pathOffset = 0, this.pointsOffset = 0, this.dataOffset = 0, 
                        this._curPath = null, this.paths.length = 0, this._points.length = 0;
                        for (var datas = this._renderDatas, i = 0, l = datas.length; i < l; i++) {
                            var data = datas[i];
                            data && data.reset();
                        }
                        this._renderDatas.length = 0, clean && this._renderDatasPool.reset();
                    }
                }, {
                    key: "close",
                    value: function close() {
                        this._curPath.closed = !0;
                    }
                }, {
                    key: "requestRenderData",
                    value: function requestRenderData() {
                        var renderData = this._renderDatasPool.add();
                        return this._renderDatas.push(renderData), renderData;
                    }
                }, {
                    key: "getRenderDatas",
                    value: function getRenderDatas() {
                        return 0 === this._renderDatas.length && this.requestRenderData(), this._renderDatas;
                    }
                }, {
                    key: "addPoint",
                    value: function addPoint(x, y, flags) {
                        var path = this._curPath;
                        if (path) {
                            var points = this._points, pathPoints = path.points, pt = points[this.pointsOffset++];
                            pt ? (pt.x = x, pt.y = y) : (pt = new Point(x, y), points.push(pt)), pt.flags = flags, 
                            pathPoints.push(pt);
                        }
                    }
                }, {
                    key: "_addPath",
                    value: function _addPath() {
                        var offset = this.pathLength, path = this.paths[offset];
                        return path ? path.reset() : (path = new Path(), this.paths.push(path)), this.pathLength++, 
                        this._curPath = path;
                    }
                } ]), Impl;
            }(), PI$1 = Math.PI, min$3 = Math.min, max$4 = Math.max, ceil = Math.ceil, acos$1 = Math.acos, cos$2 = Math.cos, sin$1 = Math.sin, atan2 = Math.atan2, attrs = vfmt, positions = [], uvs = [], colors$1 = [], indices = [], _renderData = null, _impl = null, _curColor = new Color(), vec3_temps = [], i$2 = 0; i$2 < 4; i$2++) vec3_temps.push(new Vec3());
            function clamp$1(v, minNum, maxNum) {
                return v < minNum ? minNum : maxNum < v ? maxNum : v;
            }
            var graphicsAssembler = exports("graphics", {
                useModel: !0,
                createImpl: function createImpl() {
                    return new Impl();
                },
                updateRenderData: function updateRenderData(graphics) {
                    for (var datas = graphics.impl ? graphics.impl.getRenderDatas() : [], _i = 0, l = datas.length; _i < l; _i++) datas[_i].material = graphics.material;
                },
                fillBuffers: function fillBuffers() {},
                renderIA: function renderIA() {},
                getRenderData: function getRenderData(graphics, cverts) {
                    if (!_impl) return null;
                    var renderDatas = _impl.getRenderDatas(), renderData = renderDatas[_impl.dataOffset];
                    if (!renderData) return null;
                    var meshbuffer = renderData, maxVertsCount = meshbuffer ? meshbuffer.vertexCount + cverts : 0;
                    return (65535 < maxVertsCount || 131070 < 3 * maxVertsCount) && (++_impl.dataOffset, 
                    _impl.dataOffset < renderDatas.length ? renderData = renderDatas[_impl.dataOffset] : (renderData = _impl.requestRenderData(), 
                    renderDatas[_impl.dataOffset] = renderData), renderData.material = graphics.material, 
                    meshbuffer = renderData), meshbuffer && meshbuffer.vertexCount < maxVertsCount && meshbuffer.request(cverts, 3 * cverts), 
                    renderData;
                },
                stroke: function stroke(graphics) {
                    Color.copy(_curColor, graphics.strokeColor), graphics.impl && (this._flattenPaths(graphics.impl), 
                    this._expandStroke(graphics), graphics.impl.updatePathOffset = !0, this.end(graphics));
                },
                fill: function fill(graphics) {
                    Color.copy(_curColor, graphics.fillColor), this._expandFill(graphics), graphics.impl && (graphics.impl.updatePathOffset = !0), 
                    this.end(graphics);
                },
                end: function end(graphics) {
                    var scene = director.root.ui.renderScene;
                    graphics.model && (graphics.model.destroy(), scene.destroyModel(graphics.model), 
                    graphics.model = null);
                    var impl = graphics.impl, primitiveMode = GFXPrimitiveMode.TRIANGLE_LIST, renderDatas = impl && impl.getRenderDatas();
                    if (renderDatas) {
                        var i = 0;
                        positions.length = 0, uvs.length = 0, colors$1.length = 0, indices.length = 0;
                        var _iterator = renderDatas, _isArray = Array.isArray(_iterator), _i2 = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i2 >= _iterator.length) break;
                                _ref = _iterator[_i2++];
                            } else {
                                if ((_i2 = _iterator.next()).done) break;
                                _ref = _i2.value;
                            }
                            var renderData = _ref, len = renderData.byteCount >> 2, vData = renderData.vData;
                            for (i = 0; i < len; ) positions.push(vData[i++]), positions.push(vData[i++]), positions.push(vData[i++]), 
                            uvs.push(vData[i++]), uvs.push(vData[i++]), colors$1.push(vData[i++]), colors$1.push(vData[i++]), 
                            colors$1.push(vData[i++]), colors$1.push(vData[i++]);
                            len = renderData.indiceCount;
                            var iData = renderData.iData;
                            for (i = 0; i < len; ) indices.push(iData[i++]);
                        }
                        var mesh = createMesh({
                            primitiveMode: primitiveMode,
                            positions: positions,
                            uvs: uvs,
                            colors: colors$1,
                            attributes: attrs,
                            indices: indices
                        }, void 0, {
                            calculateBounds: !1
                        });
                        graphics.model = scene.createModel(Model, graphics.node), graphics.model.initSubModel(0, mesh.getSubMesh(0), graphics.material), 
                        graphics.model.enabled = !0, graphics.markForUpdateRenderData();
                    }
                },
                _expandStroke: function _expandStroke(graphics) {
                    var w = .5 * graphics.lineWidth, lineCap = graphics.lineCap, lineJoin = graphics.lineJoin, miterLimit = graphics.miterLimit;
                    if (_impl = graphics.impl) {
                        var ncap = function curveDivs(r, arc, tol) {
                            var da = 2 * acos$1(r / (r + tol));
                            return max$4(2, ceil(arc / da));
                        }(w, PI$1, _impl.tessTol);
                        this._calculateJoins(_impl, w, lineJoin, miterLimit);
                        for (var paths = _impl.paths, cverts = 0, _i3 = _impl.pathOffset, l = _impl.pathLength; _i3 < l; _i3++) {
                            var path = paths[_i3], pointsLength = path.points.length;
                            lineJoin === LineJoin.ROUND ? cverts += 2 * (pointsLength + path.nbevel * (ncap + 2) + 1) : cverts += 2 * (pointsLength + 5 * path.nbevel + 1), 
                            path.closed || (lineCap === LineCap.ROUND ? cverts += 2 * (2 * ncap + 2) : cverts += 12);
                        }
                        var meshbuffer = _renderData = this.getRenderData(graphics, cverts);
                        if (meshbuffer) {
                            for (var vData = meshbuffer.vData, iData = meshbuffer.iData, _i4 = _impl.pathOffset, _l = _impl.pathLength; _i4 < _l; _i4++) {
                                var _path = paths[_i4], pts = _path.points, _pointsLength = pts.length, offset = meshbuffer.vertexStart, p0 = void 0, p1 = void 0, start = 0, end = 0, loop = _path.closed;
                                if (end = loop ? (p0 = pts[_pointsLength - 1], p1 = pts[0], start = 0, _pointsLength) : (p0 = pts[0], 
                                p1 = pts[1], _pointsLength - (start = 1)), !loop) {
                                    var dPos = new Point(p1.x, p1.y);
                                    dPos.subtract(p0), dPos.normalize();
                                    var dx = dPos.x, dy = dPos.y;
                                    lineCap === LineCap.BUTT ? this._buttCap(p0, dx, dy, w, 0) : lineCap === LineCap.SQUARE ? this._buttCap(p0, dx, dy, w, w) : lineCap === LineCap.ROUND && this._roundCapStart(p0, dx, dy, w, ncap);
                                }
                                for (var j = start; j < end; ++j) lineJoin === LineJoin.ROUND ? this._roundJoin(p0, p1, w, w, ncap) : 0 != (p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) ? this._bevelJoin(p0, p1, w, w) : (this._vset(p1.x + p1.dmx * w, p1.y + p1.dmy * w), 
                                this._vset(p1.x - p1.dmx * w, p1.y - p1.dmy * w)), p0 = p1, p1 = pts[j + 1];
                                if (loop) {
                                    var vDataoOfset = 9 * offset, data = vData.slice(vDataoOfset, vDataoOfset + 9);
                                    vData.set(data, 9 * meshbuffer.vertexStart), vDataoOfset += 9, meshbuffer.vertexStart++, 
                                    data = vData.slice(vDataoOfset, vDataoOfset + 9), vData.set(data, 9 * meshbuffer.vertexStart), 
                                    meshbuffer.vertexStart++;
                                } else {
                                    var _dPos = new Point(p1.x, p1.y);
                                    _dPos.subtract(p0), _dPos.normalize();
                                    var _dx = _dPos.x, _dy = _dPos.y;
                                    lineCap === LineCap.BUTT ? this._buttCap(p1, _dx, _dy, w, 0) : lineCap === LineCap.SQUARE ? this._buttCap(p1, _dx, _dy, w, w) : lineCap === LineCap.ROUND && this._roundCapEnd(p1, _dx, _dy, w, ncap);
                                }
                                for (var indicesOffset = meshbuffer.indiceStart, begin = offset + 2, over = meshbuffer.vertexStart; begin < over; begin++) iData[indicesOffset++] = begin - 2, 
                                iData[indicesOffset++] = begin - 1, iData[indicesOffset++] = begin;
                                if ((meshbuffer.indiceStart = indicesOffset) !== meshbuffer.indiceCount) {
                                    var arr = new Array(meshbuffer.indiceCount - indicesOffset);
                                    meshbuffer.iData.set(arr, indicesOffset);
                                }
                            }
                            _impl = _renderData = null;
                        }
                    }
                },
                _expandFill: function _expandFill(graphics) {
                    if (_impl = graphics.impl) {
                        for (var paths = _impl.paths, cverts = 0, _i5 = _impl.pathOffset, l = _impl.pathLength; _i5 < l; _i5++) {
                            cverts += paths[_i5].points.length;
                        }
                        var renderData = _renderData = this.getRenderData(graphics, cverts);
                        if (renderData) {
                            for (var meshbuffer = renderData, vData = meshbuffer.vData, iData = meshbuffer.iData, _i6 = _impl.pathOffset, _l2 = _impl.pathLength; _i6 < _l2; _i6++) {
                                var _path2 = paths[_i6], pts = _path2.points, _pointsLength2 = pts.length;
                                if (0 !== _pointsLength2) {
                                    for (var vertexOffset = renderData.vertexStart, j = 0; j < _pointsLength2; ++j) this._vset(pts[j].x, pts[j].y);
                                    var indicesOffset = renderData.indiceStart;
                                    if (_path2.complex) {
                                        for (var earcutData = [], _j = vertexOffset, end = renderData.vertexStart; _j < end; _j++) {
                                            var vDataOffset = 9 * _j;
                                            earcutData.push(vData[vDataOffset++]), earcutData.push(vData[vDataOffset++]), earcutData.push(vData[vDataOffset++]);
                                        }
                                        var newIndices = earcut(earcutData, null, 3);
                                        if (!newIndices || 0 === newIndices.length) continue;
                                        for (var _j2 = 0, nIndices = newIndices.length; _j2 < nIndices; _j2++) iData[indicesOffset++] = newIndices[_j2] + vertexOffset;
                                    } else for (var first = vertexOffset, start = vertexOffset + 2, _end = meshbuffer.vertexStart; start < _end; start++) iData[indicesOffset++] = first, 
                                    iData[indicesOffset++] = start - 1, iData[indicesOffset++] = start;
                                    if ((meshbuffer.indiceStart = indicesOffset) !== meshbuffer.indiceCount) {
                                        var arr = new Array(meshbuffer.indiceCount - indicesOffset);
                                        meshbuffer.iData.set(arr, indicesOffset);
                                    }
                                }
                            }
                            _impl = _renderData = null;
                        }
                    }
                },
                _calculateJoins: function _calculateJoins(impl, w, lineJoin, miterLimit) {
                    var iw = 0;
                    0 < w && (iw = 1 / w);
                    for (var paths = impl.paths, _i7 = impl.pathOffset, l = impl.pathLength; _i7 < l; _i7++) for (var path = paths[_i7], pts = path.points, ptsLength = pts.length, p0 = pts[ptsLength - 1], p1 = pts[0], j = path.nbevel = 0; j < ptsLength; j++) {
                        var dmr2, limit, dlx0 = p0.dy, dly0 = -p0.dx, dlx1 = p1.dy, dly1 = -p1.dx;
                        if (p1.dmx = .5 * (dlx0 + dlx1), p1.dmy = .5 * (dly0 + dly1), 1e-6 < (dmr2 = p1.dmx * p1.dmx + p1.dmy * p1.dmy)) {
                            var scale = 1 / dmr2;
                            600 < scale && (scale = 600), p1.dmx *= scale, p1.dmy *= scale;
                        }
                        0 < p1.dx * p0.dy - p0.dx * p1.dy && (p1.flags |= PointFlags.PT_LEFT), dmr2 * (limit = max$4(11, min$3(p0.len, p1.len) * iw)) * limit < 1 && (p1.flags |= PointFlags.PT_INNERBEVEL), 
                        p1.flags & PointFlags.PT_CORNER && (dmr2 * miterLimit * miterLimit < 1 || lineJoin === LineJoin.BEVEL || lineJoin === LineJoin.ROUND) && (p1.flags |= PointFlags.PT_BEVEL), 
                        0 != (p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) && path.nbevel++, 
                        p0 = p1, p1 = pts[j + 1];
                    }
                },
                _flattenPaths: function _flattenPaths(impl) {
                    for (var paths = impl.paths, _i8 = impl.pathOffset, l = impl.pathLength; _i8 < l; _i8++) {
                        var path = paths[_i8], pts = path.points, p0 = pts[pts.length - 1], p1 = pts[0];
                        p0.equals(p1) && (path.closed = !0, pts.pop(), p0 = pts[pts.length - 1]);
                        for (var j = 0, size = pts.length; j < size; j++) {
                            var dPos = new Point(p1.x, p1.y);
                            dPos.subtract(p0), p0.len = dPos.length(), (dPos.x || dPos.y) && dPos.normalize(), 
                            p0.dx = dPos.x, p0.dy = dPos.y, p0 = p1, p1 = pts[j + 1];
                        }
                    }
                },
                _chooseBevel: function _chooseBevel(bevel, p0, p1, w) {
                    var x = p1.x, y = p1.y, x0 = 0, y0 = 0, x1 = 0, y1 = 0;
                    return 0 !== bevel ? (x0 = x + p0.dy * w, y0 = y - p0.dx * w, x1 = x + p1.dy * w, 
                    y1 = y - p1.dx * w) : (x0 = x1 = x + p1.dmx * w, y0 = y1 = y + p1.dmy * w), [ x0, y0, x1, y1 ];
                },
                _buttCap: function _buttCap(p, dx, dy, w, d) {
                    var px = p.x - dx * d, py = p.y - dy * d, dlx = dy, dly = -dx;
                    this._vset(px + dlx * w, py + dly * w), this._vset(px - dlx * w, py - dly * w);
                },
                _roundCapStart: function _roundCapStart(p, dx, dy, w, ncap) {
                    for (var px = p.x, py = p.y, dlx = dy, dly = -dx, _i9 = 0; _i9 < ncap; _i9++) {
                        var a = _i9 / (ncap - 1) * PI$1, ax = cos$2(a) * w, ay = sin$1(a) * w;
                        this._vset(px - dlx * ax - dx * ay, py - dly * ax - dy * ay), this._vset(px, py);
                    }
                    this._vset(px + dlx * w, py + dly * w), this._vset(px - dlx * w, py - dly * w);
                },
                _roundCapEnd: function _roundCapEnd(p, dx, dy, w, ncap) {
                    var px = p.x, py = p.y, dlx = dy, dly = -dx;
                    this._vset(px + dlx * w, py + dly * w), this._vset(px - dlx * w, py - dly * w);
                    for (var _i10 = 0; _i10 < ncap; _i10++) {
                        var a = _i10 / (ncap - 1) * PI$1, ax = cos$2(a) * w, ay = sin$1(a) * w;
                        this._vset(px, py), this._vset(px - dlx * ax + dx * ay, py - dly * ax + dy * ay);
                    }
                },
                _roundJoin: function _roundJoin(p0, p1, lw, rw, ncap) {
                    var dlx0 = p0.dy, dly0 = -p0.dx, dlx1 = p1.dy, dly1 = -p1.dx, p1x = p1.x, p1y = p1.y;
                    if (0 != (p1.flags & PointFlags.PT_LEFT)) {
                        var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw), lx0 = out[0], ly0 = out[1], lx1 = out[2], ly1 = out[3], a0 = atan2(-dly0, -dlx0), a1 = atan2(-dly1, -dlx1);
                        a0 < a1 && (a1 -= 2 * PI$1), this._vset(lx0, ly0), this._vset(p1x - dlx0 * rw, p1.y - dly0 * rw);
                        for (var n = clamp$1(ceil((a0 - a1) / PI$1) * ncap, 2, ncap), _i11 = 0; _i11 < n; _i11++) {
                            var a = a0 + _i11 / (n - 1) * (a1 - a0), rx = p1x + cos$2(a) * rw, ry = p1y + sin$1(a) * rw;
                            this._vset(p1x, p1y), this._vset(rx, ry);
                        }
                        this._vset(lx1, ly1), this._vset(p1x - dlx1 * rw, p1y - dly1 * rw);
                    } else {
                        var _out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw), rx0 = _out[0], ry0 = _out[1], rx1 = _out[2], ry1 = _out[3], _a = atan2(dly0, dlx0), _a2 = atan2(dly1, dlx1);
                        _a2 < _a && (_a2 += 2 * PI$1), this._vset(p1x + dlx0 * rw, p1y + dly0 * rw, 0), 
                        this._vset(rx0, ry0, 0);
                        for (var _n = clamp$1(ceil((_a2 - _a) / PI$1) * ncap, 2, ncap), _i12 = 0; _i12 < _n; _i12++) {
                            var _a3 = _a + _i12 / (_n - 1) * (_a2 - _a), lx = p1x + cos$2(_a3) * lw, ly = p1y + sin$1(_a3) * lw;
                            this._vset(lx, ly, 0), this._vset(p1x, p1y, 0);
                        }
                        this._vset(p1x + dlx1 * rw, p1y + dly1 * rw), this._vset(rx1, ry1);
                    }
                },
                _bevelJoin: function _bevelJoin(p0, p1, lw, rw) {
                    var rx0 = 0, ry0 = 0, rx1 = 0, ry1 = 0, lx0 = 0, ly0 = 0, lx1 = 0, ly1 = 0, dlx0 = p0.dy, dly0 = -p0.dx, dlx1 = p1.dy, dly1 = -p1.dx;
                    if (p1.flags & PointFlags.PT_LEFT) {
                        var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);
                        lx0 = out[0], ly0 = out[1], lx1 = out[2], ly1 = out[3], this._vset(lx0, ly0, 0), 
                        this._vset(p1.x - dlx0 * rw, p1.y - dly0 * rw, 0), this._vset(lx1, ly1, 0), this._vset(p1.x - dlx1 * rw, p1.y - dly1 * rw, 0);
                    } else {
                        var _out2 = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);
                        rx0 = _out2[0], ry0 = _out2[1], rx1 = _out2[2], ry1 = _out2[3], this._vset(p1.x + dlx0 * lw, p1.y + dly0 * lw, 0), 
                        this._vset(rx0, ry0), this._vset(p1.x + dlx1 * lw, p1.y + dly1 * lw, 0), this._vset(rx1, ry1);
                    }
                },
                _vset: function _vset(x, y) {
                    if (_renderData) {
                        var meshbuffer = _renderData, dataOffset = 9 * meshbuffer.vertexStart, vData = meshbuffer.vData;
                        vData[dataOffset++] = x, vData[dataOffset++] = y, vData[dataOffset++] = 0, vData[dataOffset++] = 1, 
                        vData[dataOffset++] = 1, Color.toArray(vData, _curColor, dataOffset), meshbuffer.vertexStart++;
                    }
                }
            }), graphicsAssemblerManager = exports("graphicsAssembler", {
                getAssembler: function getAssembler() {
                    return graphicsAssembler;
                }
            });
            GraphicsComponent.Assembler = graphicsAssemblerManager;
            function FontLetterDefinition() {
                _classCallCheck(this, FontLetterDefinition), this.u = 0, this.v = 0, this.width = 0, 
                this.height = 0, this.offsetX = 0, this.offsetY = 0, this.textureID = 0, this.validDefinition = !1, 
                this.xAdvance = 0;
            }
            var FontAtlas = function() {
                function FontAtlas() {
                    _classCallCheck(this, FontAtlas), this._letterDefinitions = {};
                }
                return _createClass(FontAtlas, [ {
                    key: "addLetterDefinitions",
                    value: function addLetterDefinitions(letter, letterDefinition) {
                        this._letterDefinitions[letter] = letterDefinition;
                    }
                }, {
                    key: "cloneLetterDefinition",
                    value: function cloneLetterDefinition() {
                        for (var copyLetterDefinitions = {}, _i = 0, _Object$keys = Object.keys(this._letterDefinitions); _i < _Object$keys.length; _i++) {
                            var _key = _Object$keys[_i], value = new FontLetterDefinition();
                            mixin(value, this._letterDefinitions[_key]), copyLetterDefinitions[_key] = value;
                        }
                        return copyLetterDefinitions;
                    }
                }, {
                    key: "assignLetterDefinitions",
                    value: function assignLetterDefinitions(letterDefinition) {
                        for (var _i2 = 0, _Object$keys2 = Object.keys(this._letterDefinitions); _i2 < _Object$keys2.length; _i2++) {
                            var _key2 = _Object$keys2[_i2], newValue = letterDefinition[_key2];
                            mixin(this._letterDefinitions[_key2], newValue);
                        }
                    }
                }, {
                    key: "scaleFontLetterDefinition",
                    value: function scaleFontLetterDefinition(scaleFactor) {
                        for (var _i3 = 0, _Object$keys3 = Object.keys(this._letterDefinitions); _i3 < _Object$keys3.length; _i3++) {
                            var fontDefinition = _Object$keys3[_i3], letterDefinitions = this._letterDefinitions[fontDefinition];
                            letterDefinitions.width *= scaleFactor, letterDefinitions.height *= scaleFactor, 
                            letterDefinitions.offsetX *= scaleFactor, letterDefinitions.offsetY *= scaleFactor, 
                            letterDefinitions.xAdvance *= scaleFactor;
                        }
                    }
                }, {
                    key: "getLetterDefinitionForChar",
                    value: function getLetterDefinitionForChar(_char) {
                        return this._letterDefinitions.hasOwnProperty(_char.charCodeAt(0)) ? this._letterDefinitions[_char.charCodeAt(0)] : null;
                    }
                }, {
                    key: "letterDefinitions",
                    get: function get() {
                        return this._letterDefinitions;
                    }
                } ]), FontAtlas;
            }();
            cc.FontAtlas = FontAtlas;
            function LetterInfo() {
                _classCallCheck(this, LetterInfo), this.char = "", this.valid = !0, this.positionX = 0, 
                this.positionY = 0, this.lineIndex = 0;
            }
            var _tmpRect = new Rect(), _comp = null, _horizontalKernings = [], _lettersInfo = [], _linesWidth = [], _linesOffsetX = [], _labelDimensions = new Size(), _fontAtlas = null, _fntConfig = null, _numberOfLines = 0, _textDesiredHeight = 0, _letterOffsetY = 0, _tailoredTopY = 0, _tailoredBottomY = 0, _bmfontScale = 1, _spriteFrame = null, _string = "", _fontSize = 0, _originFontSize = 0, _contentSize = new Size(), _hAlign = 0, _vAlign = 0, _spacingX = 0, _lineHeight = 0, _overflow = 0, _isWrapText = !1, _labelWidth = 0, _labelHeight = 0, _maxLineWidth = 0, bmfontUtils = {
                updateRenderData: function updateRenderData(comp) {
                    comp.renderData && comp.renderData.vertDirty && _comp !== comp && (_comp = comp, 
                    this._updateProperties(), this._updateContent(), _comp.actualFontSize = _fontSize, 
                    _comp.node.setContentSize(_contentSize), _comp.renderData.vertDirty = _comp.renderData.uvDirty = !1, 
                    _comp = null, this._resetProperties());
                },
                _updateFontScale: function _updateFontScale() {
                    _bmfontScale = _fontSize / _originFontSize;
                },
                _updateProperties: function _updateProperties() {
                    if (_comp) {
                        var fontAsset = _comp.font;
                        if (fontAsset) {
                            if (_spriteFrame = fontAsset.spriteFrame, _fntConfig = fontAsset.fntConfig, !(_fontAtlas = _comp.fontAtlas)) {
                                _fontAtlas = new FontAtlas();
                                for (var fontDict = _fntConfig.fontDefDictionary, _i4 = 0, _Object$keys4 = Object.keys(fontDict); _i4 < _Object$keys4.length; _i4++) {
                                    var fontDef = _Object$keys4[_i4], letterDefinition = new FontLetterDefinition(), rect = fontDict[fontDef].rect;
                                    letterDefinition.offsetX = fontDict[fontDef].xOffset, letterDefinition.offsetY = fontDict[fontDef].yOffset, 
                                    letterDefinition.width = rect.width, letterDefinition.height = rect.height, letterDefinition.u = rect.x, 
                                    letterDefinition.v = rect.y, letterDefinition.textureID = 0, letterDefinition.validDefinition = !0, 
                                    letterDefinition.xAdvance = fontDict[fontDef].xAdvance, _fontAtlas.addLetterDefinitions(fontDef, letterDefinition);
                                }
                                _comp.fontAtlas = _fontAtlas;
                            }
                            _string = _comp.string.toString(), _fontSize = _comp.fontSize, _originFontSize = _fntConfig.fontSize;
                            var contentSize = _comp.node.getContentSize();
                            _contentSize.width = contentSize.width, _contentSize.height = contentSize.height, 
                            _hAlign = _comp.horizontalAlign, _vAlign = _comp.verticalAlign, _spacingX = _comp.spacingX, 
                            _overflow = _comp.overflow, _lineHeight = _comp.lineHeight, _isWrapText = _overflow !== Overflow.NONE && (_overflow === Overflow.RESIZE_HEIGHT || _comp.enableWrapText), 
                            this._setupBMFontOverflowMetrics();
                        }
                    }
                },
                _resetProperties: function _resetProperties() {
                    _spriteFrame = _fntConfig = _fontAtlas = null;
                },
                _updateContent: function _updateContent() {
                    this._updateFontScale(), this._computeHorizontalKerningForText(), this._alignText();
                },
                _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {
                    for (var string = _string, stringLen = string.length, kerningDict = _fntConfig.kerningDict, horizontalKernings = _horizontalKernings, prev = -1, i = 0; i < stringLen; ++i) {
                        var _key3 = string.charCodeAt(i), kerningAmount = kerningDict[prev << 16 | 65535 & _key3] || 0;
                        horizontalKernings[i] = i < stringLen - 1 ? kerningAmount : 0, prev = _key3;
                    }
                },
                _multilineTextWrap: function _multilineTextWrap(nextTokenFunc) {
                    var textLen = _string.length, lineIndex = 0, nextTokenX = 0, nextTokenY = 0, longestLine = 0, letterRight = 0, highestY = 0, lowestY = 0, letterDef = null, letterPosition = new Vec2();
                    this._updateFontScale();
                    for (var letterDefinitions = _fontAtlas.letterDefinitions, index = 0; index < textLen; ) {
                        var character = _string.charAt(index);
                        if ("\n" !== character) {
                            for (var tokenLen = nextTokenFunc(_string, index, textLen), tokenHighestY = highestY, tokenLowestY = lowestY, tokenRight = letterRight, nextLetterX = nextTokenX, newLine = !1, tmp = 0; tmp < tokenLen; ++tmp) {
                                var letterIndex = index + tmp;
                                if ("\r" !== (character = _string.charAt(letterIndex))) if (letterDef = _fontAtlas && _fontAtlas.getLetterDefinitionForChar(character)) {
                                    var letterX = nextLetterX + letterDef.offsetX * _bmfontScale;
                                    if (_isWrapText && 0 < _maxLineWidth && 0 < nextTokenX && letterX + letterDef.width * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character)) {
                                        _linesWidth.push(letterRight), lineIndex++, nextTokenY -= _lineHeight * _bmfontScale + (nextTokenX = letterRight = 0), 
                                        newLine = !0;
                                        break;
                                    }
                                    letterPosition.x = letterX, letterPosition.y = nextTokenY - letterDef.offsetY * _bmfontScale, 
                                    this._recordLetterInfo(letterDefinitions, letterPosition, character, letterIndex, lineIndex), 
                                    letterIndex + 1 < _horizontalKernings.length && letterIndex < textLen - 1 && (nextLetterX += _horizontalKernings[letterIndex + 1]), 
                                    nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX, tokenRight = letterPosition.x + letterDef.width * _bmfontScale, 
                                    tokenHighestY < letterPosition.y && (tokenHighestY = letterPosition.y), tokenLowestY > letterPosition.y - letterDef.height * _bmfontScale && (tokenLowestY = letterPosition.y - letterDef.height * _bmfontScale);
                                } else this._recordPlaceholderInfo(letterIndex, character), console.log("Can't find letter definition in texture atlas " + _fntConfig.atlasName + " for letter:" + character); else this._recordPlaceholderInfo(letterIndex, character);
                            }
                            newLine || (nextTokenX = nextLetterX, highestY < tokenHighestY && (highestY = tokenHighestY), 
                            tokenLowestY < lowestY && (lowestY = tokenLowestY), longestLine < (letterRight = tokenRight) && (longestLine = letterRight), 
                            index += tokenLen);
                        } else _linesWidth.push(letterRight), lineIndex++, nextTokenY -= _lineHeight * _bmfontScale + (nextTokenX = letterRight = 0), 
                        this._recordPlaceholderInfo(index, character), index++;
                    }
                    return _linesWidth.push(letterRight), _textDesiredHeight = (_numberOfLines = lineIndex + 1) * _lineHeight * _bmfontScale, 
                    1 < _numberOfLines && (_textDesiredHeight += 0 * (_numberOfLines - 1)), _contentSize.width = _labelWidth, 
                    _contentSize.height = _labelHeight, _labelWidth <= 0 && (_contentSize.width = parseFloat(longestLine.toFixed(2))), 
                    _labelHeight <= 0 && (_contentSize.height = parseFloat(_textDesiredHeight.toFixed(2))), 
                    _tailoredTopY = _contentSize.height, (_tailoredBottomY = 0) < highestY && (_tailoredTopY = _contentSize.height + highestY), 
                    lowestY < -_textDesiredHeight && (_tailoredBottomY = _textDesiredHeight + lowestY), 
                    !0;
                },
                _getFirstCharLen: function _getFirstCharLen() {
                    return 1;
                },
                _getFirstWordLen: function _getFirstWordLen(text, startIndex, textLen) {
                    var character = text.charAt(startIndex);
                    if (isUnicodeCJK(character) || "\n" === character || isUnicodeSpace(character)) return 1;
                    var len = 1, letterDef = _fontAtlas && _fontAtlas.getLetterDefinitionForChar(character);
                    if (!letterDef) return len;
                    for (var nextLetterX = letterDef._xAdvance * _bmfontScale + _spacingX, index = startIndex + 1; index < textLen && (character = text.charAt(index), 
                    letterDef = _fontAtlas && _fontAtlas.getLetterDefinitionForChar(character)); ++index) {
                        if (nextLetterX + letterDef._offsetX * _bmfontScale + letterDef._width * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character) && 0 < _maxLineWidth) return len;
                        if (nextLetterX += letterDef._xAdvance * _bmfontScale + _spacingX, "\n" === character || isUnicodeSpace(character) || isUnicodeCJK(character)) break;
                        len++;
                    }
                    return len;
                },
                _multilineTextWrapByWord: function _multilineTextWrapByWord() {
                    return this._multilineTextWrap(this._getFirstWordLen);
                },
                _multilineTextWrapByChar: function _multilineTextWrapByChar() {
                    return this._multilineTextWrap(this._getFirstCharLen);
                },
                _recordPlaceholderInfo: function _recordPlaceholderInfo(letterIndex, _char2) {
                    if (letterIndex >= _lettersInfo.length) {
                        var tmpInfo = new LetterInfo();
                        _lettersInfo.push(tmpInfo);
                    }
                    _lettersInfo[letterIndex].char = _char2, _lettersInfo[letterIndex].valid = !1;
                },
                _recordLetterInfo: function _recordLetterInfo(letterDefinitions, letterPosition, character, letterIndex, lineIndex) {
                    if (letterIndex >= _lettersInfo.length) {
                        var tmpInfo = new LetterInfo();
                        _lettersInfo.push(tmpInfo);
                    }
                    var cIndex = character.charCodeAt(0);
                    _lettersInfo[letterIndex].lineIndex = lineIndex, _lettersInfo[letterIndex].char = character, 
                    _lettersInfo[letterIndex].valid = letterDefinitions[cIndex].validDefinition, _lettersInfo[letterIndex].positionX = letterPosition.x, 
                    _lettersInfo[letterIndex].positionY = letterPosition.y;
                },
                _alignText: function _alignText() {
                    _textDesiredHeight = 0, _linesWidth.length = 0, this._multilineTextWrapByWord(), 
                    this._computeAlignmentOffset(), _overflow === Overflow.SHRINK && 0 < _fontSize && this._isVerticalClamp() && this._shrinkLabelToContentSize(this._isVerticalClamp), 
                    this._updateQuads() || _overflow === Overflow.SHRINK && this._shrinkLabelToContentSize(this._isHorizontalClamp);
                },
                _scaleFontSizeDown: function _scaleFontSizeDown(fontSize) {
                    var shouldUpdateContent = !0;
                    fontSize || (shouldUpdateContent = !(fontSize = .1)), _fontSize = fontSize, shouldUpdateContent && this._updateContent();
                },
                _shrinkLabelToContentSize: function _shrinkLabelToContentSize(lambda) {
                    for (var fontSize = _fontSize, originalLineHeight = _lineHeight, fontAtlas = _fontAtlas, i = 0, tempLetterDefinition = fontAtlas ? fontAtlas.cloneLetterDefinition() : {}, flag = !0; lambda(); ) {
                        var newFontSize = fontSize - ++i;
                        if (flag = !1, newFontSize <= 0) break;
                        var scale = newFontSize / fontSize;
                        fontAtlas && (fontAtlas.assignLetterDefinitions(tempLetterDefinition), fontAtlas.scaleFontLetterDefinition(scale)), 
                        _lineHeight = originalLineHeight * scale, this._multilineTextWrapByWord(), this._computeAlignmentOffset();
                    }
                    _lineHeight = originalLineHeight, fontAtlas && fontAtlas.assignLetterDefinitions(tempLetterDefinition), 
                    flag || 0 <= fontSize - i && this._scaleFontSizeDown(fontSize - i);
                },
                _isVerticalClamp: function _isVerticalClamp() {
                    return _textDesiredHeight > _contentSize.height;
                },
                _isHorizontalClamp: function _isHorizontalClamp() {
                    if (_fontAtlas) {
                        for (var letterDefinitions = _fontAtlas.letterDefinitions, letterClamp = !1, ctr = 0, l = _string.length; ctr < l; ++ctr) {
                            var letterInfo = _lettersInfo[ctr];
                            if (letterInfo.valid) {
                                var letterDef = letterDefinitions[letterInfo.char], px = letterInfo.positionX + letterDef.width / 2 * _bmfontScale, lineIndex = letterInfo.lineIndex;
                                if (0 < _labelWidth) if (_isWrapText) {
                                    if (_linesWidth[lineIndex] > _contentSize.width && (px > _contentSize.width || px < 0)) {
                                        letterClamp = !0;
                                        break;
                                    }
                                } else if (px > _contentSize.width) {
                                    letterClamp = !0;
                                    break;
                                }
                            }
                        }
                        return letterClamp;
                    }
                },
                _isHorizontalClamped: function _isHorizontalClamped(px, lineIndex) {
                    var wordWidth = _linesWidth[lineIndex], letterOverClamp = px > _contentSize.width || px < 0;
                    return _isWrapText ? wordWidth > _contentSize.width && letterOverClamp : letterOverClamp;
                },
                _updateQuads: function _updateQuads() {
                    if (!_comp) return !1;
                    var letterDefinitions = _fontAtlas ? _fontAtlas.letterDefinitions : {}, texture = _spriteFrame, node = _comp.node, renderData = _comp.renderData;
                    renderData.dataLength = renderData.vertexCount = renderData.indiceCount = 0;
                    for (var anchorPoint = node.getAnchorPoint(), contentSize = _contentSize, appx = anchorPoint.x * contentSize.width, appy = anchorPoint.y * contentSize.height, ret = !0, ctr = 0, l = _string.length; ctr < l; ++ctr) {
                        var letterInfo = _lettersInfo[ctr];
                        if (letterInfo.valid) {
                            var letterDef = letterDefinitions[letterInfo.char.charCodeAt(0)];
                            if (letterDef) {
                                _tmpRect.height = letterDef.height, _tmpRect.width = letterDef.width, _tmpRect.x = letterDef.u, 
                                _tmpRect.y = letterDef.v;
                                var py = letterInfo.positionY + _letterOffsetY;
                                if (0 < _labelHeight) {
                                    if (_tailoredTopY < py) {
                                        var clipTop = py - _tailoredTopY;
                                        _tmpRect.y += clipTop, _tmpRect.height -= clipTop, py -= clipTop;
                                    }
                                    py - letterDef.height * _bmfontScale < _tailoredBottomY && (_tmpRect.height = py < _tailoredBottomY ? 0 : py - _tailoredBottomY);
                                }
                                var lineIndex = letterInfo.lineIndex, px = letterInfo.positionX + letterDef.width / 2 * _bmfontScale + _linesOffsetX[lineIndex];
                                if (0 < _labelWidth && this._isHorizontalClamped(px, lineIndex)) if (_overflow === Overflow.CLAMP) _tmpRect.width = 0; else if (_overflow === Overflow.SHRINK) {
                                    if (_contentSize.width > letterDef.width) {
                                        ret = !1;
                                        break;
                                    }
                                    _tmpRect.width = 0;
                                }
                                if (_spriteFrame && 0 < _tmpRect.height && 0 < _tmpRect.width) {
                                    var isRotated = _spriteFrame.isRotated(), originalSize = _spriteFrame.getOriginalSize(), rect = _spriteFrame.getRect(), offset = _spriteFrame.getOffset(), trimmedLeft = offset.x + (originalSize.width - rect.width) / 2, trimmedTop = offset.y - (originalSize.height - rect.height) / 2;
                                    if (isRotated) {
                                        var originalX = _tmpRect.x;
                                        _tmpRect.x = rect.x + rect.height - _tmpRect.y - _tmpRect.height - trimmedTop, _tmpRect.y = originalX + rect.y - trimmedLeft, 
                                        _tmpRect.y < 0 && (_tmpRect.height = _tmpRect.height + trimmedTop);
                                    } else _tmpRect.x += rect.x - trimmedLeft, _tmpRect.y += rect.y + trimmedTop;
                                    var letterPositionX = letterInfo.positionX + _linesOffsetX[letterInfo.lineIndex];
                                    this.appendQuad(_comp, texture, _tmpRect, isRotated, letterPositionX - appx, py - appy, _bmfontScale);
                                }
                            } else console.warn("Can't find letter in this bitmap-font");
                        }
                    }
                    return ret;
                },
                appendQuad: function appendQuad() {},
                _computeAlignmentOffset: function _computeAlignmentOffset() {
                    switch (_linesOffsetX.length = 0, _hAlign) {
                      case HorizontalTextAlignment.LEFT:
                        for (var i = 0; i < _numberOfLines; ++i) _linesOffsetX.push(0);
                        break;

                      case HorizontalTextAlignment.CENTER:
                        for (var _i5 = 0, l = _linesWidth.length; _i5 < l; _i5++) _linesOffsetX.push((_contentSize.width - _linesWidth[_i5]) / 2);
                        break;

                      case HorizontalTextAlignment.RIGHT:
                        for (var _i6 = 0, _l = _linesWidth.length; _i6 < _l; _i6++) _linesOffsetX.push(_contentSize.width - _linesWidth[_i6]);
                    }
                    switch (_vAlign) {
                      case VerticalTextAlignment.TOP:
                        _letterOffsetY = _contentSize.height;
                        break;

                      case VerticalTextAlignment.CENTER:
                        _letterOffsetY = (_contentSize.height + _textDesiredHeight) / 2;
                        break;

                      case VerticalTextAlignment.BOTTOM:
                        _letterOffsetY = _textDesiredHeight;
                    }
                },
                _setupBMFontOverflowMetrics: function _setupBMFontOverflowMetrics() {
                    var newWidth = _contentSize.width, newHeight = _contentSize.height;
                    _overflow === Overflow.RESIZE_HEIGHT && (newHeight = 0), _overflow === Overflow.NONE && (newHeight = newWidth = 0), 
                    _labelWidth = newWidth, _labelHeight = newHeight, _labelDimensions.width = newWidth, 
                    _labelDimensions.height = newHeight, _maxLineWidth = newWidth;
                }
            }, bmfont = exports("bmfont", {
                createData: function createData(comp) {
                    return comp.requestRenderData();
                },
                fillBuffers: function fillBuffers(comp, renderer) {
                    fillMeshVertices3D(comp.node, renderer, comp.renderData, comp.color);
                },
                appendQuad: function appendQuad(comp, spriteframe, rect, rotated, x, y, scale) {
                    var renderData = comp.renderData;
                    if (renderData) {
                        var dataOffset = renderData.dataLength;
                        renderData.dataLength += 4, renderData.vertexCount = renderData.dataLength, renderData.indiceCount = renderData.dataLength / 2 * 3;
                        var datas = renderData.datas, texw = spriteframe.width, texh = spriteframe.height, rectWidth = rect.width, rectHeight = rect.height, l = 0, b = 0, t = 0, r = 0;
                        rotated ? (l = rect.x / texw, r = (rect.x + rectHeight) / texw, b = (rect.y + rectWidth) / texh, 
                        t = rect.y / texh, datas[dataOffset].u = l, datas[dataOffset].v = t, datas[dataOffset + 1].u = l, 
                        datas[dataOffset + 1].v = b, datas[dataOffset + 2].u = r, datas[dataOffset + 2].v = t, 
                        datas[dataOffset + 3].u = r, datas[dataOffset + 3].v = b) : (l = rect.x / texw, 
                        r = (rect.x + rectWidth) / texw, b = (rect.y + rectHeight) / texh, t = rect.y / texh, 
                        datas[dataOffset].u = l, datas[dataOffset].v = b, datas[dataOffset + 1].u = r, datas[dataOffset + 1].v = b, 
                        datas[dataOffset + 2].u = l, datas[dataOffset + 2].v = t, datas[dataOffset + 3].u = r, 
                        datas[dataOffset + 3].v = t), datas[dataOffset].x = x, datas[dataOffset].y = y - rectHeight * scale, 
                        datas[dataOffset + 1].x = x + rectWidth * scale, datas[dataOffset + 1].y = y - rectHeight * scale, 
                        datas[dataOffset + 2].x = x, datas[dataOffset + 2].y = y, datas[dataOffset + 3].x = x + rectWidth * scale, 
                        datas[dataOffset + 3].y = y;
                    }
                }
            });
            addon(bmfont, bmfontUtils);
            function LetterInfo$1() {
                _classCallCheck(this, LetterInfo$1), this.char = "", this.valid = !0, this.x = 0, 
                this.y = 0, this.line = 0, this.hash = "";
            }
            function FontLetterDefinition$1() {
                _classCallCheck(this, FontLetterDefinition$1), this.u = 0, this.v = 0, this.w = 0, 
                this.h = 0, this.texture = null, this.offsetX = 0, this.offsetY = 0, this.valid = !1, 
                this.xAdvance = 0;
            }
            var Overflow$1 = LabelComponent.Overflow, WHITE = Color.WHITE.clone(), TextAlignment = LabelComponent.HorizontalAlign, VerticalTextAlignment$1 = LabelComponent.VerticalAlign, LetterTexture = function() {
                function LetterTexture(_char, labelInfo) {
                    _classCallCheck(this, LetterTexture), this.spriteframe = null, this.labelInfo = void 0, 
                    this.char = void 0, this.data = null, this.canvas = null, this.context = null, this.width = 0, 
                    this.height = 0, this.hash = void 0, this._lastImage = null, this.char = _char, 
                    this.labelInfo = labelInfo, this.hash = _char.charCodeAt(0) + labelInfo.hash;
                }
                return _createClass(LetterTexture, [ {
                    key: "updateRenderData",
                    value: function updateRenderData() {
                        this._updateProperties(), this._updateTexture();
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.spriteframe && (this.spriteframe.texture.destroy(), this.spriteframe.destroy(), 
                        this.spriteframe = null);
                    }
                }, {
                    key: "_updateProperties",
                    value: function _updateProperties() {
                        if (this.spriteframe = new SpriteFrame(), this.data = LabelComponent.CanvasPool.get(), 
                        this.canvas = this.data.canvas, this.context = this.data.context, this.context) {
                            this.context.font = this.labelInfo.fontDesc;
                            var width = safeMeasureText(this.context, this.char);
                            this.width = parseFloat(width.toFixed(2)), this.height = this.labelInfo.fontSize;
                        }
                        this.canvas.width !== this.width && (this.canvas.width = this.width), this.canvas.height !== this.height && (this.canvas.height = this.height), 
                        this._lastImage && (this._lastImage._texture.destroy(), this._lastImage.destroy());
                        var image = new ImageAsset(this.canvas), tex = (this._lastImage = image)._texture;
                        this.spriteframe.texture = tex;
                    }
                }, {
                    key: "_updateTexture",
                    value: function _updateTexture() {
                        if (this.context && this.canvas) {
                            var context = this.context, labelInfo = this.labelInfo, width = this.canvas.width, height = this.canvas.height;
                            context.textAlign = "center", context.textBaseline = "middle", context.clearRect(0, 0, width, height), 
                            context.fillStyle = "rgba(255, 255, 255, 0.005)", context.fillRect(0, 0, width, height), 
                            context.font = labelInfo.fontDesc;
                            var startX = width / 2, startY = height / 2, color = labelInfo.color;
                            if (context.lineJoin = "round", context.fillStyle = "rgba(".concat(color.r, ", ").concat(color.g, ", ").concat(color.b, ", ", 1, ")"), 
                            labelInfo.isOutlined) {
                                var strokeColor = labelInfo.out || WHITE;
                                context.strokeStyle = "rgba(".concat(strokeColor.r, ", ").concat(strokeColor.g, ", ").concat(strokeColor.b, ", ").concat(strokeColor.a / 255, ")"), 
                                context.lineWidth = 2 * labelInfo.margin, context.strokeText(this.char, startX, startY);
                            }
                            context.fillText(this.char, startX, startY), this.spriteframe.texture.updateImage();
                        }
                    }
                } ]), LetterTexture;
            }(), LetterRenderTexture = function() {
                function LetterRenderTexture() {
                    return _classCallCheck(this, LetterRenderTexture), _possibleConstructorReturn(this, _getPrototypeOf(LetterRenderTexture).apply(this, arguments));
                }
                return _inherits(LetterRenderTexture, Texture2D), _createClass(LetterRenderTexture, [ {
                    key: "initWithSize",
                    value: function initWithSize(width, height, argument_2) {
                        var format = 2 < arguments.length && void 0 !== argument_2 ? argument_2 : PixelFormat.RGBA8888;
                        this.destroy(), this.reset({
                            width: width,
                            height: height,
                            format: format
                        }), this.loaded = !0, this.emit("load");
                    }
                }, {
                    key: "drawTextureAt",
                    value: function drawTextureAt(texture, x, y) {
                        var gfxTexture = this.getGFXTexture();
                        if (texture._image && gfxTexture) {
                            var gfxDevice = this._getGFXDevice();
                            if (gfxDevice) {
                                var region = {
                                    buffOffset: 0,
                                    buffStride: 0,
                                    buffTexHeight: 0,
                                    texOffset: {
                                        x: x,
                                        y: y,
                                        z: 0
                                    },
                                    texExtent: {
                                        width: texture._image.width,
                                        height: texture._image.height,
                                        depth: 1
                                    },
                                    texSubres: {
                                        baseMipLevel: 0,
                                        levelCount: 1,
                                        baseArrayLayer: 0,
                                        layerCount: 1
                                    }
                                };
                                gfxDevice.copyTexImagesToTexture([ texture._image.data ], gfxTexture, [ region ]);
                            } else console.warn("Unable to get device");
                        }
                    }
                } ]), LetterRenderTexture;
            }(), LetterAtlas = function() {
                function LetterAtlas(width, height) {
                    _classCallCheck(this, LetterAtlas), this.texture = void 0, this._x = 2, this._y = 2, 
                    this._nexty = 2, this._width = 0, this._height = 0, this._letterDefinitions = new Map(), 
                    this._imageAssets = [], this._dirty = !1, this.texture = new LetterRenderTexture(), 
                    this.texture.initWithSize(width, height), this._width = width, this._height = height, 
                    director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
                }
                return _createClass(LetterAtlas, [ {
                    key: "width",
                    get: function get() {
                        return this._width;
                    }
                }, {
                    key: "height",
                    get: function get() {
                        return this._height;
                    }
                } ]), _createClass(LetterAtlas, [ {
                    key: "insertLetterTexture",
                    value: function insertLetterTexture(letterTexture) {
                        var texture = letterTexture.spriteframe, device = director.root.device;
                        if (!(texture && this.texture && device && texture._image)) return null;
                        var width = texture.width, height = texture.height;
                        if (this._x + width + 2 > this._width && (this._x = 2, this._y = this._nexty), this._y + height > this._nexty && (this._nexty = this._y + height + 2), 
                        this._nexty > this._height) return null;
                        this.texture.drawTextureAt(texture, this._x, this._y), this._dirty = !0;
                        var letterDefinition = new FontLetterDefinition$1();
                        return letterDefinition.u = this._x, letterDefinition.v = this._y, letterDefinition.texture = this.texture, 
                        letterDefinition.valid = !0, letterDefinition.w = letterTexture.width, letterDefinition.h = letterTexture.height, 
                        letterDefinition.xAdvance = letterTexture.width, this._x += width + 2, this._letterDefinitions.set(letterTexture.hash, letterDefinition), 
                        letterDefinition;
                    }
                }, {
                    key: "update",
                    value: function update() {
                        this._dirty && (this._dirty = !1);
                    }
                }, {
                    key: "reset",
                    value: function reset() {
                        this._x = 2, this._y = 2, this._nexty = 2, this._letterDefinitions.clear();
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.reset(), this.texture && this.texture.destroy();
                    }
                }, {
                    key: "beforeSceneLoad",
                    value: function beforeSceneLoad() {
                        this.destroy();
                        var texture = new LetterRenderTexture();
                        texture.initWithSize(this._width, this._height), this.texture = texture;
                    }
                }, {
                    key: "getLetter",
                    value: function getLetter(key) {
                        return this._letterDefinitions.get(key);
                    }
                }, {
                    key: "addLetterDefinitions",
                    value: function addLetterDefinitions(key, letterDefinition) {
                        this._letterDefinitions[key] = letterDefinition;
                    }
                }, {
                    key: "cloneLetterDefinition",
                    value: function cloneLetterDefinition() {
                        for (var copyLetterDefinitions = {}, _i = 0, _Object$keys = Object.keys(this._letterDefinitions); _i < _Object$keys.length; _i++) {
                            var key = _Object$keys[_i], value = new FontLetterDefinition$1();
                            mixin(value, this._letterDefinitions[key]), copyLetterDefinitions[key] = value;
                        }
                        return copyLetterDefinitions;
                    }
                }, {
                    key: "assignLetterDefinitions",
                    value: function assignLetterDefinitions(letterDefinitions) {
                        var _this = this;
                        letterDefinitions.forEach(function(value, key) {
                            mixin(_this._letterDefinitions[key], value);
                        });
                    }
                }, {
                    key: "scaleFontLetterDefinition",
                    value: function scaleFontLetterDefinition(scaleFactor) {
                        for (var _i2 = 0, _Object$keys2 = Object.keys(this._letterDefinitions); _i2 < _Object$keys2.length; _i2++) {
                            var fontDefinition = _Object$keys2[_i2], letterDefinitions = this._letterDefinitions[fontDefinition];
                            letterDefinitions.w *= scaleFactor, letterDefinitions.h *= scaleFactor, letterDefinitions.offsetX *= scaleFactor, 
                            letterDefinitions.offsetY *= scaleFactor, letterDefinitions.xAdvance *= scaleFactor;
                        }
                    }
                }, {
                    key: "getLetterDefinitionForChar",
                    value: function getLetterDefinitionForChar(_char2, labelInfo) {
                        var hash = _char2.charCodeAt(0) + labelInfo.hash, letterDefinition = this._letterDefinitions.get(hash);
                        if (!letterDefinition) {
                            var temp = new LetterTexture(_char2, labelInfo);
                            temp.updateRenderData(), letterDefinition = this.insertLetterTexture(temp), temp.destroy();
                        }
                        return letterDefinition;
                    }
                } ]), LetterAtlas;
            }(), _tmpRect$1 = new Rect(), _comp$1 = null, _horizontalKernings$1 = [], _lettersInfo$1 = [], _linesWidth$1 = [], _linesOffsetX$1 = [], _labelDimensions$1 = new Size(), _fontAtlas$1 = null, _numberOfLines$1 = 0, _textDesiredHeight$1 = 0, _letterOffsetY$1 = 0, _tailoredTopY$1 = 0, _tailoredBottomY$1 = 0, _bmfontScale$1 = 1, _string$1 = "", _fontSize$1 = 0, _originFontSize$1 = 0, _contentSize$1 = new Size(), _hAlign$1 = 0, _vAlign$1 = 0, _spacingX$1 = 0, _lineHeight$1 = 0, _overflow$1 = 0, _isWrapText$1 = !1, _labelWidth$1 = 0, _labelHeight$1 = 0, _maxLineWidth$1 = 0, _fontFamily = "", _isBold = !1, _labelInfo = {
                fontSize: 0,
                lineHeight: 0,
                hash: "",
                fontFamily: "",
                fontDesc: "Arial",
                hAlign: 0,
                vAlign: 0,
                color: WHITE,
                isOutlined: !1,
                out: WHITE,
                margin: 0
            }, letterFont = {
                getAssemblerData: function getAssemblerData() {
                    return (_fontAtlas$1 = _fontAtlas$1 || new LetterAtlas(1024, 1024)).texture;
                },
                updateRenderData: function updateRenderData(comp) {
                    comp.renderData && comp.renderData.vertDirty && _comp$1 !== comp && (_comp$1 = comp, 
                    this._updateFontFamily(comp), _labelInfo.fontFamily = _fontFamily, this._updateProperties(), 
                    _labelInfo.fontDesc = this._getFontDesc(), this._updateContent(), _comp$1.actualFontSize = _fontSize$1, 
                    _comp$1.node.setContentSize(_contentSize$1), _comp$1.renderData.vertDirty = _comp$1.renderData.uvDirty = !1, 
                    _comp$1 = null, this._resetProperties());
                },
                _updateFontScale: function _updateFontScale() {
                    _bmfontScale$1 = _fontSize$1 / _originFontSize$1;
                },
                _updateProperties: function _updateProperties() {
                    if (_comp$1) {
                        _string$1 = _comp$1.string.toString(), _fontSize$1 = _comp$1.fontSize, _originFontSize$1 = _fontSize$1;
                        var contentSize = _comp$1.node.getContentSize();
                        _contentSize$1.width = contentSize.width, _contentSize$1.height = contentSize.height, 
                        _hAlign$1 = _comp$1.horizontalAlign, _vAlign$1 = _comp$1.verticalAlign, _spacingX$1 = _comp$1.spacingX, 
                        _overflow$1 = _comp$1.overflow, _lineHeight$1 = _comp$1.lineHeight, _isBold = _comp$1.isBold, 
                        _isWrapText$1 = _overflow$1 !== Overflow$1.NONE && (_overflow$1 === Overflow$1.RESIZE_HEIGHT || _comp$1.enableWrapText);
                        var outline = _comp$1.getComponent(LabelOutlineComponent);
                        outline && outline.enabled ? (_labelInfo.isOutlined = !0, _labelInfo.margin = outline.width, 
                        _labelInfo.out = outline.color, _labelInfo.out.a = outline.color.a * _comp$1.color.a / 255) : (_labelInfo.isOutlined = !1, 
                        _labelInfo.margin = 0), _labelInfo.lineHeight = _lineHeight$1, _labelInfo.fontSize = _fontSize$1, 
                        _labelInfo.fontFamily = _fontFamily, _labelInfo.color = _comp$1.color, _labelInfo.hash = this._computeHash(_labelInfo), 
                        this._setupBMFontOverflowMetrics();
                    }
                },
                _updateFontFamily: function _updateFontFamily(comp) {
                    comp.useSystemFont ? _fontFamily = comp.fontFamily : comp.font ? comp.font._nativeAsset ? _fontFamily = comp.font._nativeAsset : (_fontFamily = loader.getRes(comp.font.nativeUrl) || "") || loader.load(comp.font.nativeUrl, function(err, fontFamily) {
                        _fontFamily = fontFamily || "Arial", comp.font && (comp.font._nativeAsset = fontFamily), 
                        comp.updateRenderData(!0);
                    }) : _fontFamily = "Arial";
                },
                _computeHash: function _computeHash(labelInfo) {
                    var color = labelInfo.color.toHEX("#rrggbb"), out = "";
                    return labelInfo.isOutlined && (out = labelInfo.out.toHEX("#rrggbb")), "" + labelInfo.fontSize + labelInfo.fontFamily + color + out;
                },
                _getFontDesc: function _getFontDesc() {
                    var fontDesc = _fontSize$1.toString() + "px ";
                    return fontDesc += _fontFamily, _isBold && (fontDesc = "bold " + fontDesc), fontDesc;
                },
                _resetProperties: function _resetProperties() {},
                _updateContent: function _updateContent() {
                    this._updateFontScale(), this._alignText();
                },
                _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {},
                _multilineTextWrap: function _multilineTextWrap(nextTokenFunc) {
                    var textLen = _string$1.length, lineIndex = 0, nextTokenX = 0, nextTokenY = 0, longestLine = 0, letterRight = 0, highestY = 0, lowestY = 0, letterDef = null, letterPosition = new Vec2(0, 0);
                    this._updateFontScale();
                    for (var index = 0; index < textLen; ) {
                        var character = _string$1.charAt(index);
                        if ("\n" !== character) {
                            for (var tokenLen = nextTokenFunc(_string$1, index, textLen), tokenHighestY = highestY, tokenLowestY = lowestY, tokenRight = letterRight, nextLetterX = nextTokenX, newLine = !1, tmp = 0; tmp < tokenLen; ++tmp) {
                                var letterIndex = index + tmp;
                                if ("\r" !== (character = _string$1.charAt(letterIndex))) if (letterDef = _fontAtlas$1 && _fontAtlas$1.getLetterDefinitionForChar(character, _labelInfo)) {
                                    var letterX = nextLetterX + letterDef.offsetX * _bmfontScale$1;
                                    if (_isWrapText$1 && 0 < _maxLineWidth$1 && 0 < nextTokenX && letterX + letterDef.w * _bmfontScale$1 > _maxLineWidth$1 && !isUnicodeSpace(character)) {
                                        _linesWidth$1.push(letterRight), lineIndex++, nextTokenY -= _lineHeight$1 * _bmfontScale$1 + (nextTokenX = letterRight = 0), 
                                        newLine = !0;
                                        break;
                                    }
                                    letterPosition.x = letterX, letterPosition.y = nextTokenY - letterDef.offsetY * _bmfontScale$1, 
                                    this._recordLetterInfo(letterPosition, character, letterIndex, lineIndex), letterIndex + 1 < _horizontalKernings$1.length && letterIndex < textLen - 1 && (nextLetterX += _horizontalKernings$1[letterIndex + 1]), 
                                    nextLetterX += letterDef.xAdvance * _bmfontScale$1 + _spacingX$1, tokenRight = letterPosition.x + letterDef.w * _bmfontScale$1, 
                                    tokenHighestY < letterPosition.y && (tokenHighestY = letterPosition.y), tokenLowestY > letterPosition.y - letterDef.h * _bmfontScale$1 && (tokenLowestY = letterPosition.y - letterDef.h * _bmfontScale$1);
                                } else this._recordPlaceholderInfo(letterIndex, character); else this._recordPlaceholderInfo(letterIndex, character);
                            }
                            newLine || (nextTokenX = nextLetterX, highestY < tokenHighestY && (highestY = tokenHighestY), 
                            tokenLowestY < lowestY && (lowestY = tokenLowestY), longestLine < (letterRight = tokenRight) && (longestLine = letterRight), 
                            index += tokenLen);
                        } else _linesWidth$1.push(letterRight), lineIndex++, nextTokenY -= _lineHeight$1 * _bmfontScale$1 + (nextTokenX = letterRight = 0), 
                        this._recordPlaceholderInfo(index, character), index++;
                    }
                    return _linesWidth$1.push(letterRight), _textDesiredHeight$1 = (_numberOfLines$1 = lineIndex + 1) * _lineHeight$1 * _bmfontScale$1, 
                    1 < _numberOfLines$1 && (_textDesiredHeight$1 += 0 * (_numberOfLines$1 - 1)), _contentSize$1.width = _labelWidth$1, 
                    _contentSize$1.height = _labelHeight$1, _labelWidth$1 <= 0 && (_contentSize$1.width = parseFloat(longestLine.toFixed(2))), 
                    _labelHeight$1 <= 0 && (_contentSize$1.height = parseFloat(_textDesiredHeight$1.toFixed(2))), 
                    _tailoredTopY$1 = _contentSize$1.height, (_tailoredBottomY$1 = 0) < highestY && (_tailoredTopY$1 = _contentSize$1.height + highestY), 
                    lowestY < -_textDesiredHeight$1 && (_tailoredBottomY$1 = _textDesiredHeight$1 + lowestY), 
                    !0;
                },
                _getFirstCharLen: function _getFirstCharLen() {
                    return 1;
                },
                _getFirstWordLen: function _getFirstWordLen(text, startIndex, textLen) {
                    var character = text.charAt(startIndex);
                    if (isUnicodeCJK(character) || "\n" === character || isUnicodeSpace(character)) return 1;
                    if (_fontAtlas$1) {
                        var len = 1, letterDef = _fontAtlas$1.getLetterDefinitionForChar(character, _labelInfo);
                        if (!letterDef) return len;
                        for (var nextLetterX = letterDef.xAdvance * _bmfontScale$1 + _spacingX$1, index = startIndex + 1; index < textLen && (character = text.charAt(index), 
                        letterDef = _fontAtlas$1.getLetterDefinitionForChar(character, _labelInfo)); ++index) {
                            if (nextLetterX + letterDef.offsetX * _bmfontScale$1 + letterDef.w * _bmfontScale$1 > _maxLineWidth$1 && !isUnicodeSpace(character) && 0 < _maxLineWidth$1) return len;
                            if (nextLetterX += letterDef.xAdvance * _bmfontScale$1 + _spacingX$1, "\n" === character || isUnicodeSpace(character) || isUnicodeCJK(character)) break;
                            len++;
                        }
                        return len;
                    }
                },
                _multilineTextWrapByWord: function _multilineTextWrapByWord() {
                    return this._multilineTextWrap(this._getFirstWordLen);
                },
                _multilineTextWrapByChar: function _multilineTextWrapByChar() {
                    return this._multilineTextWrap(this._getFirstCharLen);
                },
                _recordPlaceholderInfo: function _recordPlaceholderInfo(letterIndex, _char3) {
                    if (letterIndex >= _lettersInfo$1.length) {
                        var tmpInfo = new LetterInfo$1();
                        _lettersInfo$1.push(tmpInfo);
                    }
                    _lettersInfo$1[letterIndex].char = _char3, _lettersInfo$1[letterIndex].hash = _char3.charCodeAt(0) + _labelInfo.hash, 
                    _lettersInfo$1[letterIndex].valid = !1;
                },
                _recordLetterInfo: function _recordLetterInfo(letterPosition, character, letterIndex, lineIndex) {
                    if (letterIndex >= _lettersInfo$1.length) {
                        var tmpInfo = new LetterInfo$1();
                        _lettersInfo$1.push(tmpInfo);
                    }
                    var key = character.charCodeAt(0) + _labelInfo.hash;
                    _lettersInfo$1[letterIndex].line = lineIndex, _lettersInfo$1[letterIndex].char = character, 
                    _lettersInfo$1[letterIndex].hash = key;
                    var fontLetter = _fontAtlas$1 && _fontAtlas$1.getLetter(key);
                    _lettersInfo$1[letterIndex].valid = !!fontLetter && !!fontLetter.valid, _lettersInfo$1[letterIndex].x = letterPosition.x, 
                    _lettersInfo$1[letterIndex].y = letterPosition.y;
                },
                _alignText: function _alignText() {
                    _textDesiredHeight$1 = 0, _linesWidth$1.length = 0, this._multilineTextWrapByWord(), 
                    this._computeAlignmentOffset(), this._updateQuads();
                },
                _scaleFontSizeDown: function _scaleFontSizeDown(fontSize) {
                    var shouldUpdateContent = !0;
                    fontSize || (shouldUpdateContent = !(fontSize = .1)), _fontSize$1 = fontSize, shouldUpdateContent && this._updateContent();
                },
                _isVerticalClamp: function _isVerticalClamp() {
                    return _textDesiredHeight$1 > _contentSize$1.height;
                },
                _isHorizontalClamp: function _isHorizontalClamp() {
                    for (var letterClamp = !1, ctr = 0, l = _string$1.length; ctr < l; ++ctr) {
                        var letterInfo = _lettersInfo$1[ctr];
                        if (letterInfo.valid) {
                            var letterDef = _fontAtlas$1.getLetter(letterInfo.hash);
                            if (!letterDef) continue;
                            var px = letterInfo.x + letterDef.w * _bmfontScale$1, lineIndex = letterInfo.line;
                            if (0 < _labelWidth$1) if (_isWrapText$1) {
                                if (_linesWidth$1[lineIndex] > _contentSize$1.width && (px > _contentSize$1.width || px < 0)) {
                                    letterClamp = !0;
                                    break;
                                }
                            } else if (px > _contentSize$1.width) {
                                letterClamp = !0;
                                break;
                            }
                        }
                    }
                    return letterClamp;
                },
                _isHorizontalClamped: function _isHorizontalClamped(px, lineIndex) {
                    var wordWidth = _linesWidth$1[lineIndex], letterOverClamp = px > _contentSize$1.width || px < 0;
                    return _isWrapText$1 ? wordWidth > _contentSize$1.width && letterOverClamp : letterOverClamp;
                },
                _updateQuads: function _updateQuads() {
                    if (_comp$1 && _fontAtlas$1) {
                        var texture = _fontAtlas$1.texture, node = _comp$1.node, renderData = _comp$1.renderData;
                        renderData.dataLength = renderData.vertexCount = renderData.indiceCount = 0;
                        for (var contentSize = _contentSize$1, ap = node.getAnchorPoint(), appx = ap.x * contentSize.width, appy = ap.y * contentSize.height, ret = !0, ctr = 0, l = _string$1.length; ctr < l; ++ctr) {
                            var letterInfo = _lettersInfo$1[ctr];
                            if (letterInfo.valid) {
                                var letterDef = _fontAtlas$1.getLetter(letterInfo.hash);
                                if (letterDef) {
                                    _tmpRect$1.height = letterDef.h, _tmpRect$1.width = letterDef.w, _tmpRect$1.x = letterDef.u, 
                                    _tmpRect$1.y = letterDef.v;
                                    var py = letterInfo.y + _letterOffsetY$1;
                                    if (0 < _labelHeight$1) {
                                        if (_tailoredTopY$1 < py) {
                                            var clipTop = py - _tailoredTopY$1;
                                            _tmpRect$1.y += clipTop, _tmpRect$1.height -= clipTop, py -= clipTop;
                                        }
                                        py - letterDef.h * _bmfontScale$1 < _tailoredBottomY$1 && (_tmpRect$1.height = py < _tailoredBottomY$1 ? 0 : py - _tailoredBottomY$1);
                                    }
                                    var lineIndex = letterInfo.line, px = letterInfo.x + letterDef.w / 2 * _bmfontScale$1 + _linesOffsetX$1[lineIndex];
                                    if (0 < _labelWidth$1 && this._isHorizontalClamped(px, lineIndex)) if (_overflow$1 === Overflow$1.CLAMP) _tmpRect$1.width = 0; else if (_overflow$1 === Overflow$1.SHRINK) {
                                        if (_contentSize$1.width > letterDef.w) {
                                            ret = !1;
                                            break;
                                        }
                                        _tmpRect$1.width = 0;
                                    }
                                    if (0 < _tmpRect$1.height && 0 < _tmpRect$1.width) {
                                        var letterPositionX = letterInfo.x + _linesOffsetX$1[letterInfo.line];
                                        this.appendQuad(renderData, texture, _tmpRect$1, !1, letterPositionX - appx, py - appy, _bmfontScale$1);
                                    }
                                }
                            }
                        }
                        return ret;
                    }
                },
                appendQuad: function appendQuad() {},
                _computeAlignmentOffset: function _computeAlignmentOffset() {
                    switch (_linesOffsetX$1.length = 0, _hAlign$1) {
                      case TextAlignment.LEFT:
                        for (var i = 0; i < _numberOfLines$1; ++i) _linesOffsetX$1.push(0);
                        break;

                      case TextAlignment.CENTER:
                        for (var _i3 = 0, l = _linesWidth$1.length; _i3 < l; _i3++) _linesOffsetX$1.push((_contentSize$1.width - _linesWidth$1[_i3]) / 2);
                        break;

                      case TextAlignment.RIGHT:
                        for (var _i4 = 0, _l = _linesWidth$1.length; _i4 < _l; _i4++) _linesOffsetX$1.push(_contentSize$1.width - _linesWidth$1[_i4]);
                    }
                    switch (_vAlign$1) {
                      case VerticalTextAlignment$1.TOP:
                        _letterOffsetY$1 = _contentSize$1.height;
                        break;

                      case VerticalTextAlignment$1.CENTER:
                        _letterOffsetY$1 = (_contentSize$1.height + _textDesiredHeight$1) / 2 - (_lineHeight$1 - _fontSize$1) / 2;
                        break;

                      case VerticalTextAlignment$1.BOTTOM:
                        _letterOffsetY$1 = (_contentSize$1.height + _textDesiredHeight$1) / 2 - (_lineHeight$1 - _fontSize$1);
                    }
                },
                _setupBMFontOverflowMetrics: function _setupBMFontOverflowMetrics() {
                    var newWidth = _contentSize$1.width, newHeight = _contentSize$1.height;
                    _overflow$1 === Overflow$1.RESIZE_HEIGHT && (newHeight = 0), _overflow$1 === Overflow$1.NONE && (newHeight = newWidth = 0), 
                    _labelWidth$1 = newWidth, _labelHeight$1 = newHeight, _labelDimensions$1.width = newWidth, 
                    _labelDimensions$1.height = newHeight, _maxLineWidth$1 = newWidth;
                }
            }, WHITE$1 = new Color(255, 255, 255, 255), letter = exports("letter", {
                createData: function createData(comp) {
                    return comp.requestRenderData();
                },
                fillBuffers: function fillBuffers(comp, renderer) {
                    if (comp.renderData) {
                        var node = comp.node;
                        WHITE$1.a = comp.color.a, fillMeshVertices3D(node, renderer, comp.renderData, WHITE$1);
                    }
                },
                appendQuad: bmfont.appendQuad
            });
            addon(letter, letterFont);
            var Overflow$2 = LabelComponent.Overflow, WHITE$2 = Color.WHITE.clone(), OUTLINE_SUPPORTED = isChildClassOf(LabelOutlineComponent, Component), _context = null, _canvas = null, _texture = null, _fontDesc = "", _string$2 = "", _fontSize$2 = 0, _drawFontsize = 0, _splitedStrings = [], _canvasSize = new Size(), _lineHeight$2 = 0, _hAlign$2 = 0, _vAlign$2 = 0, _color$1 = new Color(), _fontFamily$1 = "", _overflow$2 = Overflow$2.NONE, _isWrapText$2 = !1, _isOutlined = !1, _outlineColor = new Color(), _outlineWidth = 0, _margin = 0, _isBold$1 = !1, _isItalic = !1, _isUnderline = !1, _canvasPool = new CanvasPool(), ttfUtils = {
                getAssemblerData: function getAssemblerData() {
                    var labelCanvas = document.createElement("canvas"), sharedLabelData = {
                        canvas: labelCanvas,
                        context: labelCanvas.getContext("2d")
                    };
                    return sharedLabelData.canvas.width = sharedLabelData.canvas.height = 1, sharedLabelData;
                },
                resetAssemblerData: function resetAssemblerData(assemblerData) {
                    cc.game.renderType === cc.game.RENDER_TYPE_CANVAS && assemblerData && _canvasPool.put(assemblerData);
                },
                updateRenderData: function updateRenderData(comp) {
                    comp.renderData && comp.renderData.vertDirty && (this._updateFontFamly(comp), this._updateProperties(comp), 
                    this._calculateLabelFont(), this._calculateSplitedStrings(), this._updateLabelDimensions(), 
                    this._calculateTextBaseline(), this._updateTexture(), comp.actualFontSize = _fontSize$2, 
                    comp.node.setContentSize(_canvasSize), this.updateVerts(comp), comp.markForUpdateRenderData(!1), 
                    _texture = _canvas = _context = null);
                },
                updateVerts: function updateVerts() {},
                _updateFontFamly: function _updateFontFamly(comp) {
                    comp.useSystemFont ? _fontFamily$1 = comp.fontFamily : comp.font ? comp.font._nativeAsset ? _fontFamily$1 = comp.font._nativeAsset : loader.load(comp.font.nativeUrl, function(err, fontFamily) {
                        _fontFamily$1 = fontFamily || "Arial", comp.updateRenderData(!0);
                    }) : _fontFamily$1 = "Arial";
                },
                _updateProperties: function _updateProperties(comp) {
                    var assemblerData = comp.assemblerData;
                    if (assemblerData) {
                        _context = assemblerData.context, _canvas = assemblerData.canvas, _texture = comp.spriteFrame, 
                        _string$2 = comp.string.toString(), _fontSize$2 = comp.fontSize, _drawFontsize = _fontSize$2, 
                        _overflow$2 = comp.overflow, _canvasSize.width = comp.node.width, _canvasSize.height = comp.node.height, 
                        _lineHeight$2 = comp.lineHeight, _hAlign$2 = comp.horizontalAlign, _vAlign$2 = comp.verticalAlign, 
                        _color$1 = comp.color, _isBold$1 = comp.isBold, _isItalic = comp.isItalic, _isUnderline = comp.isUnderline, 
                        _isWrapText$2 = _overflow$2 !== Overflow$2.NONE && (_overflow$2 === Overflow$2.RESIZE_HEIGHT || comp.enableWrapText);
                        var outline = OUTLINE_SUPPORTED && comp.getComponent(LabelOutlineComponent);
                        outline && outline.enabled ? (_isOutlined = !0, _margin = _outlineWidth = outline.width, 
                        (_outlineColor = outline.color.clone()).a = _outlineColor.a * comp.color.a / 255) : (_isOutlined = !1, 
                        _margin = 0);
                    }
                },
                _calculateFillTextStartPosition: function _calculateFillTextStartPosition() {
                    var labelX, firstLinelabelY, lineHeight = this._getLineHeight(), lineCount = _splitedStrings.length;
                    return labelX = _hAlign$2 === HorizontalTextAlignment.RIGHT ? _canvasSize.width - _margin : _hAlign$2 === HorizontalTextAlignment.CENTER ? _canvasSize.width / 2 : 0 + _margin, 
                    firstLinelabelY = _vAlign$2 === VerticalTextAlignment.TOP ? 0 : _vAlign$2 === VerticalTextAlignment.CENTER ? _canvasSize.height / 2 - lineHeight * (lineCount - 1) / 2 : _canvasSize.height - lineHeight * (lineCount - 1), 
                    new Vec2(labelX, firstLinelabelY);
                },
                _updateTexture: function _updateTexture() {
                    if (_context && _canvas) {
                        _context.clearRect(0, 0, _canvas.width, _canvas.height), _context.font = _fontDesc;
                        var underlineStartPosition, startPosition = this._calculateFillTextStartPosition(), lineHeight = this._getLineHeight();
                        _context.lineJoin = "round", _context.fillStyle = "rgba(".concat(_color$1.r, ", ").concat(_color$1.g, ", ").concat(_color$1.b, ", ").concat(_color$1.a / 255, ")");
                        for (var i = 0; i < _splitedStrings.length; ++i) {
                            if (_isOutlined) {
                                var strokeColor = _outlineColor || WHITE$2;
                                _context.strokeStyle = "rgba(".concat(strokeColor.r, ", ").concat(strokeColor.g, ", ").concat(strokeColor.b, ", ").concat(strokeColor.a / 255, ")"), 
                                _context.lineWidth = 2 * _outlineWidth, _context.strokeText(_splitedStrings[i], startPosition.x, startPosition.y + i * lineHeight);
                            }
                            _context.fillText(_splitedStrings[i], startPosition.x, startPosition.y + i * lineHeight), 
                            _isUnderline && (underlineStartPosition = this._calculateUnderlineStartPosition(), 
                            _context.save(), _context.beginPath(), _context.lineWidth = _fontSize$2 / 8, _context.strokeStyle = "rgba(".concat(_color$1.r, ", ").concat(_color$1.g, ", ").concat(_color$1.b, ", ").concat(_color$1.a / 255, ")"), 
                            _context.moveTo(underlineStartPosition.x, underlineStartPosition.y + i * lineHeight - 1), 
                            _context.lineTo(underlineStartPosition.x + _canvas.width, underlineStartPosition.y + i * lineHeight - 1), 
                            _context.stroke(), _context.restore());
                        }
                        if (_texture) {
                            var tex;
                            tex = _texture instanceof SpriteFrame ? _texture.texture : _texture;
                            var uploadAgain = 0 === _canvas.width || 0 === _canvas.height;
                            tex.reset({
                                width: _canvas.width,
                                height: _canvas.height,
                                mipmapLevel: uploadAgain ? 0 : 1
                            }), uploadAgain || tex.uploadData(_canvas);
                        }
                    }
                },
                _calculateUnderlineStartPosition: function _calculateUnderlineStartPosition() {
                    var labelX, firstLinelabelY, lineHeight = this._getLineHeight(), lineCount = _splitedStrings.length;
                    return labelX = 0 + _margin, firstLinelabelY = _vAlign$2 === VerticalTextAlignment.TOP ? _fontSize$2 : _vAlign$2 === VerticalTextAlignment.CENTER ? _canvasSize.height / 2 - lineHeight * (lineCount - 1) / 2 + _fontSize$2 / 2 : _canvasSize.height - lineHeight * (lineCount - 1), 
                    new Vec2(labelX, firstLinelabelY);
                },
                _updateLabelDimensions: function _updateLabelDimensions() {
                    if (_context) {
                        var paragraphedStrings = _string$2.split("\n");
                        if (_overflow$2 === Overflow$2.RESIZE_HEIGHT) _canvasSize.height = _splitedStrings.length * this._getLineHeight(); else if (_overflow$2 === Overflow$2.NONE) {
                            var canvasSizeX = 0, canvasSizeY = 0, _iterator = _splitedStrings = paragraphedStrings, _isArray = Array.isArray(_iterator), _i = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i >= _iterator.length) break;
                                    _ref = _iterator[_i++];
                                } else {
                                    if ((_i = _iterator.next()).done) break;
                                    _ref = _i.value;
                                }
                                var paraLength = safeMeasureText(_context, _ref);
                                canvasSizeX = paraLength < canvasSizeX ? canvasSizeX : paraLength;
                            }
                            canvasSizeY = _splitedStrings.length * this._getLineHeight(), _canvasSize.width = parseFloat(canvasSizeX.toFixed(2)) + 2 * _margin, 
                            _canvasSize.height = parseFloat(canvasSizeY.toFixed(2)), _isItalic && (_canvasSize.width += _drawFontsize * Math.tan(.20943951));
                        }
                        _canvas && (_canvas.width = _canvasSize.width, _canvas.height = _canvasSize.height);
                    }
                },
                _calculateTextBaseline: function _calculateTextBaseline() {
                    var hAlign, vAlign;
                    hAlign = _hAlign$2 === HorizontalTextAlignment.RIGHT ? "right" : _hAlign$2 === HorizontalTextAlignment.CENTER ? "center" : "left", 
                    vAlign = _vAlign$2 === VerticalTextAlignment.TOP ? "top" : _vAlign$2 === VerticalTextAlignment.CENTER ? "middle" : "bottom", 
                    _context && (_context.textAlign = hAlign, _context.textBaseline = vAlign);
                },
                _calculateSplitedStrings: function _calculateSplitedStrings() {
                    if (_context) {
                        var paragraphedStrings = _string$2.split("\n");
                        if (_isWrapText$2) {
                            _splitedStrings = [];
                            var canvasWidthNoMargin = _canvasSize.width - 2 * _margin, _iterator2 = paragraphedStrings, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                                var _ref2;
                                if (_isArray2) {
                                    if (_i2 >= _iterator2.length) break;
                                    _ref2 = _iterator2[_i2++];
                                } else {
                                    if ((_i2 = _iterator2.next()).done) break;
                                    _ref2 = _i2.value;
                                }
                                var textFragment = fragmentText(_ref2, safeMeasureText(_context, _ref2), canvasWidthNoMargin, this._measureText(_context));
                                _splitedStrings = _splitedStrings.concat(textFragment);
                            }
                        } else _splitedStrings = paragraphedStrings;
                    }
                },
                _getFontDesc: function _getFontDesc() {
                    var fontDesc = _fontSize$2.toString() + "px ";
                    return fontDesc += _fontFamily$1, _isBold$1 && (fontDesc = "bold " + fontDesc), 
                    _isItalic && (fontDesc = "italic " + fontDesc), fontDesc;
                },
                _getLineHeight: function _getLineHeight() {
                    var nodeSpacingY = _lineHeight$2;
                    return 0 | (nodeSpacingY = 0 === nodeSpacingY ? _fontSize$2 : nodeSpacingY * _fontSize$2 / _drawFontsize);
                },
                _calculateParagraphLength: function _calculateParagraphLength(paragraphedStrings, ctx) {
                    var paragraphLength = [], _iterator3 = paragraphedStrings, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                    for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                        var _ref3;
                        if (_isArray3) {
                            if (_i3 >= _iterator3.length) break;
                            _ref3 = _iterator3[_i3++];
                        } else {
                            if ((_i3 = _iterator3.next()).done) break;
                            _ref3 = _i3.value;
                        }
                        var width = safeMeasureText(ctx, _ref3);
                        paragraphLength.push(width);
                    }
                    return paragraphLength;
                },
                _measureText: function _measureText(ctx) {
                    return function(string) {
                        return safeMeasureText(ctx, string);
                    };
                },
                _calculateLabelFont: function _calculateLabelFont() {
                    if (_context && (_fontDesc = this._getFontDesc(), _context.font = _fontDesc, _overflow$2 === Overflow$2.SHRINK)) {
                        var paragraphedStrings = _string$2.split("\n"), paragraphLength = this._calculateParagraphLength(paragraphedStrings, _context);
                        _splitedStrings = paragraphedStrings;
                        var i = 0, totalHeight = 0, maxLength = 0;
                        if (_isWrapText$2) {
                            var canvasWidthNoMargin = _canvasSize.width - 2 * _margin, canvasHeightNoMargin = _canvasSize.height - 2 * _margin;
                            if (canvasWidthNoMargin < 0 || canvasHeightNoMargin < 0) return _fontDesc = this._getFontDesc(), 
                            void (_context.font = _fontDesc);
                            totalHeight = 1 + canvasHeightNoMargin, maxLength = 1 + canvasWidthNoMargin;
                            for (var actualFontSize = _fontSize$2 + 1, textFragment = [], tryDivideByTwo = !0, startShrinkFontSize = 0 | actualFontSize; canvasHeightNoMargin < totalHeight || canvasWidthNoMargin < maxLength; ) {
                                if (tryDivideByTwo ? actualFontSize = startShrinkFontSize / 2 | 0 : startShrinkFontSize = actualFontSize = startShrinkFontSize - 1, 
                                actualFontSize <= 0) {
                                    logID(4003);
                                    break;
                                }
                                for (_fontSize$2 = actualFontSize, _fontDesc = this._getFontDesc(), _context.font = _fontDesc, 
                                _splitedStrings = [], i = totalHeight = 0; i < paragraphedStrings.length; ++i) {
                                    var j = 0, allWidth = safeMeasureText(_context, paragraphedStrings[i]);
                                    for (textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context)); j < textFragment.length; ) {
                                        maxLength = safeMeasureText(_context, textFragment[j]), totalHeight += this._getLineHeight(), 
                                        ++j;
                                    }
                                    _splitedStrings = _splitedStrings.concat(textFragment);
                                }
                                tryDivideByTwo && (canvasHeightNoMargin < totalHeight ? startShrinkFontSize = 0 | actualFontSize : (tryDivideByTwo = !1, 
                                totalHeight = 1 + canvasHeightNoMargin));
                            }
                        } else {
                            for (totalHeight = paragraphedStrings.length * this._getLineHeight(), i = 0; i < paragraphedStrings.length; ++i) maxLength < paragraphLength[i] && (maxLength = paragraphLength[i]);
                            var scaleX = (_canvasSize.width - 2 * _margin) / maxLength, scaleY = _canvasSize.height / totalHeight;
                            _fontSize$2 = _drawFontsize * Math.min(1, scaleX, scaleY) | 0, _fontDesc = this._getFontDesc(), 
                            _context.font = _fontDesc;
                        }
                    }
                }
            }, WHITE$3 = Color.WHITE.clone(), ttf = exports("ttf", {
                createData: function createData(comp) {
                    var renderData = comp.requestRenderData();
                    renderData.dataLength = 4, renderData.vertexCount = 4, renderData.indiceCount = 6;
                    var vData = renderData.vData = new Float32Array(36);
                    vData[3] = vData[21] = vData[22] = vData[31] = 0, vData[4] = vData[12] = vData[13] = vData[30] = 1;
                    for (var offset = 5, i = 0; i < 4; i++) Color.toArray(vData, WHITE$3, offset), offset += 9;
                    return renderData;
                },
                fillBuffers: function fillBuffers(comp, renderer) {
                    var renderData = comp.renderData, datas = renderData.datas, node = comp.node, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
                    buffer.request() || (buffer = renderer.currBufferBatch, vertexId = indiceOffset = 0);
                    var vbuf = buffer.vData, ibuf = buffer.iData, vData = renderData.vData, data0 = datas[0], data3 = datas[3];
                    node.updateWorldTransform();
                    var pos = node._pos, rot = node._rot, scale = node._scale, ax = data0.x * scale.x, bx = data3.x * scale.x, ay = data0.y * scale.y, by = data3.y * scale.y, qx = rot.x, qy = rot.y, qz = rot.z, qw = rot.w, qxy = qx * qy, qzw = qz * qw, qxy2 = qx * qx - qy * qy, qzw2 = qw * qw - qz * qz, cx1 = qzw2 + qxy2, cx2 = 2 * (qxy - qzw), cy1 = qzw2 - qxy2, cy2 = 2 * (qxy + qzw), x = pos.x, y = pos.y;
                    vData[0] = cx1 * ax + cx2 * ay + x, vData[1] = cy1 * ay + cy2 * ax + y, vData[9] = cx1 * bx + cx2 * ay + x, 
                    vData[10] = cy1 * ay + cy2 * bx + y, vData[18] = cx1 * ax + cx2 * by + x, vData[19] = cy1 * by + cy2 * ax + y, 
                    vData[27] = cx1 * bx + cx2 * by + x, vData[28] = cy1 * by + cy2 * bx + y, vbuf.set(vData, vertexOffset), 
                    ibuf[indiceOffset++] = vertexId, ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 2, 
                    ibuf[indiceOffset++] = vertexId + 2, ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 3;
                },
                updateVerts: function updateVerts(comp) {
                    var renderData = comp.renderData;
                    if (renderData) {
                        var node = comp.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, datas = renderData.datas;
                        datas[0].x = -appx, datas[0].y = -appy, datas[3].x = width - appx, datas[3].y = height - appy;
                    }
                }
            });
            addon(ttf, ttfUtils);
            var labelAssembler = exports("labelAssembler", {
                getAssembler: function getAssembler(comp) {
                    var assembler = ttf;
                    return comp.font instanceof BitmapFont ? assembler = bmfont : comp.cacheMode === LabelComponent.CacheMode.CHAR && (sys.browserType === sys.BROWSER_TYPE_WECHAT_GAME_SUB ? warn("sorry, subdomain does not support CHAR mode currently!") : assembler = letter), 
                    assembler;
                }
            });
            LabelComponent.Assembler = labelAssembler;
            var _stencilManager = StencilManager.sharedManager, maskAssembler = exports("mask", {
                createData: function createData(mask) {
                    var renderData = mask.requestRenderData();
                    return renderData.dataLength = 4, renderData.vertexCount = 4, renderData.indiceCount = 6, 
                    renderData;
                },
                updateRenderData: function updateRenderData(mask) {
                    var renderData = mask.renderData;
                    renderData && renderData.vertDirty && this.updateVerts && this.updateVerts(mask);
                },
                updateVerts: function updateVerts(mask) {
                    var renderData = mask.renderData;
                    if (renderData) {
                        var l, b, r, t, node = mask.node, datas = renderData.datas, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch;
                        l = -appx, b = -appy, r = cw - appx, t = ch - appy, datas[0].x = l, datas[0].y = b, 
                        datas[3].x = r, datas[3].y = t, renderData.vertDirty = !1;
                    }
                },
                fillBuffers: function fillBuffers(mask, renderer) {
                    _stencilManager.pushMask(mask), _stencilManager.clear(), mask.clearGraphics.updateAssembler(renderer), 
                    _stencilManager.enterLevel(), mask.graphics.updateAssembler(renderer), _stencilManager.enableMask();
                }
            }), maskEndAssembler = exports("maskEnd", {
                fillBuffers: function fillBuffers() {
                    _stencilManager.exitMask();
                }
            }), StartAssembler = {
                getAssembler: function getAssembler() {
                    return maskAssembler;
                }
            }, PostAssembler = {
                getAssembler: function getAssembler() {
                    return maskEndAssembler;
                }
            };
            MaskComponent.Assembler = StartAssembler, MaskComponent.PostAssembler = PostAssembler;
            var FillType$1 = SpriteComponent.FillType, matrix = new Mat4(), barFilled = exports("barFilled", {
                useModel: !1,
                updateRenderData: function updateRenderData(sprite) {
                    var frame = sprite.spriteFrame, renderData = sprite.renderData;
                    if (renderData && frame) {
                        var uvDirty = renderData.uvDirty, vertDirty = renderData.vertDirty;
                        if (!uvDirty && !vertDirty) return;
                        var fillStart = sprite.fillStart, fillRange = sprite.fillRange;
                        fillRange < 0 && (fillStart += fillRange, fillRange = -fillRange), fillRange = (fillRange = 1 < (fillRange = fillStart + fillRange) ? 1 : fillRange) < 0 ? 0 : fillRange;
                        var fillEnd = (fillStart = (fillStart = 1 < fillStart ? 1 : fillStart) < 0 ? 0 : fillStart) + (fillRange = (fillRange -= fillStart) < 0 ? 0 : fillRange);
                        fillEnd = 1 < fillEnd ? 1 : fillEnd, uvDirty && this.updateUVs(sprite, fillStart, fillEnd), 
                        vertDirty && (this.updateVerts && this.updateVerts(sprite, fillStart, fillEnd), 
                        this.updateWorldVerts(sprite));
                    }
                },
                updateUVs: function updateUVs(sprite, fillStart, fillEnd) {
                    var spriteFrame = sprite.spriteFrame, renderData = sprite.renderData, datas = renderData.datas, atlasWidth = spriteFrame.width, atlasHeight = spriteFrame.height, textureRect = spriteFrame.getRect(), ul = 0, vb = 0, quadUV0 = 0, quadUV1 = 0, quadUV2 = 0, quadUV3 = 0, quadUV4 = 0, quadUV5 = 0, quadUV6 = 0, quadUV7 = 0;
                    switch (spriteFrame.isRotated() ? (ul = textureRect.x / atlasWidth, vb = (textureRect.y + textureRect.width) / atlasHeight, 
                    quadUV0 = quadUV2 = ul, quadUV4 = quadUV6 = (textureRect.x + textureRect.height) / atlasWidth, 
                    quadUV3 = quadUV7 = vb, quadUV1 = quadUV5 = textureRect.y / atlasHeight) : (ul = textureRect.x / atlasWidth, 
                    vb = (textureRect.y + textureRect.height) / atlasHeight, quadUV0 = quadUV4 = ul, 
                    quadUV2 = quadUV6 = (textureRect.x + textureRect.width) / atlasWidth, quadUV1 = quadUV3 = vb, 
                    quadUV5 = quadUV7 = textureRect.y / atlasHeight), sprite.fillType) {
                      case FillType$1.HORIZONTAL:
                        datas[0].u = quadUV0 + (quadUV2 - quadUV0) * fillStart, datas[0].v = quadUV1 + (quadUV3 - quadUV1) * fillStart, 
                        datas[1].u = quadUV0 + (quadUV2 - quadUV0) * fillEnd, datas[1].v = quadUV1 + (quadUV3 - quadUV1) * fillEnd, 
                        datas[2].u = quadUV4 + (quadUV6 - quadUV4) * fillStart, datas[2].v = quadUV5 + (quadUV7 - quadUV5) * fillStart, 
                        datas[3].u = quadUV4 + (quadUV6 - quadUV4) * fillEnd, datas[3].v = quadUV5 + (quadUV7 - quadUV5) * fillEnd;
                        break;

                      case FillType$1.VERTICAL:
                        datas[0].u = quadUV0 + (quadUV4 - quadUV0) * fillStart, datas[0].v = quadUV1 + (quadUV5 - quadUV1) * fillStart, 
                        datas[1].u = quadUV2 + (quadUV6 - quadUV2) * fillStart, datas[1].v = quadUV3 + (quadUV7 - quadUV3) * fillStart, 
                        datas[2].u = quadUV0 + (quadUV4 - quadUV0) * fillEnd, datas[2].v = quadUV1 + (quadUV5 - quadUV1) * fillEnd, 
                        datas[3].u = quadUV2 + (quadUV6 - quadUV2) * fillEnd, datas[3].v = quadUV3 + (quadUV7 - quadUV3) * fillEnd;
                        break;

                      default:
                        errorID(2626);
                    }
                    renderData.uvDirty = !1;
                },
                updateVerts: function updateVerts(sprite, fillStart, fillEnd) {
                    var renderData = sprite.renderData, datas = renderData.datas, node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, l = -appx, b = -appy, r = width - appx, t = height - appy, progressEnd = 0;
                    switch (sprite.fillType) {
                      case FillType$1.HORIZONTAL:
                        progressEnd = l + (r - l) * fillEnd, l = l + (r - l) * fillStart, r = progressEnd;
                        break;

                      case FillType$1.VERTICAL:
                        progressEnd = b + (t - b) * fillEnd, b = b + (t - b) * fillStart, t = progressEnd;
                        break;

                      default:
                        errorID(2626);
                    }
                    datas[4].x = l, datas[4].y = b, datas[5].x = r, datas[5].y = b, datas[6].x = l, 
                    datas[6].y = t, datas[7].x = r, datas[7].y = t, renderData.vertDirty = !1;
                },
                createData: function createData(sprite) {
                    var renderData = sprite.requestRenderData();
                    renderData.dataLength = 8, renderData.vertexCount = 4, renderData.indiceCount = 6;
                    var _iterator = renderData.datas, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        _ref.z = 0;
                    }
                    return renderData;
                },
                updateWorldVerts: function updateWorldVerts(sprite) {
                    var node = sprite.node, datas = sprite.renderData.datas;
                    node.getWorldMatrix(matrix);
                    for (var i = 0; i < 4; i++) {
                        var local = datas[i + 4], world = datas[i];
                        Vec3.transformMat4(world, local, matrix);
                    }
                },
                fillBuffers: function fillBuffers(sprite, renderer) {
                    sprite.node.hasChangedFlags && this.updateWorldVerts(sprite);
                    sprite.node;
                    !function fillVerticesWithoutCalc3D(node, renderer, renderData, color) {
                        var datas = renderData.datas, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
                        buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
                        vertexId = indiceOffset = vertexCount = 0);
                        for (var vbuf = buffer.vData, i = 0; i < vertexCount; i++) {
                            var vert = datas[i];
                            vbuf[vertexOffset++] = vert.x, vbuf[vertexOffset++] = vert.y, vbuf[vertexOffset++] = vert.z, 
                            vbuf[vertexOffset++] = vert.u, vbuf[vertexOffset++] = vert.v, Color.toArray(vbuf, color, vertexOffset), 
                            vertexOffset += 4;
                        }
                        var ibuf = buffer.iData;
                        ibuf[indiceOffset++] = vertexId, ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 2, 
                        ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 3, ibuf[indiceOffset++] = vertexId + 2;
                    }(0, renderer, sprite.renderData, sprite.color);
                }
            }), PI_2 = 2 * Math.PI, _vertPos = [ new Vec2(), new Vec2(), new Vec2(), new Vec2() ], _vertices = new Array(4), _uvs = new Array(8), _intersectPoint_1 = [ new Vec2(), new Vec2(), new Vec2(), new Vec2() ], _intersectPoint_2 = [ new Vec2(), new Vec2(), new Vec2(), new Vec2() ], _center = new Vec2(), _triangles = [ new Vec2(), new Vec2(), new Vec2(), new Vec2() ];
            function _calcInsectedPoints(left, right, bottom, top, center, angle, intersectPoints) {
                var sinAngle = Math.sin(angle);
                sinAngle = 1e-6 < Math.abs(sinAngle) ? sinAngle : 0;
                var cosAngle = Math.cos(angle), tanAngle = 0, cotAngle = 0;
                if (0 !== (cosAngle = 1e-6 < Math.abs(cosAngle) ? cosAngle : 0)) {
                    if (tanAngle = sinAngle / cosAngle, 0 < (left - center.x) * cosAngle) {
                        var yleft = center.y + tanAngle * (left - center.x);
                        intersectPoints[0].x = left, intersectPoints[0].y = yleft;
                    }
                    if (0 < (right - center.x) * cosAngle) {
                        var yright = center.y + tanAngle * (right - center.x);
                        intersectPoints[2].x = right, intersectPoints[2].y = yright;
                    }
                }
                if (0 !== sinAngle) {
                    if (cotAngle = cosAngle / sinAngle, 0 < (top - center.y) * sinAngle) {
                        var xtop = center.x + cotAngle * (top - center.y);
                        intersectPoints[3].x = xtop, intersectPoints[3].y = top;
                    }
                    if (0 < (bottom - center.y) * sinAngle) {
                        var xbottom = center.x + cotAngle * (bottom - center.y);
                        intersectPoints[1].x = xbottom, intersectPoints[1].y = bottom;
                    }
                }
            }
            function _getVertAngle(start, end) {
                var placementX = end.x - start.x, placementY = end.y - start.y;
                if (0 == placementX && 0 == placementY) return 0;
                if (0 == placementX) return 0 < placementY ? .5 * Math.PI : 1.5 * Math.PI;
                var angle = Math.atan(placementY / placementX);
                return placementX < 0 && (angle += Math.PI), angle;
            }
            function _generateTriangle(datas, offset, vert0, vert1, vert2) {
                var vertices = _vertices, v0x = vertices[0], v0y = vertices[1], v1x = vertices[2], v1y = vertices[3];
                datas[offset].x = vert0.x, datas[offset].y = vert0.y, datas[offset + 1].x = vert1.x, 
                datas[offset + 1].y = vert1.y, datas[offset + 2].x = vert2.x, datas[offset + 2].y = vert2.y;
                _generateUV((vert0.x - v0x) / (v1x - v0x), (vert0.y - v0y) / (v1y - v0y), datas, offset), 
                _generateUV((vert1.x - v0x) / (v1x - v0x), (vert1.y - v0y) / (v1y - v0y), datas, offset + 1), 
                _generateUV((vert2.x - v0x) / (v1x - v0x), (vert2.y - v0y) / (v1y - v0y), datas, offset + 2);
            }
            function _generateUV(progressX, progressY, data, offset) {
                var uvs = _uvs, px1 = uvs[0] + (uvs[2] - uvs[0]) * progressX, px2 = uvs[4] + (uvs[6] - uvs[4]) * progressX, py1 = uvs[1] + (uvs[3] - uvs[1]) * progressX, py2 = uvs[5] + (uvs[7] - uvs[5]) * progressX, uv = data[offset];
                uv.u = px1 + (px2 - px1) * progressY, uv.v = py1 + (py2 - py1) * progressY;
            }
            for (var radialFilled = exports("radialFilled", {
                useModel: !1,
                createData: function createData(sprite) {
                    return sprite.requestRenderData();
                },
                updateRenderData: function updateRenderData(sprite) {
                    var frame = sprite.spriteFrame, renderData = sprite.renderData;
                    if (renderData && frame && (renderData.vertDirty || renderData.uvDirty)) {
                        var datas = renderData.datas, fillStart = sprite.fillStart, fillRange = sprite.fillRange;
                        for (fillRange < 0 && (fillStart += fillRange, fillRange = -fillRange); 1 <= fillStart; ) fillStart -= 1;
                        for (;fillStart < 0; ) fillStart += 1;
                        var fillEnd = (fillStart *= PI_2) + (fillRange *= PI_2);
                        !function _calculateVertices(sprite) {
                            var node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, l = -appx, b = -appy, r = width - appx, t = height - appy, vertices = _vertices;
                            vertices[0] = l, vertices[1] = b, vertices[2] = r, vertices[3] = t;
                            var fillCenter = sprite.fillCenter, cx = _center.x = Math.min(Math.max(0, fillCenter.x), 1) * (r - l) + l, cy = _center.y = Math.min(Math.max(0, fillCenter.y), 1) * (t - b) + b;
                            _vertPos[0].x = _vertPos[3].x = l, _vertPos[1].x = _vertPos[2].x = r, _vertPos[0].y = _vertPos[1].y = b, 
                            _vertPos[2].y = _vertPos[3].y = t;
                            var _iterator = _triangles, _isArray = Array.isArray(_iterator), _i = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i >= _iterator.length) break;
                                    _ref = _iterator[_i++];
                                } else {
                                    if ((_i = _iterator.next()).done) break;
                                    _ref = _i.value;
                                }
                                var num = _ref;
                                Vec2.set(num, 0, 0);
                            }
                            cx !== vertices[0] && Vec2.set(_triangles[0], 3, 0), cx !== vertices[2] && Vec2.set(_triangles[2], 1, 2), 
                            cy !== vertices[1] && Vec2.set(_triangles[1], 0, 1), cy !== vertices[3] && Vec2.set(_triangles[3], 2, 3);
                        }(sprite), function _calculateUVs(spriteFrame) {
                            var atlasWidth = spriteFrame.width, atlasHeight = spriteFrame.height, textureRect = spriteFrame.getRect(), u0 = 0, u1 = 0, v0 = 0, v1 = 0, uvs = _uvs;
                            spriteFrame.isRotated() ? (u0 = textureRect.x / atlasWidth, u1 = (textureRect.x + textureRect.height) / atlasWidth, 
                            v0 = textureRect.y / atlasHeight, v1 = (textureRect.y + textureRect.width) / atlasHeight, 
                            uvs[0] = uvs[2] = u0, uvs[4] = uvs[6] = u1, uvs[3] = uvs[7] = v1, uvs[1] = uvs[5] = v0) : (u0 = textureRect.x / atlasWidth, 
                            u1 = (textureRect.x + textureRect.width) / atlasWidth, v0 = textureRect.y / atlasHeight, 
                            v1 = (textureRect.y + textureRect.height) / atlasHeight, uvs[0] = uvs[4] = u0, uvs[2] = uvs[6] = u1, 
                            uvs[1] = uvs[3] = v1, uvs[5] = uvs[7] = v0);
                        }(frame), _calcInsectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart, _intersectPoint_1), 
                        _calcInsectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart + fillRange, _intersectPoint_2);
                        for (var offset = 0, triangleIndex = 0; triangleIndex < 4; ++triangleIndex) {
                            var triangle = _triangles[triangleIndex];
                            if (triangle) if (PI_2 <= fillRange) renderData.dataLength = offset + 3, _generateTriangle(datas, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]), 
                            offset += 3; else {
                                var startAngle = _getVertAngle(_center, _vertPos[triangle.x]), endAngle = _getVertAngle(_center, _vertPos[triangle.y]);
                                endAngle < startAngle && (endAngle += PI_2), startAngle -= PI_2, endAngle -= PI_2;
                                for (var testIndex = 0; testIndex < 3; ++testIndex) fillEnd <= startAngle || (fillStart <= startAngle ? (renderData.dataLength = offset + 3, 
                                _generateTriangle(datas, offset, _center, _vertPos[triangle.x], fillEnd <= endAngle ? _intersectPoint_2[triangleIndex] : _vertPos[triangle.y]), 
                                offset += 3) : endAngle <= fillStart || (endAngle <= fillEnd ? (renderData.dataLength = offset + 3, 
                                _generateTriangle(datas, offset, _center, _intersectPoint_1[triangleIndex], _vertPos[triangle.y])) : (renderData.dataLength = offset + 3, 
                                _generateTriangle(datas, offset, _center, _intersectPoint_1[triangleIndex], _intersectPoint_2[triangleIndex])), 
                                offset += 3)), startAngle += PI_2, endAngle += PI_2;
                            }
                        }
                        renderData.indiceCount = renderData.vertexCount = offset, renderData.vertDirty = renderData.uvDirty = !1;
                    }
                },
                fillBuffers: function fillBuffers(comp, renderer) {
                    !function fillVertices3D(node, renderer, renderData, color) {
                        var datas = renderData.datas, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
                        buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
                        vertexId = indiceOffset = vertexCount = 0);
                        var vbuf = buffer.vData;
                        node.getWorldMatrix(_worldMatrix$1);
                        for (var i = 0; i < vertexCount; i++) {
                            var vert = datas[i];
                            Vec3.set(vec3_temp, vert.x, vert.y, 0), Vec3.transformMat4(vec3_temp, vec3_temp, _worldMatrix$1), 
                            vbuf[vertexOffset++] = vec3_temp.x, vbuf[vertexOffset++] = vec3_temp.y, vbuf[vertexOffset++] = vec3_temp.z, 
                            vbuf[vertexOffset++] = vert.u, vbuf[vertexOffset++] = vert.v, Color.toArray(vbuf, color, vertexOffset), 
                            vertexOffset += 4;
                        }
                        for (var ibuf = buffer.iData, _i = 0; _i < renderData.dataLength; _i++) ibuf[indiceOffset + _i] = vertexId + _i;
                    }(comp.node, renderer, comp.renderData, comp.color);
                }
            }), vec3_temps$1 = [], i$3 = 0; i$3 < 4; i$3++) vec3_temps$1.push(new Vec3());
            var _dec$1g, _dec2$T, _dec3$D, _dec4$x, _class$1i, _class2$12, _descriptor$_, _descriptor2$Q, _descriptor3$B, _descriptor4$w, simple = exports("simple", {
                createData: function createData(sprite) {
                    var renderData = sprite.requestRenderData();
                    return renderData.dataLength = 4, renderData.vertexCount = 4, renderData.indiceCount = 6, 
                    renderData.vData = new Float32Array(36), renderData;
                },
                updateRenderData: function updateRenderData(sprite) {
                    var frame = sprite.spriteFrame, renderData = sprite.renderData;
                    renderData && frame && (renderData.vertDirty && this.updateVerts(sprite), renderData.uvDirty && this.updateUvs(sprite));
                },
                fillBuffers: function fillBuffers(sprite, renderer) {
                    if (null !== sprite) {
                        var datas = sprite.renderData.datas, node = sprite.node, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
                        buffer.request() || (buffer = renderer.currBufferBatch, vertexId = indiceOffset = vertexOffset = 0);
                        var vbuf = buffer.vData, ibuf = buffer.iData, vData = sprite.renderData.vData, data0 = datas[0], data3 = datas[3], matrix = node.worldMatrix, a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13, vl = data0.x, vr = data3.x, vb = data0.y, vt = data3.y, al = a * vl, ar = a * vr, bl = b * vl, br = b * vr, cb = c * vb, ct = c * vt, db = d * vb, dt = d * vt;
                        vData[0] = al + cb + tx, vData[1] = bl + db + ty, vData[9] = ar + cb + tx, vData[10] = br + db + ty, 
                        vData[18] = al + ct + tx, vData[19] = bl + dt + ty, vData[27] = ar + ct + tx, vData[28] = br + dt + ty, 
                        vbuf.set(vData, vertexOffset), ibuf[indiceOffset++] = vertexId, ibuf[indiceOffset++] = vertexId + 1, 
                        ibuf[indiceOffset++] = vertexId + 2, ibuf[indiceOffset++] = vertexId + 2, ibuf[indiceOffset++] = vertexId + 1, 
                        ibuf[indiceOffset++] = vertexId + 3;
                    }
                },
                updateVerts: function updateVerts(sprite) {
                    var renderData = sprite.renderData;
                    if (renderData) {
                        var node = sprite.node, datas = renderData.datas, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch, l = 0, b = 0, r = 0, t = 0;
                        if (sprite.trim) l = -appx, b = -appy, r = cw - appx, t = ch - appy; else {
                            var frame = sprite.spriteFrame, originSize = frame.getOriginalSize(), rect = frame.getRect(), ow = originSize.width, oh = originSize.height, rw = rect.width, rh = rect.height, offset = frame.getOffset(), scaleX = cw / ow, scaleY = ch / oh, trimLeft = offset.x + (ow - rw) / 2, trimRight = offset.x - (ow - rw) / 2;
                            l = trimLeft * scaleX - appx, b = (offset.y + (oh - rh) / 2) * scaleY - appy, r = cw + trimRight * scaleX - appx, 
                            t = ch + (offset.y - (oh - rh) / 2) * scaleY - appy;
                        }
                        datas[0].x = l, datas[0].y = b, datas[0].z = 0, datas[3].x = r, datas[3].y = t, 
                        datas[3].z = 0, renderData.vertDirty = !1;
                    }
                },
                updateUvs: function updateUvs(sprite) {
                    var renderData = sprite.renderData, vData = renderData.vData, uv = sprite.spriteFrame.uv;
                    vData[3] = uv[0], vData[4] = uv[1], vData[12] = uv[2], vData[13] = uv[3], vData[21] = uv[4], 
                    vData[22] = uv[5], vData[30] = uv[6], vData[31] = uv[7], renderData.uvDirty = !1;
                },
                updateColor: function updateColor(sprite) {
                    for (var vData = sprite.renderData.vData, colorOffset = 5, color = sprite.color, colorr = color.r / 255, colorg = color.g / 255, colorb = color.b / 255, colora = color.a / 255, _i = 0; _i < 4; _i++) vData[colorOffset] = colorr, 
                    vData[colorOffset + 1] = colorg, vData[colorOffset + 2] = colorb, vData[colorOffset + 3] = colora, 
                    colorOffset += 9;
                }
            }), vec3_temp$1 = new Vec3(), matrix$1 = new Mat4(), sliced = exports("sliced", {
                useModel: !1,
                createData: function createData(sprite) {
                    var renderData = sprite.requestRenderData();
                    return renderData.dataLength = 20, renderData.vertexCount = 16, renderData.indiceCount = 54, 
                    renderData;
                },
                updateRenderData: function updateRenderData(sprite) {
                    var frame = sprite.spriteFrame, renderData = sprite.renderData;
                    renderData && frame && renderData.vertDirty && (this.updateVerts(sprite), this.updateWorldVerts(sprite));
                },
                updateVerts: function updateVerts(sprite) {
                    var renderData = sprite.renderData, datas = renderData.datas, node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, frame = sprite.spriteFrame, leftWidth = frame.insetLeft, rightWidth = frame.insetRight, topHeight = frame.insetTop, bottomHeight = frame.insetBottom, sizableWidth = width - leftWidth - rightWidth, sizableHeight = height - topHeight - bottomHeight, xScale = width / (leftWidth + rightWidth), yScale = height / (topHeight + bottomHeight);
                    xScale = isNaN(xScale) || 1 < xScale ? 1 : xScale, yScale = isNaN(yScale) || 1 < yScale ? 1 : yScale, 
                    sizableWidth = sizableWidth < 0 ? 0 : sizableWidth, sizableHeight = sizableHeight < 0 ? 0 : sizableHeight, 
                    datas[0].x = -appx, datas[0].y = -appy, datas[1].x = leftWidth * xScale - appx, 
                    datas[1].y = bottomHeight * yScale - appy, datas[2].x = datas[1].x + sizableWidth, 
                    datas[2].y = datas[1].y + sizableHeight, datas[3].x = width - appx, datas[3].y = height - appy, 
                    renderData.vertDirty = !1;
                },
                fillBuffers: function fillBuffers(sprite, renderer) {
                    sprite.node.hasChangedFlags && this.updateWorldVerts(sprite);
                    var buffer = renderer.currBufferBatch, renderData = sprite.renderData, datas = renderData.datas, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset, uvSliced = sprite.spriteFrame.uvSliced;
                    buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
                    vertexId = indiceOffset = vertexOffset = 0);
                    for (var vbuf = buffer.vData, ibuf = buffer.iData, i = 4; i < 20; ++i) {
                        var vert = datas[i], uvs = uvSliced[i - 4];
                        vbuf[vertexOffset++] = vert.x, vbuf[vertexOffset++] = vert.y, vbuf[vertexOffset++] = vert.z, 
                        vbuf[vertexOffset++] = uvs.u, vbuf[vertexOffset++] = uvs.v, Color.toArray(vbuf, sprite.color, vertexOffset), 
                        vertexOffset += 4;
                    }
                    for (var r = 0; r < 3; ++r) for (var c = 0; c < 3; ++c) {
                        var start = vertexId + 4 * r + c;
                        ibuf[indiceOffset++] = start, ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 4, 
                        ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 5, ibuf[indiceOffset++] = start + 4;
                    }
                },
                updateWorldVerts: function updateWorldVerts(sprite) {
                    var node = sprite.node, datas = sprite.renderData.datas;
                    node.getWorldMatrix(matrix$1);
                    for (var row = 0; row < 4; ++row) for (var rowD = datas[row], col = 0; col < 4; ++col) {
                        var colD = datas[col], world = datas[4 + 4 * row + col];
                        Vec3.set(vec3_temp$1, colD.x, rowD.y, 0), Vec3.transformMat4(world, vec3_temp$1, matrix$1);
                    }
                }
            }), SpriteType$1 = SpriteComponent.Type, FillType$2 = SpriteComponent.FillType, spriteAssembler = exports("spriteAssembler", {
                getAssembler: function getAssembler(spriteComp) {
                    var util = simple, comp = spriteComp;
                    switch (comp.type) {
                      case SpriteType$1.SLICED:
                        util = sliced;
                        break;

                      case SpriteType$1.FILLED:
                        util = comp.fillType === FillType$2.RADIAL ? radialFilled : barFilled;
                    }
                    return util;
                }
            });
            SpriteComponent.Assembler = spriteAssembler, cc.UI = {
                MeshBuffer: MeshBuffer,
                UIVertexFormat: UIVertexFormat,
                barFilled: barFilled,
                radialFilled: radialFilled,
                simple: simple,
                sliced: sliced,
                ttf: ttf,
                bmfont: bmfont,
                letter: letter,
                mask: maskAssembler,
                maskEnd: maskEndAssembler,
                graphics: graphicsAssembler,
                spriteAssembler: spriteAssembler,
                graphicsAssembler: graphicsAssemblerManager,
                labelAssembler: labelAssembler
            };
            var _dec$1h, _dec2$U, _dec3$E, _dec4$y, _dec5$u, _class$1j, _class2$13, _descriptor$$, _descriptor2$R, _descriptor3$C, _descriptor4$x, _descriptor5$p, _descriptor6$g, _descriptor7$e, _descriptor8$e, _class3$y, _temp$1b, _class$1k, _class2$14, _descriptor$10, _descriptor2$S, _class4$6, _class5$6, _descriptor3$D, _descriptor4$y, _class7$1, _class8$1, _descriptor5$q, _descriptor6$h, _descriptor7$f, _class9, _temp3$1, _dec$1j, _dec2$W, _dec3$G, _dec4$z, _dec5$v, _dec6$q, _class$1l, _class2$15, _descriptor$11, _descriptor2$T, _descriptor3$E, _descriptor4$z, _descriptor5$r, _descriptor6$i, _descriptor7$g, _class3$z, _temp$1d, _dec$1k, _dec2$X, _dec3$H, _dec4$A, _dec5$w, _dec6$r, _dec7$j, _dec8$b, _dec9$9, _dec10$8, _dec11$7, _dec12$6, _dec13$3, _class$1m, _class2$16, _descriptor$12, _descriptor2$U, _descriptor3$F, _descriptor4$A, _descriptor5$s, _descriptor6$j, _descriptor7$h, _dec$1l, _dec2$Y, _dec3$I, _class$1n, _class2$17, _descriptor$13, _descriptor2$V, _dec$1m, _dec2$Z, _dec3$J, _dec4$B, _dec5$x, _dec6$s, _class$1o, _class2$18, _descriptor$14, _descriptor2$W, _descriptor3$G, _descriptor4$B, _descriptor5$t, BillboardComponent = exports("BillboardComponent", (_dec$1g = ccclass("cc.BillboardComponent"), 
            _dec2$T = menu("Components/Billboard"), _dec3$D = property({
                type: Texture2D
            }), _dec4$x = property({
                type: Texture2D
            }), _dec$1g(_class$1i = _dec2$T(_class$1i = executeInEditMode((_descriptor$_ = _applyDecoratedDescriptor((_class2$12 = function() {
                function BillboardComponent() {
                    var _this;
                    return _classCallCheck(this, BillboardComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(BillboardComponent).call(this)), "_texture", _descriptor$_, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_height", _descriptor2$Q, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_width", _descriptor3$B, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_rotation", _descriptor4$w, _assertThisInitialized(_this)), 
                    _this._model = null, _this._mesh = null, _this._material = null, _this._uniform = new Vec4(1, 1, 0, 0), 
                    _this;
                }
                return _inherits(BillboardComponent, Component), _createClass(BillboardComponent, [ {
                    key: "texture",
                    get: function get() {
                        return this._texture;
                    },
                    set: function set(val) {
                        this._texture = val, this._material && this._material.setProperty("mainTexture", val);
                    }
                }, {
                    key: "height",
                    get: function get() {
                        return this._height;
                    },
                    set: function set(val) {
                        this._height = val, this._material && (this._uniform.y = val, this._material.setProperty("cc_size_rotation", this._uniform));
                    }
                }, {
                    key: "width",
                    get: function get() {
                        return this._width;
                    },
                    set: function set(val) {
                        this._width = val, this._material && (this._uniform.x = val, this._material.setProperty("cc_size_rotation", this._uniform));
                    }
                }, {
                    key: "rotation",
                    get: function get() {
                        return Math.round(100 * toDegree(this._rotation)) / 100;
                    },
                    set: function set(val) {
                        this._rotation = toRadian(val), this._material && (this._uniform.z = this._rotation, 
                        this._material.setProperty("cc_size_rotation", this._uniform));
                    }
                } ]), _createClass(BillboardComponent, [ {
                    key: "onEnable",
                    value: function onEnable() {
                        this._model || this.createModel(), this._model.enabled = !0, this.width = this._width, 
                        this.height = this._height, this.rotation = this.rotation, this.texture = this.texture;
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this._model && (this._model.enabled = !1);
                    }
                }, {
                    key: "createModel",
                    value: function createModel() {
                        this._mesh = createMesh({
                            primitiveMode: GFXPrimitiveMode.TRIANGLE_LIST,
                            positions: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
                            uvs: [ 0, 0, 1, 0, 0, 1, 1, 1 ],
                            colors: [ Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a, Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a, Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a, Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a ],
                            attributes: [ {
                                name: GFXAttributeName.ATTR_POSITION,
                                format: GFXFormat.RGB32F
                            }, {
                                name: GFXAttributeName.ATTR_TEX_COORD,
                                format: GFXFormat.RG32F
                            }, {
                                name: GFXAttributeName.ATTR_COLOR,
                                format: GFXFormat.RGBA8UI,
                                isNormalized: !0
                            } ],
                            indices: [ 0, 1, 2, 1, 2, 3 ]
                        }, void 0, {
                            calculateBounds: !1
                        }), this._model = this._getRenderScene().createModel(Model, this.node), null == this._material && (this._material = new Material(), 
                        this._material.copy(builtinResMgr.get("default-billboard-material"))), this._model.initSubModel(0, this._mesh.getSubMesh(0), this._material);
                    }
                } ]), BillboardComponent;
            }()).prototype, "_texture", [ _dec3$D ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _applyDecoratedDescriptor(_class2$12.prototype, "texture", [ _dec4$x ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "texture"), _class2$12.prototype), 
            _descriptor2$Q = _applyDecoratedDescriptor(_class2$12.prototype, "_height", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _applyDecoratedDescriptor(_class2$12.prototype, "height", [ property ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "height"), _class2$12.prototype), 
            _descriptor3$B = _applyDecoratedDescriptor(_class2$12.prototype, "_width", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _applyDecoratedDescriptor(_class2$12.prototype, "width", [ property ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "width"), _class2$12.prototype), 
            _descriptor4$w = _applyDecoratedDescriptor(_class2$12.prototype, "_rotation", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _applyDecoratedDescriptor(_class2$12.prototype, "rotation", [ property ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "rotation"), _class2$12.prototype), 
            _class$1i = _class2$12)) || _class$1i) || _class$1i) || _class$1i)), _vertex_attrs = [ {
                name: GFXAttributeName.ATTR_POSITION,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_TEX_COORD,
                format: GFXFormat.RGBA32F
            }, {
                name: GFXAttributeName.ATTR_TEX_COORD1,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_COLOR,
                format: GFXFormat.RGBA8,
                isNormalized: !0
            } ], _temp_v1 = new Vec3(), _temp_v2 = new Vec3(), LineModel = function() {
                function LineModel(scene, node) {
                    var _this;
                    return _classCallCheck(this, LineModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(LineModel).call(this, scene, node)))._capacity = void 0, 
                    _this._vertSize = 0, _this._vBuffer = null, _this._vertAttrsFloatCount = 0, _this._vdataF32 = null, 
                    _this._vdataUint32 = null, _this._iaInfo = void 0, _this._iaInfoBuffer = void 0, 
                    _this._subMeshData = null, _this._vertCount = 0, _this._indexCount = 0, _this._capacity = 100, 
                    _this._iaInfo = {
                        drawInfos: [ {
                            vertexCount: 0,
                            firstVertex: 0,
                            indexCount: 0,
                            firstIndex: 0,
                            vertexOffset: 0,
                            instanceCount: 0,
                            firstInstance: 0
                        } ]
                    }, _this._iaInfoBuffer = _this._device.createBuffer({
                        usage: GFXBufferUsageBit.INDIRECT,
                        memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                        size: 56,
                        stride: 1
                    }), _this;
                }
                return _inherits(LineModel, Model), _createClass(LineModel, [ {
                    key: "setCapacity",
                    value: function setCapacity(capacity) {
                        this._capacity = capacity, this.createBuffer();
                    }
                }, {
                    key: "createBuffer",
                    value: function createBuffer() {
                        this._vertSize = 0;
                        var _iterator = _vertex_attrs, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var a = _ref;
                            a.offset = this._vertSize, this._vertSize += GFXFormatInfos[a.format].size;
                        }
                        this._vertAttrsFloatCount = this._vertSize / 4, this._vBuffer = this._createSubMeshData(), 
                        this._vdataF32 = new Float32Array(this._vBuffer), this._vdataUint32 = new Uint32Array(this._vBuffer);
                    }
                }, {
                    key: "_createSubMeshData",
                    value: function _createSubMeshData() {
                        this._subMeshData && this.destroySubMeshData(), this._vertCount = 2, this._indexCount = 6;
                        var vertexBuffer = this._device.createBuffer({
                            usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                            size: this._vertSize * this._capacity * this._vertCount,
                            stride: this._vertSize
                        }), vBuffer = new ArrayBuffer(this._vertSize * this._capacity * this._vertCount);
                        vertexBuffer.update(vBuffer);
                        for (var indices = new Uint16Array((this._capacity - 1) * this._indexCount), dst = 0, i = 0; i < this._capacity - 1; ++i) {
                            var baseIdx = 2 * i;
                            indices[dst++] = baseIdx, indices[dst++] = 1 + baseIdx, indices[dst++] = 2 + baseIdx, 
                            indices[dst++] = 3 + baseIdx, indices[dst++] = 2 + baseIdx, indices[dst++] = 1 + baseIdx;
                        }
                        var indexBuffer = this._device.createBuffer({
                            usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                            size: (this._capacity - 1) * this._indexCount * Uint16Array.BYTES_PER_ELEMENT,
                            stride: Uint16Array.BYTES_PER_ELEMENT
                        });
                        return indexBuffer.update(indices), this._iaInfo.drawInfos[0].vertexCount = this._capacity * this._vertCount, 
                        this._iaInfo.drawInfos[0].indexCount = (this._capacity - 1) * this._indexCount, 
                        this._iaInfoBuffer.update(this._iaInfo), this._subMeshData = {
                            vertexBuffers: [ vertexBuffer ],
                            indexBuffer: indexBuffer,
                            indirectBuffer: this._iaInfoBuffer,
                            attributes: _vertex_attrs,
                            primitiveMode: GFXPrimitiveMode.TRIANGLE_LIST,
                            flatBuffers: []
                        }, this.setSubModelMesh(0, this._subMeshData), vBuffer;
                    }
                }, {
                    key: "addLineVertexData",
                    value: function addLineVertexData(positions, width, color) {
                        if (1 < positions.length) {
                            var offset = 0;
                            Vec3.subtract(_temp_v1, positions[1], positions[0]), this._vdataF32[offset++] = positions[0].x, 
                            this._vdataF32[offset++] = positions[0].y, this._vdataF32[offset++] = positions[0].z, 
                            this._vdataF32[offset++] = 0, this._vdataF32[offset++] = width.evaluate(0, 1), this._vdataF32[offset++] = 0, 
                            this._vdataF32[offset++] = 0, this._vdataF32[offset++] = _temp_v1.x, this._vdataF32[offset++] = _temp_v1.y, 
                            this._vdataF32[offset++] = _temp_v1.z, this._vdataUint32[offset++] = color.evaluate(0, 1)._val, 
                            this._vdataF32[offset++] = positions[0].x, this._vdataF32[offset++] = positions[0].y, 
                            this._vdataF32[offset++] = positions[0].z, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = width.evaluate(0, 1), 
                            this._vdataF32[offset++] = 0, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = _temp_v1.x, 
                            this._vdataF32[offset++] = _temp_v1.y, this._vdataF32[offset++] = _temp_v1.z, this._vdataUint32[offset++] = color.evaluate(0, 1)._val;
                            for (var i = 1; i < positions.length - 1; i++) {
                                Vec3.subtract(_temp_v1, positions[i - 1], positions[i]), Vec3.subtract(_temp_v2, positions[i + 1], positions[i]), 
                                Vec3.subtract(_temp_v2, _temp_v2, _temp_v1);
                                var seg = i / positions.length;
                                this._vdataF32[offset++] = positions[i].x, this._vdataF32[offset++] = positions[i].y, 
                                this._vdataF32[offset++] = positions[i].z, this._vdataF32[offset++] = 0, this._vdataF32[offset++] = width.evaluate(seg, 1), 
                                this._vdataF32[offset++] = seg, this._vdataF32[offset++] = 0, this._vdataF32[offset++] = _temp_v2.x, 
                                this._vdataF32[offset++] = _temp_v2.y, this._vdataF32[offset++] = _temp_v2.z, this._vdataUint32[offset++] = color.evaluate(seg, 1)._val, 
                                this._vdataF32[offset++] = positions[i].x, this._vdataF32[offset++] = positions[i].y, 
                                this._vdataF32[offset++] = positions[i].z, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = width.evaluate(seg, 1), 
                                this._vdataF32[offset++] = seg, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = _temp_v2.x, 
                                this._vdataF32[offset++] = _temp_v2.y, this._vdataF32[offset++] = _temp_v2.z, this._vdataUint32[offset++] = color.evaluate(seg, 1)._val;
                            }
                            Vec3.subtract(_temp_v1, positions[positions.length - 1], positions[positions.length - 2]), 
                            this._vdataF32[offset++] = positions[positions.length - 1].x, this._vdataF32[offset++] = positions[positions.length - 1].y, 
                            this._vdataF32[offset++] = positions[positions.length - 1].z, this._vdataF32[offset++] = 0, 
                            this._vdataF32[offset++] = width.evaluate(1, 1), this._vdataF32[offset++] = 1, this._vdataF32[offset++] = 0, 
                            this._vdataF32[offset++] = _temp_v1.x, this._vdataF32[offset++] = _temp_v1.y, this._vdataF32[offset++] = _temp_v1.z, 
                            this._vdataUint32[offset++] = color.evaluate(1, 1)._val, this._vdataF32[offset++] = positions[positions.length - 1].x, 
                            this._vdataF32[offset++] = positions[positions.length - 1].y, this._vdataF32[offset++] = positions[positions.length - 1].z, 
                            this._vdataF32[offset++] = 1, this._vdataF32[offset++] = width.evaluate(1, 1), this._vdataF32[offset++] = 1, 
                            this._vdataF32[offset++] = 1, this._vdataF32[offset++] = _temp_v1.x, this._vdataF32[offset++] = _temp_v1.y, 
                            this._vdataF32[offset++] = _temp_v1.z, this._vdataUint32[offset++] = color.evaluate(1, 1)._val;
                        }
                        this.updateIA(Math.max(0, positions.length - 1));
                    }
                }, {
                    key: "updateIA",
                    value: function updateIA(count) {
                        this.getSubModel(0).inputAssembler.vertexBuffers[0].update(this._vdataF32), this.getSubModel(0).inputAssembler.indexCount = this._indexCount * count, 
                        this.getSubModel(0).inputAssembler.extractDrawInfo(this._iaInfo.drawInfos[0]), this._iaInfoBuffer.update(this._iaInfo);
                    }
                }, {
                    key: "destroySubMeshData",
                    value: function destroySubMeshData() {
                        var _iterator2 = this._subMeshData.vertexBuffers, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            _ref2.destroy();
                        }
                        this._subMeshData.indexBuffer.destroy();
                    }
                } ]), LineModel;
            }(), Mode$1 = Enum({
                Constant: 0,
                Curve: 1,
                TwoCurves: 2,
                TwoConstants: 3
            }), CurveRange = (_dec$1h = ccclass("cc.CurveRange"), _dec2$U = property({
                type: Mode$1
            }), _dec3$E = property({
                type: AnimationCurve
            }), _dec4$y = property({
                type: AnimationCurve
            }), _dec5$u = property({
                type: AnimationCurve
            }), _dec$1h((_temp$1b = _class3$y = function() {
                function CurveRange() {
                    _classCallCheck(this, CurveRange), _initializerDefineProperty(this, "mode", _descriptor$$, this), 
                    _initializerDefineProperty(this, "curve", _descriptor2$R, this), _initializerDefineProperty(this, "curveMin", _descriptor3$C, this), 
                    _initializerDefineProperty(this, "curveMax", _descriptor4$x, this), _initializerDefineProperty(this, "constant", _descriptor5$p, this), 
                    _initializerDefineProperty(this, "constantMin", _descriptor6$g, this), _initializerDefineProperty(this, "constantMax", _descriptor7$e, this), 
                    _initializerDefineProperty(this, "multiplier", _descriptor8$e, this);
                }
                return _createClass(CurveRange, [ {
                    key: "evaluate",
                    value: function evaluate(time, rndRatio) {
                        switch (this.mode) {
                          case Mode$1.Constant:
                            return this.constant;

                          case Mode$1.Curve:
                            return this.curve.evaluate(time) * this.multiplier;

                          case Mode$1.TwoCurves:
                            return lerp(this.curveMin.evaluate(time), this.curveMax.evaluate(time), rndRatio) * this.multiplier;

                          case Mode$1.TwoConstants:
                            return lerp(this.constantMin, this.constantMax, rndRatio);
                        }
                    }
                }, {
                    key: "getMax",
                    value: function getMax() {
                        switch (this.mode) {
                          case Mode$1.Constant:
                            return this.constant;

                          case Mode$1.Curve:
                            return this.multiplier;

                          case Mode$1.TwoConstants:
                            return this.constantMax;

                          case Mode$1.TwoCurves:
                            return this.multiplier;
                        }
                        return 0;
                    }
                } ]), CurveRange;
            }(), _class3$y.Mode = Mode$1, _descriptor$$ = _applyDecoratedDescriptor((_class2$13 = _temp$1b).prototype, "mode", [ _dec2$U ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Mode$1.Constant;
                }
            }), _descriptor2$R = _applyDecoratedDescriptor(_class2$13.prototype, "curve", [ _dec3$E ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new AnimationCurve();
                }
            }), _descriptor3$C = _applyDecoratedDescriptor(_class2$13.prototype, "curveMin", [ _dec4$y ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new AnimationCurve();
                }
            }), _descriptor4$x = _applyDecoratedDescriptor(_class2$13.prototype, "curveMax", [ _dec5$u ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new AnimationCurve();
                }
            }), _descriptor5$p = _applyDecoratedDescriptor(_class2$13.prototype, "constant", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor6$g = _applyDecoratedDescriptor(_class2$13.prototype, "constantMin", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor7$e = _applyDecoratedDescriptor(_class2$13.prototype, "constantMax", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor8$e = _applyDecoratedDescriptor(_class2$13.prototype, "multiplier", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _class$1j = _class2$13)) || _class$1j), Mode$2 = Enum({
                Blend: 0,
                Fixed: 1
            }), Gradient = (ccclass("cc.ColorKey")((_descriptor$10 = _applyDecoratedDescriptor((_class2$14 = function ColorKey() {
                _classCallCheck(this, ColorKey), _initializerDefineProperty(this, "color", _descriptor$10, this), 
                _initializerDefineProperty(this, "time", _descriptor2$S, this);
            }).prototype, "color", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Color.WHITE.clone();
                }
            }), _descriptor2$S = _applyDecoratedDescriptor(_class2$14.prototype, "time", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _class$1k = _class2$14)), ccclass("cc.AlphaKey")((_descriptor3$D = _applyDecoratedDescriptor((_class5$6 = function AlphaKey() {
                _classCallCheck(this, AlphaKey), _initializerDefineProperty(this, "alpha", _descriptor3$D, this), 
                _initializerDefineProperty(this, "time", _descriptor4$y, this);
            }).prototype, "alpha", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _descriptor4$y = _applyDecoratedDescriptor(_class5$6.prototype, "time", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _class4$6 = _class5$6)), ccclass("cc.Gradient")((_temp3$1 = _class9 = function() {
                function Gradient() {
                    _classCallCheck(this, Gradient), _initializerDefineProperty(this, "colorKeys", _descriptor5$q, this), 
                    _initializerDefineProperty(this, "alphaKeys", _descriptor6$h, this), _initializerDefineProperty(this, "mode", _descriptor7$f, this), 
                    this._color = void 0, this._color = Color.WHITE.clone();
                }
                return _createClass(Gradient, [ {
                    key: "setKeys",
                    value: function setKeys(colorKeys, alphaKeys) {
                        this.colorKeys = colorKeys, this.alphaKeys = alphaKeys;
                    }
                }, {
                    key: "sortKeys",
                    value: function sortKeys() {
                        1 < this.colorKeys.length && this.colorKeys.sort(function(a, b) {
                            return a.time - b.time;
                        }), 1 < this.alphaKeys.length && this.alphaKeys.sort(function(a, b) {
                            return a.time - b.time;
                        });
                    }
                }, {
                    key: "evaluate",
                    value: function evaluate(time) {
                        return this.getRGB(time), this._color._set_a_unsafe(this.getAlpha(time)), this._color;
                    }
                }, {
                    key: "randomColor",
                    value: function randomColor() {
                        var c = this.colorKeys[Math.trunc(Math.random() * this.colorKeys.length)], a = this.alphaKeys[Math.trunc(Math.random() * this.alphaKeys.length)];
                        return this._color.set(c.color), this._color._set_a_unsafe(a.alpha), this._color;
                    }
                }, {
                    key: "getRGB",
                    value: function getRGB(time) {
                        if (!(1 < this.colorKeys.length)) return 1 === this.colorKeys.length ? this._color.set(this.colorKeys[0].color) : this._color.set(Color.WHITE), 
                        this._color;
                        time = repeat(time, 1);
                        for (var i = 1; i < this.colorKeys.length; ++i) {
                            var preTime = this.colorKeys[i - 1].time, curTime = this.colorKeys[i].time;
                            if (preTime <= time && time < curTime) {
                                if (this.mode === Mode$2.Fixed) return this.colorKeys[i].color;
                                var factor = (time - preTime) / (curTime - preTime);
                                return Color.lerp(this._color, this.colorKeys[i - 1].color, this.colorKeys[i].color, factor), 
                                this._color;
                            }
                        }
                        var lastIndex = this.colorKeys.length - 1;
                        time < this.colorKeys[0].time ? Color.lerp(this._color, Color.BLACK, this.colorKeys[0].color, time / this.colorKeys[0].time) : time > this.colorKeys[lastIndex].time && Color.lerp(this._color, this.colorKeys[lastIndex].color, Color.BLACK, (time - this.colorKeys[lastIndex].time) / (1 - this.colorKeys[lastIndex].time));
                    }
                }, {
                    key: "getAlpha",
                    value: function getAlpha(time) {
                        if (!(1 < this.alphaKeys.length)) return 1 === this.alphaKeys.length ? this.alphaKeys[0].alpha : 255;
                        time = repeat(time, 1);
                        for (var i = 1; i < this.alphaKeys.length; ++i) {
                            var preTime = this.alphaKeys[i - 1].time, curTime = this.alphaKeys[i].time;
                            if (preTime <= time && time < curTime) {
                                if (this.mode === Mode$2.Fixed) return this.alphaKeys[i].alpha;
                                var factor = (time - preTime) / (curTime - preTime);
                                return lerp(this.alphaKeys[i - 1].alpha, this.alphaKeys[i].alpha, factor);
                            }
                        }
                        var lastIndex = this.alphaKeys.length - 1;
                        return time < this.alphaKeys[0].time ? lerp(255, this.alphaKeys[0].alpha, time / this.alphaKeys[0].time) : time > this.alphaKeys[lastIndex].time ? lerp(this.alphaKeys[lastIndex].alpha, 255, (time - this.alphaKeys[lastIndex].time) / (1 - this.alphaKeys[lastIndex].time)) : void 0;
                    }
                } ]), Gradient;
            }(), _class9.Mode = Mode$2, _descriptor5$q = _applyDecoratedDescriptor((_class8$1 = _temp3$1).prototype, "colorKeys", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Array();
                }
            }), _descriptor6$h = _applyDecoratedDescriptor(_class8$1.prototype, "alphaKeys", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Array();
                }
            }), _descriptor7$f = _applyDecoratedDescriptor(_class8$1.prototype, "mode", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Mode$2.Blend;
                }
            }), _class7$1 = _class8$1)) || _class7$1), Mode$3 = Enum({
                Color: 0,
                Gradient: 1,
                TwoColors: 2,
                TwoGradients: 3,
                RandomColor: 4
            }), GradientRange = (_dec$1j = ccclass("cc.GradientRange"), _dec2$W = property({
                type: Mode$3
            }), _dec3$G = property({
                type: Gradient
            }), _dec4$z = property({
                type: Gradient
            }), _dec5$v = property({
                type: Gradient
            }), _dec6$q = property({
                type: Mode$3
            }), _dec$1j((_temp$1d = _class3$z = function() {
                function GradientRange() {
                    _classCallCheck(this, GradientRange), _initializerDefineProperty(this, "color", _descriptor$11, this), 
                    _initializerDefineProperty(this, "colorMin", _descriptor2$T, this), _initializerDefineProperty(this, "colorMax", _descriptor3$E, this), 
                    _initializerDefineProperty(this, "gradient", _descriptor4$z, this), _initializerDefineProperty(this, "gradientMin", _descriptor5$r, this), 
                    _initializerDefineProperty(this, "gradientMax", _descriptor6$i, this), _initializerDefineProperty(this, "_mode", _descriptor7$g, this), 
                    this._color = Color.WHITE.clone();
                }
                return _createClass(GradientRange, [ {
                    key: "evaluate",
                    value: function evaluate(time, rndRatio) {
                        switch (this.mode) {
                          case Mode$3.Color:
                            return this.color;

                          case Mode$3.TwoColors:
                            return Color.lerp(this._color, this.colorMin, this.colorMax, rndRatio), this._color;

                          case Mode$3.RandomColor:
                            return this.gradient.randomColor();

                          case Mode$3.Gradient:
                            return this.gradient.evaluate(time);

                          case Mode$3.TwoGradients:
                            return Color.lerp(this._color, this.gradientMin.evaluate(time), this.gradientMax.evaluate(time), rndRatio), 
                            this._color;

                          default:
                            return this.color;
                        }
                    }
                }, {
                    key: "mode",
                    get: function get() {
                        return this._mode;
                    },
                    set: function set(m) {
                        this._mode = m;
                    }
                } ]), GradientRange;
            }(), _class3$z.Mode = Mode$3, _applyDecoratedDescriptor((_class2$15 = _temp$1d).prototype, "mode", [ _dec2$W ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "mode"), _class2$15.prototype), 
            _descriptor$11 = _applyDecoratedDescriptor(_class2$15.prototype, "color", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Color.WHITE.clone();
                }
            }), _descriptor2$T = _applyDecoratedDescriptor(_class2$15.prototype, "colorMin", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Color.WHITE.clone();
                }
            }), _descriptor3$E = _applyDecoratedDescriptor(_class2$15.prototype, "colorMax", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Color.WHITE.clone();
                }
            }), _descriptor4$z = _applyDecoratedDescriptor(_class2$15.prototype, "gradient", [ _dec3$G ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Gradient();
                }
            }), _descriptor5$r = _applyDecoratedDescriptor(_class2$15.prototype, "gradientMin", [ _dec4$z ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Gradient();
                }
            }), _descriptor6$i = _applyDecoratedDescriptor(_class2$15.prototype, "gradientMax", [ _dec5$v ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Gradient();
                }
            }), _descriptor7$g = _applyDecoratedDescriptor(_class2$15.prototype, "_mode", [ _dec6$q ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Mode$3.Color;
                }
            }), _class$1l = _class2$15)) || _class$1l), define$1 = {
                CC_USE_WORLD_SPACE: !1
            }, LineComponent = exports("LineComponent", (_dec$1k = ccclass("cc.LineComponent"), 
            _dec2$X = menu("Components/Line"), _dec3$H = property({
                type: Texture2D
            }), _dec4$A = property({
                type: Texture2D,
                displayOrder: 0
            }), _dec5$w = property({
                displayOrder: 1
            }), _dec6$r = property({
                type: [ Vec3 ]
            }), _dec7$j = property({
                type: [ Vec3 ],
                displayOrder: 2
            }), _dec8$b = property({
                type: CurveRange
            }), _dec9$9 = property({
                type: CurveRange,
                displayOrder: 3
            }), _dec10$8 = property({
                type: Vec2,
                displayOrder: 4
            }), _dec11$7 = property({
                type: Vec2,
                displayOrder: 5
            }), _dec12$6 = property({
                type: GradientRange
            }), _dec13$3 = property({
                type: GradientRange,
                displayOrder: 6
            }), _dec$1k(_class$1m = _dec2$X(_class$1m = executeInEditMode((_descriptor$12 = _applyDecoratedDescriptor((_class2$16 = function() {
                function LineComponent() {
                    var _this;
                    return _classCallCheck(this, LineComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(LineComponent).call(this)), "_texture", _descriptor$12, _assertThisInitialized(_this)), 
                    _this._material = null, _initializerDefineProperty(_this, "_worldSpace", _descriptor2$U, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_positions", _descriptor3$F, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_width", _descriptor4$A, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_tile", _descriptor5$s, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_offset", _descriptor6$j, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_color", _descriptor7$h, _assertThisInitialized(_this)), 
                    _this._model = null, _this._tile_offset = new Vec4(), _this;
                }
                return _inherits(LineComponent, Component), _createClass(LineComponent, [ {
                    key: "texture",
                    get: function get() {
                        return this._texture;
                    },
                    set: function set(val) {
                        this._texture = val, this._material && this._material.setProperty("mainTexture", val);
                    }
                }, {
                    key: "worldSpace",
                    get: function get() {
                        return this._worldSpace;
                    },
                    set: function set(val) {
                        this._worldSpace = val, this._material && (define$1.CC_USE_WORLD_SPACE = this.worldSpace, 
                        this._material.recompileShaders(define$1), this._model && this._model.setSubModelMaterial(0, this._material));
                    }
                }, {
                    key: "positions",
                    get: function get() {
                        return this._positions;
                    },
                    set: function set(val) {
                        this._positions = val, this._model && this._model.addLineVertexData(this._positions, this._width, this._color);
                    }
                }, {
                    key: "width",
                    get: function get() {
                        return this._width;
                    },
                    set: function set(val) {
                        this._width = val, this._model && this._model.addLineVertexData(this._positions, this._width, this._color);
                    }
                }, {
                    key: "tile",
                    get: function get() {
                        return this._tile;
                    },
                    set: function set(val) {
                        this._tile.set(val), this._material && (this._tile_offset.x = this._tile.x, this._tile_offset.y = this._tile.y, 
                        this._material.setProperty("mainTiling_Offset", this._tile_offset));
                    }
                }, {
                    key: "offset",
                    get: function get() {
                        return this._offset;
                    },
                    set: function set(val) {
                        this._offset.set(val), this._material && (this._tile_offset.z = this._offset.x, 
                        this._tile_offset.w = this._offset.y, this._material.setProperty("mainTiling_Offset", this._tile_offset));
                    }
                }, {
                    key: "color",
                    get: function get() {
                        return this._color;
                    },
                    set: function set(val) {
                        this._color = val, this._model && this._model.addLineVertexData(this._positions, this._width, this._color);
                    }
                } ]), _createClass(LineComponent, [ {
                    key: "onEnable",
                    value: function onEnable() {
                        this._model || (this._model = this._getRenderScene().createModel(LineModel, this.node), 
                        this._model.setCapacity(100), null == this._material && (this._material = new Material(), 
                        this._material.copy(builtinResMgr.get("default-trail-material")), define$1.CC_USE_WORLD_SPACE = this.worldSpace, 
                        this._material.recompileShaders(define$1)), this._model.setSubModelMaterial(0, this._material)), 
                        this._model.enabled = !0, this.texture = this.texture, this.tile = this._tile, this.offset = this._offset, 
                        this._model.addLineVertexData(this._positions, this._width, this._color);
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this._model && (this._model.enabled = !1);
                    }
                } ]), LineComponent;
            }()).prototype, "_texture", [ _dec3$H ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _applyDecoratedDescriptor(_class2$16.prototype, "texture", [ _dec4$A ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "texture"), _class2$16.prototype), 
            _descriptor2$U = _applyDecoratedDescriptor(_class2$16.prototype, "_worldSpace", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _applyDecoratedDescriptor(_class2$16.prototype, "worldSpace", [ _dec5$w ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "worldSpace"), _class2$16.prototype), 
            _descriptor3$F = _applyDecoratedDescriptor(_class2$16.prototype, "_positions", [ _dec6$r ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _applyDecoratedDescriptor(_class2$16.prototype, "positions", [ _dec7$j ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "positions"), _class2$16.prototype), 
            _descriptor4$A = _applyDecoratedDescriptor(_class2$16.prototype, "_width", [ _dec8$b ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _applyDecoratedDescriptor(_class2$16.prototype, "width", [ _dec9$9 ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "width"), _class2$16.prototype), 
            _descriptor5$s = _applyDecoratedDescriptor(_class2$16.prototype, "_tile", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec2(1, 1);
                }
            }), _applyDecoratedDescriptor(_class2$16.prototype, "tile", [ _dec10$8 ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "tile"), _class2$16.prototype), 
            _descriptor6$j = _applyDecoratedDescriptor(_class2$16.prototype, "_offset", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec2(0, 0);
                }
            }), _applyDecoratedDescriptor(_class2$16.prototype, "offset", [ _dec11$7 ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "offset"), _class2$16.prototype), 
            _descriptor7$h = _applyDecoratedDescriptor(_class2$16.prototype, "_color", [ _dec12$6 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new GradientRange();
                }
            }), _applyDecoratedDescriptor(_class2$16.prototype, "color", [ _dec13$3 ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "color"), _class2$16.prototype), 
            _class$1m = _class2$16)) || _class$1m) || _class$1m) || _class$1m)), ColorOvertimeModule = (_dec$1l = ccclass("cc.ColorOvertimeModule"), 
            _dec2$Y = property({
                displayOrder: 0
            }), _dec3$I = property({
                type: GradientRange,
                displayOrder: 1
            }), _dec$1l((_descriptor$13 = _applyDecoratedDescriptor((_class2$17 = function() {
                function ColorOvertimeModule() {
                    _classCallCheck(this, ColorOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$13, this), 
                    _initializerDefineProperty(this, "color", _descriptor2$V, this);
                }
                return _createClass(ColorOvertimeModule, [ {
                    key: "animate",
                    value: function animate(particle) {
                        this.enable && (particle.color.set(particle.startColor), particle.color.multiply(this.color.evaluate(1 - particle.remainingLifetime / particle.startLifetime, pseudoRandom(particle.randomSeed + 91041))));
                    }
                } ]), ColorOvertimeModule;
            }()).prototype, "enable", [ _dec2$Y ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor2$V = _applyDecoratedDescriptor(_class2$17.prototype, "color", [ _dec3$I ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new GradientRange();
                }
            }), _class$1n = _class2$17)) || _class$1n), Space = Enum({
                World: 0,
                Local: 1,
                Custom: 2
            }), RenderMode$1 = Enum({
                Billboard: 0,
                StrecthedBillboard: 1,
                HorizontalBillboard: 2,
                VerticalBillboard: 3,
                Mesh: 4
            }), ShapeType = Enum({
                Box: 0,
                Circle: 1,
                Cone: 2,
                Sphere: 3,
                Hemisphere: 4
            }), EmitLocation = Enum({
                Base: 0,
                Edge: 1,
                Shell: 2,
                Volume: 3
            }), ArcMode = Enum({
                Random: 0,
                Loop: 1,
                PingPong: 2
            }), TrailMode = Enum({
                Particles: 0,
                Ribbon: 1
            }), TextureMode = Enum({
                Stretch: 0,
                Repeat: 1
            }), particleEmitZAxis = new Vec3(0, 0, -1);
            function calculateTransform(systemSpace, moduleSpace, worldTransform, outQuat) {
                return moduleSpace !== systemSpace ? (systemSpace === Space.World || Mat4.invert(worldTransform, worldTransform), 
                Mat4.getRotation(outQuat, worldTransform), !0) : (Quat.set(outQuat, 0, 0, 0, 1), 
                !1);
            }
            function fixedAngleUnitVector2(out, theta) {
                Vec2.set(out, Math.cos(theta), Math.sin(theta));
            }
            function randomUnitVector(out) {
                var z = randomRange(-1, 1), a = randomRange(0, 2 * Math.PI), r = Math.sqrt(1 - z * z), x = r * Math.cos(a), y = r * Math.sin(a);
                Vec3.set(out, x, y, z);
            }
            function randomPointBetweenSphere(out, minRadius, maxRadius) {
                randomUnitVector(out), Vec3.multiplyScalar(out, out, minRadius + (maxRadius - minRadius) * random());
            }
            function randomPointBetweenCircleAtFixedAngle(out, minRadius, maxRadius, theta) {
                fixedAngleUnitVector2(out, theta), out.z = 0, Vec3.multiplyScalar(out, out, minRadius + (maxRadius - minRadius) * random());
            }
            function randomSortArray(arr) {
                for (var i = 0; i < arr.length; i++) {
                    var transpose = i + randomRangeInt(0, arr.length - i), val = arr[transpose];
                    arr[transpose] = arr[i], arr[i] = val;
                }
            }
            function randomSign() {
                var sgn = randomRange(-1, 1);
                return 0 === sgn && sgn++, sign(sgn);
            }
            var _dec$1n, _dec2$_, _dec3$K, _dec4$C, _dec5$y, _dec6$t, _dec7$k, _dec8$c, _dec9$a, _class$1p, _class2$19, _descriptor$15, _descriptor2$X, _descriptor3$H, _descriptor4$C, _descriptor5$u, _descriptor6$k, _descriptor7$i, _descriptor8$f, _dec$1o, _dec2$$, _dec3$L, _dec4$D, _dec5$z, _dec6$u, _class$1q, _class2$1a, _descriptor$16, _descriptor2$Y, _descriptor3$I, _descriptor4$D, _descriptor5$v, _temp_v3 = new Vec3(), ForceOvertimeModule = (_dec$1m = ccclass("cc.ForceOvertimeModule"), 
            _dec2$Z = property({
                displayOrder: 0
            }), _dec3$J = property({
                type: CurveRange,
                range: [ -1, 1 ],
                displayOrder: 2
            }), _dec4$B = property({
                type: CurveRange,
                range: [ -1, 1 ],
                displayOrder: 3
            }), _dec5$x = property({
                type: CurveRange,
                range: [ -1, 1 ],
                displayOrder: 4
            }), _dec6$s = property({
                type: Space,
                displayOrder: 1
            }), _dec$1m((_descriptor$14 = _applyDecoratedDescriptor((_class2$18 = function() {
                function ForceOvertimeModule() {
                    _classCallCheck(this, ForceOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$14, this), 
                    _initializerDefineProperty(this, "x", _descriptor2$W, this), _initializerDefineProperty(this, "y", _descriptor3$G, this), 
                    _initializerDefineProperty(this, "z", _descriptor4$B, this), _initializerDefineProperty(this, "space", _descriptor5$t, this), 
                    this.randomized = !1, this.rotation = void 0, this.needTransform = void 0, this.rotation = new Quat(), 
                    this.needTransform = !1;
                }
                return _createClass(ForceOvertimeModule, [ {
                    key: "update",
                    value: function update(space, worldTransform) {
                        this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
                    }
                }, {
                    key: "animate",
                    value: function animate(p, dt) {
                        var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, force = Vec3.set(_temp_v3, this.x.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 212165)), this.y.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 212165)), this.z.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 212165)));
                        this.needTransform && Vec3.transformQuat(force, force, this.rotation), Vec3.scaleAndAdd(p.velocity, p.velocity, force, dt);
                    }
                } ]), ForceOvertimeModule;
            }()).prototype, "enable", [ _dec2$Z ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor2$W = _applyDecoratedDescriptor(_class2$18.prototype, "x", [ _dec3$J ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor3$G = _applyDecoratedDescriptor(_class2$18.prototype, "y", [ _dec4$B ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor4$B = _applyDecoratedDescriptor(_class2$18.prototype, "z", [ _dec5$x ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor5$t = _applyDecoratedDescriptor(_class2$18.prototype, "space", [ _dec6$s ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Space.Local;
                }
            }), _class$1o = _class2$18)) || _class$1o), _temp_v3$1 = new Vec3(), LimitVelocityOvertimeModule = (_dec$1n = ccclass("cc.LimitVelocityOvertimeModule"), 
            _dec2$_ = property({
                displayOrder: 0
            }), _dec3$K = property({
                type: CurveRange,
                range: [ -1, 1 ],
                displayOrder: 4
            }), _dec4$C = property({
                type: CurveRange,
                range: [ -1, 1 ],
                displayOrder: 5
            }), _dec5$y = property({
                type: CurveRange,
                range: [ -1, 1 ],
                displayOrder: 6
            }), _dec6$t = property({
                type: CurveRange,
                range: [ -1, 1 ],
                displayOrder: 3
            }), _dec7$k = property({
                displayOrder: 7
            }), _dec8$c = property({
                displayOrder: 2
            }), _dec9$a = property({
                type: Space,
                displayOrder: 1
            }), _dec$1n((_descriptor$15 = _applyDecoratedDescriptor((_class2$19 = function() {
                function LimitVelocityOvertimeModule() {
                    _classCallCheck(this, LimitVelocityOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$15, this), 
                    _initializerDefineProperty(this, "limitX", _descriptor2$X, this), _initializerDefineProperty(this, "limitY", _descriptor3$H, this), 
                    _initializerDefineProperty(this, "limitZ", _descriptor4$C, this), _initializerDefineProperty(this, "limit", _descriptor5$u, this), 
                    _initializerDefineProperty(this, "dampen", _descriptor6$k, this), _initializerDefineProperty(this, "separateAxes", _descriptor7$i, this), 
                    _initializerDefineProperty(this, "space", _descriptor8$f, this), this.drag = null, 
                    this.multiplyDragByParticleSize = !1, this.multiplyDragByParticleVelocity = !1;
                }
                return _createClass(LimitVelocityOvertimeModule, [ {
                    key: "animate",
                    value: function animate(p) {
                        var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, dampedVel = _temp_v3$1;
                        this.separateAxes ? Vec3.set(dampedVel, dampenBeyondLimit(p.ultimateVelocity.x, this.limitX.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 23541)), this.dampen), dampenBeyondLimit(p.ultimateVelocity.y, this.limitY.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 23541)), this.dampen), dampenBeyondLimit(p.ultimateVelocity.z, this.limitZ.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 23541)), this.dampen)) : (Vec3.normalize(dampedVel, p.ultimateVelocity), 
                        Vec3.multiplyScalar(dampedVel, dampedVel, dampenBeyondLimit(p.ultimateVelocity.length(), this.limit.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 23541)), this.dampen))), 
                        Vec3.copy(p.ultimateVelocity, dampedVel);
                    }
                } ]), LimitVelocityOvertimeModule;
            }()).prototype, "enable", [ _dec2$_ ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor2$X = _applyDecoratedDescriptor(_class2$19.prototype, "limitX", [ _dec3$K ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor3$H = _applyDecoratedDescriptor(_class2$19.prototype, "limitY", [ _dec4$C ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor4$C = _applyDecoratedDescriptor(_class2$19.prototype, "limitZ", [ _dec5$y ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor5$u = _applyDecoratedDescriptor(_class2$19.prototype, "limit", [ _dec6$t ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor6$k = _applyDecoratedDescriptor(_class2$19.prototype, "dampen", [ _dec7$k ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 3;
                }
            }), _descriptor7$i = _applyDecoratedDescriptor(_class2$19.prototype, "separateAxes", [ _dec8$c ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor8$f = _applyDecoratedDescriptor(_class2$19.prototype, "space", [ _dec9$a ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Space.Local;
                }
            }), _class$1p = _class2$19)) || _class$1p);
            function dampenBeyondLimit(vel, limit, dampen) {
                var sgn = Math.sign(vel), abs = Math.abs(vel);
                return limit < abs && (abs = lerp(abs, limit, dampen)), abs * sgn;
            }
            var _dec$1p, _dec2$10, _dec3$M, _dec4$E, _dec5$A, _dec6$v, _dec7$l, _class$1r, _class2$1b, _descriptor$17, _descriptor2$Z, _descriptor3$J, _descriptor4$E, _descriptor5$w, _descriptor6$l, _dec$1q, _dec2$11, _dec3$N, _dec4$F, _dec5$B, _dec6$w, _dec7$m, _dec8$d, _dec9$b, _dec10$9, _dec11$8, _dec12$7, _class$1s, _class2$1c, _descriptor$18, _descriptor2$_, _descriptor3$K, _descriptor4$F, _descriptor5$x, _descriptor6$m, _descriptor7$j, _descriptor8$g, _descriptor9$c, _descriptor10$a, _descriptor11$9, _descriptor12$8, _descriptor13$7, _dec$1r, _dec2$12, _dec3$O, _dec4$G, _dec5$C, _dec6$x, _dec7$n, _class$1t, _class2$1d, _descriptor$19, _descriptor2$$, _descriptor3$L, _descriptor4$G, _descriptor5$y, _descriptor6$n, _dec$1s, _dec2$13, _class$1u, _class2$1e, _descriptor$1a, _descriptor2$10, _descriptor3$M, _descriptor4$H, _descriptor5$z, _descriptor6$o, _dec$1t, _dec2$14, _dec3$P, _dec4$H, _dec5$D, _dec6$y, _dec7$o, _dec8$e, _dec9$c, _dec10$a, _dec11$9, _dec12$8, _dec13$4, _dec14$3, _dec15$3, _dec16$2, _dec17$2, _dec18$2, _dec19$1, _dec20, _dec21, _class$1v, _class2$1f, _descriptor$1b, _descriptor2$11, _descriptor3$N, _descriptor4$I, _descriptor5$A, _descriptor6$p, _descriptor7$k, _descriptor8$h, _descriptor9$d, _descriptor10$b, _descriptor11$a, _descriptor12$9, _descriptor13$8, _descriptor14$7, _descriptor15$3, _descriptor16$3, _descriptor17$2, _descriptor18$1, _descriptor19$1, RotationOvertimeModule = (_dec$1o = ccclass("cc.RotationOvertimeModule"), 
            _dec2$$ = property({
                displayOrder: 0
            }), _dec3$L = property({
                displayOrder: 1
            }), _dec4$D = property({
                type: CurveRange,
                range: [ -1, 1 ],
                radian: !0,
                displayOrder: 2
            }), _dec5$z = property({
                type: CurveRange,
                range: [ -1, 1 ],
                radian: !0,
                displayOrder: 3
            }), _dec6$u = property({
                type: CurveRange,
                range: [ -1, 1 ],
                radian: !0,
                displayOrder: 4
            }), _dec$1o((_descriptor$16 = _applyDecoratedDescriptor((_class2$1a = function() {
                function RotationOvertimeModule() {
                    _classCallCheck(this, RotationOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$16, this), 
                    _initializerDefineProperty(this, "_separateAxes", _descriptor2$Y, this), _initializerDefineProperty(this, "x", _descriptor3$I, this), 
                    _initializerDefineProperty(this, "y", _descriptor4$D, this), _initializerDefineProperty(this, "z", _descriptor5$v, this);
                }
                return _createClass(RotationOvertimeModule, [ {
                    key: "separateAxes",
                    get: function get() {
                        return this._separateAxes;
                    },
                    set: function set(val) {
                        this._separateAxes = val;
                    }
                } ]), _createClass(RotationOvertimeModule, [ {
                    key: "animate",
                    value: function animate(p, dt) {
                        var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
                        if (this._separateAxes) {
                            var rotationRand = pseudoRandom(p.randomSeed + 125292);
                            p.rotation.x += this.x.evaluate(normalizedTime, rotationRand) * dt, p.rotation.y += this.y.evaluate(normalizedTime, rotationRand) * dt, 
                            p.rotation.z += this.z.evaluate(normalizedTime, rotationRand) * dt;
                        } else p.rotation.z += this.z.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 125292)) * dt;
                    }
                } ]), RotationOvertimeModule;
            }()).prototype, "enable", [ _dec2$$ ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor2$Y = _applyDecoratedDescriptor(_class2$1a.prototype, "_separateAxes", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _applyDecoratedDescriptor(_class2$1a.prototype, "separateAxes", [ _dec3$L ], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "separateAxes"), _class2$1a.prototype), 
            _descriptor3$I = _applyDecoratedDescriptor(_class2$1a.prototype, "x", [ _dec4$D ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor4$D = _applyDecoratedDescriptor(_class2$1a.prototype, "y", [ _dec5$z ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor5$v = _applyDecoratedDescriptor(_class2$1a.prototype, "z", [ _dec6$u ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _class$1q = _class2$1a)) || _class$1q), SizeOvertimeModule = (_dec$1p = ccclass("cc.SizeOvertimeModule"), 
            _dec2$10 = property({
                displayOrder: 0
            }), _dec3$M = property({
                displayOrder: 1
            }), _dec4$E = property({
                type: CurveRange,
                displayOrder: 2
            }), _dec5$A = property({
                type: CurveRange,
                displayOrder: 3
            }), _dec6$v = property({
                type: CurveRange,
                displayOrder: 4
            }), _dec7$l = property({
                type: CurveRange,
                displayOrder: 5
            }), _dec$1p((_descriptor$17 = _applyDecoratedDescriptor((_class2$1b = function() {
                function SizeOvertimeModule() {
                    _classCallCheck(this, SizeOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$17, this), 
                    _initializerDefineProperty(this, "separateAxes", _descriptor2$Z, this), _initializerDefineProperty(this, "size", _descriptor3$J, this), 
                    _initializerDefineProperty(this, "x", _descriptor4$E, this), _initializerDefineProperty(this, "y", _descriptor5$w, this), 
                    _initializerDefineProperty(this, "z", _descriptor6$l, this);
                }
                return _createClass(SizeOvertimeModule, [ {
                    key: "animate",
                    value: function animate(particle) {
                        if (this.separateAxes) {
                            var currLifetime = 1 - particle.remainingLifetime / particle.startLifetime, sizeRand = pseudoRandom(particle.randomSeed + 39825);
                            particle.size.x = particle.startSize.x * this.x.evaluate(currLifetime, sizeRand), 
                            particle.size.y = particle.startSize.y * this.y.evaluate(currLifetime, sizeRand), 
                            particle.size.z = particle.startSize.z * this.z.evaluate(currLifetime, sizeRand);
                        } else Vec3.multiplyScalar(particle.size, particle.startSize, this.size.evaluate(1 - particle.remainingLifetime / particle.startLifetime, pseudoRandom(particle.randomSeed + 39825)));
                    }
                } ]), SizeOvertimeModule;
            }()).prototype, "enable", [ _dec2$10 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor2$Z = _applyDecoratedDescriptor(_class2$1b.prototype, "separateAxes", [ _dec3$M ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor3$J = _applyDecoratedDescriptor(_class2$1b.prototype, "size", [ _dec4$E ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor4$E = _applyDecoratedDescriptor(_class2$1b.prototype, "x", [ _dec5$A ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor5$w = _applyDecoratedDescriptor(_class2$1b.prototype, "y", [ _dec6$v ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor6$l = _applyDecoratedDescriptor(_class2$1b.prototype, "z", [ _dec7$l ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _class$1r = _class2$1b)) || _class$1r), Mode$4 = Enum({
                Grid: 0
            }), Animation = Enum({
                WholeSheet: 0,
                SingleRow: 1
            }), TextureAnimationModule = (_dec$1q = ccclass("cc.TextureAnimationModule"), _dec2$11 = property({
                displayOrder: 0
            }), _dec3$N = property({
                type: Mode$4
            }), _dec4$F = property({
                type: Mode$4,
                displayOrder: 1
            }), _dec5$B = property({
                displayOrder: 2
            }), _dec6$w = property({
                displayOrder: 3
            }), _dec7$m = property({
                type: Animation,
                displayOrder: 4
            }), _dec8$d = property({
                type: CurveRange,
                displayOrder: 7
            }), _dec9$b = property({
                type: CurveRange,
                displayOrder: 8
            }), _dec10$9 = property({
                displayOrder: 9
            }), _dec11$8 = property({
                displayOrder: 5
            }), _dec12$7 = property({
                displayOrder: 6
            }), _dec$1q((_descriptor$18 = _applyDecoratedDescriptor((_class2$1c = function() {
                function TextureAnimationModule() {
                    _classCallCheck(this, TextureAnimationModule), _initializerDefineProperty(this, "_enable", _descriptor$18, this), 
                    _initializerDefineProperty(this, "_mode", _descriptor2$_, this), _initializerDefineProperty(this, "numTilesX", _descriptor3$K, this), 
                    _initializerDefineProperty(this, "numTilesY", _descriptor4$F, this), _initializerDefineProperty(this, "animation", _descriptor5$x, this), 
                    _initializerDefineProperty(this, "frameOverTime", _descriptor6$m, this), _initializerDefineProperty(this, "startFrame", _descriptor7$j, this), 
                    _initializerDefineProperty(this, "cycleCount", _descriptor8$g, this), _initializerDefineProperty(this, "_flipU", _descriptor9$c, this), 
                    _initializerDefineProperty(this, "_flipV", _descriptor10$a, this), _initializerDefineProperty(this, "_uvChannelMask", _descriptor11$9, this), 
                    _initializerDefineProperty(this, "randomRow", _descriptor12$8, this), _initializerDefineProperty(this, "rowIndex", _descriptor13$7, this), 
                    this.ps = null;
                }
                return _createClass(TextureAnimationModule, [ {
                    key: "onInit",
                    value: function onInit(ps) {
                        this.ps = ps;
                    }
                }, {
                    key: "init",
                    value: function init(p) {
                        p.startRow = Math.floor(Math.random() * this.numTilesY);
                    }
                }, {
                    key: "animate",
                    value: function animate(p) {
                        var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, startFrame = this.startFrame.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 90794)) / (this.numTilesX * this.numTilesY);
                        if (this.animation === Animation.WholeSheet) p.frameIndex = repeat(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 90794)) + startFrame), 1); else if (this.animation === Animation.SingleRow) {
                            var rowLength = 1 / this.numTilesY;
                            if (this.randomRow) {
                                var f = repeat(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 90794)) + startFrame), 1), from = p.startRow * rowLength, to = from + rowLength;
                                p.frameIndex = lerp(from, to, f);
                            } else {
                                var _from = this.rowIndex * rowLength, _to = _from + rowLength;
                                p.frameIndex = lerp(_from, _to, repeat(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 90794)) + startFrame), 1));
                            }
                        }
                    }
                }, {
                    key: "enable",
                    get: function get() {
                        return this._enable;
                    },
                    set: function set(val) {
                        this._enable = val, this.ps && this.ps.renderer._updateMaterialParams();
                    }
                }, {
                    key: "mode",
                    get: function get() {
                        return this._mode;
                    },
                    set: function set(val) {
                        val === Mode$4.Grid || console.error("particle texture animation's sprites is not supported!");
                    }
                }, {
                    key: "flipU",
                    get: function get() {
                        return this._flipU;
                    },
                    set: function set() {
                        console.error("particle texture animation's flipU is not supported!");
                    }
                }, {
                    key: "flipV",
                    get: function get() {
                        return this._flipV;
                    },
                    set: function set() {
                        console.error("particle texture animation's flipV is not supported!");
                    }
                }, {
                    key: "uvChannelMask",
                    get: function get() {
                        return this._uvChannelMask;
                    },
                    set: function set() {
                        console.error("particle texture animation's uvChannelMask is not supported!");
                    }
                } ]), TextureAnimationModule;
            }()).prototype, "_enable", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _applyDecoratedDescriptor(_class2$1c.prototype, "enable", [ _dec2$11 ], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "enable"), _class2$1c.prototype), 
            _descriptor2$_ = _applyDecoratedDescriptor(_class2$1c.prototype, "_mode", [ _dec3$N ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Mode$4.Grid;
                }
            }), _applyDecoratedDescriptor(_class2$1c.prototype, "mode", [ _dec4$F ], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "mode"), _class2$1c.prototype), 
            _descriptor3$K = _applyDecoratedDescriptor(_class2$1c.prototype, "numTilesX", [ _dec5$B ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor4$F = _applyDecoratedDescriptor(_class2$1c.prototype, "numTilesY", [ _dec6$w ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor5$x = _applyDecoratedDescriptor(_class2$1c.prototype, "animation", [ _dec7$m ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Animation.WholeSheet;
                }
            }), _descriptor6$m = _applyDecoratedDescriptor(_class2$1c.prototype, "frameOverTime", [ _dec8$d ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor7$j = _applyDecoratedDescriptor(_class2$1c.prototype, "startFrame", [ _dec9$b ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor8$g = _applyDecoratedDescriptor(_class2$1c.prototype, "cycleCount", [ _dec10$9 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor9$c = _applyDecoratedDescriptor(_class2$1c.prototype, "_flipU", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor10$a = _applyDecoratedDescriptor(_class2$1c.prototype, "_flipV", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor11$9 = _applyDecoratedDescriptor(_class2$1c.prototype, "_uvChannelMask", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return -1;
                }
            }), _descriptor12$8 = _applyDecoratedDescriptor(_class2$1c.prototype, "randomRow", [ _dec11$8 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor13$7 = _applyDecoratedDescriptor(_class2$1c.prototype, "rowIndex", [ _dec12$7 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _class$1s = _class2$1c)) || _class$1s), _temp_v3$2 = new Vec3(), VelocityOvertimeModule = (_dec$1r = ccclass("cc.VelocityOvertimeModule"), 
            _dec2$12 = property({
                displayOrder: 0
            }), _dec3$O = property({
                type: CurveRange,
                range: [ -1, 1 ],
                displayOrder: 2
            }), _dec4$G = property({
                type: CurveRange,
                range: [ -1, 1 ],
                displayOrder: 3
            }), _dec5$C = property({
                type: CurveRange,
                range: [ -1, 1 ],
                displayOrder: 4
            }), _dec6$x = property({
                type: CurveRange,
                range: [ -1, 1 ],
                displayOrder: 5
            }), _dec7$n = property({
                type: Space,
                displayOrder: 1
            }), _dec$1r((_descriptor$19 = _applyDecoratedDescriptor((_class2$1d = function() {
                function VelocityOvertimeModule() {
                    _classCallCheck(this, VelocityOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$19, this), 
                    _initializerDefineProperty(this, "x", _descriptor2$$, this), _initializerDefineProperty(this, "y", _descriptor3$L, this), 
                    _initializerDefineProperty(this, "z", _descriptor4$G, this), _initializerDefineProperty(this, "speedModifier", _descriptor5$y, this), 
                    _initializerDefineProperty(this, "space", _descriptor6$n, this), this.rotation = void 0, 
                    this.needTransform = void 0, this.rotation = new Quat(), this.speedModifier.constant = 1, 
                    this.needTransform = !1;
                }
                return _createClass(VelocityOvertimeModule, [ {
                    key: "update",
                    value: function update(space, worldTransform) {
                        this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
                    }
                }, {
                    key: "animate",
                    value: function animate(p) {
                        var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, vel = Vec3.set(_temp_v3$2, this.x.evaluate(normalizedTime, pseudoRandom(197866 ^ p.randomSeed)), this.y.evaluate(normalizedTime, pseudoRandom(156497 ^ p.randomSeed)), this.z.evaluate(normalizedTime, pseudoRandom(984136 ^ p.randomSeed)));
                        this.needTransform && Vec3.transformQuat(vel, vel, this.rotation), Vec3.add(p.animatedVelocity, p.animatedVelocity, vel), 
                        Vec3.add(p.ultimateVelocity, p.velocity, p.animatedVelocity), Vec3.multiplyScalar(p.ultimateVelocity, p.ultimateVelocity, this.speedModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, pseudoRandom(p.randomSeed + 197866)));
                    }
                } ]), VelocityOvertimeModule;
            }()).prototype, "enable", [ _dec2$12 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor2$$ = _applyDecoratedDescriptor(_class2$1d.prototype, "x", [ _dec3$O ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor3$L = _applyDecoratedDescriptor(_class2$1d.prototype, "y", [ _dec4$G ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor4$G = _applyDecoratedDescriptor(_class2$1d.prototype, "z", [ _dec5$C ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor5$y = _applyDecoratedDescriptor(_class2$1d.prototype, "speedModifier", [ _dec6$x ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor6$n = _applyDecoratedDescriptor(_class2$1d.prototype, "space", [ _dec7$n ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Space.Local;
                }
            }), _class$1t = _class2$1d)) || _class$1t), Burst = (_dec$1s = ccclass("cc.Burst"), 
            _dec2$13 = property({
                type: CurveRange
            }), _dec$1s((_descriptor$1a = _applyDecoratedDescriptor((_class2$1e = function() {
                function Burst() {
                    _classCallCheck(this, Burst), _initializerDefineProperty(this, "_time", _descriptor$1a, this), 
                    _initializerDefineProperty(this, "minCount", _descriptor2$10, this), _initializerDefineProperty(this, "maxCount", _descriptor3$M, this), 
                    _initializerDefineProperty(this, "_repeatCount", _descriptor4$H, this), _initializerDefineProperty(this, "repeatInterval", _descriptor5$z, this), 
                    _initializerDefineProperty(this, "count", _descriptor6$o, this), this._remainingCount = void 0, 
                    this._curTime = void 0, this._remainingCount = 1, this._curTime = 0;
                }
                return _createClass(Burst, [ {
                    key: "time",
                    get: function get() {
                        return this._time;
                    },
                    set: function set(val) {
                        this._time = val, this._curTime = val;
                    }
                }, {
                    key: "repeatCount",
                    get: function get() {
                        return this._repeatCount;
                    },
                    set: function set(val) {
                        this._repeatCount = val, this._remainingCount = val;
                    }
                } ]), _createClass(Burst, [ {
                    key: "update",
                    value: function update(psys, dt) {
                        if (0 === this._remainingCount && (this._remainingCount = this._repeatCount, this._curTime = this._time), 
                        0 < this._remainingCount) {
                            var preFrameTime = repeat(psys._time - psys.startDelay.evaluate(0, 1), psys.duration) - dt;
                            preFrameTime = 0 < preFrameTime ? preFrameTime : 0;
                            var curFrameTime = repeat(psys.time - psys.startDelay.evaluate(0, 1), psys.duration);
                            this._curTime >= preFrameTime && this._curTime < curFrameTime && (psys.emit(this.count.evaluate(this._curTime / psys.duration, 1), dt - (curFrameTime - this._curTime)), 
                            this._curTime += this.repeatInterval, --this._remainingCount);
                        }
                    }
                }, {
                    key: "getMaxCount",
                    value: function getMaxCount(psys) {
                        return this.count.getMax() * Math.min(Math.ceil(psys.duration / this.repeatInterval), this.repeatCount);
                    }
                } ]), Burst;
            }()).prototype, "_time", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _applyDecoratedDescriptor(_class2$1e.prototype, "time", [ property ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "time"), _class2$1e.prototype), 
            _descriptor2$10 = _applyDecoratedDescriptor(_class2$1e.prototype, "minCount", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 30;
                }
            }), _descriptor3$M = _applyDecoratedDescriptor(_class2$1e.prototype, "maxCount", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 30;
                }
            }), _descriptor4$H = _applyDecoratedDescriptor(_class2$1e.prototype, "_repeatCount", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _applyDecoratedDescriptor(_class2$1e.prototype, "repeatCount", [ property ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "repeatCount"), _class2$1e.prototype), 
            _descriptor5$z = _applyDecoratedDescriptor(_class2$1e.prototype, "repeatInterval", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _descriptor6$o = _applyDecoratedDescriptor(_class2$1e.prototype, "count", [ _dec2$13 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _class$1u = _class2$1e)) || _class$1u), _intermediVec = new Vec3(0, 0, 0), _intermediArr = new Array(), _unitBoxExtent = new Vec3(.5, .5, .5), ShapeModule = (_dec$1t = ccclass("cc.ShapeModule"), 
            _dec2$14 = property({
                displayOrder: 13
            }), _dec3$P = property({
                displayOrder: 14
            }), _dec4$H = property({
                displayOrder: 15
            }), _dec5$D = property({
                displayOrder: 6
            }), _dec6$y = property({
                displayOrder: 5
            }), _dec7$o = property({
                displayOrder: 0
            }), _dec8$e = property({
                type: ShapeType,
                displayOrder: 1,
                formerlySerializedAs: "shapeType"
            }), _dec9$c = property({
                type: ShapeType
            }), _dec10$a = property({
                type: EmitLocation,
                displayOrder: 2
            }), _dec11$9 = property({
                displayOrder: 16
            }), _dec12$8 = property({
                displayOrder: 17
            }), _dec13$4 = property({
                displayOrder: 18
            }), _dec14$3 = property({
                displayOrder: 19
            }), _dec15$3 = property({
                displayOrder: 3
            }), _dec16$2 = property({
                displayOrder: 4
            }), _dec17$2 = property({
                type: ArcMode,
                displayOrder: 7
            }), _dec18$2 = property({
                displayOrder: 9
            }), _dec19$1 = property({
                type: CurveRange,
                displayOrder: 10
            }), _dec20 = property({
                displayOrder: 11
            }), _dec21 = property({
                displayOrder: 12
            }), _dec$1t((_applyDecoratedDescriptor((_class2$1f = function() {
                function ShapeModule() {
                    _classCallCheck(this, ShapeModule), _initializerDefineProperty(this, "enable", _descriptor$1b, this), 
                    _initializerDefineProperty(this, "_shapeType", _descriptor2$11, this), _initializerDefineProperty(this, "emitFrom", _descriptor3$N, this), 
                    _initializerDefineProperty(this, "alignToDirection", _descriptor4$I, this), _initializerDefineProperty(this, "randomDirectionAmount", _descriptor5$A, this), 
                    _initializerDefineProperty(this, "sphericalDirectionAmount", _descriptor6$p, this), 
                    _initializerDefineProperty(this, "randomPositionAmount", _descriptor7$k, this), 
                    _initializerDefineProperty(this, "radius", _descriptor8$h, this), _initializerDefineProperty(this, "radiusThickness", _descriptor9$d, this), 
                    _initializerDefineProperty(this, "arcMode", _descriptor10$b, this), _initializerDefineProperty(this, "arcSpread", _descriptor11$a, this), 
                    _initializerDefineProperty(this, "arcSpeed", _descriptor12$9, this), _initializerDefineProperty(this, "length", _descriptor13$8, this), 
                    _initializerDefineProperty(this, "boxThickness", _descriptor14$7, this), _initializerDefineProperty(this, "_position", _descriptor15$3, this), 
                    _initializerDefineProperty(this, "_rotation", _descriptor16$3, this), _initializerDefineProperty(this, "_scale", _descriptor17$2, this), 
                    _initializerDefineProperty(this, "_arc", _descriptor18$1, this), _initializerDefineProperty(this, "_angle", _descriptor19$1, this), 
                    this.mat = void 0, this.quat = void 0, this.particleSystem = void 0, this.lastTime = void 0, 
                    this.totalAngle = void 0, this.mat = new Mat4(), this.quat = new Quat(), this.particleSystem = null, 
                    this.lastTime = 0, this.totalAngle = 0;
                }
                return _createClass(ShapeModule, [ {
                    key: "position",
                    get: function get() {
                        return this._position;
                    },
                    set: function set(val) {
                        this._position = val, this.constructMat();
                    }
                }, {
                    key: "rotation",
                    get: function get() {
                        return this._rotation;
                    },
                    set: function set(val) {
                        this._rotation = val, this.constructMat();
                    }
                }, {
                    key: "scale",
                    get: function get() {
                        return this._scale;
                    },
                    set: function set(val) {
                        this._scale = val, this.constructMat();
                    }
                }, {
                    key: "arc",
                    get: function get() {
                        return toDegree(this._arc);
                    },
                    set: function set(val) {
                        this._arc = toRadian(val);
                    }
                }, {
                    key: "angle",
                    get: function get() {
                        return Math.round(100 * toDegree(this._angle)) / 100;
                    },
                    set: function set(val) {
                        this._angle = toRadian(val);
                    }
                }, {
                    key: "shapeType",
                    get: function get() {
                        return this._shapeType;
                    },
                    set: function set(val) {
                        switch (this._shapeType = val, this._shapeType) {
                          case ShapeType.Box:
                            this.emitFrom === EmitLocation.Base && (this.emitFrom = EmitLocation.Volume);
                            break;

                          case ShapeType.Cone:
                            this.emitFrom === EmitLocation.Edge && (this.emitFrom = EmitLocation.Base);
                            break;

                          case ShapeType.Sphere:
                          case ShapeType.Hemisphere:
                            this.emitFrom !== EmitLocation.Base && this.emitFrom !== EmitLocation.Edge || (this.emitFrom = EmitLocation.Volume);
                        }
                    }
                } ]), _createClass(ShapeModule, [ {
                    key: "onInit",
                    value: function onInit(ps) {
                        this.particleSystem = ps, this.constructMat(), this.lastTime = this.particleSystem._time;
                    }
                }, {
                    key: "emit",
                    value: function emit(p) {
                        switch (this.shapeType) {
                          case ShapeType.Box:
                            !function boxEmit(emitFrom, boxThickness, pos, dir) {
                                switch (emitFrom) {
                                  case EmitLocation.Volume:
                                    !function randomPointInCube(out, extents) {
                                        Vec3.set(out, randomRange(-extents.x, extents.x), randomRange(-extents.y, extents.y), randomRange(-extents.z, extents.z));
                                    }(pos, _unitBoxExtent);
                                    break;

                                  case EmitLocation.Shell:
                                    _intermediArr.splice(0, _intermediArr.length), _intermediArr.push(randomRange(-.5, .5)), 
                                    _intermediArr.push(randomRange(-.5, .5)), _intermediArr.push(.5 * randomSign()), 
                                    randomSortArray(_intermediArr), applyBoxThickness(_intermediArr, boxThickness), 
                                    Vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
                                    break;

                                  case EmitLocation.Edge:
                                    _intermediArr.splice(0, _intermediArr.length), _intermediArr.push(randomRange(-.5, .5)), 
                                    _intermediArr.push(.5 * randomSign()), _intermediArr.push(.5 * randomSign()), randomSortArray(_intermediArr), 
                                    applyBoxThickness(_intermediArr, boxThickness), Vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
                                    break;

                                  default:
                                    console.warn(emitFrom + " is not supported for box emitter.");
                                }
                                Vec3.copy(dir, particleEmitZAxis);
                            }(this.emitFrom, this.boxThickness, p.position, p.velocity);
                            break;

                          case ShapeType.Circle:
                            !function circleEmit(radius, radiusThickness, theta, pos, dir) {
                                randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta), 
                                Vec3.normalize(dir, pos);
                            }(this.radius, this.radiusThickness, this.generateArcAngle(), p.position, p.velocity);
                            break;

                          case ShapeType.Cone:
                            !function coneEmit(emitFrom, radius, radiusThickness, theta, angle, length, pos, dir) {
                                switch (emitFrom) {
                                  case EmitLocation.Base:
                                    randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta), 
                                    Vec2.multiplyScalar(dir, pos, Math.sin(angle)), dir.z = -Math.cos(angle) * radius, 
                                    Vec3.normalize(dir, dir), pos.z = 0;
                                    break;

                                  case EmitLocation.Shell:
                                    fixedAngleUnitVector2(pos, theta), Vec2.multiplyScalar(dir, pos, Math.sin(angle)), 
                                    dir.z = -Math.cos(angle), Vec3.normalize(dir, dir), Vec2.multiplyScalar(pos, pos, radius), 
                                    pos.z = 0;
                                    break;

                                  case EmitLocation.Volume:
                                    randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta), 
                                    Vec2.multiplyScalar(dir, pos, Math.sin(angle)), dir.z = -Math.cos(angle) * radius, 
                                    Vec3.normalize(dir, dir), pos.z = 0, Vec3.add(pos, pos, Vec3.multiplyScalar(_intermediVec, dir, length * random() / -dir.z));
                                    break;

                                  default:
                                    console.warn(emitFrom + " is not supported for cone emitter.");
                                }
                            }(this.emitFrom, this.radius, this.radiusThickness, this.generateArcAngle(), this._angle, this.length, p.position, p.velocity);
                            break;

                          case ShapeType.Sphere:
                            !function sphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
                                switch (emitFrom) {
                                  case EmitLocation.Volume:
                                    randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius), Vec3.copy(dir, pos), 
                                    Vec3.normalize(dir, dir);
                                    break;

                                  case EmitLocation.Shell:
                                    randomUnitVector(pos), Vec3.multiplyScalar(pos, pos, radius), Vec3.copy(dir, pos);
                                    break;

                                  default:
                                    console.warn(emitFrom + " is not supported for sphere emitter.");
                                }
                            }(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
                            break;

                          case ShapeType.Hemisphere:
                            !function hemisphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
                                switch (emitFrom) {
                                  case EmitLocation.Volume:
                                    randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius), 0 < pos.z && (pos.z *= -1), 
                                    Vec3.copy(dir, pos), Vec3.normalize(dir, dir);
                                    break;

                                  case EmitLocation.Shell:
                                    randomUnitVector(pos), Vec3.multiplyScalar(pos, pos, radius), 0 < pos.z && (pos.z *= -1), 
                                    Vec3.copy(dir, pos);
                                    break;

                                  default:
                                    console.warn(emitFrom + " is not supported for hemisphere emitter.");
                                }
                            }(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
                            break;

                          default:
                            console.warn(this.shapeType + " shapeType is not supported by ShapeModule.");
                        }
                        if (0 < this.randomPositionAmount && (p.position.x += randomRange(-this.randomPositionAmount, this.randomPositionAmount), 
                        p.position.y += randomRange(-this.randomPositionAmount, this.randomPositionAmount), 
                        p.position.z += randomRange(-this.randomPositionAmount, this.randomPositionAmount)), 
                        Vec3.transformQuat(p.velocity, p.velocity, this.quat), Vec3.transformMat4(p.position, p.position, this.mat), 
                        0 < this.sphericalDirectionAmount) {
                            var sphericalVel = Vec3.normalize(_intermediVec, p.position);
                            Vec3.lerp(p.velocity, p.velocity, sphericalVel, this.sphericalDirectionAmount);
                        }
                        this.lastTime = this.particleSystem._time;
                    }
                }, {
                    key: "constructMat",
                    value: function constructMat() {
                        Quat.fromEuler(this.quat, this._rotation.x, this._rotation.y, this._rotation.z), 
                        Mat4.fromRTS(this.mat, this.quat, this._position, this._scale);
                    }
                }, {
                    key: "generateArcAngle",
                    value: function generateArcAngle() {
                        if (this.arcMode === ArcMode.Random) return randomRange(0, this._arc);
                        var angle = this.totalAngle + 2 * Math.PI * this.arcSpeed.evaluate(this.particleSystem._time, 1) * (this.particleSystem._time - this.lastTime);
                        switch (this.totalAngle = angle, 0 !== this.arcSpread && (angle = Math.floor(angle / (this._arc * this.arcSpread)) * this._arc * this.arcSpread), 
                        this.arcMode) {
                          case ArcMode.Loop:
                            return repeat(angle, this._arc);

                          case ArcMode.PingPong:
                            return pingPong(angle, this._arc);
                        }
                    }
                } ]), ShapeModule;
            }()).prototype, "position", [ _dec2$14 ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "position"), _class2$1f.prototype), 
            _applyDecoratedDescriptor(_class2$1f.prototype, "rotation", [ _dec3$P ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "rotation"), _class2$1f.prototype), 
            _applyDecoratedDescriptor(_class2$1f.prototype, "scale", [ _dec4$H ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "scale"), _class2$1f.prototype), 
            _applyDecoratedDescriptor(_class2$1f.prototype, "arc", [ _dec5$D ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "arc"), _class2$1f.prototype), 
            _applyDecoratedDescriptor(_class2$1f.prototype, "angle", [ _dec6$y ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "angle"), _class2$1f.prototype), 
            _descriptor$1b = _applyDecoratedDescriptor(_class2$1f.prototype, "enable", [ _dec7$o ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor2$11 = _applyDecoratedDescriptor(_class2$1f.prototype, "_shapeType", [ _dec8$e ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return ShapeType.Cone;
                }
            }), _applyDecoratedDescriptor(_class2$1f.prototype, "shapeType", [ _dec9$c ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "shapeType"), _class2$1f.prototype), 
            _descriptor3$N = _applyDecoratedDescriptor(_class2$1f.prototype, "emitFrom", [ _dec10$a ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return EmitLocation.Volume;
                }
            }), _descriptor4$I = _applyDecoratedDescriptor(_class2$1f.prototype, "alignToDirection", [ _dec11$9 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor5$A = _applyDecoratedDescriptor(_class2$1f.prototype, "randomDirectionAmount", [ _dec12$8 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor6$p = _applyDecoratedDescriptor(_class2$1f.prototype, "sphericalDirectionAmount", [ _dec13$4 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor7$k = _applyDecoratedDescriptor(_class2$1f.prototype, "randomPositionAmount", [ _dec14$3 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor8$h = _applyDecoratedDescriptor(_class2$1f.prototype, "radius", [ _dec15$3 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _descriptor9$d = _applyDecoratedDescriptor(_class2$1f.prototype, "radiusThickness", [ _dec16$2 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _descriptor10$b = _applyDecoratedDescriptor(_class2$1f.prototype, "arcMode", [ _dec17$2 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return ArcMode.Random;
                }
            }), _descriptor11$a = _applyDecoratedDescriptor(_class2$1f.prototype, "arcSpread", [ _dec18$2 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor12$9 = _applyDecoratedDescriptor(_class2$1f.prototype, "arcSpeed", [ _dec19$1 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor13$8 = _applyDecoratedDescriptor(_class2$1f.prototype, "length", [ _dec20 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 5;
                }
            }), _descriptor14$7 = _applyDecoratedDescriptor(_class2$1f.prototype, "boxThickness", [ _dec21 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec3(0, 0, 0);
                }
            }), _descriptor15$3 = _applyDecoratedDescriptor(_class2$1f.prototype, "_position", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec3(0, 0, 0);
                }
            }), _descriptor16$3 = _applyDecoratedDescriptor(_class2$1f.prototype, "_rotation", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec3(0, 0, 0);
                }
            }), _descriptor17$2 = _applyDecoratedDescriptor(_class2$1f.prototype, "_scale", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec3(1, 1, 1);
                }
            }), _descriptor18$1 = _applyDecoratedDescriptor(_class2$1f.prototype, "_arc", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return toRadian(360);
                }
            }), _descriptor19$1 = _applyDecoratedDescriptor(_class2$1f.prototype, "_angle", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return toRadian(25);
                }
            }), _class$1v = _class2$1f)) || _class$1v);
            function applyBoxThickness(pos, thickness) {
                0 < thickness.x && (pos[0] += .5 * randomRange(-thickness.x, thickness.x), pos[0] = clamp(pos[0], -.5, .5)), 
                0 < thickness.y && (pos[1] += .5 * randomRange(-thickness.y, thickness.y), pos[1] = clamp(pos[1], -.5, .5)), 
                0 < thickness.z && (pos[2] += .5 * randomRange(-thickness.z, thickness.z), pos[2] = clamp(pos[2], -.5, .5));
            }
            function Particle(particleSystem) {
                _classCallCheck(this, Particle), this.particleSystem = void 0, this.position = void 0, 
                this.velocity = void 0, this.animatedVelocity = void 0, this.ultimateVelocity = void 0, 
                this.angularVelocity = void 0, this.axisOfRotation = void 0, this.rotation = void 0, 
                this.startSize = void 0, this.size = void 0, this.startColor = void 0, this.color = void 0, 
                this.randomSeed = void 0, this.remainingLifetime = void 0, this.startLifetime = void 0, 
                this.emitAccumulator0 = void 0, this.emitAccumulator1 = void 0, this.frameIndex = void 0, 
                this.startRow = void 0, this.particleSystem = particleSystem, this.position = new Vec3(0, 0, 0), 
                this.velocity = new Vec3(0, 0, 0), this.animatedVelocity = new Vec3(0, 0, 0), this.ultimateVelocity = new Vec3(0, 0, 0), 
                this.angularVelocity = new Vec3(0, 0, 0), this.axisOfRotation = new Vec3(0, 0, 0), 
                this.rotation = new Vec3(0, 0, 0), this.startSize = new Vec3(0, 0, 0), this.size = new Vec3(0, 0, 0), 
                this.startColor = Color.WHITE.clone(), this.color = Color.WHITE.clone(), this.randomSeed = 0, 
                this.remainingLifetime = 0, this.startLifetime = 0, this.emitAccumulator0 = 0, this.emitAccumulator1 = 0, 
                this.frameIndex = 0, this.startRow = 0;
            }
            var _dec$1u, _dec2$15, _dec3$Q, _dec4$I, _dec5$E, _dec6$z, _dec7$p, _dec8$f, _dec9$d, _dec10$b, _dec11$a, _dec12$9, _class$1w, _class2$1g, _descriptor$1c, _descriptor2$12, _descriptor3$O, _descriptor4$J, _descriptor5$B, _dec$1v, _dec2$16, _dec3$R, _dec4$J, _dec5$F, _dec6$A, _dec7$q, _dec8$g, _dec9$e, _dec10$c, _dec11$b, _dec12$a, _dec13$5, _dec14$4, _dec15$4, _class$1x, _class2$1h, _descriptor$1d, _descriptor2$13, _descriptor3$P, _descriptor4$K, _descriptor5$C, _descriptor6$q, _descriptor7$l, _descriptor8$i, _descriptor9$e, _descriptor10$c, _descriptor11$b, _descriptor12$a, _descriptor13$9, ParticleBatchModel = function() {
                function ParticleBatchModel(scene, node) {
                    var _this;
                    return _classCallCheck(this, ParticleBatchModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ParticleBatchModel).call(this, scene, node)))._capacity = void 0, 
                    _this._vertAttrs = void 0, _this._vertSize = void 0, _this._vBuffer = void 0, _this._vertAttrsFloatCount = void 0, 
                    _this._vdataF32 = void 0, _this._vdataUint32 = void 0, _this._iaInfo = void 0, _this._iaInfoBuffer = void 0, 
                    _this._subMeshData = void 0, _this._mesh = void 0, _this._vertCount = 0, _this._indexCount = 0, 
                    _this._type = "particle-batch", _this._capacity = 0, _this._vertAttrs = null, _this._vertSize = 0, 
                    _this._vBuffer = null, _this._vertAttrsFloatCount = 0, _this._vdataF32 = null, _this._vdataUint32 = null, 
                    _this._iaInfo = {
                        drawInfos: [ {
                            vertexCount: 0,
                            firstVertex: 0,
                            indexCount: 0,
                            firstIndex: 0,
                            vertexOffset: 0,
                            instanceCount: 0,
                            firstInstance: 0
                        } ]
                    }, _this._iaInfoBuffer = _this._device.createBuffer({
                        usage: GFXBufferUsageBit.INDIRECT,
                        memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                        size: 56,
                        stride: 1
                    }), _this._subMeshData = null, _this._mesh = null, _this;
                }
                return _inherits(ParticleBatchModel, Model), _createClass(ParticleBatchModel, [ {
                    key: "setCapacity",
                    value: function setCapacity(capacity) {
                        var capChanged = this._capacity !== capacity;
                        this._capacity = capacity, this._inited && capChanged && this._recreateBuffer();
                    }
                }, {
                    key: "setVertexAttributes",
                    value: function setVertexAttributes(mesh, attrs) {
                        if (this._mesh !== mesh || this._vertAttrs !== attrs) {
                            this._mesh = mesh, this._vertAttrs = attrs, this._vertSize = 0;
                            var _iterator = this._vertAttrs, _isArray = Array.isArray(_iterator), _i = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i >= _iterator.length) break;
                                    _ref = _iterator[_i++];
                                } else {
                                    if ((_i = _iterator.next()).done) break;
                                    _ref = _i.value;
                                }
                                var a = _ref;
                                a.offset = this._vertSize, this._vertSize += GFXFormatInfos[a.format].size;
                            }
                            this._vertAttrsFloatCount = this._vertSize / 4, this._vBuffer = this._createSubMeshData(), 
                            this._vdataF32 = new Float32Array(this._vBuffer), this._vdataUint32 = new Uint32Array(this._vBuffer), 
                            this._inited = !0;
                        }
                    }
                }, {
                    key: "_createSubMeshData",
                    value: function _createSubMeshData() {
                        this._subMeshData && this.destroySubMeshData(), this._vertCount = 4, this._indexCount = 6, 
                        this._mesh && (this._vertCount = this._mesh.struct.vertexBundles[this._mesh.struct.primitives[0].vertexBundelIndices[0]].view.count, 
                        this._indexCount = this._mesh.struct.primitives[0].indexView.count);
                        var vertexBuffer = this._device.createBuffer({
                            usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                            size: this._vertSize * this._capacity * this._vertCount,
                            stride: this._vertSize
                        }), vBuffer = new ArrayBuffer(this._vertSize * this._capacity * this._vertCount);
                        if (this._mesh) {
                            var vIdx = this._vertAttrs.findIndex(function(val) {
                                return val.name === GFXAttributeName.ATTR_TEX_COORD3;
                            }), vOffset = this._vertAttrs[vIdx++].offset;
                            if (this._mesh.copyAttribute(0, GFXAttributeName.ATTR_POSITION, vBuffer, this._vertSize, vOffset), 
                            vOffset = this._vertAttrs[vIdx++].offset, this._mesh.copyAttribute(0, GFXAttributeName.ATTR_NORMAL, vBuffer, this._vertSize, vOffset), 
                            vOffset = this._vertAttrs[this._vertAttrs.findIndex(function(val) {
                                return val.name === GFXAttributeName.ATTR_TEX_COORD;
                            })].offset, this._mesh.copyAttribute(0, GFXAttributeName.ATTR_TEX_COORD, vBuffer, this._vertSize, vOffset), 
                            vOffset = this._vertAttrs[vIdx++].offset, !this._mesh.copyAttribute(0, GFXAttributeName.ATTR_COLOR, vBuffer, this._vertSize, vOffset)) for (var vb = new Uint32Array(vBuffer), iVertex = 0; iVertex < this._vertCount; ++iVertex) vb[iVertex * this._vertAttrsFloatCount + vOffset / 4] = Color.WHITE._val;
                            for (var vbFloatArray = new Float32Array(vBuffer), i = 1; i < this._capacity; i++) vbFloatArray.copyWithin(i * this._vertSize * this._vertCount / 4, 0, this._vertSize * this._vertCount / 4);
                        }
                        vertexBuffer.update(vBuffer);
                        var indices = new Uint16Array(this._capacity * this._indexCount);
                        if (this._mesh) {
                            this._mesh.copyIndices(0, indices);
                            for (var _i2 = 1; _i2 < this._capacity; _i2++) for (var j = 0; j < this._indexCount; j++) indices[_i2 * this._indexCount + j] = indices[j] + _i2 * this._vertCount;
                        } else for (var dst = 0, _i3 = 0; _i3 < this._capacity; ++_i3) {
                            var baseIdx = 4 * _i3;
                            indices[dst++] = baseIdx, indices[dst++] = 1 + baseIdx, indices[dst++] = 2 + baseIdx, 
                            indices[dst++] = 3 + baseIdx, indices[dst++] = 2 + baseIdx, indices[dst++] = 1 + baseIdx;
                        }
                        var indexBuffer = this._device.createBuffer({
                            usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                            size: this._capacity * this._indexCount * Uint16Array.BYTES_PER_ELEMENT,
                            stride: Uint16Array.BYTES_PER_ELEMENT
                        });
                        return indexBuffer.update(indices), this._iaInfo.drawInfos[0].vertexCount = this._capacity * this._vertCount, 
                        this._iaInfo.drawInfos[0].indexCount = this._capacity * this._indexCount, this._iaInfoBuffer.update(this._iaInfo), 
                        this._subMeshData = {
                            vertexBuffers: [ vertexBuffer ],
                            indexBuffer: indexBuffer,
                            indirectBuffer: this._iaInfoBuffer,
                            attributes: this._vertAttrs,
                            primitiveMode: GFXPrimitiveMode.TRIANGLE_LIST,
                            flatBuffers: []
                        }, this.setSubModelMesh(0, this._subMeshData), vBuffer;
                    }
                }, {
                    key: "setSubModelMaterial",
                    value: function setSubModelMaterial(idx, mat) {
                        this.initLocalBindings(mat), _get(_getPrototypeOf(ParticleBatchModel.prototype), "setSubModelMaterial", this).call(this, idx, mat);
                    }
                }, {
                    key: "addParticleVertexData",
                    value: function addParticleVertexData(index, pvdata) {
                        if (this._mesh) for (var i = 0; i < this._vertCount; i++) {
                            var _offset = (index * this._vertCount + i) * this._vertAttrsFloatCount;
                            this._vdataF32[_offset++] = pvdata[0].x, this._vdataF32[_offset++] = pvdata[0].y, 
                            this._vdataF32[_offset++] = pvdata[0].z, _offset += 2, this._vdataF32[_offset++] = pvdata[1].z, 
                            this._vdataF32[_offset++] = pvdata[2].x, this._vdataF32[_offset++] = pvdata[2].y, 
                            this._vdataF32[_offset++] = pvdata[2].z, this._vdataF32[_offset++] = pvdata[3].x, 
                            this._vdataF32[_offset++] = pvdata[3].y, this._vdataF32[_offset++] = pvdata[3].z, 
                            this._vdataUint32[_offset++] = pvdata[4];
                        } else {
                            var offset = index * this._vertAttrsFloatCount;
                            this._vdataF32[offset++] = pvdata[0].x, this._vdataF32[offset++] = pvdata[0].y, 
                            this._vdataF32[offset++] = pvdata[0].z, this._vdataF32[offset++] = pvdata[1].x, 
                            this._vdataF32[offset++] = pvdata[1].y, this._vdataF32[offset++] = pvdata[1].z, 
                            this._vdataF32[offset++] = pvdata[2].x, this._vdataF32[offset++] = pvdata[2].y, 
                            this._vdataF32[offset++] = pvdata[2].z, this._vdataF32[offset++] = pvdata[3].x, 
                            this._vdataF32[offset++] = pvdata[3].y, this._vdataF32[offset++] = pvdata[3].z, 
                            this._vdataUint32[offset++] = pvdata[4], pvdata[5] && (this._vdataF32[offset++] = pvdata[5].x, 
                            this._vdataF32[offset++] = pvdata[5].y, this._vdataF32[offset++] = pvdata[5].z);
                        }
                    }
                }, {
                    key: "updateIA",
                    value: function updateIA(count) {
                        this.getSubModel(0).inputAssembler.vertexBuffers[0].update(this._vdataF32), this.getSubModel(0).inputAssembler.indexCount = this._indexCount * count, 
                        this.getSubModel(0).inputAssembler.extractDrawInfo(this._iaInfo.drawInfos[0]), this._iaInfoBuffer.update(this._iaInfo);
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        this.getSubModel(0).inputAssembler.indexCount = 0;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        _get(_getPrototypeOf(ParticleBatchModel.prototype), "destroy", this).call(this), 
                        this._vBuffer = null, this._vdataF32 = null, this._subMeshData && this.destroySubMeshData(), 
                        this._iaInfoBuffer.destroy(), this._subMeshData = null;
                    }
                }, {
                    key: "_recreateBuffer",
                    value: function _recreateBuffer() {
                        this._vBuffer = this._createSubMeshData(), this.getSubModel(0).updateCommandBuffer(), 
                        this._vdataF32 = new Float32Array(this._vBuffer), this._vdataUint32 = new Uint32Array(this._vBuffer);
                    }
                }, {
                    key: "destroySubMeshData",
                    value: function destroySubMeshData() {
                        var _iterator2 = this._subMeshData.vertexBuffers, _isArray2 = Array.isArray(_iterator2), _i4 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i4 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i4++];
                            } else {
                                if ((_i4 = _iterator2.next()).done) break;
                                _ref2 = _i4.value;
                            }
                            _ref2.destroy();
                        }
                        this._subMeshData.indexBuffer.destroy();
                    }
                } ]), ParticleBatchModel;
            }(), _tempAttribUV = new Vec3(), _tempWorldTrans = (new Vec2(), new Mat4()), _uvs$1 = [ 0, 0, 1, 0, 0, 1, 1, 1 ], _vertex_attrs$1 = [ {
                name: GFXAttributeName.ATTR_POSITION,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_TEX_COORD,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_TEX_COORD1,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_TEX_COORD2,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_COLOR,
                format: GFXFormat.RGBA8,
                isNormalized: !0
            } ], _vertex_attrs_stretch = [ {
                name: GFXAttributeName.ATTR_POSITION,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_TEX_COORD,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_TEX_COORD1,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_TEX_COORD2,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_COLOR,
                format: GFXFormat.RGBA8,
                isNormalized: !0
            }, {
                name: GFXAttributeName.ATTR_COLOR1,
                format: GFXFormat.RGB32F
            } ], _vertex_attrs_mesh = [ {
                name: GFXAttributeName.ATTR_POSITION,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_TEX_COORD,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_TEX_COORD1,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_TEX_COORD2,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_COLOR,
                format: GFXFormat.RGBA8,
                isNormalized: !0
            }, {
                name: GFXAttributeName.ATTR_TEX_COORD3,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_NORMAL,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_COLOR1,
                format: GFXFormat.RGBA8,
                isNormalized: !0
            } ], ParticleSystemRenderer = (_dec$1u = ccclass("cc.ParticleSystemRenderer"), _dec2$15 = property({
                type: RenderMode$1,
                displayOrder: 0
            }), _dec3$Q = property({
                displayOrder: 1
            }), _dec4$I = property({
                displayOrder: 2
            }), _dec5$E = property({
                type: RenderMode$1,
                displayOrder: 3
            }), _dec6$z = property({
                displayOrder: 4
            }), _dec7$p = property({
                displayOrder: 5
            }), _dec8$f = property({
                displayOrder: 6
            }), _dec9$d = property({
                type: cc.ParticleSystemComponent,
                visible: !1
            }), _dec10$b = property({
                type: Mesh,
                displayOrder: 7
            }), _dec11$a = property({
                type: Material,
                displayOrder: 8
            }), _dec12$9 = property({
                type: Material,
                displayOrder: 9
            }), _dec$1u((_applyDecoratedDescriptor((_class2$1g = function() {
                function ParticleSystemRenderer() {
                    _classCallCheck(this, ParticleSystemRenderer), _initializerDefineProperty(this, "_renderMode", _descriptor$1c, this), 
                    _initializerDefineProperty(this, "_velocityScale", _descriptor2$12, this), _initializerDefineProperty(this, "_lengthScale", _descriptor3$O, this), 
                    _initializerDefineProperty(this, "_mesh", _descriptor4$J, this), _initializerDefineProperty(this, "_particleSystem", _descriptor5$B, this), 
                    this._defines = void 0, this._trailDefines = void 0, this._model = void 0, this.frameTile_velLenScale = void 0, 
                    this._node_scale = void 0, this.attrs = void 0, this._vertAttrs = [], this._particles = null, 
                    this._defaultMat = null, this._defaultTrailMat = null, this._model = null, this.frameTile_velLenScale = new Vec4(1, 1, 0, 0), 
                    this._node_scale = new Vec4(), this.attrs = new Array(5), this._defines = {
                        CC_USE_WORLD_SPACE: !0,
                        CC_USE_BILLBOARD: !0,
                        CC_USE_STRETCHED_BILLBOARD: !1,
                        CC_USE_HORIZONTAL_BILLBOARD: !1,
                        CC_USE_VERTICAL_BILLBOARD: !1
                    }, this._trailDefines = {
                        CC_USE_WORLD_SPACE: !0
                    };
                }
                return _createClass(ParticleSystemRenderer, [ {
                    key: "renderMode",
                    get: function get() {
                        return this._renderMode;
                    },
                    set: function set(val) {
                        this._renderMode !== val && (this._renderMode = val, this._setVertexAttrib(), this._updateModel(), 
                        this._updateMaterialParams());
                    }
                }, {
                    key: "velocityScale",
                    get: function get() {
                        return this._velocityScale;
                    },
                    set: function set(val) {
                        this._velocityScale = val, this._updateMaterialParams();
                    }
                }, {
                    key: "lengthScale",
                    get: function get() {
                        return this._lengthScale;
                    },
                    set: function set(val) {
                        this._lengthScale = val, this._updateMaterialParams();
                    }
                }, {
                    key: "mesh",
                    get: function get() {
                        return this._mesh;
                    },
                    set: function set(val) {
                        this._mesh = val, this._model && this._model.setVertexAttributes(this._renderMode === RenderMode$1.Mesh ? this._mesh : null, this._vertAttrs);
                    }
                }, {
                    key: "particleMaterial",
                    get: function get() {
                        return this._particleSystem ? this._particleSystem.getMaterial(0) : null;
                    },
                    set: function set(val) {
                        this._particleSystem.setMaterial(val, 0);
                    }
                }, {
                    key: "trailMaterial",
                    get: function get() {
                        return this._particleSystem ? this._particleSystem.getMaterial(1) : null;
                    },
                    set: function set(val) {
                        this._particleSystem.setMaterial(val, 1);
                    }
                } ]), _createClass(ParticleSystemRenderer, [ {
                    key: "onInit",
                    value: function onInit(ps) {
                        var _this = this;
                        this._particleSystem = ps, this._particles = new RecyclePool(function() {
                            return new Particle(_this);
                        }, 16), this._setVertexAttrib(), this.onEnable(), this._updateModel(), this._updateMaterialParams(), 
                        this._updateTrailMaterial();
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        this._particleSystem && (null == this._model && (this._model = this._particleSystem._getRenderScene().createModel(ParticleBatchModel, this._particleSystem.node), 
                        this._model.visFlags = this._particleSystem.visibility), this._model.inited || (this._model.setCapacity(this._particleSystem.capacity), 
                        this._model.node = this._particleSystem.node), this._model.enabled = this._particleSystem.enabledInHierarchy);
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this._model && (this._model.enabled = this._particleSystem.enabledInHierarchy);
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this._model && (this._model.scene.destroyModel(this._model), this._model = null);
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        this._particles.reset(), this._updateRenderData();
                    }
                }, {
                    key: "_getFreeParticle",
                    value: function _getFreeParticle() {
                        return this._particles.length >= this._particleSystem.capacity ? null : this._particles.add();
                    }
                }, {
                    key: "_setNewParticle",
                    value: function _setNewParticle() {}
                }, {
                    key: "_updateParticles",
                    value: function _updateParticles(dt) {
                        switch (this._particleSystem.node.getWorldMatrix(_tempWorldTrans), this._particleSystem.scaleSpace) {
                          case Space.Local:
                            this._particleSystem.node.getScale(this._node_scale);
                            break;

                          case Space.World:
                            this._particleSystem.node.getWorldScale(this._node_scale);
                        }
                        (this._particleSystem.sharedMaterial ? this.particleMaterial : this._defaultMat).setProperty("scale", this._node_scale), 
                        this._particleSystem.velocityOvertimeModule.enable && this._particleSystem.velocityOvertimeModule.update(this._particleSystem._simulationSpace, _tempWorldTrans), 
                        this._particleSystem.forceOvertimeModule.enable && this._particleSystem.forceOvertimeModule.update(this._particleSystem._simulationSpace, _tempWorldTrans), 
                        this._particleSystem.trailModule.enable && this._particleSystem.trailModule.update();
                        for (var i = 0; i < this._particles.length; ++i) {
                            var p = this._particles.data[i];
                            p.remainingLifetime -= dt, Vec3.set(p.animatedVelocity, 0, 0, 0), p.remainingLifetime < 0 ? (this._particleSystem.trailModule.enable && this._particleSystem.trailModule.removeParticle(p), 
                            this._particles.removeAt(i), --i) : (p.velocity.y -= 9.8 * this._particleSystem.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, p.randomSeed) * dt, 
                            this._particleSystem.sizeOvertimeModule.enable && this._particleSystem.sizeOvertimeModule.animate(p), 
                            this._particleSystem.colorOverLifetimeModule.enable && this._particleSystem.colorOverLifetimeModule.animate(p), 
                            this._particleSystem.forceOvertimeModule.enable && this._particleSystem.forceOvertimeModule.animate(p, dt), 
                            this._particleSystem.velocityOvertimeModule.enable ? this._particleSystem.velocityOvertimeModule.animate(p) : Vec3.copy(p.ultimateVelocity, p.velocity), 
                            this._particleSystem.limitVelocityOvertimeModule.enable && this._particleSystem.limitVelocityOvertimeModule.animate(p), 
                            this._particleSystem.rotationOvertimeModule.enable && this._particleSystem.rotationOvertimeModule.animate(p, dt), 
                            this._particleSystem.textureAnimationModule.enable && this._particleSystem.textureAnimationModule.animate(p), 
                            Vec3.scaleAndAdd(p.position, p.position, p.ultimateVelocity, dt), this._particleSystem.trailModule.enable && this._particleSystem.trailModule.animate(p, dt));
                        }
                        return this._particles.length;
                    }
                }, {
                    key: "_updateRenderData",
                    value: function _updateRenderData() {
                        for (var idx = 0, uploadVel = this._renderMode === RenderMode$1.StrecthedBillboard, i = 0; i < this._particles.length; ++i) {
                            var p = this._particles.data[i], fi = 0;
                            this._particleSystem.textureAnimationModule.enable && (fi = p.frameIndex), idx = 4 * i;
                            var attrNum = 0;
                            if (this._renderMode !== RenderMode$1.Mesh) for (var j = 0; j < 4; ++j) attrNum = 0, 
                            this.attrs[attrNum++] = p.position, _tempAttribUV.x = _uvs$1[2 * j], _tempAttribUV.y = _uvs$1[2 * j + 1], 
                            _tempAttribUV.z = fi, this.attrs[attrNum++] = _tempAttribUV, this.attrs[attrNum++] = p.size, 
                            this.attrs[attrNum++] = p.rotation, this.attrs[attrNum++] = p.color._val, this.attrs[attrNum++] = uploadVel ? p.ultimateVelocity : null, 
                            this._model.addParticleVertexData(idx++, this.attrs); else attrNum = 0, this.attrs[attrNum++] = p.position, 
                            _tempAttribUV.z = fi, this.attrs[attrNum++] = _tempAttribUV, this.attrs[attrNum++] = p.size, 
                            this.attrs[attrNum++] = p.rotation, this.attrs[attrNum++] = p.color._val, this._model.addParticleVertexData(i, this.attrs);
                        }
                        this._model.updateIA(this._particles.length);
                    }
                }, {
                    key: "updateShaderUniform",
                    value: function updateShaderUniform() {}
                }, {
                    key: "getParticleCount",
                    value: function getParticleCount() {
                        return this._particles.length;
                    }
                }, {
                    key: "_onMaterialModified",
                    value: function _onMaterialModified(index) {
                        0 === index ? (this._updateModel(), this._updateMaterialParams()) : this._updateTrailMaterial();
                    }
                }, {
                    key: "_onRebuildPSO",
                    value: function _onRebuildPSO(index, material) {
                        this._model && 0 === index && this._model.setSubModelMaterial(0, material), this._particleSystem.trailModule._trailModel && 1 === index && this._particleSystem.trailModule._trailModel.setSubModelMaterial(0, material);
                    }
                }, {
                    key: "_setVertexAttrib",
                    value: function _setVertexAttrib() {
                        switch (this._renderMode) {
                          case RenderMode$1.StrecthedBillboard:
                            this._vertAttrs = _vertex_attrs_stretch.slice();
                            break;

                          case RenderMode$1.Mesh:
                            this._vertAttrs = _vertex_attrs_mesh.slice();
                            break;

                          default:
                            this._vertAttrs = _vertex_attrs$1.slice();
                        }
                    }
                }, {
                    key: "_updateMaterialParams",
                    value: function _updateMaterialParams() {
                        if (this._particleSystem) {
                            null != this._particleSystem.sharedMaterial && -1 === this._particleSystem.sharedMaterial._effectAsset._name.indexOf("particle") && this._particleSystem.setMaterial(null, 0, !1), 
                            null == this._particleSystem.sharedMaterial && null == this._defaultMat && (this._defaultMat = Material.getInstantiatedMaterial(builtinResMgr.get("default-particle-material"), this._particleSystem, !0));
                            var mat = this._particleSystem.sharedMaterial ? this.particleMaterial : this._defaultMat;
                            this._particleSystem._simulationSpace === Space.World ? this._defines.CC_USE_WORLD_SPACE = !0 : this._defines.CC_USE_WORLD_SPACE = !1, 
                            this._renderMode === RenderMode$1.Billboard ? (this._defines.CC_USE_BILLBOARD = !0, 
                            this._defines.CC_USE_STRETCHED_BILLBOARD = !1, this._defines.CC_USE_HORIZONTAL_BILLBOARD = !1, 
                            this._defines.CC_USE_VERTICAL_BILLBOARD = !1, this._defines.CC_USE_MESH = !1) : this._renderMode === RenderMode$1.StrecthedBillboard ? (this._defines.CC_USE_BILLBOARD = !1, 
                            this._defines.CC_USE_STRETCHED_BILLBOARD = !0, this._defines.CC_USE_HORIZONTAL_BILLBOARD = !1, 
                            this._defines.CC_USE_VERTICAL_BILLBOARD = !1, this._defines.CC_USE_MESH = !1, this.frameTile_velLenScale.z = this._velocityScale, 
                            this.frameTile_velLenScale.w = this._lengthScale) : this._renderMode === RenderMode$1.HorizontalBillboard ? (this._defines.CC_USE_BILLBOARD = !1, 
                            this._defines.CC_USE_STRETCHED_BILLBOARD = !1, this._defines.CC_USE_HORIZONTAL_BILLBOARD = !0, 
                            this._defines.CC_USE_VERTICAL_BILLBOARD = !1, this._defines.CC_USE_MESH = !1) : this._renderMode === RenderMode$1.VerticalBillboard ? (this._defines.CC_USE_BILLBOARD = !1, 
                            this._defines.CC_USE_STRETCHED_BILLBOARD = !1, this._defines.CC_USE_HORIZONTAL_BILLBOARD = !1, 
                            this._defines.CC_USE_VERTICAL_BILLBOARD = !0, this._defines.CC_USE_MESH = !1) : this._renderMode === RenderMode$1.Mesh ? (this._defines.CC_USE_BILLBOARD = !1, 
                            this._defines.CC_USE_STRETCHED_BILLBOARD = !1, this._defines.CC_USE_HORIZONTAL_BILLBOARD = !1, 
                            this._defines.CC_USE_VERTICAL_BILLBOARD = !1, this._defines.CC_USE_MESH = !0) : console.warn("particle system renderMode ".concat(this._renderMode, " not support.")), 
                            this._particleSystem.textureAnimationModule.enable && Vec2.set(this.frameTile_velLenScale, this._particleSystem.textureAnimationModule.numTilesX, this._particleSystem.textureAnimationModule.numTilesY), 
                            mat.setProperty("frameTile_velLenScale", this.frameTile_velLenScale), mat.recompileShaders(this._defines), 
                            this._model && this._model.setSubModelMaterial(0, this._particleSystem.sharedMaterial || this._defaultMat);
                        }
                    }
                }, {
                    key: "_updateTrailMaterial",
                    value: function _updateTrailMaterial() {
                        if (this._particleSystem.trailModule.enable) {
                            this._particleSystem._simulationSpace === Space.World || this._particleSystem.trailModule.space === Space.World ? this._trailDefines.CC_USE_WORLD_SPACE = !0 : this._trailDefines.CC_USE_WORLD_SPACE = !1;
                            var mat = this.trailMaterial;
                            null === mat && null === this._defaultTrailMat && (this._defaultTrailMat = Material.getInstantiatedMaterial(builtinResMgr.get("default-trail-material"), this._particleSystem, !0)), 
                            null === mat && (mat = this._defaultTrailMat), mat.recompileShaders(this._trailDefines), 
                            this._particleSystem.trailModule._updateMaterial();
                        }
                    }
                }, {
                    key: "_updateModel",
                    value: function _updateModel() {
                        this._model && this._model.setVertexAttributes(this._renderMode === RenderMode$1.Mesh ? this._mesh : null, this._vertAttrs);
                    }
                } ]), ParticleSystemRenderer;
            }()).prototype, "renderMode", [ _dec2$15 ], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "renderMode"), _class2$1g.prototype), 
            _applyDecoratedDescriptor(_class2$1g.prototype, "velocityScale", [ _dec3$Q ], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "velocityScale"), _class2$1g.prototype), 
            _applyDecoratedDescriptor(_class2$1g.prototype, "lengthScale", [ _dec4$I ], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "lengthScale"), _class2$1g.prototype), 
            _descriptor$1c = _applyDecoratedDescriptor(_class2$1g.prototype, "_renderMode", [ _dec5$E ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return RenderMode$1.Billboard;
                }
            }), _descriptor2$12 = _applyDecoratedDescriptor(_class2$1g.prototype, "_velocityScale", [ _dec6$z ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _descriptor3$O = _applyDecoratedDescriptor(_class2$1g.prototype, "_lengthScale", [ _dec7$p ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _descriptor4$J = _applyDecoratedDescriptor(_class2$1g.prototype, "_mesh", [ _dec8$f ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor5$B = _applyDecoratedDescriptor(_class2$1g.prototype, "_particleSystem", [ _dec9$d ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _applyDecoratedDescriptor(_class2$1g.prototype, "mesh", [ _dec10$b ], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "mesh"), _class2$1g.prototype), 
            _applyDecoratedDescriptor(_class2$1g.prototype, "particleMaterial", [ _dec11$a ], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "particleMaterial"), _class2$1g.prototype), 
            _applyDecoratedDescriptor(_class2$1g.prototype, "trailMaterial", [ _dec12$9 ], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "trailMaterial"), _class2$1g.prototype), 
            _class$1w = _class2$1g)) || _class$1w);
            Object.assign(ParticleSystemRenderer, {
                uv: _uvs$1
            });
            var _dec$1w, _dec2$17, _dec3$S, _dec4$K, _dec5$G, _dec6$B, _dec7$r, _dec8$h, _dec9$f, _dec10$d, _dec11$c, _dec12$b, _dec13$6, _dec14$5, _dec15$5, _dec16$3, _dec17$3, _dec18$3, _dec19$2, _dec20$1, _dec21$1, _dec22, _dec23, _dec24, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _dec33, _dec34, _dec35, _dec36, _dec37, _dec38, _class$1y, _class2$1i, _descriptor$1e, _descriptor2$14, _descriptor3$Q, _descriptor4$L, _descriptor5$D, _descriptor6$r, _descriptor7$m, _descriptor8$j, _descriptor9$f, _descriptor10$d, _descriptor11$c, _descriptor12$b, _descriptor13$a, _descriptor14$8, _descriptor15$4, _descriptor16$4, _descriptor17$3, _descriptor18$2, _descriptor19$2, _descriptor20, _descriptor21, _descriptor22, _descriptor23, _descriptor24, _descriptor25, _descriptor26, _descriptor27, _descriptor28, _descriptor29, _descriptor30, _descriptor31, _descriptor32, _descriptor33, _descriptor34, BoxShape, SphereShape, RigidBody, PhysicsWorld, DIRECTION_THRESHOLD = Math.cos(toRadian(100)), _temp_trailEle = {
                position: new Vec3(),
                velocity: new Vec3()
            }, _temp_quat = new Quat(), _temp_xform = new Mat4(), _temp_vec3 = new Vec3(), _temp_vec3_1$1 = new Vec3(), _temp_color = new Color(), TrailSegment = function() {
                function TrailSegment(maxTrailElementNum) {
                    for (_classCallCheck(this, TrailSegment), this.start = void 0, this.end = void 0, 
                    this.trailElements = void 0, this.start = -1, this.end = -1, this.trailElements = []; maxTrailElementNum--; ) this.trailElements.push({
                        position: new Vec3(),
                        lifetime: 0,
                        width: 0,
                        velocity: new Vec3(),
                        direction: 0,
                        color: new Color()
                    });
                }
                return _createClass(TrailSegment, [ {
                    key: "getElement",
                    value: function getElement(idx) {
                        return -1 === this.start ? null : (idx < 0 && (idx = (idx + this.trailElements.length) % this.trailElements.length), 
                        idx >= this.trailElements.length && (idx %= this.trailElements.length), this.trailElements[idx]);
                    }
                }, {
                    key: "addElement",
                    value: function addElement() {
                        if (0 === this.trailElements.length) return null;
                        if (-1 === this.start) return this.start = 0, this.end = 1, this.trailElements[0];
                        this.start === this.end && (this.trailElements.splice(this.end, 0, {
                            position: new Vec3(),
                            lifetime: 0,
                            width: 0,
                            velocity: new Vec3(),
                            direction: 0,
                            color: new Color()
                        }), this.start++, this.start %= this.trailElements.length);
                        var newEleLoc = this.end++;
                        return this.end %= this.trailElements.length, this.trailElements[newEleLoc];
                    }
                }, {
                    key: "iterateElement",
                    value: function iterateElement(target, f, p, dt) {
                        for (var end = this.start >= this.end ? this.end + this.trailElements.length : this.end, i = this.start; i < end; i++) f(target, this.trailElements[i % this.trailElements.length], p, dt) && (this.start++, 
                        this.start %= this.trailElements.length);
                        this.start === end && (this.start = -1, this.end = -1);
                    }
                }, {
                    key: "count",
                    value: function count() {
                        return this.start < this.end ? this.end - this.start : this.trailElements.length + this.end - this.start;
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        this.start = -1, this.end = -1;
                    }
                } ]), TrailSegment;
            }(), TrailModule = (_dec$1v = ccclass("cc.TrailModule"), _dec2$16 = property({
                displayOrder: 0
            }), _dec3$R = property({
                type: TrailMode,
                displayOrder: 1
            }), _dec4$J = property({
                type: CurveRange,
                displayOrder: 3
            }), _dec5$F = property({
                displayOrder: 5
            }), _dec6$A = property({
                type: Space,
                displayOrder: 6
            }), _dec7$q = property({
                displayOrder: 7
            }), _dec8$g = property({
                type: TextureMode,
                displayOrder: 8
            }), _dec9$e = property({
                displayOrder: 9
            }), _dec10$c = property({
                type: CurveRange,
                displayOrder: 10
            }), _dec11$b = property({
                displayOrder: 11
            }), _dec12$a = property({
                type: GradientRange,
                displayOrder: 12
            }), _dec13$5 = property({
                type: GradientRange,
                displayOrder: 13
            }), _dec14$4 = property({
                type: Space
            }), _dec15$4 = property({
                type: cc.ParticleSystemComponent,
                visible: !1
            }), _dec$1v((_applyDecoratedDescriptor((_class2$1h = function() {
                function TrailModule() {
                    _classCallCheck(this, TrailModule), _initializerDefineProperty(this, "_enable", _descriptor$1d, this), 
                    _initializerDefineProperty(this, "mode", _descriptor2$13, this), _initializerDefineProperty(this, "lifeTime", _descriptor3$P, this), 
                    _initializerDefineProperty(this, "_minParticleDistance", _descriptor4$K, this), 
                    _initializerDefineProperty(this, "existWithParticles", _descriptor5$C, this), _initializerDefineProperty(this, "textureMode", _descriptor6$q, this), 
                    _initializerDefineProperty(this, "widthFromParticle", _descriptor7$l, this), _initializerDefineProperty(this, "widthRatio", _descriptor8$i, this), 
                    _initializerDefineProperty(this, "colorFromParticle", _descriptor9$e, this), _initializerDefineProperty(this, "colorOverTrail", _descriptor10$c, this), 
                    _initializerDefineProperty(this, "colorOvertime", _descriptor11$b, this), _initializerDefineProperty(this, "_space", _descriptor12$a, this), 
                    _initializerDefineProperty(this, "_particleSystem", _descriptor13$9, this), this._minSquaredDistance = 0, 
                    this._vertSize = void 0, this._trailNum = 0, this._trailLifetime = 0, this.vbOffset = 0, 
                    this.ibOffset = 0, this._trailSegments = null, this._particleTrail = void 0, this._trailModel = null, 
                    this._iaInfo = void 0, this._iaInfoBuffer = null, this._subMeshData = null, this._vertAttrs = void 0, 
                    this._vbF32 = null, this._vbUint32 = null, this._iBuffer = null, this._needTransform = !1, 
                    this._defaultMat = null, this._iaInfo = {
                        drawInfos: [ {
                            vertexCount: 0,
                            firstVertex: 0,
                            indexCount: 0,
                            firstIndex: 0,
                            vertexOffset: 0,
                            instanceCount: 0,
                            firstInstance: 0
                        } ]
                    }, this._vertAttrs = [ {
                        name: GFXAttributeName.ATTR_POSITION,
                        format: GFXFormat.RGB32F
                    }, {
                        name: GFXAttributeName.ATTR_TEX_COORD,
                        format: GFXFormat.RGBA32F
                    }, {
                        name: GFXAttributeName.ATTR_TEX_COORD1,
                        format: GFXFormat.RGB32F
                    }, {
                        name: GFXAttributeName.ATTR_COLOR,
                        format: GFXFormat.RGBA8,
                        isNormalized: !0
                    } ], this._vertSize = 0;
                    var _iterator = this._vertAttrs, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var a = _ref;
                        this._vertSize += GFXFormatInfos[a.format].size;
                    }
                    this._particleTrail = new Map();
                }
                return _createClass(TrailModule, [ {
                    key: "enable",
                    get: function get() {
                        return this._enable;
                    },
                    set: function set(val) {
                        val && !this._trailModel && this._createModel(), val && !this._enable && (this._enable = val, 
                        this._particleSystem.renderer._updateTrailMaterial()), this._enable = val, this._trailModel && (this._trailModel.enabled = val);
                    }
                }, {
                    key: "minParticleDistance",
                    get: function get() {
                        return this._minParticleDistance;
                    },
                    set: function set(val) {
                        this._minParticleDistance = val, this._minSquaredDistance = val * val;
                    }
                }, {
                    key: "space",
                    get: function get() {
                        return this._space;
                    },
                    set: function set(val) {
                        this._space = val, this._particleSystem && this._particleSystem.renderer._updateTrailMaterial();
                    }
                } ]), _createClass(TrailModule, [ {
                    key: "onInit",
                    value: function onInit(ps) {
                        this._particleSystem = ps, this.minParticleDistance = this._minParticleDistance;
                        var burstCount = 0, _iterator2 = this._particleSystem.bursts, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            burstCount += _ref2.getMaxCount(this._particleSystem);
                        }
                        this._trailNum = Math.ceil(this._particleSystem.startLifetime.getMax() * this.lifeTime.getMax() * 60 * (this._particleSystem.rateOverTime.getMax() * this._particleSystem.duration + burstCount)), 
                        this._trailSegments = new Pool$1(function() {
                            return new TrailSegment(10);
                        }, Math.ceil(this._particleSystem.rateOverTime.getMax() * this._particleSystem.duration)), 
                        this._enable && (this.enable = this._enable, this._updateMaterial());
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        this._enable && this._trailModel && (this._trailModel.enabled = !0);
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this._enable && this._trailModel && (this._trailModel.enabled = !1);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._trailModel && (this._trailModel.scene.destroyModel(this._trailModel), this._trailModel = null), 
                        this._trailSegments && (this._trailSegments.clear(function(obj) {
                            obj.trailElements.length = 0;
                        }), this._trailSegments = null);
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        if (this.enable) {
                            for (var trailIter = this._particleTrail.values(), trail = trailIter.next(); !trail.done; ) trail.value.clear(), 
                            trail = trailIter.next();
                            this._particleTrail.clear(), this.updateRenderData();
                        }
                    }
                }, {
                    key: "_updateMaterial",
                    value: function _updateMaterial() {
                        if (this._particleSystem && this._trailModel) {
                            var mat = this._particleSystem.renderer.trailMaterial;
                            mat ? this._trailModel.setSubModelMaterial(0, mat) : this._trailModel.setSubModelMaterial(0, this._particleSystem.renderer._defaultTrailMat);
                        }
                    }
                }, {
                    key: "update",
                    value: function update() {
                        this._trailLifetime = this.lifeTime.evaluate(this._particleSystem._time, 1), this.space === Space.World && this._particleSystem._simulationSpace === Space.Local ? (this._needTransform = !0, 
                        this._particleSystem.node.getWorldMatrix(_temp_xform), this._particleSystem.node.getWorldRotation(_temp_quat)) : this._needTransform = !1;
                    }
                }, {
                    key: "animate",
                    value: function animate(p, scaledDt) {
                        if (this._trailSegments) {
                            var trail = this._particleTrail.get(p);
                            trail || (trail = this._trailSegments.alloc(), this._particleTrail.set(p, trail));
                            var lastSeg = trail.getElement(trail.end - 1);
                            if (this._needTransform ? Vec3.transformMat4(_temp_vec3, p.position, _temp_xform) : Vec3.copy(_temp_vec3, p.position), 
                            !(lastSeg && (trail.iterateElement(this, this._updateTrailElement, p, scaledDt), 
                            Vec3.squaredDistance(lastSeg.position, _temp_vec3) < this._minSquaredDistance)) && (lastSeg = trail.addElement())) {
                                Vec3.copy(lastSeg.position, _temp_vec3), lastSeg.lifetime = 0, this.widthFromParticle ? lastSeg.width = p.size.x * this.widthRatio.evaluate(0, 1) : lastSeg.width = this.widthRatio.evaluate(0, 1);
                                var trailNum = trail.count();
                                if (2 === trailNum) {
                                    var lastSecondTrail = trail.getElement(trail.end - 2);
                                    Vec3.subtract(lastSecondTrail.velocity, lastSeg.position, lastSecondTrail.position);
                                } else if (2 < trailNum) {
                                    var _lastSecondTrail = trail.getElement(trail.end - 2), lastThirdTrail = trail.getElement(trail.end - 3);
                                    Vec3.subtract(_temp_vec3, lastThirdTrail.position, _lastSecondTrail.position), Vec3.subtract(_temp_vec3_1$1, lastSeg.position, _lastSecondTrail.position), 
                                    Vec3.subtract(_lastSecondTrail.velocity, _temp_vec3_1$1, _temp_vec3), Vec3.equals(Vec3.ZERO, _lastSecondTrail.velocity) && Vec3.copy(_lastSecondTrail.velocity, _temp_vec3), 
                                    Vec3.normalize(_lastSecondTrail.velocity, _lastSecondTrail.velocity), this._checkDirectionReverse(_lastSecondTrail, lastThirdTrail);
                                }
                                this.colorFromParticle ? lastSeg.color.set(p.color) : lastSeg.color.set(this.colorOvertime.evaluate(0, 1));
                            }
                        }
                    }
                }, {
                    key: "removeParticle",
                    value: function removeParticle(p) {
                        var trail = this._particleTrail.get(p);
                        trail && this._trailSegments && (trail.clear(), this._trailSegments.free(trail), 
                        this._particleTrail.delete(p));
                    }
                }, {
                    key: "updateRenderData",
                    value: function updateRenderData() {
                        this.vbOffset = 0, this.ibOffset = 0;
                        var _iterator3 = this._particleTrail.keys(), _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i3 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i3++];
                            } else {
                                if ((_i3 = _iterator3.next()).done) break;
                                _ref3 = _i3.value;
                            }
                            var p = _ref3, trailSeg = this._particleTrail.get(p);
                            if (-1 !== trailSeg.start) {
                                var indexOffset = 4 * this.vbOffset / this._vertSize, end = trailSeg.start >= trailSeg.end ? trailSeg.end + trailSeg.trailElements.length : trailSeg.end, trailNum = end - trailSeg.start, textCoordSeg = 1 / trailNum, startSegEle = trailSeg.trailElements[trailSeg.start];
                                this._fillVertexBuffer(startSegEle, this.colorOverTrail.evaluate(1, 1), indexOffset, 1, 0, 4);
                                for (var i = trailSeg.start + 1; i < end; i++) {
                                    var segEle = trailSeg.trailElements[i % trailSeg.trailElements.length], j = i - trailSeg.start;
                                    this._fillVertexBuffer(segEle, this.colorOverTrail.evaluate(1 - j / trailNum, 1), indexOffset, 1 - j * textCoordSeg, j, 5);
                                }
                                if (this._needTransform ? Vec3.transformMat4(_temp_trailEle.position, p.position, _temp_xform) : Vec3.copy(_temp_trailEle.position, p.position), 
                                1 == trailNum || 2 == trailNum) {
                                    var lastSecondTrail = trailSeg.getElement(trailSeg.end - 1);
                                    Vec3.subtract(lastSecondTrail.velocity, _temp_trailEle.position, lastSecondTrail.position), 
                                    this._vbF32[this.vbOffset - this._vertSize / 4 - 4] = lastSecondTrail.velocity.x, 
                                    this._vbF32[this.vbOffset - this._vertSize / 4 - 3] = lastSecondTrail.velocity.y, 
                                    this._vbF32[this.vbOffset - this._vertSize / 4 - 2] = lastSecondTrail.velocity.z, 
                                    this._vbF32[this.vbOffset - 4] = lastSecondTrail.velocity.x, this._vbF32[this.vbOffset - 3] = lastSecondTrail.velocity.y, 
                                    this._vbF32[this.vbOffset - 2] = lastSecondTrail.velocity.z, Vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, lastSecondTrail.position), 
                                    this._checkDirectionReverse(_temp_trailEle, lastSecondTrail);
                                } else if (2 < trailNum) {
                                    var _lastSecondTrail2 = trailSeg.getElement(trailSeg.end - 1), lastThirdTrail = trailSeg.getElement(trailSeg.end - 2);
                                    Vec3.subtract(_temp_vec3, lastThirdTrail.position, _lastSecondTrail2.position), 
                                    Vec3.subtract(_temp_vec3_1$1, _temp_trailEle.position, _lastSecondTrail2.position), 
                                    Vec3.subtract(_lastSecondTrail2.velocity, _temp_vec3_1$1, _temp_vec3), Vec3.normalize(_lastSecondTrail2.velocity, _lastSecondTrail2.velocity), 
                                    this._checkDirectionReverse(_lastSecondTrail2, lastThirdTrail), this._vbF32[this.vbOffset - this._vertSize / 4 - 4] = _lastSecondTrail2.velocity.x, 
                                    this._vbF32[this.vbOffset - this._vertSize / 4 - 3] = _lastSecondTrail2.velocity.y, 
                                    this._vbF32[this.vbOffset - this._vertSize / 4 - 2] = _lastSecondTrail2.velocity.z, 
                                    this._vbF32[this.vbOffset - 4] = _lastSecondTrail2.velocity.x, this._vbF32[this.vbOffset - 3] = _lastSecondTrail2.velocity.y, 
                                    this._vbF32[this.vbOffset - 2] = _lastSecondTrail2.velocity.z, Vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, _lastSecondTrail2.position), 
                                    Vec3.normalize(_temp_trailEle.velocity, _temp_trailEle.velocity), this._checkDirectionReverse(_temp_trailEle, _lastSecondTrail2);
                                }
                                _temp_trailEle.width = p.size.x, _temp_trailEle.color = p.color, Vec3.equals(_temp_trailEle.velocity, Vec3.ZERO) ? this.ibOffset -= 3 : this._fillVertexBuffer(_temp_trailEle, this.colorOverTrail.evaluate(0, 1), indexOffset, 0, trailNum, 1);
                            }
                        }
                        this.updateIA(this.ibOffset);
                    }
                }, {
                    key: "updateIA",
                    value: function updateIA(count) {
                        if (this._trailModel && 0 < this._trailModel.subModelNum) {
                            var subModel = this._trailModel.getSubModel(0);
                            subModel.inputAssembler.vertexBuffers[0].update(this._vbF32), subModel.inputAssembler.indexBuffer.update(this._iBuffer), 
                            subModel.inputAssembler.indexCount = count, subModel.inputAssembler.extractDrawInfo(this._iaInfo.drawInfos[0]), 
                            this._iaInfoBuffer.update(this._iaInfo);
                        }
                    }
                }, {
                    key: "_createModel",
                    value: function _createModel() {
                        if (!this._trailModel) {
                            var device = director.root.device, vertexBuffer = device.createBuffer({
                                usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                                size: this._vertSize * (this._trailNum + 1) * 2,
                                stride: this._vertSize
                            }), vBuffer = new ArrayBuffer(this._vertSize * (this._trailNum + 1) * 2);
                            this._vbF32 = new Float32Array(vBuffer), this._vbUint32 = new Uint32Array(vBuffer), 
                            vertexBuffer.update(vBuffer);
                            var indexBuffer = device.createBuffer({
                                usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                                size: 6 * this._trailNum * Uint16Array.BYTES_PER_ELEMENT,
                                stride: Uint16Array.BYTES_PER_ELEMENT
                            });
                            this._iBuffer = new Uint16Array(6 * this._trailNum), indexBuffer.update(this._iBuffer), 
                            this._iaInfoBuffer = device.createBuffer({
                                usage: GFXBufferUsageBit.INDIRECT,
                                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                                size: 56,
                                stride: 1
                            }), this._iaInfo.drawInfos[0].vertexCount = 2 * (this._trailNum + 1), this._iaInfo.drawInfos[0].indexCount = 6 * this._trailNum, 
                            this._iaInfoBuffer.update(this._iaInfo), this._subMeshData = {
                                vertexBuffers: [ vertexBuffer ],
                                indexBuffer: indexBuffer,
                                indirectBuffer: this._iaInfoBuffer,
                                attributes: this._vertAttrs,
                                primitiveMode: GFXPrimitiveMode.TRIANGLE_LIST,
                                flatBuffers: []
                            }, this._trailModel = this._particleSystem._getRenderScene().createModel(Model, this._particleSystem.node), 
                            this._trailModel.visFlags = this._particleSystem.visibility, this._trailModel.setSubModelMesh(0, this._subMeshData), 
                            this._trailModel.enabled = !0;
                        }
                    }
                }, {
                    key: "_updateTrailElement",
                    value: function _updateTrailElement(module, trailEle, p, dt) {
                        return trailEle.lifetime += dt, module.colorFromParticle ? (trailEle.color.set(p.color), 
                        trailEle.color.multiply(module.colorOvertime.evaluate(1 - p.remainingLifetime / p.startLifetime, 1))) : trailEle.color.set(module.colorOvertime.evaluate(1 - p.remainingLifetime / p.startLifetime, 1)), 
                        module.widthFromParticle ? trailEle.width = p.size.x * module.widthRatio.evaluate(trailEle.lifetime / module._trailLifetime, 1) : trailEle.width = module.widthRatio.evaluate(trailEle.lifetime / module._trailLifetime, 1), 
                        trailEle.lifetime > module._trailLifetime;
                    }
                }, {
                    key: "_fillVertexBuffer",
                    value: function _fillVertexBuffer(trailSeg, colorModifer, indexOffset, xTexCoord, trailEleIdx, indexSet) {
                        this._vbF32[this.vbOffset++] = trailSeg.position.x, this._vbF32[this.vbOffset++] = trailSeg.position.y, 
                        this._vbF32[this.vbOffset++] = trailSeg.position.z, this._vbF32[this.vbOffset++] = trailSeg.direction, 
                        this._vbF32[this.vbOffset++] = trailSeg.width, this._vbF32[this.vbOffset++] = xTexCoord, 
                        this._vbF32[this.vbOffset++] = 0, this._vbF32[this.vbOffset++] = trailSeg.velocity.x, 
                        this._vbF32[this.vbOffset++] = trailSeg.velocity.y, this._vbF32[this.vbOffset++] = trailSeg.velocity.z, 
                        _temp_color.set(trailSeg.color), _temp_color.multiply(colorModifer), this._vbUint32[this.vbOffset++] = _temp_color._val, 
                        this._vbF32[this.vbOffset++] = trailSeg.position.x, this._vbF32[this.vbOffset++] = trailSeg.position.y, 
                        this._vbF32[this.vbOffset++] = trailSeg.position.z, this._vbF32[this.vbOffset++] = 1 - trailSeg.direction, 
                        this._vbF32[this.vbOffset++] = trailSeg.width, this._vbF32[this.vbOffset++] = xTexCoord, 
                        this._vbF32[this.vbOffset++] = 1, this._vbF32[this.vbOffset++] = trailSeg.velocity.x, 
                        this._vbF32[this.vbOffset++] = trailSeg.velocity.y, this._vbF32[this.vbOffset++] = trailSeg.velocity.z, 
                        this._vbUint32[this.vbOffset++] = _temp_color._val, 1 & indexSet && (this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx, 
                        this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx - 1, this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1), 
                        4 & indexSet && (this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx, 
                        this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1, this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 2);
                    }
                }, {
                    key: "_checkDirectionReverse",
                    value: function _checkDirectionReverse(currElement, prevElement) {
                        Vec3.dot(currElement.velocity, prevElement.velocity) < DIRECTION_THRESHOLD ? currElement.direction = 1 - prevElement.direction : currElement.direction = prevElement.direction;
                    }
                } ]), TrailModule;
            }()).prototype, "enable", [ _dec2$16 ], Object.getOwnPropertyDescriptor(_class2$1h.prototype, "enable"), _class2$1h.prototype), 
            _descriptor$1d = _applyDecoratedDescriptor(_class2$1h.prototype, "_enable", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor2$13 = _applyDecoratedDescriptor(_class2$1h.prototype, "mode", [ _dec3$R ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return TrailMode.Particles;
                }
            }), _descriptor3$P = _applyDecoratedDescriptor(_class2$1h.prototype, "lifeTime", [ _dec4$J ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor4$K = _applyDecoratedDescriptor(_class2$1h.prototype, "_minParticleDistance", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return .1;
                }
            }), _applyDecoratedDescriptor(_class2$1h.prototype, "minParticleDistance", [ _dec5$F ], Object.getOwnPropertyDescriptor(_class2$1h.prototype, "minParticleDistance"), _class2$1h.prototype), 
            _applyDecoratedDescriptor(_class2$1h.prototype, "space", [ _dec6$A ], Object.getOwnPropertyDescriptor(_class2$1h.prototype, "space"), _class2$1h.prototype), 
            _descriptor5$C = _applyDecoratedDescriptor(_class2$1h.prototype, "existWithParticles", [ _dec7$q ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor6$q = _applyDecoratedDescriptor(_class2$1h.prototype, "textureMode", [ _dec8$g ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return TextureMode.Stretch;
                }
            }), _descriptor7$l = _applyDecoratedDescriptor(_class2$1h.prototype, "widthFromParticle", [ _dec9$e ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor8$i = _applyDecoratedDescriptor(_class2$1h.prototype, "widthRatio", [ _dec10$c ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor9$e = _applyDecoratedDescriptor(_class2$1h.prototype, "colorFromParticle", [ _dec11$b ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor10$c = _applyDecoratedDescriptor(_class2$1h.prototype, "colorOverTrail", [ _dec12$a ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new GradientRange();
                }
            }), _descriptor11$b = _applyDecoratedDescriptor(_class2$1h.prototype, "colorOvertime", [ _dec13$5 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new GradientRange();
                }
            }), _descriptor12$a = _applyDecoratedDescriptor(_class2$1h.prototype, "_space", [ _dec14$4 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Space.World;
                }
            }), _descriptor13$9 = _applyDecoratedDescriptor(_class2$1h.prototype, "_particleSystem", [ _dec15$4 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _class$1x = _class2$1h)) || _class$1x), _world_mat = new Mat4(), ParticleSystemComponent = exports("ParticleSystemComponent", (_dec$1w = ccclass("cc.ParticleSystemComponent"), 
            _dec2$17 = menu("Components/ParticleSystem"), _dec3$S = executionOrder(99), _dec4$K = property({
                displayOrder: 1
            }), _dec5$G = property({
                type: GradientRange,
                displayOrder: 8
            }), _dec6$B = property({
                type: Space,
                displayOrder: 9
            }), _dec7$r = property({
                displayOrder: 10
            }), _dec8$h = property({
                type: CurveRange,
                displayOrder: 10,
                formerlySerializedAs: "startSize"
            }), _dec9$f = property({
                type: CurveRange,
                displayOrder: 10
            }), _dec10$d = property({
                type: CurveRange,
                displayOrder: 10
            }), _dec11$c = property({
                type: CurveRange,
                range: [ -1, 1 ],
                displayOrder: 11
            }), _dec12$b = property({
                displayOrder: 12
            }), _dec13$6 = property({
                type: CurveRange,
                range: [ -1, 1 ],
                radian: !0,
                displayOrder: 12
            }), _dec14$5 = property({
                type: CurveRange,
                range: [ -1, 1 ],
                radian: !0,
                displayOrder: 12
            }), _dec15$5 = property({
                type: CurveRange,
                range: [ -1, 1 ],
                radian: !0,
                displayOrder: 12,
                formerlySerializedAs: "startRotation"
            }), _dec16$3 = property({
                type: CurveRange,
                displayOrder: 6
            }), _dec17$3 = property({
                type: CurveRange,
                displayOrder: 7
            }), _dec18$3 = property({
                displayOrder: 0
            }), _dec19$2 = property({
                displayOrder: 2
            }), _dec20$1 = property({
                displayOrder: 3
            }), _dec21$1 = property({
                type: Space,
                displayOrder: 4
            }), _dec22 = property({
                displayOrder: 5
            }), _dec23 = property({
                displayOrder: 2
            }), _dec24 = property({
                type: CurveRange,
                range: [ -1, 1 ],
                displayOrder: 13
            }), _dec25 = property({
                type: CurveRange,
                displayOrder: 14
            }), _dec26 = property({
                type: CurveRange,
                displayOrder: 15
            }), _dec27 = property({
                type: [ Burst ],
                displayOrder: 16
            }), _dec28 = property({
                type: Material,
                displayName: "Materials",
                visible: !1,
                override: !0
            }), _dec29 = property({
                type: ColorOvertimeModule,
                displayOrder: 23
            }), _dec30 = property({
                type: ShapeModule,
                displayOrder: 17
            }), _dec31 = property({
                type: SizeOvertimeModule,
                displayOrder: 21
            }), _dec32 = property({
                type: VelocityOvertimeModule,
                displayOrder: 18
            }), _dec33 = property({
                type: ForceOvertimeModule,
                displayOrder: 19
            }), _dec34 = property({
                type: LimitVelocityOvertimeModule,
                displayOrder: 20
            }), _dec35 = property({
                type: RotationOvertimeModule,
                displayOrder: 22
            }), _dec36 = property({
                type: TextureAnimationModule,
                displayOrder: 24
            }), _dec37 = property({
                type: TrailModule,
                displayOrder: 25
            }), _dec38 = property({
                type: ParticleSystemRenderer,
                displayOrder: 26
            }), _dec$1w(_class$1y = _dec2$17(_class$1y = _dec3$S(_class$1y = executeInEditMode((_applyDecoratedDescriptor((_class2$1i = function() {
                function ParticleSystemComponent() {
                    var _this;
                    return _classCallCheck(this, ParticleSystemComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(ParticleSystemComponent).call(this)), "startColor", _descriptor$1e, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "scaleSpace", _descriptor2$14, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "startSize3D", _descriptor3$Q, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "startSizeX", _descriptor4$L, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "startSizeY", _descriptor5$D, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "startSizeZ", _descriptor6$r, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "startSpeed", _descriptor7$m, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "startRotation3D", _descriptor8$j, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "startRotationX", _descriptor9$f, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "startRotationY", _descriptor10$d, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "startRotationZ", _descriptor11$c, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "startDelay", _descriptor12$b, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "startLifetime", _descriptor13$a, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "duration", _descriptor14$8, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "loop", _descriptor15$4, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "simulationSpeed", _descriptor16$4, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "playOnAwake", _descriptor17$3, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "gravityModifier", _descriptor18$2, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "rateOverTime", _descriptor19$2, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "rateOverDistance", _descriptor20, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "bursts", _descriptor21, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "colorOverLifetimeModule", _descriptor22, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "shapeModule", _descriptor23, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "sizeOvertimeModule", _descriptor24, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "velocityOvertimeModule", _descriptor25, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "forceOvertimeModule", _descriptor26, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "limitVelocityOvertimeModule", _descriptor27, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "rotationOvertimeModule", _descriptor28, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "textureAnimationModule", _descriptor29, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "trailModule", _descriptor30, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "renderer", _descriptor31, _assertThisInitialized(_this)), 
                    _this._isPlaying = void 0, _this._isPaused = void 0, _this._isStopped = void 0, 
                    _this._isEmitting = void 0, _this._time = void 0, _this._emitRateTimeCounter = void 0, 
                    _this._emitRateDistanceCounter = void 0, _this._oldWPos = void 0, _this._curWPos = void 0, 
                    _this._customData1 = void 0, _this._customData2 = void 0, _this._subEmitters = void 0, 
                    _initializerDefineProperty(_this, "_prewarm", _descriptor32, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_capacity", _descriptor33, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_simulationSpace", _descriptor34, _assertThisInitialized(_this)), 
                    _this.rateOverTime.constant = 10, _this.startLifetime.constant = 5, _this.startSizeX.constant = 1, 
                    _this.startSpeed.constant = 5, _this._isPlaying = !1, _this._isPaused = !1, _this._isStopped = !0, 
                    _this._isEmitting = !1, _this._time = 0, _this._emitRateTimeCounter = 0, _this._emitRateDistanceCounter = 0, 
                    _this._oldWPos = new Vec3(), _this._curWPos = new Vec3(), _this._customData1 = new Vec2(), 
                    _this._customData2 = new Vec2(), _this._subEmitters = [], _this;
                }
                return _inherits(ParticleSystemComponent, RenderableComponent), _createClass(ParticleSystemComponent, [ {
                    key: "capacity",
                    get: function get() {
                        return this._capacity;
                    },
                    set: function set(val) {
                        this._capacity = val, this.renderer && this.renderer._model && this.renderer._model.setCapacity(this._capacity);
                    }
                }, {
                    key: "prewarm",
                    get: function get() {
                        return this._prewarm;
                    },
                    set: function set(val) {
                        !0 === val && this.loop, this._prewarm = val;
                    }
                }, {
                    key: "simulationSpace",
                    get: function get() {
                        return this._simulationSpace;
                    },
                    set: function set(val) {
                        val !== this._simulationSpace && (this._simulationSpace = val, this.renderer._updateMaterialParams(), 
                        this.renderer._updateTrailMaterial());
                    }
                }, {
                    key: "sharedMaterials",
                    get: function get() {
                        return _get(_getPrototypeOf(ParticleSystemComponent.prototype), "sharedMaterials", this);
                    },
                    set: function set(val) {
                        _set(_getPrototypeOf(ParticleSystemComponent.prototype), "sharedMaterials", val, this, !0);
                    }
                } ]), _createClass(ParticleSystemComponent, [ {
                    key: "onLoad",
                    value: function onLoad() {
                        this.renderer.onInit(this), this.shapeModule.onInit(this), this.trailModule.onInit(this), 
                        this.textureAnimationModule.onInit(this), this._resetPosition();
                    }
                }, {
                    key: "_onMaterialModified",
                    value: function _onMaterialModified(index, material) {
                        this.renderer._onMaterialModified(index, material);
                    }
                }, {
                    key: "_onRebuildPSO",
                    value: function _onRebuildPSO(index, material) {
                        this.renderer._onRebuildPSO(index, material);
                    }
                }, {
                    key: "_getModel",
                    value: function _getModel() {
                        return this.renderer._model;
                    }
                }, {
                    key: "recreateModel",
                    value: function recreateModel() {
                        if (this.isValid) {
                            var r = this.renderer;
                            r && r._model && (r._model.scene.destroyModel(r._model), r._model = null, r.onEnable(), 
                            r._updateModel(), r._updateMaterialParams(), r._updateTrailMaterial());
                        }
                    }
                }, {
                    key: "play",
                    value: function play() {
                        this._isPaused && (this._isPaused = !1), this._isStopped && (this._isStopped = !1), 
                        this._isPlaying = !0, this._isEmitting = !0, this._resetPosition(), this._prewarm && this._prewarmSystem();
                    }
                }, {
                    key: "pause",
                    value: function pause() {
                        this._isStopped ? console.warn("pause(): particle system is already stopped.") : (this._isPlaying && (this._isPlaying = !1), 
                        this._isPaused = !0);
                    }
                }, {
                    key: "stop",
                    value: function stop() {
                        (this._isPlaying || this._isPaused) && this.clear(), this._isPlaying && (this._isPlaying = !1), 
                        this._isPaused && (this._isPaused = !1), this._time = 0, this._emitRateTimeCounter = 0, 
                        this._emitRateDistanceCounter = 0, this._isStopped = !0;
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        this.enabledInHierarchy && (this.renderer.clear(), this.trailModule.clear());
                    }
                }, {
                    key: "getParticleCount",
                    value: function getParticleCount() {
                        return this.renderer.getParticleCount();
                    }
                }, {
                    key: "setCustomData1",
                    value: function setCustomData1(x, y) {
                        Vec2.set(this._customData1, x, y);
                    }
                }, {
                    key: "setCustomData2",
                    value: function setCustomData2(x, y) {
                        Vec2.set(this._customData2, x, y);
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.renderer.onDestroy(), this.trailModule.destroy();
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        this.playOnAwake && this.play(), this.renderer.onEnable(), this.trailModule.onEnable();
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this.renderer.onDisable(), this.trailModule.onDisable();
                    }
                }, {
                    key: "update",
                    value: function update(dt) {
                        var scaledDeltaTime = dt * this.simulationSpeed;
                        this._isPlaying && (this._time += scaledDeltaTime, this._emit(scaledDeltaTime), 
                        0 !== this.renderer._updateParticles(scaledDeltaTime) || this._isEmitting || this.stop(), 
                        this.renderer._updateRenderData(), this.trailModule.enable && this.trailModule.updateRenderData());
                    }
                }, {
                    key: "_onVisiblityChange",
                    value: function _onVisiblityChange(val) {
                        this.renderer._model && (this.renderer._model.visFlags = val);
                    }
                }, {
                    key: "emit",
                    value: function emit(count, dt) {
                        for (var i = 0; i < count; ++i) {
                            var particle = this.renderer._getFreeParticle();
                            if (null === particle) return;
                            var rand = pseudoRandom(randomRangeInt(0, 2147483647));
                            switch (this.shapeModule.enable ? this.shapeModule.emit(particle) : (Vec3.set(particle.position, 0, 0, 0), 
                            Vec3.copy(particle.velocity, particleEmitZAxis)), this.textureAnimationModule.enable && this.textureAnimationModule.init(particle), 
                            Vec3.multiplyScalar(particle.velocity, particle.velocity, this.startSpeed.evaluate(this._time / this.duration, rand)), 
                            this._simulationSpace) {
                              case Space.Local:
                                break;

                              case Space.World:
                                this.node.getWorldMatrix(_world_mat), Vec3.transformMat4(particle.position, particle.position, _world_mat);
                                var worldRot = new Quat();
                                this.node.getWorldRotation(worldRot), Vec3.transformQuat(particle.velocity, particle.velocity, worldRot);
                                break;

                              case Space.Custom:
                            }
                            Vec3.copy(particle.ultimateVelocity, particle.velocity), this.startRotation3D ? Vec3.set(particle.rotation, this.startRotationX.evaluate(this._time / this.duration, rand), this.startRotationY.evaluate(this._time / this.duration, rand), this.startRotationZ.evaluate(this._time / this.duration, rand)) : Vec3.set(particle.rotation, 0, 0, this.startRotationZ.evaluate(this._time / this.duration, rand)), 
                            this.startSize3D ? Vec3.set(particle.startSize, this.startSizeX.evaluate(this._time / this.duration, rand), this.startSizeY.evaluate(this._time / this.duration, rand), this.startSizeZ.evaluate(this._time / this.duration, rand)) : (Vec3.set(particle.startSize, this.startSizeX.evaluate(this._time / this.duration, rand), 1, 1), 
                            particle.startSize.y = particle.startSize.x), Vec3.copy(particle.size, particle.startSize), 
                            particle.startColor.set(this.startColor.evaluate(this._time / this.duration, rand)), 
                            particle.color.set(particle.startColor), particle.startLifetime = this.startLifetime.evaluate(this._time / this.duration, rand) + dt, 
                            particle.remainingLifetime = particle.startLifetime, particle.randomSeed = randomRangeInt(0, 233280), 
                            this.renderer._setNewParticle(particle);
                        }
                    }
                }, {
                    key: "_prewarmSystem",
                    value: function _prewarmSystem() {
                        this.startDelay.mode = Mode$1.Constant, this.startDelay.constant = 0;
                        for (var cnt = this.duration / 1, i = 0; i < cnt; ++i) this._time += 1, this._emit(1), 
                        this.renderer._updateParticles(1);
                    }
                }, {
                    key: "_emit",
                    value: function _emit(dt) {
                        var startDelay = this.startDelay.evaluate(0, 1);
                        if (this._time > startDelay) {
                            if (this._time > this.duration + startDelay && !this.loop) return void (this._isEmitting = !1);
                            if (this._emitRateTimeCounter += this.rateOverTime.evaluate(this._time / this.duration, 1) * dt, 
                            1 < this._emitRateTimeCounter && this._isEmitting) {
                                var emitNum = Math.floor(this._emitRateTimeCounter);
                                this._emitRateTimeCounter -= emitNum, this.emit(emitNum, dt);
                            }
                            this.node.getWorldPosition(this._curWPos);
                            var distance = Vec3.distance(this._curWPos, this._oldWPos);
                            if (Vec3.copy(this._oldWPos, this._curWPos), this._emitRateDistanceCounter += distance * this.rateOverDistance.evaluate(this._time / this.duration, 1), 
                            1 < this._emitRateDistanceCounter && this._isEmitting) {
                                var _emitNum = Math.floor(this._emitRateDistanceCounter);
                                this._emitRateDistanceCounter -= _emitNum, this.emit(_emitNum, dt);
                            }
                            var _iterator = this.bursts, _isArray = Array.isArray(_iterator), _i = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i >= _iterator.length) break;
                                    _ref = _iterator[_i++];
                                } else {
                                    if ((_i = _iterator.next()).done) break;
                                    _ref = _i.value;
                                }
                                _ref.update(this, dt);
                            }
                        }
                    }
                }, {
                    key: "_resetPosition",
                    value: function _resetPosition() {
                        this.node.getWorldPosition(this._oldWPos), Vec3.copy(this._curWPos, this._oldWPos);
                    }
                }, {
                    key: "addSubEmitter",
                    value: function addSubEmitter(subEmitter) {
                        this._subEmitters.push(subEmitter);
                    }
                }, {
                    key: "removeSubEmitter",
                    value: function removeSubEmitter(idx) {
                        this._subEmitters.splice(this._subEmitters.indexOf(idx), 1);
                    }
                }, {
                    key: "addBurst",
                    value: function addBurst(burst) {
                        this.bursts.push(burst);
                    }
                }, {
                    key: "removeBurst",
                    value: function removeBurst(idx) {
                        this.bursts.splice(this.bursts.indexOf(idx), 1);
                    }
                }, {
                    key: "isPlaying",
                    get: function get() {
                        return this._isPlaying;
                    }
                }, {
                    key: "isPaused",
                    get: function get() {
                        return this._isPaused;
                    }
                }, {
                    key: "isStopped",
                    get: function get() {
                        return this._isStopped;
                    }
                }, {
                    key: "isEmitting",
                    get: function get() {
                        return this._isEmitting;
                    }
                }, {
                    key: "time",
                    get: function get() {
                        return this._time;
                    }
                } ]), ParticleSystemComponent;
            }()).prototype, "capacity", [ _dec4$K ], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "capacity"), _class2$1i.prototype), 
            _descriptor$1e = _applyDecoratedDescriptor(_class2$1i.prototype, "startColor", [ _dec5$G ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new GradientRange();
                }
            }), _descriptor2$14 = _applyDecoratedDescriptor(_class2$1i.prototype, "scaleSpace", [ _dec6$B ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Space.Local;
                }
            }), _descriptor3$Q = _applyDecoratedDescriptor(_class2$1i.prototype, "startSize3D", [ _dec7$r ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor4$L = _applyDecoratedDescriptor(_class2$1i.prototype, "startSizeX", [ _dec8$h ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor5$D = _applyDecoratedDescriptor(_class2$1i.prototype, "startSizeY", [ _dec9$f ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor6$r = _applyDecoratedDescriptor(_class2$1i.prototype, "startSizeZ", [ _dec10$d ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor7$m = _applyDecoratedDescriptor(_class2$1i.prototype, "startSpeed", [ _dec11$c ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor8$j = _applyDecoratedDescriptor(_class2$1i.prototype, "startRotation3D", [ _dec12$b ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor9$f = _applyDecoratedDescriptor(_class2$1i.prototype, "startRotationX", [ _dec13$6 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor10$d = _applyDecoratedDescriptor(_class2$1i.prototype, "startRotationY", [ _dec14$5 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor11$c = _applyDecoratedDescriptor(_class2$1i.prototype, "startRotationZ", [ _dec15$5 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor12$b = _applyDecoratedDescriptor(_class2$1i.prototype, "startDelay", [ _dec16$3 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor13$a = _applyDecoratedDescriptor(_class2$1i.prototype, "startLifetime", [ _dec17$3 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor14$8 = _applyDecoratedDescriptor(_class2$1i.prototype, "duration", [ _dec18$3 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 5;
                }
            }), _descriptor15$4 = _applyDecoratedDescriptor(_class2$1i.prototype, "loop", [ _dec19$2 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _applyDecoratedDescriptor(_class2$1i.prototype, "prewarm", [ _dec20$1 ], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "prewarm"), _class2$1i.prototype), 
            _applyDecoratedDescriptor(_class2$1i.prototype, "simulationSpace", [ _dec21$1 ], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "simulationSpace"), _class2$1i.prototype), 
            _descriptor16$4 = _applyDecoratedDescriptor(_class2$1i.prototype, "simulationSpeed", [ _dec22 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _descriptor17$3 = _applyDecoratedDescriptor(_class2$1i.prototype, "playOnAwake", [ _dec23 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor18$2 = _applyDecoratedDescriptor(_class2$1i.prototype, "gravityModifier", [ _dec24 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor19$2 = _applyDecoratedDescriptor(_class2$1i.prototype, "rateOverTime", [ _dec25 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor20 = _applyDecoratedDescriptor(_class2$1i.prototype, "rateOverDistance", [ _dec26 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new CurveRange();
                }
            }), _descriptor21 = _applyDecoratedDescriptor(_class2$1i.prototype, "bursts", [ _dec27 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Array();
                }
            }), _applyDecoratedDescriptor(_class2$1i.prototype, "sharedMaterials", [ _dec28 ], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "sharedMaterials"), _class2$1i.prototype), 
            _descriptor22 = _applyDecoratedDescriptor(_class2$1i.prototype, "colorOverLifetimeModule", [ _dec29 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new ColorOvertimeModule();
                }
            }), _descriptor23 = _applyDecoratedDescriptor(_class2$1i.prototype, "shapeModule", [ _dec30 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new ShapeModule();
                }
            }), _descriptor24 = _applyDecoratedDescriptor(_class2$1i.prototype, "sizeOvertimeModule", [ _dec31 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new SizeOvertimeModule();
                }
            }), _descriptor25 = _applyDecoratedDescriptor(_class2$1i.prototype, "velocityOvertimeModule", [ _dec32 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new VelocityOvertimeModule();
                }
            }), _descriptor26 = _applyDecoratedDescriptor(_class2$1i.prototype, "forceOvertimeModule", [ _dec33 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new ForceOvertimeModule();
                }
            }), _descriptor27 = _applyDecoratedDescriptor(_class2$1i.prototype, "limitVelocityOvertimeModule", [ _dec34 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new LimitVelocityOvertimeModule();
                }
            }), _descriptor28 = _applyDecoratedDescriptor(_class2$1i.prototype, "rotationOvertimeModule", [ _dec35 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new RotationOvertimeModule();
                }
            }), _descriptor29 = _applyDecoratedDescriptor(_class2$1i.prototype, "textureAnimationModule", [ _dec36 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new TextureAnimationModule();
                }
            }), _descriptor30 = _applyDecoratedDescriptor(_class2$1i.prototype, "trailModule", [ _dec37 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new TrailModule();
                }
            }), _descriptor31 = _applyDecoratedDescriptor(_class2$1i.prototype, "renderer", [ _dec38 ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new ParticleSystemRenderer();
                }
            }), _descriptor32 = _applyDecoratedDescriptor(_class2$1i.prototype, "_prewarm", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor33 = _applyDecoratedDescriptor(_class2$1i.prototype, "_capacity", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 100;
                }
            }), _descriptor34 = _applyDecoratedDescriptor(_class2$1i.prototype, "_simulationSpace", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return Space.Local;
                }
            }), _class$1y = _class2$1i)) || _class$1y) || _class$1y) || _class$1y) || _class$1y)), ParticleUtils = exports("ParticleUtils", function() {
                function ParticleUtils() {
                    _classCallCheck(this, ParticleUtils);
                }
                return _createClass(ParticleUtils, null, [ {
                    key: "instantiate",
                    value: function instantiate$1(prefab) {
                        return this.registeredSceneEvent || (director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, this.onSceneUnload, this), 
                        this.registeredSceneEvent = !0), this.particleSystemPool.has(prefab._uuid) || this.particleSystemPool.set(prefab._uuid, new Pool$1(function() {
                            return instantiate(prefab);
                        }, 1)), this.particleSystemPool.get(prefab._uuid).alloc();
                    }
                }, {
                    key: "destroy",
                    value: function destroy(prefab) {
                        this.particleSystemPool.has(prefab._prefab.asset._uuid) && (this.stop(prefab), this.particleSystemPool.get(prefab._prefab.asset._uuid).free(prefab));
                    }
                }, {
                    key: "onSceneUnload",
                    value: function onSceneUnload() {
                        this.particleSystemPool.forEach(function(value) {
                            value.clear(function(prefab) {
                                prefab.destroy();
                            });
                        }), this.particleSystemPool.clear();
                    }
                }, {
                    key: "play",
                    value: function play(rootNode) {
                        var _iterator = rootNode.getComponentsInChildren(ParticleSystemComponent), _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            _ref.play();
                        }
                    }
                }, {
                    key: "stop",
                    value: function stop(rootNode) {
                        var _iterator2 = rootNode.getComponentsInChildren(ParticleSystemComponent), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            _ref2.stop();
                        }
                    }
                } ]), ParticleUtils;
            }());
            function commonjsRequire() {
                throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs");
            }
            function createCommonjsModule(fn, module) {
                return fn(module = {
                    exports: {}
                }, module.exports), module.exports;
            }
            ParticleUtils.particleSystemPool = new Map(), ParticleUtils.registeredSceneEvent = !1, 
            cc.ParticleSystemComponent = ParticleSystemComponent, cc.BillboardComponent = BillboardComponent, 
            cc.LineComponent = LineComponent, cc.ParticleUtils = ParticleUtils;
            var ERigidBodyType, ETransformSource, cannon_min = createCommonjsModule(function(module, exports) {
                module.exports = function n(s, r, a) {
                    function h(i, t) {
                        if (!r[i]) {
                            if (!s[i]) {
                                var e = commonjsRequire;
                                if (!t && e) return e(i, !0);
                                if (l) return l(i, !0);
                                throw new Error("Cannot find module '" + i + "'");
                            }
                            var o = r[i] = {
                                exports: {}
                            };
                            s[i][0].call(o.exports, function(t) {
                                var e = s[i][1][t];
                                return h(e || t);
                            }, o, o.exports, n, s, r, a);
                        }
                        return r[i].exports;
                    }
                    for (var l = commonjsRequire, t = 0; t < a.length; t++) h(a[t]);
                    return h;
                }({
                    1: [ function(t, e, i) {
                        e.exports = {
                            name: "cannon",
                            version: "1.0.1",
                            description: "A lightweight 3D physics engine written in JavaScript.",
                            homepage: "https://github.com/cocos-creator/cannon.js",
                            author: "JayceLai",
                            keywords: [ "cannon.js", "cannon", "physics", "engine", "3d" ],
                            scripts: {
                                build: "grunt && npm run preprocess && grunt addLicense && grunt addDate",
                                preprocess: "node node_modules/uglify-js/bin/uglifyjs build/cannon.js -o build/cannon.min.js -d doProfiling=false,DEBUG=false -c -m"
                            },
                            main: "./build/cannon.min.js",
                            engines: {
                                node: "*"
                            },
                            repository: {
                                type: "git",
                                url: "https://github.com/cocos-creator/cannon.js.git"
                            },
                            bugs: {
                                url: "https://github.com/cocos-creator/cannon.js/issues"
                            },
                            licenses: [ {
                                type: "MIT"
                            } ],
                            devDependencies: {
                                jshint: "latest",
                                "uglify-js": "latest",
                                nodeunit: "^0.9.0",
                                grunt: "~0.4.0",
                                "grunt-contrib-jshint": "~0.1.1",
                                "grunt-contrib-nodeunit": "^0.4.1",
                                "grunt-contrib-concat": "~0.1.3",
                                "grunt-contrib-uglify": "^0.5.1",
                                "grunt-browserify": "^2.1.4",
                                "grunt-contrib-yuidoc": "^0.5.2",
                                browserify: "*"
                            },
                            dependencies: {}
                        };
                    }, {} ],
                    2: [ function(t, e, i) {
                        e.exports = {
                            version: t("../package.json").version,
                            AABB: t("./collision/AABB"),
                            ArrayCollisionMatrix: t("./collision/ArrayCollisionMatrix"),
                            Body: t("./objects/Body"),
                            Box: t("./shapes/Box"),
                            Broadphase: t("./collision/Broadphase"),
                            Constraint: t("./constraints/Constraint"),
                            ContactEquation: t("./equations/ContactEquation"),
                            Narrowphase: t("./world/Narrowphase"),
                            ConeTwistConstraint: t("./constraints/ConeTwistConstraint"),
                            ContactMaterial: t("./material/ContactMaterial"),
                            ConvexPolyhedron: t("./shapes/ConvexPolyhedron"),
                            Cylinder: t("./shapes/Cylinder"),
                            DistanceConstraint: t("./constraints/DistanceConstraint"),
                            Equation: t("./equations/Equation"),
                            EventTarget: t("./utils/EventTarget"),
                            FrictionEquation: t("./equations/FrictionEquation"),
                            GSSolver: t("./solver/GSSolver"),
                            GridBroadphase: t("./collision/GridBroadphase"),
                            Heightfield: t("./shapes/Heightfield"),
                            HingeConstraint: t("./constraints/HingeConstraint"),
                            LockConstraint: t("./constraints/LockConstraint"),
                            Mat3: t("./math/Mat3"),
                            Material: t("./material/Material"),
                            NaiveBroadphase: t("./collision/NaiveBroadphase"),
                            ObjectCollisionMatrix: t("./collision/ObjectCollisionMatrix"),
                            Pool: t("./utils/Pool"),
                            Particle: t("./shapes/Particle"),
                            Plane: t("./shapes/Plane"),
                            PointToPointConstraint: t("./constraints/PointToPointConstraint"),
                            Quaternion: t("./math/Quaternion"),
                            Ray: t("./collision/Ray"),
                            RaycastVehicle: t("./objects/RaycastVehicle"),
                            RaycastResult: t("./collision/RaycastResult"),
                            RigidVehicle: t("./objects/RigidVehicle"),
                            RotationalEquation: t("./equations/RotationalEquation"),
                            RotationalMotorEquation: t("./equations/RotationalMotorEquation"),
                            SAPBroadphase: t("./collision/SAPBroadphase"),
                            SPHSystem: t("./objects/SPHSystem"),
                            Shape: t("./shapes/Shape"),
                            Solver: t("./solver/Solver"),
                            Sphere: t("./shapes/Sphere"),
                            SplitSolver: t("./solver/SplitSolver"),
                            Spring: t("./objects/Spring"),
                            Transform: t("./math/Transform"),
                            Trimesh: t("./shapes/Trimesh"),
                            Vec3: t("./math/Vec3"),
                            Vec3Pool: t("./utils/Vec3Pool"),
                            World: t("./world/World")
                        };
                    }, {
                        "../package.json": 1,
                        "./collision/AABB": 3,
                        "./collision/ArrayCollisionMatrix": 4,
                        "./collision/Broadphase": 5,
                        "./collision/GridBroadphase": 6,
                        "./collision/NaiveBroadphase": 7,
                        "./collision/ObjectCollisionMatrix": 8,
                        "./collision/Ray": 10,
                        "./collision/RaycastResult": 11,
                        "./collision/SAPBroadphase": 12,
                        "./constraints/ConeTwistConstraint": 13,
                        "./constraints/Constraint": 14,
                        "./constraints/DistanceConstraint": 15,
                        "./constraints/HingeConstraint": 16,
                        "./constraints/LockConstraint": 17,
                        "./constraints/PointToPointConstraint": 18,
                        "./equations/ContactEquation": 20,
                        "./equations/Equation": 21,
                        "./equations/FrictionEquation": 22,
                        "./equations/RotationalEquation": 23,
                        "./equations/RotationalMotorEquation": 24,
                        "./material/ContactMaterial": 25,
                        "./material/Material": 26,
                        "./math/Mat3": 28,
                        "./math/Quaternion": 29,
                        "./math/Transform": 30,
                        "./math/Vec3": 31,
                        "./objects/Body": 32,
                        "./objects/RaycastVehicle": 33,
                        "./objects/RigidVehicle": 34,
                        "./objects/SPHSystem": 35,
                        "./objects/Spring": 36,
                        "./shapes/Box": 38,
                        "./shapes/ConvexPolyhedron": 39,
                        "./shapes/Cylinder": 40,
                        "./shapes/Heightfield": 41,
                        "./shapes/Particle": 42,
                        "./shapes/Plane": 43,
                        "./shapes/Shape": 44,
                        "./shapes/Sphere": 45,
                        "./shapes/Trimesh": 46,
                        "./solver/GSSolver": 47,
                        "./solver/Solver": 48,
                        "./solver/SplitSolver": 49,
                        "./utils/EventTarget": 50,
                        "./utils/Pool": 52,
                        "./utils/Vec3Pool": 55,
                        "./world/Narrowphase": 56,
                        "./world/World": 57
                    } ],
                    3: [ function(t, e, i) {
                        var o = t("../math/Vec3");
                        function n(t) {
                            t = t || {}, this.lowerBound = new o(), t.lowerBound && this.lowerBound.copy(t.lowerBound), 
                            this.upperBound = new o(), t.upperBound && this.upperBound.copy(t.upperBound);
                        }
                        t("../utils/Utils"), e.exports = n;
                        var l = new o();
                        n.prototype.setFromPoints = function(t, e, i, o) {
                            var n = this.lowerBound, s = this.upperBound, r = i;
                            n.copy(t[0]), r && r.vmult(n, n), s.copy(n);
                            for (var a = 1; a < t.length; a++) {
                                var h = t[a];
                                r && (r.vmult(h, l), h = l), h.x > s.x && (s.x = h.x), h.x < n.x && (n.x = h.x), 
                                h.y > s.y && (s.y = h.y), h.y < n.y && (n.y = h.y), h.z > s.z && (s.z = h.z), h.z < n.z && (n.z = h.z);
                            }
                            return e && (e.vadd(n, n), e.vadd(s, s)), o && (n.x -= o, n.y -= o, n.z -= o, s.x += o, 
                            s.y += o, s.z += o), this;
                        }, n.prototype.copy = function(t) {
                            return this.lowerBound.copy(t.lowerBound), this.upperBound.copy(t.upperBound), this;
                        }, n.prototype.clone = function() {
                            return new n().copy(this);
                        }, n.prototype.extend = function(t) {
                            this.lowerBound.x = Math.min(this.lowerBound.x, t.lowerBound.x), this.upperBound.x = Math.max(this.upperBound.x, t.upperBound.x), 
                            this.lowerBound.y = Math.min(this.lowerBound.y, t.lowerBound.y), this.upperBound.y = Math.max(this.upperBound.y, t.upperBound.y), 
                            this.lowerBound.z = Math.min(this.lowerBound.z, t.lowerBound.z), this.upperBound.z = Math.max(this.upperBound.z, t.upperBound.z);
                        }, n.prototype.overlaps = function(t) {
                            var e = this.lowerBound, i = this.upperBound, o = t.lowerBound, n = t.upperBound, s = o.x <= i.x && i.x <= n.x || e.x <= n.x && n.x <= i.x, r = o.y <= i.y && i.y <= n.y || e.y <= n.y && n.y <= i.y, a = o.z <= i.z && i.z <= n.z || e.z <= n.z && n.z <= i.z;
                            return s && r && a;
                        }, n.prototype.volume = function() {
                            var t = this.lowerBound, e = this.upperBound;
                            return (e.x - t.x) * (e.y - t.y) * (e.z - t.z);
                        }, n.prototype.contains = function(t) {
                            var e = this.lowerBound, i = this.upperBound, o = t.lowerBound, n = t.upperBound;
                            return e.x <= o.x && i.x >= n.x && e.y <= o.y && i.y >= n.y && e.z <= o.z && i.z >= n.z;
                        }, n.prototype.getCorners = function(t, e, i, o, n, s, r, a) {
                            var h = this.lowerBound, l = this.upperBound;
                            t.copy(h), e.set(l.x, h.y, h.z), i.set(l.x, l.y, h.z), o.set(h.x, l.y, l.z), n.set(l.x, h.y, h.z), 
                            s.set(h.x, l.y, h.z), r.set(h.x, h.y, l.z), a.copy(l);
                        };
                        var d = [ new o(), new o(), new o(), new o(), new o(), new o(), new o(), new o() ];
                        n.prototype.toLocalFrame = function(t, e) {
                            var i = d, o = i[0], n = i[1], s = i[2], r = i[3], a = i[4], h = i[5], l = i[6], p = i[7];
                            this.getCorners(o, n, s, r, a, h, l, p);
                            for (var c = 0; 8 !== c; c++) {
                                var u = i[c];
                                t.pointToLocal(u, u);
                            }
                            return e.setFromPoints(i);
                        }, n.prototype.toWorldFrame = function(t, e) {
                            var i = d, o = i[0], n = i[1], s = i[2], r = i[3], a = i[4], h = i[5], l = i[6], p = i[7];
                            this.getCorners(o, n, s, r, a, h, l, p);
                            for (var c = 0; 8 !== c; c++) {
                                var u = i[c];
                                t.pointToWorld(u, u);
                            }
                            return e.setFromPoints(i);
                        }, n.prototype.overlapsRay = function(t) {
                            var e = 1 / t._direction.x, i = 1 / t._direction.y, o = 1 / t._direction.z, n = (this.lowerBound.x - t.from.x) * e, s = (this.upperBound.x - t.from.x) * e, r = (this.lowerBound.y - t.from.y) * i, a = (this.upperBound.y - t.from.y) * i, h = (this.lowerBound.z - t.from.z) * o, l = (this.upperBound.z - t.from.z) * o, p = Math.max(Math.max(Math.min(n, s), Math.min(r, a)), Math.min(h, l)), c = Math.min(Math.min(Math.max(n, s), Math.max(r, a)), Math.max(h, l));
                            return !(c < 0 || c < p);
                        };
                    }, {
                        "../math/Vec3": 31,
                        "../utils/Utils": 54
                    } ],
                    4: [ function(t, e, i) {
                        function o() {
                            this.matrix = [];
                        }
                        (e.exports = o).prototype.get = function(t, e) {
                            if ((t = t.index) < (e = e.index)) {
                                var i = e;
                                e = t, t = i;
                            }
                            return this.matrix[(t * (t + 1) >> 1) + e - 1];
                        }, o.prototype.set = function(t, e, i) {
                            if ((t = t.index) < (e = e.index)) {
                                var o = e;
                                e = t, t = o;
                            }
                            this.matrix[(t * (t + 1) >> 1) + e - 1] = i ? 1 : 0;
                        }, o.prototype.reset = function() {
                            for (var t = 0, e = this.matrix.length; t !== e; t++) this.matrix[t] = 0;
                        }, o.prototype.setNumObjects = function(t) {
                            this.matrix.length = t * (t - 1) >> 1;
                        };
                    }, {} ],
                    5: [ function(t, e, i) {
                        var o = t("../objects/Body"), n = t("../math/Vec3"), s = t("../math/Quaternion");
                        function r() {
                            this.world = null, this.useBoundingBoxes = !1, this.dirty = !0;
                        }
                        t("../shapes/Shape"), t("../shapes/Plane"), (e.exports = r).prototype.collisionPairs = function(t, e, i) {
                            throw new Error("collisionPairs not implemented for this BroadPhase class!");
                        }, r.prototype.needBroadphaseCollision = function(t, e) {
                            return 0 != (t.collisionFilterGroup & e.collisionFilterMask) && 0 != (e.collisionFilterGroup & t.collisionFilterMask) && (0 == (t.type & o.STATIC) && t.sleepState !== o.SLEEPING || 0 == (e.type & o.STATIC) && e.sleepState !== o.SLEEPING);
                        }, r.prototype.intersectionTest = function(t, e, i, o) {
                            this.useBoundingBoxes ? this.doBoundingBoxBroadphase(t, e, i, o) : this.doBoundingSphereBroadphase(t, e, i, o);
                        };
                        var a = new n();
                        new n(), new s(), new n(), r.prototype.doBoundingSphereBroadphase = function(t, e, i, o) {
                            var n = a;
                            e.position.vsub(t.position, n);
                            var s = Math.pow(t.boundingRadius + e.boundingRadius, 2);
                            n.norm2() < s && (i.push(t), o.push(e));
                        }, r.prototype.doBoundingBoxBroadphase = function(t, e, i, o) {
                            t.aabbNeedsUpdate && t.computeAABB(), e.aabbNeedsUpdate && e.computeAABB(), t.aabb.overlaps(e.aabb) && (i.push(t), 
                            o.push(e));
                        };
                        var c = {
                            keys: []
                        }, u = [], d = [];
                        r.prototype.makePairsUnique = function(t, e) {
                            for (var i = c, o = u, n = d, s = t.length, r = 0; r !== s; r++) o[r] = t[r], n[r] = e[r];
                            for (t.length = 0, r = e.length = 0; r !== s; r++) {
                                var a = o[r].id, h = n[r].id;
                                i[l = a < h ? a + "," + h : h + "," + a] = r, i.keys.push(l);
                            }
                            for (r = 0; r !== i.keys.length; r++) {
                                var l = i.keys.pop(), p = i[l];
                                t.push(o[p]), e.push(n[p]), delete i[l];
                            }
                        }, r.prototype.setWorld = function(t) {};
                        var h = new n();
                        r.boundingSphereCheck = function(t, e) {
                            var i = h;
                            return t.position.vsub(e.position, i), Math.pow(t.shape.boundingSphereRadius + e.shape.boundingSphereRadius, 2) > i.norm2();
                        }, r.prototype.aabbQuery = function(t, e, i) {
                            return console.warn(".aabbQuery is not implemented in this Broadphase subclass."), 
                            [];
                        };
                    }, {
                        "../math/Quaternion": 29,
                        "../math/Vec3": 31,
                        "../objects/Body": 32,
                        "../shapes/Plane": 43,
                        "../shapes/Shape": 44
                    } ],
                    6: [ function(t, e, i) {
                        e.exports = o;
                        var a = t("./Broadphase"), h = t("../math/Vec3"), it = t("../shapes/Shape");
                        function o(t, e, i, o, n) {
                            a.apply(this), this.nx = i || 10, this.ny = o || 10, this.nz = n || 10, this.aabbMin = t || new h(100, 100, 100), 
                            this.aabbMax = e || new h(-100, -100, -100);
                            var s = this.nx * this.ny * this.nz;
                            if (s <= 0) throw "GridBroadphase: Each dimension's n must be >0";
                            this.bins = [], this.binLengths = [], this.bins.length = s, this.binLengths.length = s;
                            for (var r = 0; r < s; r++) this.bins[r] = [], this.binLengths[r] = 0;
                        }
                        (o.prototype = new a()).constructor = o;
                        var ot = new h();
                        new h(), o.prototype.collisionPairs = function(t, e, i) {
                            for (var o = t.numObjects(), n = t.bodies, s = this.aabbMax, r = this.aabbMin, m = this.nx, w = this.ny, g = this.nz, x = w * g, b = g, B = 1, a = s.x, h = s.y, l = s.z, E = r.x, A = r.y, S = r.z, z = m / (a - E), M = w / (h - A), C = g / (l - S), p = (a - E) / m, c = (h - A) / w, u = (l - S) / g, d = .5 * Math.sqrt(p * p + c * c + u * u), v = it.types, y = v.SPHERE, f = v.PLANE, q = (v.BOX, 
                            v.COMPOUND, v.CONVEXPOLYHEDRON, this.bins), F = this.binLengths, R = this.bins.length, T = 0; T !== R; T++) F[T] = 0;
                            var P = Math.ceil;
                            function V(t, e, i, o, n, s, r) {
                                var a = (t - E) * z | 0, h = (e - A) * M | 0, l = (i - S) * C | 0, p = P((o - E) * z), c = P((n - A) * M), u = P((s - S) * C);
                                a < 0 ? a = 0 : m <= a && (a = m - 1), h < 0 ? h = 0 : w <= h && (h = w - 1), l < 0 ? l = 0 : g <= l && (l = g - 1), 
                                p < 0 ? p = 0 : m <= p && (p = m - 1), c < 0 ? c = 0 : w <= c && (c = w - 1), u < 0 ? u = 0 : g <= u && (u = g - 1), 
                                h *= b, l *= B, p *= x, c *= b, u *= B;
                                for (var d = a *= x; d <= p; d += x) for (var v = h; v <= c; v += b) for (var y = l; y <= u; y += B) {
                                    var f = d + v + y;
                                    q[f][F[f]++] = r;
                                }
                            }
                            for (r = Math.min, s = Math.max, T = 0; T !== o; T++) {
                                var I = (tt = n[T]).shape;
                                switch (I.type) {
                                  case y:
                                    var N = tt.position.x, L = tt.position.y, W = tt.position.z, j = I.radius;
                                    V(N - j, L - j, W - j, N + j, L + j, W + j, tt);
                                    break;

                                  case f:
                                    I.worldNormalNeedsUpdate && I.computeWorldNormal(tt.quaternion);
                                    var O = I.worldNormal, k = E + .5 * p - tt.position.x, _ = A + .5 * c - tt.position.y, D = S + .5 * u - tt.position.z, U = ot;
                                    U.set(k, _, D);
                                    for (var H = 0, G = 0; H !== m; H++, G += x, U.y = _, U.x += p) for (var X = 0, Q = 0; X !== w; X++, 
                                    Q += b, U.z = D, U.y += c) for (var Y = 0, K = 0; Y !== g; Y++, K += B, U.z += u) if (U.dot(O) < d) {
                                        var Z = G + Q + K;
                                        q[Z][F[Z]++] = tt;
                                    }
                                    break;

                                  default:
                                    tt.aabbNeedsUpdate && tt.computeAABB(), V(tt.aabb.lowerBound.x, tt.aabb.lowerBound.y, tt.aabb.lowerBound.z, tt.aabb.upperBound.x, tt.aabb.upperBound.y, tt.aabb.upperBound.z, tt);
                                }
                            }
                            for (T = 0; T !== R; T++) {
                                var J = F[T];
                                if (1 < J) {
                                    var $ = q[T];
                                    for (H = 0; H !== J; H++) {
                                        var tt = $[H];
                                        for (X = 0; X !== H; X++) {
                                            var et = $[X];
                                            this.needBroadphaseCollision(tt, et) && this.intersectionTest(tt, et, e, i);
                                        }
                                    }
                                }
                            }
                            this.makePairsUnique(e, i);
                        };
                    }, {
                        "../math/Vec3": 31,
                        "../shapes/Shape": 44,
                        "./Broadphase": 5
                    } ],
                    7: [ function(t, e, i) {
                        e.exports = s;
                        var o = t("./Broadphase"), n = t("./AABB");
                        function s() {
                            o.apply(this);
                        }
                        ((s.prototype = new o()).constructor = s).prototype.collisionPairs = function(t, e, i) {
                            var o, n, s, r, a = t.bodies, h = a.length;
                            for (o = 0; o !== h; o++) for (n = 0; n !== o; n++) s = a[o], r = a[n], this.needBroadphaseCollision(s, r) && this.intersectionTest(s, r, e, i);
                        }, new n(), s.prototype.aabbQuery = function(t, e, i) {
                            i = i || [];
                            for (var o = 0; o < t.bodies.length; o++) {
                                var n = t.bodies[o];
                                n.aabbNeedsUpdate && n.computeAABB(), n.aabb.overlaps(e) && i.push(n);
                            }
                            return i;
                        };
                    }, {
                        "./AABB": 3,
                        "./Broadphase": 5
                    } ],
                    8: [ function(t, e, i) {
                        function o() {
                            this.matrix = {};
                        }
                        (e.exports = o).prototype.get = function(t, e) {
                            if ((t = t.id) < (e = e.id)) {
                                var i = e;
                                e = t, t = i;
                            }
                            return t + "-" + e in this.matrix;
                        }, o.prototype.set = function(t, e, i) {
                            if ((t = t.id) < (e = e.id)) {
                                var o = e;
                                e = t, t = o;
                            }
                            i ? this.matrix[t + "-" + e] = !0 : delete this.matrix[t + "-" + e];
                        }, o.prototype.reset = function() {
                            this.matrix = {};
                        }, o.prototype.setNumObjects = function(t) {};
                    }, {} ],
                    9: [ function(t, e, i) {
                        function o() {
                            this.current = [], this.previous = [];
                        }
                        function p(t, e) {
                            t.push((4294901760 & e) >> 16, 65535 & e);
                        }
                        (e.exports = o).prototype.getKey = function(t, e) {
                            if (e < t) {
                                var i = e;
                                e = t, t = i;
                            }
                            return t << 16 | e;
                        }, o.prototype.set = function(t, e) {
                            for (var i = this.getKey(t, e), o = this.current, n = 0; i > o[n]; ) n++;
                            if (i !== o[n]) {
                                for (e = o.length - 1; n <= e; e--) o[e + 1] = o[e];
                                o[n] = i;
                            }
                        }, o.prototype.tick = function() {
                            var t = this.current;
                            this.current = this.previous, this.previous = t, this.current.length = 0;
                        }, o.prototype.reset = function() {
                            this.previous.length = 0, this.current.length = 0;
                        }, o.prototype.getDiff = function(t, e) {
                            for (var i = this.current, o = this.previous, n = i.length, s = o.length, r = 0, a = 0; a < n; a++) {
                                for (var h = i[a]; h > o[r]; ) r++;
                                h === o[r] || p(t, h);
                            }
                            for (a = r = 0; a < s; a++) {
                                for (var l = o[a]; l > i[r]; ) r++;
                                i[r] === l || p(e, l);
                            }
                        }, o.prototype.copy = function(t) {
                            this.current.length = 0, this.previous.length = 0, this.current = t.current.slice(), 
                            this.previous = t.previous.slice();
                        };
                    }, {} ],
                    10: [ function(t, e, i) {
                        e.exports = l;
                        var f = t("../math/Vec3"), o = t("../math/Quaternion"), z = t("../math/Transform"), n = (t("../shapes/ConvexPolyhedron"), 
                        t("../shapes/Box"), t("../collision/RaycastResult")), s = t("../shapes/Shape"), v = t("../collision/AABB");
                        function l(t, e) {
                            this.from = t ? t.clone() : new f(), this.to = e ? e.clone() : new f(), this._direction = new f(), 
                            this.precision = 1e-4, this.checkCollisionResponse = !0, this.skipBackfaces = !1, 
                            this.collisionFilterMask = -1, this.collisionFilterGroup = -1, this.mode = l.ANY, 
                            this.result = new n(), this.hasHit = !1, this.callback = function(t) {};
                        }
                        (l.prototype.constructor = l).CLOSEST = 1, l.ANY = 2, l.ALL = 4;
                        var r = new v(), a = [];
                        l.prototype.intersectWorld = function(t, e) {
                            return this.mode = e.mode || l.ANY, this.result = e.result || new n(), this.skipBackfaces = !!e.skipBackfaces, 
                            this.collisionFilterMask = void 0 !== e.collisionFilterMask ? e.collisionFilterMask : -1, 
                            this.collisionFilterGroup = void 0 !== e.collisionFilterGroup ? e.collisionFilterGroup : -1, 
                            e.from && this.from.copy(e.from), e.to && this.to.copy(e.to), this.callback = e.callback || function() {}, 
                            this.hasHit = !1, this.result.reset(), this._updateDirection(), this.getAABB(r), 
                            a.length = 0, t.broadphase.aabbQuery(t, r, a), this.intersectBodies(a), this.hasHit;
                        };
                        var c = new f(), u = new f();
                        function C(t, e, i, o) {
                            o.vsub(e, d), i.vsub(e, c), t.vsub(e, u);
                            var n, s, r = d.dot(d), a = d.dot(c), h = d.dot(u), l = c.dot(c), p = c.dot(u);
                            return 0 <= (n = l * h - a * p) && 0 <= (s = r * p - a * h) && n + s < r * l - a * a;
                        }
                        l.pointInTriangle = C;
                        var h = new f(), p = new o();
                        l.prototype.intersectBody = function(t, e) {
                            e && (this.result = e, this._updateDirection());
                            var i = this.checkCollisionResponse;
                            if ((!i || t.collisionResponse) && 0 != (this.collisionFilterGroup & t.collisionFilterMask) && 0 != (t.collisionFilterGroup & this.collisionFilterMask)) for (var o = h, n = p, s = 0, r = t.shapes.length; s < r; s++) {
                                var a = t.shapes[s];
                                if ((!i || a.collisionResponse) && (t.quaternion.mult(t.shapeOrientations[s], n), 
                                t.quaternion.vmult(t.shapeOffsets[s], o), o.vadd(t.position, o), this.intersectShape(a, n, o, t), 
                                this.result._shouldStop)) break;
                            }
                        }, l.prototype.intersectBodies = function(t, e) {
                            e && (this.result = e, this._updateDirection());
                            for (var i = 0, o = t.length; !this.result._shouldStop && i < o; i++) this.intersectBody(t[i]);
                        }, l.prototype._updateDirection = function() {
                            this.to.vsub(this.from, this._direction), this._direction.normalize();
                        }, l.prototype.intersectShape = function(t, e, i, o) {
                            if (!(function(t, e, i) {
                                i.vsub(t, d);
                                var o = d.dot(e);
                                return e.mult(o, B), B.vadd(t, B), i.distanceTo(B);
                            }(this.from, this._direction, i) > t.boundingSphereRadius)) {
                                var n = this[t.type];
                                n && n.call(this, t, e, i, o, t);
                            }
                        }, new f(), new f();
                        var q = new f(), F = new f(), R = new f(), T = new f();
                        new f(), new n(), l.prototype.intersectBox = function(t, e, i, o, n) {
                            return this.intersectConvex(t.convexPolyhedronRepresentation, e, i, o, n);
                        }, l.prototype[s.types.BOX] = l.prototype.intersectBox, l.prototype.intersectPlane = function(t, e, i, o, n) {
                            var s = this.from, r = this.to, a = this._direction, h = new f(0, 0, 1);
                            e.vmult(h, h);
                            var l = new f();
                            s.vsub(i, l);
                            var p = l.dot(h);
                            if (r.vsub(i, l), !(0 < p * l.dot(h) || s.distanceTo(r) < p)) {
                                var c = h.dot(a);
                                if (!(Math.abs(c) < this.precision)) {
                                    var u = new f(), d = new f(), v = new f();
                                    s.vsub(i, u);
                                    var y = -h.dot(u) / c;
                                    a.scale(y, d), s.vadd(d, v), this.reportIntersection(h, v, n, o, -1);
                                }
                            }
                        }, l.prototype[s.types.PLANE] = l.prototype.intersectPlane, l.prototype.getAABB = function(t) {
                            var e = this.to, i = this.from;
                            t.lowerBound.x = Math.min(e.x, i.x), t.lowerBound.y = Math.min(e.y, i.y), t.lowerBound.z = Math.min(e.z, i.z), 
                            t.upperBound.x = Math.max(e.x, i.x), t.upperBound.y = Math.max(e.y, i.y), t.upperBound.z = Math.max(e.z, i.z);
                        };
                        var y = {
                            faceList: [ 0 ]
                        }, m = new f(), w = new l(), g = [];
                        l.prototype.intersectHeightfield = function(t, e, i, o, n) {
                            t.data, t.elementSize;
                            var s = w;
                            s.from.copy(this.from), s.to.copy(this.to), z.pointToLocalFrame(i, e, s.from, s.from), 
                            z.pointToLocalFrame(i, e, s.to, s.to), s._updateDirection();
                            var r, a, h, l, p = g;
                            r = a = 0, h = l = t.data.length - 1;
                            var c = new v();
                            s.getAABB(c), t.getIndexOfPosition(c.lowerBound.x, c.lowerBound.y, p, !0), r = Math.max(r, p[0]), 
                            a = Math.max(a, p[1]), t.getIndexOfPosition(c.upperBound.x, c.upperBound.y, p, !0), 
                            h = Math.min(h, p[0] + 1), l = Math.min(l, p[1] + 1);
                            for (var u = r; u < h; u++) for (var d = a; d < l; d++) {
                                if (this.result._shouldStop) return;
                                if (t.getAabbAtIndex(u, d, c), c.overlapsRay(s)) {
                                    if (t.getConvexTrianglePillar(u, d, !1), z.pointToWorldFrame(i, e, t.pillarOffset, m), 
                                    this.intersectConvex(t.pillarConvex, e, m, o, n, y), this.result._shouldStop) return;
                                    t.getConvexTrianglePillar(u, d, !0), z.pointToWorldFrame(i, e, t.pillarOffset, m), 
                                    this.intersectConvex(t.pillarConvex, e, m, o, n, y);
                                }
                            }
                        }, l.prototype[s.types.HEIGHTFIELD] = l.prototype.intersectHeightfield;
                        var x = new f(), b = new f();
                        l.prototype.intersectSphere = function(t, e, i, o, n) {
                            var s = this.from, r = this.to, a = t.radius, h = Math.pow(r.x - s.x, 2) + Math.pow(r.y - s.y, 2) + Math.pow(r.z - s.z, 2), l = 2 * ((r.x - s.x) * (s.x - i.x) + (r.y - s.y) * (s.y - i.y) + (r.z - s.z) * (s.z - i.z)), p = Math.pow(s.x - i.x, 2) + Math.pow(s.y - i.y, 2) + Math.pow(s.z - i.z, 2) - Math.pow(a, 2), c = Math.pow(l, 2) - 4 * h * p, u = x, d = b;
                            if (!(c < 0)) if (0 == c) s.lerp(r, c, u), u.vsub(i, d), d.normalize(), this.reportIntersection(d, u, n, o, -1); else {
                                var v = (-l - Math.sqrt(c)) / (2 * h), y = (-l + Math.sqrt(c)) / (2 * h);
                                if (0 <= v && v <= 1 && (s.lerp(r, v, u), u.vsub(i, d), d.normalize(), this.reportIntersection(d, u, n, o, -1)), 
                                this.result._shouldStop) return;
                                0 <= y && y <= 1 && (s.lerp(r, y, u), u.vsub(i, d), d.normalize(), this.reportIntersection(d, u, n, o, -1));
                            }
                        }, l.prototype[s.types.SPHERE] = l.prototype.intersectSphere;
                        var P = new f(), V = (new f(), new f(), new f());
                        l.prototype.intersectConvex = function(t, e, i, o, n, s) {
                            for (var r = P, a = V, h = s && s.faceList || null, l = t.faces, p = t.vertices, c = t.faceNormals, u = this._direction, d = this.from, v = this.to, y = d.distanceTo(v), f = h ? h.length : l.length, m = this.result, w = 0; !m._shouldStop && w < f; w++) {
                                var g = h ? h[w] : w, x = l[g], b = c[g], B = e, E = i;
                                a.copy(p[x[0]]), B.vmult(a, a), a.vadd(E, a), a.vsub(d, a), B.vmult(b, r);
                                var A = u.dot(r);
                                if (!(Math.abs(A) < this.precision)) {
                                    var S = r.dot(a) / A;
                                    if (!(S < 0)) {
                                        u.mult(S, q), q.vadd(d, q), F.copy(p[x[0]]), B.vmult(F, F), E.vadd(F, F);
                                        for (var z = 1; !m._shouldStop && z < x.length - 1; z++) {
                                            R.copy(p[x[z]]), T.copy(p[x[z + 1]]), B.vmult(R, R), B.vmult(T, T), E.vadd(R, R), 
                                            E.vadd(T, T);
                                            var M = q.distanceTo(d);
                                            !C(q, F, R, T) && !C(q, R, F, T) || y < M || this.reportIntersection(r, q, n, o, g);
                                        }
                                    }
                                }
                            }
                        }, l.prototype[s.types.CONVEXPOLYHEDRON] = l.prototype.intersectConvex;
                        var M = new f(), I = new f(), N = new f(), L = new f(), W = new f(), j = new f(), O = (new v(), 
                        []), k = new z();
                        l.prototype.intersectTrimesh = function(t, e, i, o, n, s) {
                            var r = M, a = O, h = k, l = V, p = I, c = N, u = L, d = j, v = W, y = (s && s.faceList, 
                            t.indices), f = (t.vertices, t.faceNormals, this.from), m = this.to, w = this._direction;
                            h.position.copy(i), h.quaternion.copy(e), z.vectorToLocalFrame(i, e, w, p), z.pointToLocalFrame(i, e, f, c), 
                            z.pointToLocalFrame(i, e, m, u), u.x *= t.scale.x, u.y *= t.scale.y, u.z *= t.scale.z, 
                            c.x *= t.scale.x, c.y *= t.scale.y, c.z *= t.scale.z, u.vsub(c, p), p.normalize();
                            var g = c.distanceSquared(u);
                            t.tree.rayQuery(this, h, a);
                            for (var x = 0, b = a.length; !this.result._shouldStop && x !== b; x++) {
                                var B = a[x];
                                t.getNormal(B, r), t.getVertex(y[3 * B], F), F.vsub(c, l);
                                var E = p.dot(r), A = r.dot(l) / E;
                                if (!(A < 0)) {
                                    p.scale(A, q), q.vadd(c, q), t.getVertex(y[3 * B + 1], R), t.getVertex(y[3 * B + 2], T);
                                    var S = q.distanceSquared(c);
                                    !C(q, R, F, T) && !C(q, F, R, T) || g < S || (z.vectorToWorldFrame(e, r, v), z.pointToWorldFrame(i, e, q, d), 
                                    this.reportIntersection(v, d, n, o, B));
                                }
                            }
                            a.length = 0;
                        }, l.prototype[s.types.TRIMESH] = l.prototype.intersectTrimesh, l.prototype.reportIntersection = function(t, e, i, o, n) {
                            var s = this.from, r = this.to, a = s.distanceTo(e), h = this.result;
                            if (!(this.skipBackfaces && 0 < t.dot(this._direction))) switch (h.hitFaceIndex = void 0 !== n ? n : -1, 
                            this.mode) {
                              case l.ALL:
                                this.hasHit = !0, h.set(s, r, t, e, i, o, a), h.hasHit = !0, this.callback(h);
                                break;

                              case l.CLOSEST:
                                (a < h.distance || !h.hasHit) && (this.hasHit = !0, h.hasHit = !0, h.set(s, r, t, e, i, o, a));
                                break;

                              case l.ANY:
                                this.hasHit = !0, h.hasHit = !0, h.set(s, r, t, e, i, o, a), h._shouldStop = !0;
                            }
                        };
                        var d = new f(), B = new f();
                    }, {
                        "../collision/AABB": 3,
                        "../collision/RaycastResult": 11,
                        "../math/Quaternion": 29,
                        "../math/Transform": 30,
                        "../math/Vec3": 31,
                        "../shapes/Box": 38,
                        "../shapes/ConvexPolyhedron": 39,
                        "../shapes/Shape": 44
                    } ],
                    11: [ function(t, e, i) {
                        var o = t("../math/Vec3");
                        function n() {
                            this.rayFromWorld = new o(), this.rayToWorld = new o(), this.hitNormalWorld = new o(), 
                            this.hitPointWorld = new o(), this.hasHit = !1, this.shape = null, this.body = null, 
                            this.hitFaceIndex = -1, this.distance = -1, this._shouldStop = !1;
                        }
                        (e.exports = n).prototype.reset = function() {
                            this.rayFromWorld.setZero(), this.rayToWorld.setZero(), this.hitNormalWorld.setZero(), 
                            this.hitPointWorld.setZero(), this.hasHit = !1, this.shape = null, this.body = null, 
                            this.hitFaceIndex = -1, this.distance = -1, this._shouldStop = !1;
                        }, n.prototype.abort = function() {
                            this._shouldStop = !0;
                        }, n.prototype.set = function(t, e, i, o, n, s, r) {
                            this.rayFromWorld.copy(t), this.rayToWorld.copy(e), this.hitNormalWorld.copy(i), 
                            this.hitPointWorld.copy(o), this.shape = n, this.body = s, this.distance = r;
                        };
                    }, {
                        "../math/Vec3": 31
                    } ],
                    12: [ function(t, e, i) {
                        t("../shapes/Shape");
                        var o = t("../collision/Broadphase");
                        function p(t) {
                            o.apply(this), this.axisList = [], this.world = null, this.axisIndex = 0;
                            var i = this.axisList;
                            this._addBodyHandler = function(t) {
                                i.push(t.body);
                            }, this._removeBodyHandler = function(t) {
                                var e = i.indexOf(t.body);
                                -1 !== e && i.splice(e, 1);
                            }, t && this.setWorld(t);
                        }
                        ((e.exports = p).prototype = new o()).setWorld = function(t) {
                            for (var e = this.axisList.length = 0; e < t.bodies.length; e++) this.axisList.push(t.bodies[e]);
                            t.removeEventListener("addBody", this._addBodyHandler), t.removeEventListener("removeBody", this._removeBodyHandler), 
                            t.addEventListener("addBody", this._addBodyHandler), t.addEventListener("removeBody", this._removeBodyHandler), 
                            this.world = t, this.dirty = !0;
                        }, p.insertionSortX = function(t) {
                            for (var e = 1, i = t.length; e < i; e++) {
                                for (var o = t[e], n = e - 1; 0 <= n && !(t[n].aabb.lowerBound.x <= o.aabb.lowerBound.x); n--) t[n + 1] = t[n];
                                t[n + 1] = o;
                            }
                            return t;
                        }, p.insertionSortY = function(t) {
                            for (var e = 1, i = t.length; e < i; e++) {
                                for (var o = t[e], n = e - 1; 0 <= n && !(t[n].aabb.lowerBound.y <= o.aabb.lowerBound.y); n--) t[n + 1] = t[n];
                                t[n + 1] = o;
                            }
                            return t;
                        }, p.insertionSortZ = function(t) {
                            for (var e = 1, i = t.length; e < i; e++) {
                                for (var o = t[e], n = e - 1; 0 <= n && !(t[n].aabb.lowerBound.z <= o.aabb.lowerBound.z); n--) t[n + 1] = t[n];
                                t[n + 1] = o;
                            }
                            return t;
                        }, p.prototype.collisionPairs = function(t, e, i) {
                            var o, n, s = this.axisList, r = s.length, a = this.axisIndex;
                            for (this.dirty && (this.sortList(), this.dirty = !1), o = 0; o !== r; o++) {
                                var h = s[o];
                                for (n = o + 1; n < r; n++) {
                                    var l = s[n];
                                    if (this.needBroadphaseCollision(h, l)) {
                                        if (!p.checkBounds(h, l, a)) break;
                                        this.intersectionTest(h, l, e, i);
                                    }
                                }
                            }
                        }, p.prototype.sortList = function() {
                            for (var t = this.axisList, e = this.axisIndex, i = t.length, o = 0; o !== i; o++) {
                                var n = t[o];
                                n.aabbNeedsUpdate && n.computeAABB();
                            }
                            0 === e ? p.insertionSortX(t) : 1 === e ? p.insertionSortY(t) : 2 === e && p.insertionSortZ(t);
                        }, p.checkBounds = function(t, e, i) {
                            var o, n;
                            0 === i ? (o = t.position.x, n = e.position.x) : 1 === i ? (o = t.position.y, n = e.position.y) : 2 === i && (o = t.position.z, 
                            n = e.position.z);
                            var s = t.boundingRadius, r = e.boundingRadius;
                            return n - r < o + s;
                        }, p.prototype.autoDetectAxis = function() {
                            for (var t = 0, e = 0, i = 0, o = 0, n = 0, s = 0, r = this.axisList, a = r.length, h = 1 / a, l = 0; l !== a; l++) {
                                var p = r[l], c = p.position.x;
                                t += c, e += c * c;
                                var u = p.position.y;
                                i += u, o += u * u;
                                var d = p.position.z;
                                n += d, s += d * d;
                            }
                            var v = e - t * t * h, y = o - i * i * h, f = s - n * n * h;
                            this.axisIndex = y < v ? f < v ? 0 : 2 : f < y ? 1 : 2;
                        }, p.prototype.aabbQuery = function(t, e, i) {
                            i = i || [], this.dirty && (this.sortList(), this.dirty = !1);
                            var o = this.axisIndex, n = "x";
                            1 === o && (n = "y"), 2 === o && (n = "z");
                            for (var s = this.axisList, r = (e.lowerBound[n], e.upperBound[n], 0); r < s.length; r++) {
                                var a = s[r];
                                a.aabbNeedsUpdate && a.computeAABB(), a.aabb.overlaps(e) && i.push(a);
                            }
                            return i;
                        };
                    }, {
                        "../collision/Broadphase": 5,
                        "../shapes/Shape": 44
                    } ],
                    13: [ function(t, e, i) {
                        e.exports = o, t("./Constraint");
                        var h = t("./PointToPointConstraint"), l = t("../equations/ConeEquation"), p = t("../equations/RotationalEquation"), c = (t("../equations/ContactEquation"), 
                        t("../math/Vec3"));
                        function o(t, e, i) {
                            var o = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6, n = i.pivotA ? i.pivotA.clone() : new c(), s = i.pivotB ? i.pivotB.clone() : new c();
                            this.axisA = i.axisA ? i.axisA.clone() : new c(), this.axisB = i.axisB ? i.axisB.clone() : new c(), 
                            h.call(this, t, n, e, s, o), this.collideConnected = !!i.collideConnected, this.angle = void 0 !== i.angle ? i.angle : 0;
                            var r = this.coneEquation = new l(t, e, i), a = this.twistEquation = new p(t, e, i);
                            this.twistAngle = void 0 !== i.twistAngle ? i.twistAngle : 0, r.maxForce = 0, r.minForce = -o, 
                            a.maxForce = 0, a.minForce = -o, this.equations.push(r, a);
                        }
                        o.prototype = new h(), o.constructor = o, new c(), new c(), o.prototype.update = function() {
                            var t = this.bodyA, e = this.bodyB, i = this.coneEquation, o = this.twistEquation;
                            h.prototype.update.call(this), t.vectorToWorldFrame(this.axisA, i.axisA), e.vectorToWorldFrame(this.axisB, i.axisB), 
                            this.axisA.tangents(o.axisA, o.axisA), t.vectorToWorldFrame(o.axisA, o.axisA), this.axisB.tangents(o.axisB, o.axisB), 
                            e.vectorToWorldFrame(o.axisB, o.axisB), i.angle = this.angle, o.maxAngle = this.twistAngle;
                        };
                    }, {
                        "../equations/ConeEquation": 19,
                        "../equations/ContactEquation": 20,
                        "../equations/RotationalEquation": 23,
                        "../math/Vec3": 31,
                        "./Constraint": 14,
                        "./PointToPointConstraint": 18
                    } ],
                    14: [ function(t, e, i) {
                        e.exports = n;
                        var o = t("../utils/Utils");
                        function n(t, e, i) {
                            i = o.defaults(i, {
                                collideConnected: !0,
                                wakeUpBodies: !0
                            }), this.equations = [], this.bodyA = t, this.bodyB = e, this.id = n.idCounter++, 
                            this.collideConnected = i.collideConnected, i.wakeUpBodies && (t && t.wakeUp(), 
                            e && e.wakeUp());
                        }
                        n.prototype.update = function() {
                            throw new Error("method update() not implmemented in this Constraint subclass!");
                        }, n.prototype.enable = function() {
                            for (var t = this.equations, e = 0; e < t.length; e++) t[e].enabled = !0;
                        }, n.prototype.disable = function() {
                            for (var t = this.equations, e = 0; e < t.length; e++) t[e].enabled = !1;
                        }, n.idCounter = 0;
                    }, {
                        "../utils/Utils": 54
                    } ],
                    15: [ function(t, e, i) {
                        e.exports = o;
                        var s = t("./Constraint"), r = t("../equations/ContactEquation");
                        function o(t, e, i, o) {
                            s.call(this, t, e), void 0 === i && (i = t.position.distanceTo(e.position)), void 0 === o && (o = 1e6), 
                            this.distance = i;
                            var n = this.distanceEquation = new r(t, e);
                            this.equations.push(n), n.minForce = -o, n.maxForce = o;
                        }
                        (o.prototype = new s()).update = function() {
                            var t = this.bodyA, e = this.bodyB, i = this.distanceEquation, o = .5 * this.distance, n = i.ni;
                            e.position.vsub(t.position, n), n.normalize(), n.mult(o, i.ri), n.mult(-o, i.rj);
                        };
                    }, {
                        "../equations/ContactEquation": 20,
                        "./Constraint": 14
                    } ],
                    16: [ function(t, e, i) {
                        e.exports = o, t("./Constraint");
                        var l = t("./PointToPointConstraint"), p = t("../equations/RotationalEquation"), c = t("../equations/RotationalMotorEquation"), u = (t("../equations/ContactEquation"), 
                        t("../math/Vec3"));
                        function o(t, e, i) {
                            var o = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6, n = i.pivotA ? i.pivotA.clone() : new u(), s = i.pivotB ? i.pivotB.clone() : new u();
                            l.call(this, t, n, e, s, o), (this.axisA = i.axisA ? i.axisA.clone() : new u(1, 0, 0)).normalize(), 
                            (this.axisB = i.axisB ? i.axisB.clone() : new u(1, 0, 0)).normalize();
                            var r = this.rotationalEquation1 = new p(t, e, i), a = this.rotationalEquation2 = new p(t, e, i), h = this.motorEquation = new c(t, e, o);
                            h.enabled = !1, this.equations.push(r, a, h);
                        }
                        o.prototype = new l(), (o.constructor = o).prototype.enableMotor = function() {
                            this.motorEquation.enabled = !0;
                        }, o.prototype.disableMotor = function() {
                            this.motorEquation.enabled = !1;
                        }, o.prototype.setMotorSpeed = function(t) {
                            this.motorEquation.targetVelocity = t;
                        }, o.prototype.setMotorMaxForce = function(t) {
                            this.motorEquation.maxForce = t, this.motorEquation.minForce = -t;
                        };
                        var d = new u(), v = new u();
                        o.prototype.update = function() {
                            var t = this.bodyA, e = this.bodyB, i = this.motorEquation, o = this.rotationalEquation1, n = this.rotationalEquation2, s = d, r = v, a = this.axisA, h = this.axisB;
                            l.prototype.update.call(this), t.quaternion.vmult(a, s), e.quaternion.vmult(h, r), 
                            s.tangents(o.axisA, n.axisA), o.axisB.copy(r), n.axisB.copy(r), this.motorEquation.enabled && (t.quaternion.vmult(this.axisA, i.axisA), 
                            e.quaternion.vmult(this.axisB, i.axisB));
                        };
                    }, {
                        "../equations/ContactEquation": 20,
                        "../equations/RotationalEquation": 23,
                        "../equations/RotationalMotorEquation": 24,
                        "../math/Vec3": 31,
                        "./Constraint": 14,
                        "./PointToPointConstraint": 18
                    } ],
                    17: [ function(t, e, i) {
                        e.exports = o, t("./Constraint");
                        var p = t("./PointToPointConstraint"), c = t("../equations/RotationalEquation"), u = (t("../equations/RotationalMotorEquation"), 
                        t("../equations/ContactEquation"), t("../math/Vec3"));
                        function o(t, e, i) {
                            var o = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6, n = new u(), s = new u(), r = new u();
                            t.position.vadd(e.position, r), r.scale(.5, r), e.pointToLocalFrame(r, s), t.pointToLocalFrame(r, n), 
                            p.call(this, t, n, e, s, o), this.xA = t.vectorToLocalFrame(u.UNIT_X), this.xB = e.vectorToLocalFrame(u.UNIT_X), 
                            this.yA = t.vectorToLocalFrame(u.UNIT_Y), this.yB = e.vectorToLocalFrame(u.UNIT_Y), 
                            this.zA = t.vectorToLocalFrame(u.UNIT_Z), this.zB = e.vectorToLocalFrame(u.UNIT_Z);
                            var a = this.rotationalEquation1 = new c(t, e, i), h = this.rotationalEquation2 = new c(t, e, i), l = this.rotationalEquation3 = new c(t, e, i);
                            this.equations.push(a, h, l);
                        }
                        o.prototype = new p(), o.constructor = o, new u(), new u(), o.prototype.update = function() {
                            var t = this.bodyA, e = this.bodyB, i = (this.motorEquation, this.rotationalEquation1), o = this.rotationalEquation2, n = this.rotationalEquation3;
                            p.prototype.update.call(this), t.vectorToWorldFrame(this.xA, i.axisA), e.vectorToWorldFrame(this.yB, i.axisB), 
                            t.vectorToWorldFrame(this.yA, o.axisA), e.vectorToWorldFrame(this.zB, o.axisB), 
                            t.vectorToWorldFrame(this.zA, n.axisA), e.vectorToWorldFrame(this.xB, n.axisB);
                        };
                    }, {
                        "../equations/ContactEquation": 20,
                        "../equations/RotationalEquation": 23,
                        "../equations/RotationalMotorEquation": 24,
                        "../math/Vec3": 31,
                        "./Constraint": 14,
                        "./PointToPointConstraint": 18
                    } ],
                    18: [ function(t, e, i) {
                        e.exports = o;
                        var h = t("./Constraint"), l = t("../equations/ContactEquation"), p = t("../math/Vec3");
                        function o(t, e, i, o, n) {
                            h.call(this, t, i), n = void 0 !== n ? n : 1e6, this.pivotA = e ? e.clone() : new p(), 
                            this.pivotB = o ? o.clone() : new p();
                            var s = this.equationX = new l(t, i), r = this.equationY = new l(t, i), a = this.equationZ = new l(t, i);
                            this.equations.push(s, r, a), s.minForce = r.minForce = a.minForce = -n, s.maxForce = r.maxForce = a.maxForce = n, 
                            s.ni.set(1, 0, 0), r.ni.set(0, 1, 0), a.ni.set(0, 0, 1);
                        }
                        (o.prototype = new h()).update = function() {
                            var t = this.bodyA, e = this.bodyB, i = this.equationX, o = this.equationY, n = this.equationZ;
                            t.quaternion.vmult(this.pivotA, i.ri), e.quaternion.vmult(this.pivotB, i.rj), o.ri.copy(i.ri), 
                            o.rj.copy(i.rj), n.ri.copy(i.ri), n.rj.copy(i.rj);
                        };
                    }, {
                        "../equations/ContactEquation": 20,
                        "../math/Vec3": 31,
                        "./Constraint": 14
                    } ],
                    19: [ function(t, e, i) {
                        e.exports = o;
                        var n = t("../math/Vec3"), s = (t("../math/Mat3"), t("./Equation"));
                        function o(t, e, i) {
                            var o = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6;
                            s.call(this, t, e, -o, o), this.axisA = i.axisA ? i.axisA.clone() : new n(1, 0, 0), 
                            this.axisB = i.axisB ? i.axisB.clone() : new n(0, 1, 0), this.angle = void 0 !== i.angle ? i.angle : 0;
                        }
                        (o.prototype = new s()).constructor = o;
                        var l = new n(), p = new n();
                        o.prototype.computeB = function(t) {
                            var e = this.a, i = this.b, o = this.axisA, n = this.axisB, s = l, r = p, a = this.jacobianElementA, h = this.jacobianElementB;
                            return o.cross(n, s), n.cross(o, r), a.rotational.copy(r), h.rotational.copy(s), 
                            -(Math.cos(this.angle) - o.dot(n)) * e - this.computeGW() * i - t * this.computeGiMf();
                        };
                    }, {
                        "../math/Mat3": 28,
                        "../math/Vec3": 31,
                        "./Equation": 21
                    } ],
                    20: [ function(t, e, i) {
                        e.exports = s;
                        var o = t("./Equation"), n = t("../math/Vec3");
                        function s(t, e, i) {
                            i = void 0 !== i ? i : 1e6, o.call(this, t, e, 0, i), this.si = null, this.sj = null, 
                            this.restitution = 0, this.ri = new n(), this.rj = new n(), this.ni = new n();
                        }
                        t("../math/Mat3"), (s.prototype = new o()).constructor = s;
                        var g = new n(), x = new n(), b = new n();
                        s.prototype.computeB = function(t) {
                            var e = this.a, i = this.b, o = this.bi, n = this.bj, s = this.ri, r = this.rj, a = g, h = x, l = o.velocity, p = o.angularVelocity, c = (o.force, 
                            o.torque, n.velocity), u = n.angularVelocity, d = (n.force, n.torque, b), v = this.jacobianElementA, y = this.jacobianElementB, f = this.ni;
                            s.cross(f, a), r.cross(f, h), f.negate(v.spatial), a.negate(v.rotational), y.spatial.copy(f), 
                            y.rotational.copy(h), d.copy(n.position), d.vadd(r, d), d.vsub(o.position, d), d.vsub(s, d);
                            var m = f.dot(d), w = this.restitution + 1;
                            return -m * e - (w * c.dot(f) - w * l.dot(f) + u.dot(h) - p.dot(a)) * i - t * this.computeGiMf();
                        };
                        var r = new n(), a = new n(), h = new n(), l = new n(), p = new n();
                        s.prototype.getImpactVelocityAlongNormal = function() {
                            var t = r, e = a, i = h, o = l, n = p;
                            return this.bi.position.vadd(this.ri, i), this.bj.position.vadd(this.rj, o), this.bi.getVelocityAtWorldPoint(i, t), 
                            this.bj.getVelocityAtWorldPoint(o, e), t.vsub(e, n), this.ni.dot(n);
                        };
                    }, {
                        "../math/Mat3": 28,
                        "../math/Vec3": 31,
                        "./Equation": 21
                    } ],
                    21: [ function(t, e, i) {
                        e.exports = s;
                        var n = t("../math/JacobianElement"), o = t("../math/Vec3");
                        function s(t, e, i, o) {
                            this.id = s.id++, this.minForce = void 0 === i ? -1e6 : i, this.maxForce = void 0 === o ? 1e6 : o, 
                            this.bi = t, this.bj = e, this.a = 0, this.b = 0, this.eps = 0, this.jacobianElementA = new n(), 
                            this.jacobianElementB = new n(), this.enabled = !0, this.multiplier = 0, this.setSpookParams(1e7, 4, 1 / 60);
                        }
                        (s.prototype.constructor = s).id = 0, s.prototype.setSpookParams = function(t, e, i) {
                            var o = e, n = t, s = i;
                            this.a = 4 / (s * (1 + 4 * o)), this.b = 4 * o / (1 + 4 * o), this.eps = 4 / (s * s * n * (1 + 4 * o));
                        }, s.prototype.computeB = function(t, e, i) {
                            var o = this.computeGW();
                            return -this.computeGq() * t - o * e - this.computeGiMf() * i;
                        }, s.prototype.computeGq = function() {
                            var t = this.jacobianElementA, e = this.jacobianElementB, i = this.bi, o = this.bj, n = i.position, s = o.position;
                            return t.spatial.dot(n) + e.spatial.dot(s);
                        }, new o(), s.prototype.computeGW = function() {
                            var t = this.jacobianElementA, e = this.jacobianElementB, i = this.bi, o = this.bj, n = i.velocity, s = o.velocity, r = i.angularVelocity, a = o.angularVelocity;
                            return t.multiplyVectors(n, r) + e.multiplyVectors(s, a);
                        }, s.prototype.computeGWlambda = function() {
                            var t = this.jacobianElementA, e = this.jacobianElementB, i = this.bi, o = this.bj, n = i.vlambda, s = o.vlambda, r = i.wlambda, a = o.wlambda;
                            return t.multiplyVectors(n, r) + e.multiplyVectors(s, a);
                        };
                        var p = new o(), c = new o(), u = new o(), d = new o();
                        s.prototype.computeGiMf = function() {
                            var t = this.jacobianElementA, e = this.jacobianElementB, i = this.bi, o = this.bj, n = i.force, s = i.torque, r = o.force, a = o.torque, h = i.invMassSolve, l = o.invMassSolve;
                            return n.scale(h, p), r.scale(l, c), i.invInertiaWorldSolve.vmult(s, u), o.invInertiaWorldSolve.vmult(a, d), 
                            t.multiplyVectors(p, u) + e.multiplyVectors(c, d);
                        };
                        var l = new o();
                        s.prototype.computeGiMGt = function() {
                            var t = this.jacobianElementA, e = this.jacobianElementB, i = this.bi, o = this.bj, n = i.invMassSolve, s = o.invMassSolve, r = i.invInertiaWorldSolve, a = o.invInertiaWorldSolve, h = n + s;
                            return r.vmult(t.rotational, l), h += l.dot(t.rotational), a.vmult(e.rotational, l), 
                            h += l.dot(e.rotational);
                        };
                        var r = new o();
                        new o(), new o(), new o(), new o(), new o(), s.prototype.addToWlambda = function(t) {
                            var e = this.jacobianElementA, i = this.jacobianElementB, o = this.bi, n = this.bj, s = r;
                            o.vlambda.addScaledVector(o.invMassSolve * t, e.spatial, o.vlambda), n.vlambda.addScaledVector(n.invMassSolve * t, i.spatial, n.vlambda), 
                            o.invInertiaWorldSolve.vmult(e.rotational, s), o.wlambda.addScaledVector(t, s, o.wlambda), 
                            n.invInertiaWorldSolve.vmult(i.rotational, s), n.wlambda.addScaledVector(t, s, n.wlambda);
                        }, s.prototype.computeC = function() {
                            return this.computeGiMGt() + this.eps;
                        };
                    }, {
                        "../math/JacobianElement": 27,
                        "../math/Vec3": 31
                    } ],
                    22: [ function(t, e, i) {
                        e.exports = s;
                        var o = t("./Equation"), n = t("../math/Vec3");
                        function s(t, e, i) {
                            o.call(this, t, e, -i, i), this.ri = new n(), this.rj = new n(), this.t = new n();
                        }
                        t("../math/Mat3"), (s.prototype = new o()).constructor = s;
                        var l = new n(), p = new n();
                        s.prototype.computeB = function(t) {
                            this.a;
                            var e = this.b, i = (this.bi, this.bj, this.ri), o = this.rj, n = l, s = p, r = this.t;
                            i.cross(r, n), o.cross(r, s);
                            var a = this.jacobianElementA, h = this.jacobianElementB;
                            return r.negate(a.spatial), n.negate(a.rotational), h.spatial.copy(r), h.rotational.copy(s), 
                            -this.computeGW() * e - t * this.computeGiMf();
                        };
                    }, {
                        "../math/Mat3": 28,
                        "../math/Vec3": 31,
                        "./Equation": 21
                    } ],
                    23: [ function(t, e, i) {
                        e.exports = o;
                        var n = t("../math/Vec3"), s = (t("../math/Mat3"), t("./Equation"));
                        function o(t, e, i) {
                            var o = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6;
                            s.call(this, t, e, -o, o), this.axisA = i.axisA ? i.axisA.clone() : new n(1, 0, 0), 
                            this.axisB = i.axisB ? i.axisB.clone() : new n(0, 1, 0), this.maxAngle = Math.PI / 2;
                        }
                        (o.prototype = new s()).constructor = o;
                        var l = new n(), p = new n();
                        o.prototype.computeB = function(t) {
                            var e = this.a, i = this.b, o = this.axisA, n = this.axisB, s = l, r = p, a = this.jacobianElementA, h = this.jacobianElementB;
                            return o.cross(n, s), n.cross(o, r), a.rotational.copy(r), h.rotational.copy(s), 
                            -(Math.cos(this.maxAngle) - o.dot(n)) * e - this.computeGW() * i - t * this.computeGiMf();
                        };
                    }, {
                        "../math/Mat3": 28,
                        "../math/Vec3": 31,
                        "./Equation": 21
                    } ],
                    24: [ function(t, e, i) {
                        e.exports = s;
                        var o = t("../math/Vec3"), n = (t("../math/Mat3"), t("./Equation"));
                        function s(t, e, i) {
                            i = void 0 !== i ? i : 1e6, n.call(this, t, e, -i, i), this.axisA = new o(), this.axisB = new o(), 
                            this.targetVelocity = 0;
                        }
                        ((s.prototype = new n()).constructor = s).prototype.computeB = function(t) {
                            this.a;
                            var e = this.b, i = (this.bi, this.bj, this.axisA), o = this.axisB, n = this.jacobianElementA, s = this.jacobianElementB;
                            return n.rotational.copy(i), o.negate(s.rotational), -(this.computeGW() - this.targetVelocity) * e - t * this.computeGiMf();
                        };
                    }, {
                        "../math/Mat3": 28,
                        "../math/Vec3": 31,
                        "./Equation": 21
                    } ],
                    25: [ function(t, e, i) {
                        var o = t("../utils/Utils");
                        (e.exports = function n(t, e, i) {
                            i = o.defaults(i, {
                                friction: .3,
                                restitution: .3,
                                contactEquationStiffness: 1e7,
                                contactEquationRelaxation: 3,
                                frictionEquationStiffness: 1e7,
                                frictionEquationRelaxation: 3
                            }), this.id = n.idCounter++, this.materials = [ t, e ], this.friction = i.friction, 
                            this.restitution = i.restitution, this.contactEquationStiffness = i.contactEquationStiffness, 
                            this.contactEquationRelaxation = i.contactEquationRelaxation, this.frictionEquationStiffness = i.frictionEquationStiffness, 
                            this.frictionEquationRelaxation = i.frictionEquationRelaxation;
                        }).idCounter = 0;
                    }, {
                        "../utils/Utils": 54
                    } ],
                    26: [ function(t, e, i) {
                        (e.exports = function o(t) {
                            var e = "";
                            "string" == typeof (t = t || {}) ? (e = t, t = {}) : "object" == typeof t && (e = ""), 
                            this.name = e, this.id = o.idCounter++, this.friction = void 0 !== t.friction ? t.friction : -1, 
                            this.restitution = void 0 !== t.restitution ? t.restitution : -1;
                        }).idCounter = 0;
                    }, {} ],
                    27: [ function(t, e, i) {
                        e.exports = n;
                        var o = t("./Vec3");
                        function n() {
                            this.spatial = new o(), this.rotational = new o();
                        }
                        n.prototype.multiplyElement = function(t) {
                            return t.spatial.dot(this.spatial) + t.rotational.dot(this.rotational);
                        }, n.prototype.multiplyVectors = function(t, e) {
                            return t.dot(this.spatial) + e.dot(this.rotational);
                        };
                    }, {
                        "./Vec3": 31
                    } ],
                    28: [ function(t, e, i) {
                        e.exports = l;
                        var p = t("./Vec3");
                        function l(t) {
                            this.elements = t || [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
                        }
                        l.prototype.identity = function() {
                            var t = this.elements;
                            t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, 
                            t[8] = 1;
                        }, l.prototype.setZero = function() {
                            var t = this.elements;
                            t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, 
                            t[8] = 0;
                        }, l.prototype.setTrace = function(t) {
                            var e = this.elements;
                            e[0] = t.x, e[4] = t.y, e[8] = t.z;
                        }, l.prototype.getTrace = function(t) {
                            t = t || new p();
                            var e = this.elements;
                            t.x = e[0], t.y = e[4], t.z = e[8];
                        }, l.prototype.vmult = function(t, e) {
                            e = e || new p();
                            var i = this.elements, o = t.x, n = t.y, s = t.z;
                            return e.x = i[0] * o + i[1] * n + i[2] * s, e.y = i[3] * o + i[4] * n + i[5] * s, 
                            e.z = i[6] * o + i[7] * n + i[8] * s, e;
                        }, l.prototype.smult = function(t) {
                            for (var e = 0; e < this.elements.length; e++) this.elements[e] *= t;
                        }, l.prototype.mmult = function(t, e) {
                            for (var i = e || new l(), o = 0; o < 3; o++) for (var n = 0; n < 3; n++) {
                                for (var s = 0, r = 0; r < 3; r++) s += t.elements[o + 3 * r] * this.elements[r + 3 * n];
                                i.elements[o + 3 * n] = s;
                            }
                            return i;
                        }, l.prototype.scale = function(t, e) {
                            e = e || new l();
                            for (var i = this.elements, o = e.elements, n = 0; 3 !== n; n++) o[3 * n + 0] = t.x * i[3 * n + 0], 
                            o[3 * n + 1] = t.y * i[3 * n + 1], o[3 * n + 2] = t.z * i[3 * n + 2];
                            return e;
                        }, l.prototype.solve = function(t, e) {
                            e = e || new p();
                            for (var i, o = [], n = 0; n < 12; n++) o.push(0);
                            for (n = 0; n < 3; n++) for (i = 0; i < 3; i++) o[n + 4 * i] = this.elements[n + 3 * i];
                            o[3] = t.x, o[7] = t.y, o[11] = t.z;
                            var s, r, a = 3, h = a;
                            do {
                                if (0 === o[(n = h - a) + 4 * n]) for (i = n + 1; i < h; i++) if (0 !== o[n + 4 * i]) {
                                    for (s = 4; o[(r = 4 - s) + 4 * n] += o[r + 4 * i], --s; ) ;
                                    break;
                                }
                                if (0 !== o[n + 4 * n]) for (i = n + 1; i < h; i++) {
                                    var l = o[n + 4 * i] / o[n + 4 * n];
                                    for (s = 4; o[(r = 4 - s) + 4 * i] = r <= n ? 0 : o[r + 4 * i] - o[r + 4 * n] * l, 
                                    --s; ) ;
                                }
                            } while (--a);
                            if (e.z = o[11] / o[10], e.y = (o[7] - o[6] * e.z) / o[5], e.x = (o[3] - o[2] * e.z - o[1] * e.y) / o[0], 
                            isNaN(e.x) || isNaN(e.y) || isNaN(e.z) || e.x === 1 / 0 || e.y === 1 / 0 || e.z === 1 / 0) throw "Could not solve equation! Got x=[" + e.toString() + "], b=[" + t.toString() + "], A=[" + this.toString() + "]";
                            return e;
                        }, l.prototype.e = function(t, e, i) {
                            if (void 0 === i) return this.elements[e + 3 * t];
                            this.elements[e + 3 * t] = i;
                        }, l.prototype.copy = function(t) {
                            for (var e = 0; e < t.elements.length; e++) this.elements[e] = t.elements[e];
                            return this;
                        }, l.prototype.toString = function() {
                            for (var t = "", e = 0; e < 9; e++) t += this.elements[e] + ",";
                            return t;
                        }, l.prototype.reverse = function(t) {
                            t = t || new l();
                            for (var e, i = [], o = 0; o < 18; o++) i.push(0);
                            for (o = 0; o < 3; o++) for (e = 0; e < 3; e++) i[o + 6 * e] = this.elements[o + 3 * e];
                            i[3] = 1, i[9] = 0, i[15] = 0, i[4] = 0, i[10] = 1, i[16] = 0, i[5] = 0, i[11] = 0, 
                            i[17] = 1;
                            var n, s, r = 3, a = r;
                            do {
                                if (0 === i[(o = a - r) + 6 * o]) for (e = o + 1; e < a; e++) if (0 !== i[o + 6 * e]) {
                                    for (n = 6; i[(s = 6 - n) + 6 * o] += i[s + 6 * e], --n; ) ;
                                    break;
                                }
                                if (0 !== i[o + 6 * o]) for (e = o + 1; e < a; e++) {
                                    var h = i[o + 6 * e] / i[o + 6 * o];
                                    for (n = 6; i[(s = 6 - n) + 6 * e] = s <= o ? 0 : i[s + 6 * e] - i[s + 6 * o] * h, 
                                    --n; ) ;
                                }
                            } while (--r);
                            o = 2;
                            do {
                                e = o - 1;
                                do {
                                    for (h = i[o + 6 * e] / i[o + 6 * o], n = 6; i[(s = 6 - n) + 6 * e] = i[s + 6 * e] - i[s + 6 * o] * h, 
                                    --n; ) ;
                                } while (e--);
                            } while (--o);
                            o = 2;
                            do {
                                for (h = 1 / i[o + 6 * o], n = 6; i[(s = 6 - n) + 6 * o] = i[s + 6 * o] * h, --n; ) ;
                            } while (o--);
                            o = 2;
                            do {
                                e = 2;
                                do {
                                    if (s = i[3 + e + 6 * o], isNaN(s) || s === 1 / 0) throw "Could not reverse! A=[" + this.toString() + "]";
                                    t.e(o, e, s);
                                } while (e--);
                            } while (o--);
                            return t;
                        }, l.prototype.setRotationFromQuaternion = function(t) {
                            var e = t.x, i = t.y, o = t.z, n = t.w, s = e + e, r = i + i, a = o + o, h = e * s, l = e * r, p = e * a, c = i * r, u = i * a, d = o * a, v = n * s, y = n * r, f = n * a, m = this.elements;
                            return m[0] = 1 - (c + d), m[1] = l - f, m[2] = p + y, m[3] = l + f, m[4] = 1 - (h + d), 
                            m[5] = u - v, m[6] = p - y, m[7] = u + v, m[8] = 1 - (h + c), this;
                        }, l.prototype.transpose = function(t) {
                            for (var e = (t = t || new l()).elements, i = this.elements, o = 0; 3 !== o; o++) for (var n = 0; 3 !== n; n++) e[3 * o + n] = i[3 * n + o];
                            return t;
                        };
                    }, {
                        "./Vec3": 31
                    } ],
                    29: [ function(t, e, i) {
                        e.exports = f;
                        var d = t("./Vec3");
                        function f(t, e, i, o) {
                            this.x = void 0 !== t ? t : 0, this.y = void 0 !== e ? e : 0, this.z = void 0 !== i ? i : 0, 
                            this.w = void 0 !== o ? o : 1;
                        }
                        f.prototype.set = function(t, e, i, o) {
                            return this.x = t, this.y = e, this.z = i, this.w = o, this;
                        }, f.prototype.toString = function() {
                            return this.x + "," + this.y + "," + this.z + "," + this.w;
                        }, f.prototype.toArray = function() {
                            return [ this.x, this.y, this.z, this.w ];
                        }, f.prototype.setFromAxisAngle = function(t, e) {
                            var i = Math.sin(.5 * e);
                            return this.x = t.x * i, this.y = t.y * i, this.z = t.z * i, this.w = Math.cos(.5 * e), 
                            this;
                        }, f.prototype.toAxisAngle = function(t) {
                            t = t || new d(), this.normalize();
                            var e = 2 * Math.acos(this.w), i = Math.sqrt(1 - this.w * this.w);
                            return i < .001 ? (t.x = this.x, t.y = this.y, t.z = this.z) : (t.x = this.x / i, 
                            t.y = this.y / i, t.z = this.z / i), [ t, e ];
                        };
                        var s = new d(), r = new d();
                        f.prototype.setFromVectors = function(t, e) {
                            if (t.isAntiparallelTo(e)) {
                                var i = s, o = r;
                                t.tangents(i, o), this.setFromAxisAngle(i, Math.PI);
                            } else {
                                var n = t.cross(e);
                                this.x = n.x, this.y = n.y, this.z = n.z, this.w = Math.sqrt(Math.pow(t.norm(), 2) * Math.pow(e.norm(), 2)) + t.dot(e), 
                                this.normalize();
                            }
                            return this;
                        }, new d(), new d(), new d(), f.prototype.mult = function(t, e) {
                            e = e || new f();
                            var i = this.x, o = this.y, n = this.z, s = this.w, r = t.x, a = t.y, h = t.z, l = t.w;
                            return e.x = i * l + s * r + o * h - n * a, e.y = o * l + s * a + n * r - i * h, 
                            e.z = n * l + s * h + i * a - o * r, e.w = s * l - i * r - o * a - n * h, e;
                        }, f.prototype.inverse = function(t) {
                            var e = this.x, i = this.y, o = this.z, n = this.w;
                            t = t || new f(), this.conjugate(t);
                            var s = 1 / (e * e + i * i + o * o + n * n);
                            return t.x *= s, t.y *= s, t.z *= s, t.w *= s, t;
                        }, f.prototype.conjugate = function(t) {
                            return (t = t || new f()).x = -this.x, t.y = -this.y, t.z = -this.z, t.w = this.w, 
                            t;
                        }, f.prototype.normalize = function() {
                            var t = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                            return 0 === t ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (t = 1 / t, 
                            this.x *= t, this.y *= t, this.z *= t, this.w *= t), this;
                        }, f.prototype.normalizeFast = function() {
                            var t = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
                            return 0 == t ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= t, 
                            this.y *= t, this.z *= t, this.w *= t), this;
                        }, f.prototype.vmult = function(t, e) {
                            e = e || new d();
                            var i = t.x, o = t.y, n = t.z, s = this.x, r = this.y, a = this.z, h = this.w, l = h * i + r * n - a * o, p = h * o + a * i - s * n, c = h * n + s * o - r * i, u = -s * i - r * o - a * n;
                            return e.x = l * h + u * -s + p * -a - c * -r, e.y = p * h + u * -r + c * -s - l * -a, 
                            e.z = c * h + u * -a + l * -r - p * -s, e;
                        }, f.prototype.copy = function(t) {
                            return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this;
                        }, f.prototype.toEuler = function(t, e) {
                            var i, o, n;
                            e = e || "YZX";
                            var s = this.x, r = this.y, a = this.z, h = this.w;
                            switch (e) {
                              case "YZX":
                                var l = s * r + a * h;
                                if (.499 < l && (i = 2 * Math.atan2(s, h), o = Math.PI / 2, n = 0), l < -.499 && (i = -2 * Math.atan2(s, h), 
                                o = -Math.PI / 2, n = 0), isNaN(i)) {
                                    var p = s * s, c = r * r, u = a * a;
                                    i = Math.atan2(2 * r * h - 2 * s * a, 1 - 2 * c - 2 * u), o = Math.asin(2 * l), 
                                    n = Math.atan2(2 * s * h - 2 * r * a, 1 - 2 * p - 2 * u);
                                }
                                break;

                              default:
                                throw new Error("Euler order " + e + " not supported yet.");
                            }
                            t.y = i, t.z = o, t.x = n;
                        }, f.prototype.setFromEuler = function(t, e, i, o) {
                            o = o || "XYZ";
                            var n = Math.cos(t / 2), s = Math.cos(e / 2), r = Math.cos(i / 2), a = Math.sin(t / 2), h = Math.sin(e / 2), l = Math.sin(i / 2);
                            return "XYZ" === o ? (this.x = a * s * r + n * h * l, this.y = n * h * r - a * s * l, 
                            this.z = n * s * l + a * h * r, this.w = n * s * r - a * h * l) : "YXZ" === o ? (this.x = a * s * r + n * h * l, 
                            this.y = n * h * r - a * s * l, this.z = n * s * l - a * h * r, this.w = n * s * r + a * h * l) : "ZXY" === o ? (this.x = a * s * r - n * h * l, 
                            this.y = n * h * r + a * s * l, this.z = n * s * l + a * h * r, this.w = n * s * r - a * h * l) : "ZYX" === o ? (this.x = a * s * r - n * h * l, 
                            this.y = n * h * r + a * s * l, this.z = n * s * l - a * h * r, this.w = n * s * r + a * h * l) : "YZX" === o ? (this.x = a * s * r + n * h * l, 
                            this.y = n * h * r + a * s * l, this.z = n * s * l - a * h * r, this.w = n * s * r - a * h * l) : "XZY" === o && (this.x = a * s * r - n * h * l, 
                            this.y = n * h * r - a * s * l, this.z = n * s * l + a * h * r, this.w = n * s * r + a * h * l), 
                            this;
                        }, f.prototype.clone = function() {
                            return new f(this.x, this.y, this.z, this.w);
                        }, f.prototype.slerp = function(t, e, i) {
                            i = i || new f();
                            var o, n, s, r, a, h = this.x, l = this.y, p = this.z, c = this.w, u = t.x, d = t.y, v = t.z, y = t.w;
                            return (n = h * u + l * d + p * v + c * y) < 0 && (n = -n, u = -u, d = -d, v = -v, 
                            y = -y), a = 1e-6 < 1 - n ? (o = Math.acos(n), s = Math.sin(o), r = Math.sin((1 - e) * o) / s, 
                            Math.sin(e * o) / s) : (r = 1 - e, e), i.x = r * h + a * u, i.y = r * l + a * d, 
                            i.z = r * p + a * v, i.w = r * c + a * y, i;
                        }, f.prototype.integrate = function(t, e, i, o) {
                            o = o || new f();
                            var n = t.x * i.x, s = t.y * i.y, r = t.z * i.z, a = this.x, h = this.y, l = this.z, p = this.w, c = .5 * e;
                            return o.x += c * (n * p + s * l - r * h), o.y += c * (s * p + r * a - n * l), o.z += c * (r * p + n * h - s * a), 
                            o.w += c * (-n * a - s * h - r * l), o;
                        };
                    }, {
                        "./Vec3": 31
                    } ],
                    30: [ function(t, e, i) {
                        var n = t("./Vec3"), o = t("./Quaternion");
                        function s(t) {
                            t = t || {}, this.position = new n(), t.position && this.position.copy(t.position), 
                            this.quaternion = new o(), t.quaternion && this.quaternion.copy(t.quaternion);
                        }
                        e.exports = s;
                        var r = new o();
                        s.pointToLocalFrame = function(t, e, i, o) {
                            return o = o || new n(), i.vsub(t, o), e.conjugate(r), r.vmult(o, o), o;
                        }, s.prototype.pointToLocal = function(t, e) {
                            return s.pointToLocalFrame(this.position, this.quaternion, t, e);
                        }, s.pointToWorldFrame = function(t, e, i, o) {
                            return o = o || new n(), e.vmult(i, o), o.vadd(t, o), o;
                        }, s.prototype.pointToWorld = function(t, e) {
                            return s.pointToWorldFrame(this.position, this.quaternion, t, e);
                        }, s.prototype.vectorToWorldFrame = function(t, e) {
                            return e = e || new n(), this.quaternion.vmult(t, e), e;
                        }, s.vectorToWorldFrame = function(t, e, i) {
                            return t.vmult(e, i), i;
                        }, s.vectorToLocalFrame = function(t, e, i, o) {
                            return o = o || new n(), e.w *= -1, e.vmult(i, o), e.w *= -1, o;
                        };
                    }, {
                        "./Quaternion": 29,
                        "./Vec3": 31
                    } ],
                    31: [ function(t, e, i) {
                        e.exports = h;
                        var o = t("./Mat3");
                        function h(t, e, i) {
                            this.x = t || 0, this.y = e || 0, this.z = i || 0;
                        }
                        h.ZERO = new h(0, 0, 0), h.UNIT_X = new h(1, 0, 0), h.UNIT_Y = new h(0, 1, 0), h.UNIT_Z = new h(0, 0, 1), 
                        h.prototype.cross = function(t, e) {
                            var i = t.x, o = t.y, n = t.z, s = this.x, r = this.y, a = this.z;
                            return (e = e || new h()).x = r * n - a * o, e.y = a * i - s * n, e.z = s * o - r * i, 
                            e;
                        }, h.prototype.set = function(t, e, i) {
                            return this.x = t, this.y = e, this.z = i, this;
                        }, h.prototype.setZero = function() {
                            this.x = this.y = this.z = 0;
                        }, h.prototype.vadd = function(t, e) {
                            if (!e) return new h(this.x + t.x, this.y + t.y, this.z + t.z);
                            e.x = t.x + this.x, e.y = t.y + this.y, e.z = t.z + this.z;
                        }, h.prototype.vsub = function(t, e) {
                            if (!e) return new h(this.x - t.x, this.y - t.y, this.z - t.z);
                            e.x = this.x - t.x, e.y = this.y - t.y, e.z = this.z - t.z;
                        }, h.prototype.crossmat = function() {
                            return new o([ 0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0 ]);
                        }, h.prototype.normalize = function() {
                            var t = this.x, e = this.y, i = this.z, o = Math.sqrt(t * t + e * e + i * i);
                            if (0 < o) {
                                var n = 1 / o;
                                this.x *= n, this.y *= n, this.z *= n;
                            } else this.x = 0, this.y = 0, this.z = 0;
                            return o;
                        }, h.prototype.unit = function(t) {
                            t = t || new h();
                            var e = this.x, i = this.y, o = this.z, n = Math.sqrt(e * e + i * i + o * o);
                            return 0 < n ? (n = 1 / n, t.x = e * n, t.y = i * n, t.z = o * n) : (t.x = 1, t.y = 0, 
                            t.z = 0), t;
                        }, h.prototype.length = h.prototype.norm = function() {
                            var t = this.x, e = this.y, i = this.z;
                            return Math.sqrt(t * t + e * e + i * i);
                        }, h.prototype.lengthSquared = h.prototype.norm2 = function() {
                            return this.dot(this);
                        }, h.prototype.distanceTo = function(t) {
                            var e = this.x, i = this.y, o = this.z, n = t.x, s = t.y, r = t.z;
                            return Math.sqrt((n - e) * (n - e) + (s - i) * (s - i) + (r - o) * (r - o));
                        }, h.prototype.distanceSquared = function(t) {
                            var e = this.x, i = this.y, o = this.z, n = t.x, s = t.y, r = t.z;
                            return (n - e) * (n - e) + (s - i) * (s - i) + (r - o) * (r - o);
                        }, h.prototype.mult = function(t, e) {
                            e = e || new h();
                            var i = this.x, o = this.y, n = this.z;
                            return e.x = t * i, e.y = t * o, e.z = t * n, e;
                        }, h.prototype.vmul = function(t, e) {
                            return (e = e || new h()).x = t.x * this.x, e.y = t.y * this.y, e.z = t.z * this.z, 
                            e;
                        }, h.prototype.scale = h.prototype.mult, h.prototype.addScaledVector = function(t, e, i) {
                            return (i = i || new h()).x = this.x + t * e.x, i.y = this.y + t * e.y, i.z = this.z + t * e.z, 
                            i;
                        }, h.prototype.dot = function(t) {
                            return this.x * t.x + this.y * t.y + this.z * t.z;
                        }, h.prototype.isZero = function() {
                            return 0 === this.x && 0 === this.y && 0 === this.z;
                        }, h.prototype.negate = function(t) {
                            return (t = t || new h()).x = -this.x, t.y = -this.y, t.z = -this.z, t;
                        };
                        var r = new h(), a = new h();
                        h.prototype.tangents = function(t, e) {
                            var i = this.norm();
                            if (0 < i) {
                                var o = r, n = 1 / i;
                                o.set(this.x * n, this.y * n, this.z * n);
                                var s = a;
                                Math.abs(o.x) < .9 ? s.set(1, 0, 0) : s.set(0, 1, 0), o.cross(s, t), o.cross(t, e);
                            } else t.set(1, 0, 0), e.set(0, 1, 0);
                        }, h.prototype.toString = function() {
                            return this.x + "," + this.y + "," + this.z;
                        }, h.prototype.toArray = function() {
                            return [ this.x, this.y, this.z ];
                        }, h.prototype.copy = function(t) {
                            return this.x = t.x, this.y = t.y, this.z = t.z, this;
                        }, h.prototype.lerp = function(t, e, i) {
                            var o = this.x, n = this.y, s = this.z;
                            i.x = o + (t.x - o) * e, i.y = n + (t.y - n) * e, i.z = s + (t.z - s) * e;
                        }, h.prototype.almostEquals = function(t, e) {
                            return void 0 === e && (e = 1e-6), !(Math.abs(this.x - t.x) > e || Math.abs(this.y - t.y) > e || Math.abs(this.z - t.z) > e);
                        }, h.prototype.almostZero = function(t) {
                            return void 0 === t && (t = 1e-6), !(Math.abs(this.x) > t || Math.abs(this.y) > t || Math.abs(this.z) > t);
                        };
                        var n = new h();
                        h.prototype.isAntiparallelTo = function(t, e) {
                            return this.negate(n), n.almostEquals(t, e);
                        }, h.prototype.clone = function() {
                            return new h(this.x, this.y, this.z);
                        };
                    }, {
                        "./Mat3": 28
                    } ],
                    32: [ function(t, e, i) {
                        e.exports = w;
                        var o = t("../utils/EventTarget"), s = (t("../shapes/Shape"), t("../math/Vec3")), n = t("../math/Mat3"), r = t("../math/Quaternion"), a = (t("../material/Material"), 
                        t("../collision/AABB")), h = t("../shapes/Box"), l = t("../world/World");
                        function w(t) {
                            t = t || {}, o.apply(this), this.id = w.idCounter++, this.world = null, this.preStep = null, 
                            this.postStep = null, this.vlambda = new s(), this.collisionFilterGroup = "number" == typeof t.collisionFilterGroup ? t.collisionFilterGroup : 1, 
                            this.collisionFilterMask = "number" == typeof t.collisionFilterMask ? t.collisionFilterMask : -1, 
                            this.collisionResponse = !0, this.position = new s(), this.previousPosition = new s(), 
                            this.interpolatedPosition = new s(), this.initPosition = new s(), t.position && (this.position.copy(t.position), 
                            this.previousPosition.copy(t.position), this.interpolatedPosition.copy(t.position), 
                            this.initPosition.copy(t.position)), this.velocity = new s(), t.velocity && this.velocity.copy(t.velocity), 
                            this.initVelocity = new s(), this.force = new s();
                            var e = "number" == typeof t.mass ? t.mass : 0;
                            this.mass = e, this.invMass = 0 < e ? 1 / e : 0, this.material = t.material || null, 
                            this.linearDamping = "number" == typeof t.linearDamping ? t.linearDamping : .01, 
                            this.type = e <= 0 ? w.STATIC : w.DYNAMIC, typeof t.type == typeof w.STATIC && (this.type = t.type), 
                            this.allowSleep = void 0 === t.allowSleep || t.allowSleep, this.sleepState = 0, 
                            this.sleepSpeedLimit = void 0 !== t.sleepSpeedLimit ? t.sleepSpeedLimit : .1, this.sleepTimeLimit = void 0 !== t.sleepTimeLimit ? t.sleepTimeLimit : 1, 
                            this.timeLastSleepy = 0, this._wakeUpAfterNarrowphase = !1, this.torque = new s(), 
                            this.quaternion = new r(), this.initQuaternion = new r(), this.previousQuaternion = new r(), 
                            this.interpolatedQuaternion = new r(), t.quaternion && (this.quaternion.copy(t.quaternion), 
                            this.initQuaternion.copy(t.quaternion), this.previousQuaternion.copy(t.quaternion), 
                            this.interpolatedQuaternion.copy(t.quaternion)), this.angularVelocity = new s(), 
                            t.angularVelocity && this.angularVelocity.copy(t.angularVelocity), this.initAngularVelocity = new s(), 
                            this.shapes = [], this.shapeOffsets = [], this.shapeOrientations = [], this.inertia = new s(), 
                            this.invInertia = new s(), this.invInertiaWorld = new n(), this.invMassSolve = 0, 
                            this.invInertiaSolve = new s(), this.invInertiaWorldSolve = new n(), this.fixedRotation = void 0 !== t.fixedRotation && t.fixedRotation, 
                            this.useGravity = !0, this.angularDamping = void 0 !== t.angularDamping ? t.angularDamping : .01, 
                            this.linearFactor = new s(1, 1, 1), t.linearFactor && this.linearFactor.copy(t.linearFactor), 
                            this.angularFactor = new s(1, 1, 1), t.angularFactor && this.angularFactor.copy(t.angularFactor), 
                            this.aabb = new a(), this.aabbNeedsUpdate = !0, this.boundingRadius = 0, this.wlambda = new s(), 
                            t.shape && this.addShape(t.shape), this.updateMassProperties();
                        }
                        ((w.prototype = new o()).constructor = w).COLLIDE_EVENT_NAME = "collide", w.DYNAMIC = 1, 
                        w.STATIC = 2, w.KINEMATIC = 4, w.AWAKE = 0, w.SLEEPY = 1, w.SLEEPING = 2, w.idCounter = 0, 
                        w.wakeupEvent = {
                            type: "wakeup"
                        }, w.prototype.wakeUp = function() {
                            var t = this.sleepState;
                            this.sleepState = 0, this._wakeUpAfterNarrowphase = !1, t === w.SLEEPING && this.dispatchEvent(w.wakeupEvent);
                        }, w.prototype.sleep = function() {
                            this.sleepState = w.SLEEPING, this.velocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0), 
                            this._wakeUpAfterNarrowphase = !1;
                        }, w.sleepyEvent = {
                            type: "sleepy"
                        }, w.sleepEvent = {
                            type: "sleep"
                        }, w.prototype.sleepTick = function(t) {
                            if (this.allowSleep) {
                                var e = this.sleepState, i = this.velocity.norm2() + this.angularVelocity.norm2(), o = Math.pow(this.sleepSpeedLimit, 2);
                                e === w.AWAKE && i < o ? (this.sleepState = w.SLEEPY, this.timeLastSleepy = t, this.dispatchEvent(w.sleepyEvent)) : e === w.SLEEPY && o < i ? this.wakeUp() : e === w.SLEEPY && t - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(), 
                                this.dispatchEvent(w.sleepEvent));
                            }
                        }, w.prototype.updateSolveMassProperties = function() {
                            this.sleepState === w.SLEEPING || this.type === w.KINEMATIC ? (this.invMassSolve = 0, 
                            this.invInertiaSolve.setZero(), this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass, 
                            this.invInertiaSolve.copy(this.invInertia), this.invInertiaWorldSolve.copy(this.invInertiaWorld));
                        }, w.prototype.pointToLocalFrame = function(t, e) {
                            return e = e || new s(), t.vsub(this.position, e), this.quaternion.conjugate().vmult(e, e), 
                            e;
                        }, w.prototype.vectorToLocalFrame = function(t, e) {
                            return e = e || new s(), this.quaternion.conjugate().vmult(t, e), e;
                        }, w.prototype.pointToWorldFrame = function(t, e) {
                            return e = e || new s(), this.quaternion.vmult(t, e), e.vadd(this.position, e), 
                            e;
                        }, w.prototype.vectorToWorldFrame = function(t, e) {
                            return e = e || new s(), this.quaternion.vmult(t, e), e;
                        };
                        var c = new s(), u = new r();
                        w.prototype.addShape = function(t, e, i) {
                            if (-1 === this.shapes.indexOf(t)) {
                                var o = new s(), n = new r();
                                return e && o.copy(e), i && n.copy(i), l.idToShapeMap[t.id] = t, this.shapes.push(t), 
                                this.shapeOffsets.push(o), this.shapeOrientations.push(n), this.updateMassProperties(), 
                                this.updateBoundingRadius(), this.aabbNeedsUpdate = !0, t.body = this;
                            }
                        }, w.prototype.removeShape = function(t) {
                            var e = this.shapes.indexOf(t);
                            -1 !== e && (this.shapes.splice(e, 1), this.shapeOffsets.splice(e, 1), this.shapeOrientations.splice(e, 1), 
                            this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0);
                        }, w.prototype.updateBoundingRadius = function() {
                            for (var t = this.shapes, e = this.shapeOffsets, i = t.length, o = 0, n = 0; n !== i; n++) {
                                var s = t[n];
                                s.updateBoundingSphereRadius();
                                var r = e[n].norm(), a = s.boundingSphereRadius;
                                o < r + a && (o = r + a);
                            }
                            this.boundingRadius = o;
                        };
                        var d = new a();
                        w.prototype.computeAABB = function() {
                            for (var t = this.shapes, e = this.shapeOffsets, i = this.shapeOrientations, o = t.length, n = c, s = u, r = this.quaternion, a = this.aabb, h = d, l = 0; l !== o; l++) {
                                var p = t[l];
                                r.vmult(e[l], n), n.vadd(this.position, n), i[l].mult(r, s), p.calculateWorldAABB(n, s, h.lowerBound, h.upperBound), 
                                0 === l ? a.copy(h) : a.extend(h);
                            }
                            this.aabbNeedsUpdate = !1;
                        };
                        var p = new n(), v = new n();
                        new n(), w.prototype.updateInertiaWorld = function(t) {
                            var e = this.invInertia;
                            if (e.x !== e.y || e.y !== e.z || t) {
                                var i = p, o = v;
                                i.setRotationFromQuaternion(this.quaternion), i.transpose(o), i.scale(e, i), i.mmult(o, this.invInertiaWorld);
                            }
                        };
                        var y = new s();
                        w.prototype.applyForce = function(t, e) {
                            if (this.type === w.DYNAMIC) {
                                var i = y;
                                e.cross(t, i), this.force.vadd(t, this.force), this.torque.vadd(i, this.torque);
                            }
                        };
                        var f = new s(), m = new s();
                        w.prototype.applyLocalForce = function(t, e) {
                            if (this.type === w.DYNAMIC) {
                                var i = f, o = m;
                                this.vectorToWorldFrame(t, i), this.vectorToWorldFrame(e, o), this.applyForce(i, o);
                            }
                        };
                        var g = new s(), x = new s();
                        w.prototype.applyImpulse = function(t, e) {
                            if (this.type === w.DYNAMIC) {
                                var i = e, o = g;
                                o.copy(t), o.mult(this.invMass, o), this.velocity.vadd(o, this.velocity);
                                var n = x;
                                i.cross(t, n), this.invInertiaWorld.vmult(n, n), this.angularVelocity.vadd(n, this.angularVelocity);
                            }
                        };
                        var b = new s(), B = new s();
                        w.prototype.applyLocalImpulse = function(t, e) {
                            if (this.type === w.DYNAMIC) {
                                var i = b, o = B;
                                this.vectorToWorldFrame(t, i), this.vectorToWorldFrame(e, o), this.applyImpulse(i, o);
                            }
                        };
                        var E = new s();
                        w.prototype.updateMassProperties = function() {
                            var t = E;
                            this.invMass = 0 < this.mass ? 1 / this.mass : 0;
                            var e = this.inertia, i = this.fixedRotation;
                            this.computeAABB(), t.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2), 
                            h.calculateInertia(t, this.mass, e), this.invInertia.set(0 < e.x && !i ? 1 / e.x : 0, 0 < e.y && !i ? 1 / e.y : 0, 0 < e.z && !i ? 1 / e.z : 0), 
                            this.updateInertiaWorld(!0);
                        }, w.prototype.getVelocityAtWorldPoint = function(t, e) {
                            var i = new s();
                            return t.vsub(this.position, i), this.angularVelocity.cross(i, e), this.velocity.vadd(e, e), 
                            e;
                        }, w.prototype.integrate = function(t, e, i) {
                            if (this.previousPosition.copy(this.position), this.previousQuaternion.copy(this.quaternion), 
                            (this.type === w.DYNAMIC || this.type === w.KINEMATIC) && this.sleepState !== w.SLEEPING) {
                                var o = this.velocity, n = this.angularVelocity, s = this.position, r = this.force, a = this.torque, h = this.quaternion, l = this.invMass, p = this.invInertiaWorld, c = this.linearFactor, u = l * t;
                                o.x += r.x * u * c.x, o.y += r.y * u * c.y, o.z += r.z * u * c.z;
                                var d = p.elements, v = this.angularFactor, y = a.x * v.x, f = a.y * v.y, m = a.z * v.z;
                                n.x += t * (d[0] * y + d[1] * f + d[2] * m), n.y += t * (d[3] * y + d[4] * f + d[5] * m), 
                                n.z += t * (d[6] * y + d[7] * f + d[8] * m), s.x += o.x * t, s.y += o.y * t, s.z += o.z * t, 
                                h.integrate(this.angularVelocity, t, this.angularFactor, h), e && (i ? h.normalizeFast() : h.normalize()), 
                                this.aabbNeedsUpdate = !0, this.updateInertiaWorld();
                            }
                        }, w.prototype.isSleeping = function() {
                            return this.sleepState === w.SLEEPING;
                        }, w.prototype.isSleepy = function() {
                            return this.sleepState === w.SLEEPY;
                        }, w.prototype.isAwake = function() {
                            return this.sleepState === w.AWAKE;
                        };
                    }, {
                        "../collision/AABB": 3,
                        "../material/Material": 26,
                        "../math/Mat3": 28,
                        "../math/Quaternion": 29,
                        "../math/Vec3": 31,
                        "../shapes/Box": 38,
                        "../shapes/Shape": 44,
                        "../utils/EventTarget": 50,
                        "../world/World": 57
                    } ],
                    33: [ function(t, e, i) {
                        t("./Body");
                        var S = t("../math/Vec3"), p = t("../math/Quaternion"), o = (t("../collision/RaycastResult"), 
                        t("../collision/Ray")), n = t("../objects/WheelInfo");
                        function s(t) {
                            this.chassisBody = t.chassisBody, this.wheelInfos = [], this.sliding = !1, this.world = null, 
                            this.indexRightAxis = void 0 !== t.indexRightAxis ? t.indexRightAxis : 1, this.indexForwardAxis = void 0 !== t.indexForwardAxis ? t.indexForwardAxis : 0, 
                            this.indexUpAxis = void 0 !== t.indexUpAxis ? t.indexUpAxis : 2;
                        }
                        e.exports = s, new S(), new S(), new S();
                        var c = new S(), u = new S(), d = new S();
                        new o(), s.prototype.addWheel = function(t) {
                            var e = new n(t = t || {}), i = this.wheelInfos.length;
                            return this.wheelInfos.push(e), i;
                        }, s.prototype.setSteeringValue = function(t, e) {
                            this.wheelInfos[e].steering = t;
                        }, new S(), s.prototype.applyEngineForce = function(t, e) {
                            this.wheelInfos[e].engineForce = t;
                        }, s.prototype.setBrake = function(t, e) {
                            this.wheelInfos[e].brake = t;
                        }, s.prototype.addToWorld = function(t) {
                            this.constraints, t.addBody(this.chassisBody);
                            var e = this;
                            this.preStepCallback = function() {
                                e.updateVehicle(t.dt);
                            }, t.addEventListener("preStep", this.preStepCallback), this.world = t;
                        }, s.prototype.getVehicleAxisWorld = function(t, e) {
                            e.set(0 === t ? 1 : 0, 1 === t ? 1 : 0, 2 === t ? 1 : 0), this.chassisBody.vectorToWorldFrame(e, e);
                        }, s.prototype.updateVehicle = function(t) {
                            for (var e = this.wheelInfos, i = e.length, o = this.chassisBody, n = 0; n < i; n++) this.updateWheelTransform(n);
                            this.currentVehicleSpeedKmHour = 3.6 * o.velocity.norm();
                            var s = new S();
                            for (this.getVehicleAxisWorld(this.indexForwardAxis, s), s.dot(o.velocity) < 0 && (this.currentVehicleSpeedKmHour *= -1), 
                            n = 0; n < i; n++) this.castRay(e[n]);
                            this.updateSuspension(t);
                            var r = new S(), a = new S();
                            for (n = 0; n < i; n++) {
                                var h = (u = e[n]).suspensionForce;
                                h > u.maxSuspensionForce && (h = u.maxSuspensionForce), u.raycastResult.hitNormalWorld.scale(h * t, r), 
                                u.raycastResult.hitPointWorld.vsub(o.position, a), o.applyImpulse(r, a);
                            }
                            this.updateFriction(t);
                            var l = new S(), p = new S(), c = new S();
                            for (n = 0; n < i; n++) {
                                var u = e[n];
                                o.getVelocityAtWorldPoint(u.chassisConnectionPointWorld, c);
                                var d = 1;
                                switch (this.indexUpAxis) {
                                  case 1:
                                    d = -1;
                                }
                                if (u.isInContact) {
                                    this.getVehicleAxisWorld(this.indexForwardAxis, p);
                                    var v = p.dot(u.raycastResult.hitNormalWorld);
                                    u.raycastResult.hitNormalWorld.scale(v, l), p.vsub(l, p);
                                    var y = p.dot(c);
                                    u.deltaRotation = d * y * t / u.radius;
                                }
                                !u.sliding && u.isInContact || 0 === u.engineForce || !u.useCustomSlidingRotationalSpeed || (u.deltaRotation = (0 < u.engineForce ? 1 : -1) * u.customSlidingRotationalSpeed * t), 
                                Math.abs(u.brake) > Math.abs(u.engineForce) && (u.deltaRotation = 0), u.rotation += u.deltaRotation, 
                                u.deltaRotation *= .99;
                            }
                        }, s.prototype.updateSuspension = function(t) {
                            for (var e = this.chassisBody.mass, i = this.wheelInfos, o = i.length, n = 0; n < o; n++) {
                                var s = i[n];
                                if (s.isInContact) {
                                    var r, a = s.suspensionRestLength - s.suspensionLength;
                                    r = s.suspensionStiffness * a * s.clippedInvContactDotSuspension;
                                    var h = s.suspensionRelativeVelocity;
                                    r -= (h < 0 ? s.dampingCompression : s.dampingRelaxation) * h, s.suspensionForce = r * e, 
                                    s.suspensionForce < 0 && (s.suspensionForce = 0);
                                } else s.suspensionForce = 0;
                            }
                        }, s.prototype.removeFromWorld = function(t) {
                            this.constraints, t.remove(this.chassisBody), t.removeEventListener("preStep", this.preStepCallback), 
                            this.world = null;
                        };
                        var m = new S(), w = new S();
                        s.prototype.castRay = function(t) {
                            var e = m, i = w;
                            this.updateWheelTransformWorld(t);
                            var o = this.chassisBody, n = -1, s = t.suspensionRestLength + t.radius;
                            t.directionWorld.scale(s, e);
                            var r = t.chassisConnectionPointWorld;
                            r.vadd(e, i);
                            var a = t.raycastResult;
                            a.reset();
                            var h = o.collisionResponse;
                            o.collisionResponse = !1, this.world.rayTest(r, i, a), o.collisionResponse = h;
                            var l = a.body;
                            if (t.raycastResult.groundObject = 0, l) {
                                n = a.distance, t.raycastResult.hitNormalWorld = a.hitNormalWorld, t.isInContact = !0;
                                var p = a.distance;
                                t.suspensionLength = p - t.radius;
                                var c = t.suspensionRestLength - t.maxSuspensionTravel, u = t.suspensionRestLength + t.maxSuspensionTravel;
                                t.suspensionLength < c && (t.suspensionLength = c), t.suspensionLength > u && (t.suspensionLength = u, 
                                t.raycastResult.reset());
                                var d = t.raycastResult.hitNormalWorld.dot(t.directionWorld), v = new S();
                                o.getVelocityAtWorldPoint(t.raycastResult.hitPointWorld, v);
                                var y = t.raycastResult.hitNormalWorld.dot(v);
                                if (-.1 <= d) t.suspensionRelativeVelocity = 0, t.clippedInvContactDotSuspension = 10; else {
                                    var f = -1 / d;
                                    t.suspensionRelativeVelocity = y * f, t.clippedInvContactDotSuspension = f;
                                }
                            } else t.suspensionLength = t.suspensionRestLength + 0 * t.maxSuspensionTravel, 
                            t.suspensionRelativeVelocity = 0, t.directionWorld.scale(-1, t.raycastResult.hitNormalWorld), 
                            t.clippedInvContactDotSuspension = 1;
                            return n;
                        }, s.prototype.updateWheelTransformWorld = function(t) {
                            t.isInContact = !1;
                            var e = this.chassisBody;
                            e.pointToWorldFrame(t.chassisConnectionPointLocal, t.chassisConnectionPointWorld), 
                            e.vectorToWorldFrame(t.directionLocal, t.directionWorld), e.vectorToWorldFrame(t.axleLocal, t.axleWorld);
                        }, s.prototype.updateWheelTransform = function(t) {
                            var e = c, i = u, o = d, n = this.wheelInfos[t];
                            this.updateWheelTransformWorld(n), n.directionLocal.scale(-1, e), i.copy(n.axleLocal), 
                            e.cross(i, o), o.normalize(), i.normalize();
                            var s = n.steering, r = new p();
                            r.setFromAxisAngle(e, s);
                            var a = new p();
                            a.setFromAxisAngle(i, n.rotation);
                            var h = n.worldTransform.quaternion;
                            this.chassisBody.quaternion.mult(r, h), h.mult(a, h), h.normalize();
                            var l = n.worldTransform.position;
                            l.copy(n.directionWorld), l.scale(n.suspensionLength, l), l.vadd(n.chassisConnectionPointWorld, l);
                        };
                        var z = [ new S(1, 0, 0), new S(0, 1, 0), new S(0, 0, 1) ];
                        s.prototype.getWheelTransformWorld = function(t) {
                            return this.wheelInfos[t].worldTransform;
                        };
                        var M = new S(), C = [], q = [];
                        s.prototype.updateFriction = function(t) {
                            for (var e = M, i = this.wheelInfos, o = i.length, n = this.chassisBody, s = q, r = C, a = 0; a < o; a++) c = (x = i[a]).raycastResult.body, 
                            x.sideImpulse = 0, x.forwardImpulse = 0, s[a] || (s[a] = new S()), r[a] || (r[a] = new S());
                            for (a = 0; a < o; a++) if (c = (x = i[a]).raycastResult.body) {
                                var h = r[a];
                                this.getWheelTransformWorld(a).vectorToWorldFrame(z[this.indexRightAxis], h);
                                var l = x.raycastResult.hitNormalWorld, p = h.dot(l);
                                l.scale(p, e), h.vsub(e, h), h.normalize(), l.cross(h, s[a]), s[a].normalize(), 
                                x.sideImpulse = R(n, x.raycastResult.hitPointWorld, c, x.raycastResult.hitPointWorld, h), 
                                x.sideImpulse *= 1;
                            }
                            for (this.sliding = !1, a = 0; a < o; a++) {
                                var c = (x = i[a]).raycastResult.body, u = 0;
                                if (x.slipInfo = 1, c) {
                                    var d = x.brake ? x.brake : 0;
                                    u = F(n, c, x.raycastResult.hitPointWorld, s[a], d);
                                    var v = d / (u += x.engineForce * t);
                                    x.slipInfo *= v;
                                }
                                if (x.forwardImpulse = 0, x.skidInfo = 1, c) {
                                    x.skidInfo = 1;
                                    var y = x.suspensionForce * t * x.frictionSlip, f = y * y;
                                    x.forwardImpulse = u;
                                    var m = .5 * x.forwardImpulse, w = 1 * x.sideImpulse, g = m * m + w * w;
                                    x.sliding = !1, f < g && (this.sliding = !0, x.sliding = !0, v = y / Math.sqrt(g), 
                                    x.skidInfo *= v);
                                }
                            }
                            if (this.sliding) for (a = 0; a < o; a++) 0 !== (x = i[a]).sideImpulse && x.skidInfo < 1 && (x.forwardImpulse *= x.skidInfo, 
                            x.sideImpulse *= x.skidInfo);
                            for (a = 0; a < o; a++) {
                                var x = i[a], b = new S();
                                if (x.raycastResult.hitPointWorld.vsub(n.position, b), 0 !== x.forwardImpulse) {
                                    var B = new S();
                                    s[a].scale(x.forwardImpulse, B), n.applyImpulse(B, b);
                                }
                                if (0 !== x.sideImpulse) {
                                    c = x.raycastResult.body;
                                    var E = new S();
                                    x.raycastResult.hitPointWorld.vsub(c.position, E);
                                    var A = new S();
                                    r[a].scale(x.sideImpulse, A), n.vectorToLocalFrame(b, b), b["xyz"[this.indexUpAxis]] *= x.rollInfluence, 
                                    n.vectorToWorldFrame(b, b), n.applyImpulse(A, b), A.scale(-1, A), c.applyImpulse(A, E);
                                }
                            }
                        };
                        var v = new S(), y = new S(), f = new S();
                        function F(t, e, i, o, n) {
                            var s = 0, r = i, a = v, h = y, l = f;
                            return t.getVelocityAtWorldPoint(r, a), e.getVelocityAtWorldPoint(r, h), a.vsub(h, l), 
                            n < (s = -o.dot(l) * (1 / (x(t, i, o) + x(e, i, o)))) && (s = n), s < -n && (s = -n), 
                            s;
                        }
                        var a = new S(), h = new S(), l = new S(), g = new S();
                        function x(t, e, i) {
                            var o = a, n = h, s = l, r = g;
                            return e.vsub(t.position, o), o.cross(i, n), t.invInertiaWorld.vmult(n, r), r.cross(o, s), 
                            t.invMass + i.dot(s);
                        }
                        var b = new S(), B = new S(), E = new S();
                        function R(t, e, i, o, n) {
                            if (1.1 < n.norm2()) return 0;
                            var s = b, r = B, a = E;
                            return t.getVelocityAtWorldPoint(e, s), i.getVelocityAtWorldPoint(o, r), s.vsub(r, a), 
                            -.2 * n.dot(a) * (1 / (t.invMass + i.invMass));
                        }
                    }, {
                        "../collision/Ray": 10,
                        "../collision/RaycastResult": 11,
                        "../math/Quaternion": 29,
                        "../math/Vec3": 31,
                        "../objects/WheelInfo": 37,
                        "./Body": 32
                    } ],
                    34: [ function(t, e, i) {
                        var r = t("./Body"), a = t("../shapes/Sphere"), o = t("../shapes/Box"), h = t("../math/Vec3"), l = t("../constraints/HingeConstraint");
                        function n(t) {
                            if (this.wheelBodies = [], this.coordinateSystem = void 0 === t.coordinateSystem ? new h(1, 2, 3) : t.coordinateSystem.clone(), 
                            this.chassisBody = t.chassisBody, !this.chassisBody) {
                                var e = new o(new h(5, 2, .5));
                                this.chassisBody = new r(1, e);
                            }
                            this.constraints = [], this.wheelAxes = [], this.wheelForces = [];
                        }
                        (e.exports = n).prototype.addWheel = function(t) {
                            var e = (t = t || {}).body;
                            e = e || new r(1, new a(1.2)), this.wheelBodies.push(e), this.wheelForces.push(0), 
                            new h();
                            var i = void 0 !== t.position ? t.position.clone() : new h(), o = new h();
                            this.chassisBody.pointToWorldFrame(i, o), e.position.set(o.x, o.y, o.z);
                            var n = void 0 !== t.axis ? t.axis.clone() : new h(0, 1, 0);
                            this.wheelAxes.push(n);
                            var s = new l(this.chassisBody, e, {
                                pivotA: i,
                                axisA: n,
                                pivotB: h.ZERO,
                                axisB: n,
                                collideConnected: !1
                            });
                            return this.constraints.push(s), this.wheelBodies.length - 1;
                        }, n.prototype.setSteeringValue = function(t, e) {
                            var i = this.wheelAxes[e], o = Math.cos(t), n = Math.sin(t), s = i.x, r = i.y;
                            this.constraints[e].axisA.set(o * s - n * r, n * s + o * r, 0);
                        }, n.prototype.setMotorSpeed = function(t, e) {
                            var i = this.constraints[e];
                            i.enableMotor(), i.motorTargetVelocity = t;
                        }, n.prototype.disableMotor = function(t) {
                            this.constraints[t].disableMotor();
                        };
                        var s = new h();
                        n.prototype.setWheelForce = function(t, e) {
                            this.wheelForces[e] = t;
                        }, n.prototype.applyWheelForce = function(t, e) {
                            var i = this.wheelAxes[e], o = this.wheelBodies[e], n = o.torque;
                            i.scale(t, s), o.vectorToWorldFrame(s, s), n.vadd(s, n);
                        }, n.prototype.addToWorld = function(t) {
                            for (var e = this.constraints, i = this.wheelBodies.concat([ this.chassisBody ]), o = 0; o < i.length; o++) t.addBody(i[o]);
                            for (o = 0; o < e.length; o++) t.addConstraint(e[o]);
                            t.addEventListener("preStep", this._update.bind(this));
                        }, n.prototype._update = function() {
                            for (var t = this.wheelForces, e = 0; e < t.length; e++) this.applyWheelForce(t[e], e);
                        }, n.prototype.removeFromWorld = function(t) {
                            for (var e = this.constraints, i = this.wheelBodies.concat([ this.chassisBody ]), o = 0; o < i.length; o++) t.remove(i[o]);
                            for (o = 0; o < e.length; o++) t.removeConstraint(e[o]);
                        };
                        var p = new h();
                        n.prototype.getWheelSpeed = function(t) {
                            var e = this.wheelAxes[t], i = this.wheelBodies[t].angularVelocity;
                            return this.chassisBody.vectorToWorldFrame(e, p), i.dot(p);
                        };
                    }, {
                        "../constraints/HingeConstraint": 16,
                        "../math/Vec3": 31,
                        "../shapes/Box": 38,
                        "../shapes/Sphere": 45,
                        "./Body": 32
                    } ],
                    35: [ function(t, e, i) {
                        e.exports = n, t("../shapes/Shape");
                        var o = t("../math/Vec3");
                        function n() {
                            this.particles = [], this.density = 1, this.smoothingRadius = 1, this.speedOfSound = 1, 
                            this.viscosity = .01, this.eps = 1e-6, this.pressures = [], this.densities = [], 
                            this.neighbors = [];
                        }
                        t("../math/Quaternion"), t("../shapes/Particle"), t("../objects/Body"), t("../material/Material"), 
                        n.prototype.add = function(t) {
                            this.particles.push(t), this.neighbors.length < this.particles.length && this.neighbors.push([]);
                        }, n.prototype.remove = function(t) {
                            var e = this.particles.indexOf(t);
                            -1 !== e && (this.particles.splice(e, 1), this.neighbors.length > this.particles.length && this.neighbors.pop());
                        };
                        var h = new o();
                        n.prototype.getNeighbors = function(t, e) {
                            for (var i = this.particles.length, o = t.id, n = this.smoothingRadius * this.smoothingRadius, s = h, r = 0; r !== i; r++) {
                                var a = this.particles[r];
                                a.position.vsub(t.position, s), o !== a.id && s.norm2() < n && e.push(a);
                            }
                        };
                        var B = new o(), E = new o(), A = new o(), S = new o(), z = new o(), M = new o();
                        n.prototype.update = function() {
                            for (var t = this.particles.length, e = B, i = this.speedOfSound, o = this.eps, n = 0; n !== t; n++) {
                                var s = this.particles[n];
                                (g = this.neighbors[n]).length = 0, this.getNeighbors(s, g), g.push(this.particles[n]);
                                for (var r = g.length, a = 0, h = 0; h !== r; h++) {
                                    s.position.vsub(g[h].position, e);
                                    var l = e.norm(), p = this.w(l);
                                    a += g[h].mass * p;
                                }
                                this.densities[n] = a, this.pressures[n] = i * i * (this.densities[n] - this.density);
                            }
                            var c = E, u = A, d = S, v = z, y = M;
                            for (n = 0; n !== t; n++) {
                                var f, m, g, w = this.particles[n];
                                for (c.set(0, 0, 0), u.set(0, 0, 0), r = (g = this.neighbors[n]).length, h = 0; h !== r; h++) {
                                    var x = g[h];
                                    w.position.vsub(x.position, v);
                                    var b = v.norm();
                                    f = -x.mass * (this.pressures[n] / (this.densities[n] * this.densities[n] + o) + this.pressures[h] / (this.densities[h] * this.densities[h] + o)), 
                                    this.gradw(v, d), d.mult(f, d), c.vadd(d, c), x.velocity.vsub(w.velocity, y), y.mult(1 / (1e-4 + this.densities[n] * this.densities[h]) * this.viscosity * x.mass, y), 
                                    m = this.nablaw(b), y.mult(m, y), u.vadd(y, u);
                                }
                                u.mult(w.mass, u), c.mult(w.mass, c), w.force.vadd(u, w.force), w.force.vadd(c, w.force);
                            }
                        }, n.prototype.w = function(t) {
                            var e = this.smoothingRadius;
                            return 315 / (64 * Math.PI * Math.pow(e, 9)) * Math.pow(e * e - t * t, 3);
                        }, n.prototype.gradw = function(t, e) {
                            var i = t.norm(), o = this.smoothingRadius;
                            t.mult(945 / (32 * Math.PI * Math.pow(o, 9)) * Math.pow(o * o - i * i, 2), e);
                        }, n.prototype.nablaw = function(t) {
                            var e = this.smoothingRadius;
                            return 945 / (32 * Math.PI * Math.pow(e, 9)) * (e * e - t * t) * (7 * t * t - 3 * e * e);
                        };
                    }, {
                        "../material/Material": 26,
                        "../math/Quaternion": 29,
                        "../math/Vec3": 31,
                        "../objects/Body": 32,
                        "../shapes/Particle": 42,
                        "../shapes/Shape": 44
                    } ],
                    36: [ function(t, e, i) {
                        var o = t("../math/Vec3");
                        function n(t, e, i) {
                            i = i || {}, this.restLength = "number" == typeof i.restLength ? i.restLength : 1, 
                            this.stiffness = i.stiffness || 100, this.damping = i.damping || 1, this.bodyA = t, 
                            this.bodyB = e, this.localAnchorA = new o(), this.localAnchorB = new o(), i.localAnchorA && this.localAnchorA.copy(i.localAnchorA), 
                            i.localAnchorB && this.localAnchorB.copy(i.localAnchorB), i.worldAnchorA && this.setWorldAnchorA(i.worldAnchorA), 
                            i.worldAnchorB && this.setWorldAnchorB(i.worldAnchorB);
                        }
                        (e.exports = n).prototype.setWorldAnchorA = function(t) {
                            this.bodyA.pointToLocalFrame(t, this.localAnchorA);
                        }, n.prototype.setWorldAnchorB = function(t) {
                            this.bodyB.pointToLocalFrame(t, this.localAnchorB);
                        }, n.prototype.getWorldAnchorA = function(t) {
                            this.bodyA.pointToWorldFrame(this.localAnchorA, t);
                        }, n.prototype.getWorldAnchorB = function(t) {
                            this.bodyB.pointToWorldFrame(this.localAnchorB, t);
                        };
                        var m = new o(), w = new o(), g = new o(), x = new o(), b = new o(), B = new o(), E = new o(), A = new o(), S = new o(), z = new o(), M = new o();
                        n.prototype.applyForce = function() {
                            var t = this.stiffness, e = this.damping, i = this.restLength, o = this.bodyA, n = this.bodyB, s = m, r = w, a = g, h = x, l = M, p = b, c = B, u = E, d = A, v = S, y = z;
                            this.getWorldAnchorA(p), this.getWorldAnchorB(c), p.vsub(o.position, u), c.vsub(n.position, d), 
                            c.vsub(p, s);
                            var f = s.norm();
                            r.copy(s), r.normalize(), n.velocity.vsub(o.velocity, a), n.angularVelocity.cross(d, l), 
                            a.vadd(l, a), o.angularVelocity.cross(u, l), a.vsub(l, a), r.mult(-t * (f - i) - e * a.dot(r), h), 
                            o.force.vsub(h, o.force), n.force.vadd(h, n.force), u.cross(h, v), d.cross(h, y), 
                            o.torque.vsub(v, o.torque), n.torque.vadd(y, n.torque);
                        };
                    }, {
                        "../math/Vec3": 31
                    } ],
                    37: [ function(t, e, i) {
                        var o = t("../math/Vec3"), n = t("../math/Transform"), s = t("../collision/RaycastResult"), r = t("../utils/Utils");
                        function a(t) {
                            t = r.defaults(t, {
                                chassisConnectionPointLocal: new o(),
                                chassisConnectionPointWorld: new o(),
                                directionLocal: new o(),
                                directionWorld: new o(),
                                axleLocal: new o(),
                                axleWorld: new o(),
                                suspensionRestLength: 1,
                                suspensionMaxLength: 2,
                                radius: 1,
                                suspensionStiffness: 100,
                                dampingCompression: 10,
                                dampingRelaxation: 10,
                                frictionSlip: 1e4,
                                steering: 0,
                                rotation: 0,
                                deltaRotation: 0,
                                rollInfluence: .01,
                                maxSuspensionForce: Number.MAX_VALUE,
                                isFrontWheel: !0,
                                clippedInvContactDotSuspension: 1,
                                suspensionRelativeVelocity: 0,
                                suspensionForce: 0,
                                skidInfo: 0,
                                suspensionLength: 0,
                                maxSuspensionTravel: 1,
                                useCustomSlidingRotationalSpeed: !1,
                                customSlidingRotationalSpeed: -.1
                            }), this.maxSuspensionTravel = t.maxSuspensionTravel, this.customSlidingRotationalSpeed = t.customSlidingRotationalSpeed, 
                            this.useCustomSlidingRotationalSpeed = t.useCustomSlidingRotationalSpeed, this.sliding = !1, 
                            this.chassisConnectionPointLocal = t.chassisConnectionPointLocal.clone(), this.chassisConnectionPointWorld = t.chassisConnectionPointWorld.clone(), 
                            this.directionLocal = t.directionLocal.clone(), this.directionWorld = t.directionWorld.clone(), 
                            this.axleLocal = t.axleLocal.clone(), this.axleWorld = t.axleWorld.clone(), this.suspensionRestLength = t.suspensionRestLength, 
                            this.suspensionMaxLength = t.suspensionMaxLength, this.radius = t.radius, this.suspensionStiffness = t.suspensionStiffness, 
                            this.dampingCompression = t.dampingCompression, this.dampingRelaxation = t.dampingRelaxation, 
                            this.frictionSlip = t.frictionSlip, this.steering = 0, this.rotation = 0, this.deltaRotation = 0, 
                            this.rollInfluence = t.rollInfluence, this.maxSuspensionForce = t.maxSuspensionForce, 
                            this.engineForce = 0, this.brake = 0, this.isFrontWheel = t.isFrontWheel, this.clippedInvContactDotSuspension = 1, 
                            this.suspensionRelativeVelocity = 0, this.suspensionForce = 0, this.skidInfo = 0, 
                            this.suspensionLength = 0, this.sideImpulse = 0, this.forwardImpulse = 0, this.raycastResult = new s(), 
                            this.worldTransform = new n(), this.isInContact = !1;
                        }
                        e.exports = a;
                        var h = new o(), l = new o();
                        h = new o(), a.prototype.updateWheel = function(t) {
                            var e = this.raycastResult;
                            if (this.isInContact) {
                                var i = e.hitNormalWorld.dot(e.directionWorld);
                                e.hitPointWorld.vsub(t.position, l), t.getVelocityAtWorldPoint(l, h);
                                var o = e.hitNormalWorld.dot(h);
                                if (-.1 <= i) this.suspensionRelativeVelocity = 0, this.clippedInvContactDotSuspension = 10; else {
                                    var n = -1 / i;
                                    this.suspensionRelativeVelocity = o * n, this.clippedInvContactDotSuspension = n;
                                }
                            } else e.suspensionLength = this.suspensionRestLength, this.suspensionRelativeVelocity = 0, 
                            e.directionWorld.scale(-1, e.hitNormalWorld), this.clippedInvContactDotSuspension = 1;
                        };
                    }, {
                        "../collision/RaycastResult": 11,
                        "../math/Transform": 30,
                        "../math/Vec3": 31,
                        "../utils/Utils": 54
                    } ],
                    38: [ function(t, e, i) {
                        e.exports = n;
                        var o = t("./Shape"), r = t("../math/Vec3"), a = t("./ConvexPolyhedron");
                        function n(t) {
                            o.call(this, {
                                type: o.types.BOX
                            }), this.halfExtents = t, this.convexPolyhedronRepresentation = null, this.updateConvexPolyhedronRepresentation(), 
                            this.updateBoundingSphereRadius();
                        }
                        ((n.prototype = new o()).constructor = n).prototype.updateConvexPolyhedronRepresentation = function() {
                            var t = this.halfExtents.x, e = this.halfExtents.y, i = this.halfExtents.z, o = r, n = [ new o(-t, -e, -i), new o(t, -e, -i), new o(t, e, -i), new o(-t, e, -i), new o(-t, -e, i), new o(t, -e, i), new o(t, e, i), new o(-t, e, i) ], s = (new o(0, 0, 1), 
                            new o(0, 1, 0), new o(1, 0, 0), new a(n, [ [ 3, 2, 1, 0 ], [ 4, 5, 6, 7 ], [ 5, 4, 0, 1 ], [ 2, 3, 7, 6 ], [ 0, 4, 7, 3 ], [ 1, 2, 6, 5 ] ]));
                            (this.convexPolyhedronRepresentation = s).material = this.material;
                        }, n.prototype.calculateLocalInertia = function(t, e) {
                            return e = e || new r(), n.calculateInertia(this.halfExtents, t, e), e;
                        }, n.calculateInertia = function(t, e, i) {
                            var o = t;
                            o.isZero() ? (i.x = 2 / 12 * e, i.y = 2 / 12 * e, i.z = 2 / 12 * e) : (i.x = 1 / 12 * e * (2 * o.y * 2 * o.y + 2 * o.z * 2 * o.z), 
                            i.y = 1 / 12 * e * (2 * o.x * 2 * o.x + 2 * o.z * 2 * o.z), i.z = 1 / 12 * e * (2 * o.y * 2 * o.y + 2 * o.x * 2 * o.x));
                        }, n.prototype.getSideNormals = function(t, e) {
                            var i = t, o = this.halfExtents;
                            if (i[0].set(o.x, 0, 0), i[1].set(0, o.y, 0), i[2].set(0, 0, o.z), i[3].set(-o.x, 0, 0), 
                            i[4].set(0, -o.y, 0), i[5].set(0, 0, -o.z), void 0 !== e) for (var n = 0; n !== i.length; n++) e.vmult(i[n], i[n]);
                            return i;
                        }, n.prototype.volume = function() {
                            return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
                        }, n.prototype.updateBoundingSphereRadius = function() {
                            this.boundingSphereRadius = this.halfExtents.norm();
                        };
                        var h = new r();
                        new r(), n.prototype.forEachWorldCorner = function(t, e, i) {
                            for (var o = this.halfExtents, n = [ [ o.x, o.y, o.z ], [ -o.x, o.y, o.z ], [ -o.x, -o.y, o.z ], [ -o.x, -o.y, -o.z ], [ o.x, -o.y, -o.z ], [ o.x, o.y, -o.z ], [ -o.x, o.y, -o.z ], [ o.x, -o.y, o.z ] ], s = 0; s < n.length; s++) h.set(n[s][0], n[s][1], n[s][2]), 
                            e.vmult(h, h), t.vadd(h, h), i(h.x, h.y, h.z);
                        };
                        var p = [ new r(), new r(), new r(), new r(), new r(), new r(), new r(), new r() ];
                        n.prototype.calculateWorldAABB = function(t, e, i, o) {
                            var n = this.halfExtents;
                            p[0].set(n.x, n.y, n.z), p[1].set(-n.x, n.y, n.z), p[2].set(-n.x, -n.y, n.z), p[3].set(-n.x, -n.y, -n.z), 
                            p[4].set(n.x, -n.y, -n.z), p[5].set(n.x, n.y, -n.z), p[6].set(-n.x, n.y, -n.z), 
                            p[7].set(n.x, -n.y, n.z);
                            var s = p[0];
                            e.vmult(s, s), t.vadd(s, s), o.copy(s), i.copy(s);
                            for (var r = 1; r < 8; r++) {
                                s = p[r], e.vmult(s, s), t.vadd(s, s);
                                var a = s.x, h = s.y, l = s.z;
                                a > o.x && (o.x = a), h > o.y && (o.y = h), l > o.z && (o.z = l), a < i.x && (i.x = a), 
                                h < i.y && (i.y = h), l < i.z && (i.z = l);
                            }
                        };
                    }, {
                        "../math/Vec3": 31,
                        "./ConvexPolyhedron": 39,
                        "./Shape": 44
                    } ],
                    39: [ function(t, e, i) {
                        e.exports = u;
                        var o = t("./Shape"), x = t("../math/Vec3"), y = (t("../math/Quaternion"), t("../math/Transform"));
                        function u(t, e, i) {
                            o.call(this, {
                                type: o.types.CONVEXPOLYHEDRON
                            }), this.vertices = t || [], this.worldVertices = [], this.worldVerticesNeedsUpdate = !0, 
                            this.faces = e || [], this.faceNormals = [], this.computeNormals(), this.worldFaceNormalsNeedsUpdate = !0, 
                            this.worldFaceNormals = [], this.uniqueEdges = [], this.uniqueAxes = i ? i.slice() : null, 
                            this.computeEdges(), this.updateBoundingSphereRadius();
                        }
                        (u.prototype = new o()).constructor = u;
                        var c = new x();
                        u.prototype.computeEdges = function() {
                            var t = this.faces, e = this.vertices, i = (e.length, this.uniqueEdges);
                            i.length = 0;
                            for (var o = c, n = 0; n !== t.length; n++) for (var s = t[n], r = s.length, a = 0; a !== r; a++) {
                                var h = (a + 1) % r;
                                e[s[a]].vsub(e[s[h]], o), o.normalize();
                                for (var l = !1, p = 0; p !== i.length; p++) if (i[p].almostEquals(o) || i[p].almostEquals(o)) {
                                    l = !0;
                                    break;
                                }
                                l || i.push(o.clone());
                            }
                        }, u.prototype.computeNormals = function() {
                            this.faceNormals.length = this.faces.length;
                            for (var t = 0; t < this.faces.length; t++) {
                                for (var e = 0; e < this.faces[t].length; e++) if (!this.vertices[this.faces[t][e]]) throw new Error("Vertex " + this.faces[t][e] + " not found!");
                                var i = this.faceNormals[t] || new x();
                                this.getFaceNormal(t, i), i.negate(i), this.faceNormals[t] = i;
                                var o = this.vertices[this.faces[t][0]];
                                if (i.dot(o) < 0) for (console.error(".faceNormals[" + t + "] = Vec3(" + i.toString() + ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule."), 
                                e = 0; e < this.faces[t].length; e++) console.warn(".vertices[" + this.faces[t][e] + "] = Vec3(" + this.vertices[this.faces[t][e]].toString() + ")");
                            }
                        };
                        var n = new x(), s = new x();
                        u.computeNormal = function(t, e, i, o) {
                            e.vsub(t, s), i.vsub(e, n), n.cross(s, o), o.isZero() || o.normalize();
                        }, u.prototype.getFaceNormal = function(t, e) {
                            var i = this.faces[t], o = this.vertices[i[0]], n = this.vertices[i[1]], s = this.vertices[i[2]];
                            return u.computeNormal(o, n, s, e);
                        };
                        var b = new x();
                        u.prototype.clipAgainstHull = function(t, e, i, o, n, s, r, a, h) {
                            for (var l = b, p = -1, c = -Number.MAX_VALUE, u = 0; u < i.faces.length; u++) {
                                l.copy(i.faceNormals[u]), n.vmult(l, l);
                                var d = l.dot(s);
                                c < d && (c = d, p = u);
                            }
                            for (var v = [], y = i.faces[p], f = y.length, m = 0; m < f; m++) {
                                var w = i.vertices[y[m]], g = new x();
                                g.copy(w), n.vmult(g, g), o.vadd(g, g), v.push(g);
                            }
                            0 <= p && this.clipFaceAgainstHull(s, t, e, v, r, a, h);
                        };
                        var A = new x(), S = new x(), z = new x(), M = new x(), C = new x(), q = new x();
                        u.prototype.findSeparatingAxis = function(t, e, i, o, n, s, r, a) {
                            var h = A, l = S, p = z, c = M, u = C, d = q, v = Number.MAX_VALUE, y = this;
                            if (y.uniqueAxes) for (m = 0; m !== y.uniqueAxes.length; m++) {
                                if (i.vmult(y.uniqueAxes[m], h), !1 === (x = y.testSepAxis(h, t, e, i, o, n))) return !1;
                                x < v && (v = x, s.copy(h));
                            } else for (var f = r ? r.length : y.faces.length, m = 0; m < f; m++) {
                                var w = r ? r[m] : m;
                                if (h.copy(y.faceNormals[w]), i.vmult(h, h), !1 === (x = y.testSepAxis(h, t, e, i, o, n))) return !1;
                                x < v && (v = x, s.copy(h));
                            }
                            if (t.uniqueAxes) for (m = 0; m !== t.uniqueAxes.length; m++) {
                                if (n.vmult(t.uniqueAxes[m], l), !1 === (x = y.testSepAxis(l, t, e, i, o, n))) return !1;
                                x < v && (v = x, s.copy(l));
                            } else for (var g = a ? a.length : t.faces.length, m = 0; m < g; m++) {
                                var x;
                                if (w = a ? a[m] : m, l.copy(t.faceNormals[w]), n.vmult(l, l), !1 === (x = y.testSepAxis(l, t, e, i, o, n))) return !1;
                                x < v && (v = x, s.copy(l));
                            }
                            for (var b = 0; b !== y.uniqueEdges.length; b++) {
                                i.vmult(y.uniqueEdges[b], c);
                                for (var B = 0; B !== t.uniqueEdges.length; B++) if (n.vmult(t.uniqueEdges[B], u), 
                                c.cross(u, d), !d.almostZero()) {
                                    d.normalize();
                                    var E = y.testSepAxis(d, t, e, i, o, n);
                                    if (!1 === E) return !1;
                                    E < v && (v = E, s.copy(d));
                                }
                            }
                            return o.vsub(e, p), 0 < p.dot(s) && s.negate(s), !0;
                        };
                        var d = [], v = [];
                        u.prototype.testSepAxis = function(t, e, i, o, n, s) {
                            u.project(this, t, i, o, d), u.project(e, t, n, s, v);
                            var r = d[0], a = d[1], h = v[0], l = v[1];
                            if (r < l || h < a) return !1;
                            var p = r - l, c = h - a;
                            return p < c ? p : c;
                        };
                        var r = new x(), a = new x();
                        u.prototype.calculateLocalInertia = function(t, e) {
                            this.computeLocalAABB(r, a);
                            var i = a.x - r.x, o = a.y - r.y, n = a.z - r.z;
                            e.x = 1 / 12 * t * (2 * o * 2 * o + 2 * n * 2 * n), e.y = 1 / 12 * t * (2 * i * 2 * i + 2 * n * 2 * n), 
                            e.z = 1 / 12 * t * (2 * o * 2 * o + 2 * i * 2 * i);
                        }, u.prototype.getPlaneConstantOfFace = function(t) {
                            var e = this.faces[t], i = this.faceNormals[t], o = this.vertices[e[0]];
                            return -i.dot(o);
                        };
                        var I = new x(), N = new x(), L = new x(), W = new x(), j = new x(), O = new x(), k = new x(), _ = new x();
                        u.prototype.clipFaceAgainstHull = function(t, e, i, o, n, s, r) {
                            for (var a = I, h = N, l = L, p = W, c = j, u = O, d = k, v = _, y = this, f = o, m = [], w = -1, g = Number.MAX_VALUE, x = 0; x < y.faces.length; x++) {
                                a.copy(y.faceNormals[x]), i.vmult(a, a);
                                var b = a.dot(t);
                                b < g && (g = b, w = x);
                            }
                            if (!(w < 0)) {
                                var B = y.faces[w];
                                B.connectedFaces = [];
                                for (var E = 0; E < y.faces.length; E++) for (var A = 0; A < y.faces[E].length; A++) -1 !== B.indexOf(y.faces[E][A]) && E !== w && -1 === B.connectedFaces.indexOf(E) && B.connectedFaces.push(E);
                                f.length;
                                for (var S = B.length, z = 0; z < S; z++) {
                                    var M = y.vertices[B[z]], C = y.vertices[B[(z + 1) % S]];
                                    M.vsub(C, h), l.copy(h), i.vmult(l, l), e.vadd(l, l), p.copy(this.faceNormals[w]), 
                                    i.vmult(p, p), e.vadd(p, p), l.cross(p, c), c.negate(c), u.copy(M), i.vmult(u, u), 
                                    e.vadd(u, u), u.dot(c);
                                    var q = B.connectedFaces[z];
                                    d.copy(this.faceNormals[q]);
                                    var F = this.getPlaneConstantOfFace(q);
                                    v.copy(d), i.vmult(v, v);
                                    var R = F - v.dot(e);
                                    for (this.clipFaceAgainstPlane(f, m, v, R); f.length; ) f.shift();
                                    for (;m.length; ) f.push(m.shift());
                                }
                                for (d.copy(this.faceNormals[w]), F = this.getPlaneConstantOfFace(w), v.copy(d), 
                                i.vmult(v, v), R = F - v.dot(e), E = 0; E < f.length; E++) {
                                    var T = v.dot(f[E]) + R;
                                    if (T <= n && (T = n), T <= s) {
                                        var P = f[E];
                                        if (T <= 0) {
                                            var V = {
                                                point: P,
                                                normal: v,
                                                depth: T
                                            };
                                            r.push(V);
                                        }
                                    }
                                }
                            }
                        }, u.prototype.clipFaceAgainstPlane = function(t, e, i, o) {
                            var n, s, r = t.length;
                            if (r < 2) return e;
                            var a = t[t.length - 1], h = t[0];
                            n = i.dot(a) + o;
                            for (var l = 0; l < r; l++) {
                                if (h = t[l], s = i.dot(h) + o, n < 0) if (s < 0) (p = new x()).copy(h), e.push(p); else {
                                    var p = new x();
                                    a.lerp(h, n / (n - s), p), e.push(p);
                                } else s < 0 && (p = new x(), a.lerp(h, n / (n - s), p), e.push(p), e.push(h));
                                a = h, n = s;
                            }
                            return e;
                        }, u.prototype.computeWorldVertices = function(t, e) {
                            for (var i = this.vertices.length; this.worldVertices.length < i; ) this.worldVertices.push(new x());
                            for (var o = this.vertices, n = this.worldVertices, s = 0; s !== i; s++) e.vmult(o[s], n[s]), 
                            t.vadd(n[s], n[s]);
                            this.worldVerticesNeedsUpdate = !1;
                        }, new x(), u.prototype.computeLocalAABB = function(t, e) {
                            var i = this.vertices.length, o = this.vertices;
                            t.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), e.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                            for (var n = 0; n < i; n++) {
                                var s = o[n];
                                s.x < t.x ? t.x = s.x : s.x > e.x && (e.x = s.x), s.y < t.y ? t.y = s.y : s.y > e.y && (e.y = s.y), 
                                s.z < t.z ? t.z = s.z : s.z > e.z && (e.z = s.z);
                            }
                        }, u.prototype.computeWorldFaceNormals = function(t) {
                            for (var e = this.faceNormals.length; this.worldFaceNormals.length < e; ) this.worldFaceNormals.push(new x());
                            for (var i = this.faceNormals, o = this.worldFaceNormals, n = 0; n !== e; n++) t.vmult(i[n], o[n]);
                            this.worldFaceNormalsNeedsUpdate = !1;
                        }, u.prototype.updateBoundingSphereRadius = function() {
                            for (var t = 0, e = this.vertices, i = 0, o = e.length; i !== o; i++) {
                                var n = e[i].norm2();
                                t < n && (t = n);
                            }
                            this.boundingSphereRadius = Math.sqrt(t);
                        };
                        var f = new x();
                        u.prototype.calculateWorldAABB = function(t, e, i, o) {
                            for (var n, s, r, a, h, l, p = this.vertices.length, c = this.vertices, u = 0; u < p; u++) {
                                f.copy(c[u]), e.vmult(f, f), t.vadd(f, f);
                                var d = f;
                                d.x < n || void 0 === n ? n = d.x : (d.x > a || void 0 === a) && (a = d.x), d.y < s || void 0 === s ? s = d.y : (d.y > h || void 0 === h) && (h = d.y), 
                                d.z < r || void 0 === r ? r = d.z : (d.z > l || void 0 === l) && (l = d.z);
                            }
                            i.set(n, s, r), o.set(a, h, l);
                        }, u.prototype.volume = function() {
                            return 4 * Math.PI * this.boundingSphereRadius / 3;
                        }, u.prototype.getAveragePointLocal = function(t) {
                            t = t || new x();
                            for (var e = this.vertices.length, i = this.vertices, o = 0; o < e; o++) t.vadd(i[o], t);
                            return t.mult(1 / e, t), t;
                        }, u.prototype.transformAllPoints = function(t, e) {
                            var i = this.vertices.length, o = this.vertices;
                            if (e) {
                                for (var n = 0; n < i; n++) {
                                    var s = o[n];
                                    e.vmult(s, s);
                                }
                                for (n = 0; n < this.faceNormals.length; n++) s = this.faceNormals[n], e.vmult(s, s);
                            }
                            if (t) for (n = 0; n < i; n++) (s = o[n]).vadd(t, s);
                        };
                        var m = new x(), w = new x(), g = new x();
                        u.prototype.pointIsInside = function(t) {
                            var e = this.vertices.length, i = this.vertices, o = this.faces, n = this.faceNormals, s = this.faces.length, r = m;
                            this.getAveragePointLocal(r);
                            for (var a = 0; a < s; a++) {
                                this.faces[a].length, e = n[a];
                                var h = i[o[a][0]], l = w;
                                t.vsub(h, l);
                                var p = e.dot(l), c = g;
                                r.vsub(h, c);
                                var u = e.dot(c);
                                if (p < 0 && 0 < u || 0 < p && u < 0) return !1;
                            }
                            return -1;
                        }, new x();
                        var B = new x(), E = new x();
                        u.project = function(t, e, i, o, n) {
                            var s = t.vertices.length, r = B, a = 0, h = 0, l = E, p = t.vertices;
                            l.setZero(), y.vectorToLocalFrame(i, o, e, r), y.pointToLocalFrame(i, o, l, l);
                            var c = l.dot(r);
                            h = a = p[0].dot(r);
                            for (var u = 1; u < s; u++) {
                                var d = p[u].dot(r);
                                a < d && (a = d), d < h && (h = d);
                            }
                            if ((a -= c) < (h -= c)) {
                                var v = h;
                                h = a, a = v;
                            }
                            n[0] = a, n[1] = h;
                        };
                    }, {
                        "../math/Quaternion": 29,
                        "../math/Transform": 30,
                        "../math/Vec3": 31,
                        "./Shape": 44
                    } ],
                    40: [ function(t, e, i) {
                        e.exports = o, t("./Shape");
                        var f = t("../math/Vec3"), m = (t("../math/Quaternion"), t("./ConvexPolyhedron"));
                        function o(t, e, i, o) {
                            var n = o, s = [], r = [], a = [], h = [], l = [], p = Math.cos, c = Math.sin;
                            s.push(new f(e * p(0), e * c(0), .5 * -i)), h.push(0), s.push(new f(t * p(0), t * c(0), .5 * i)), 
                            l.push(1);
                            for (var u = 0; u < n; u++) {
                                var d = 2 * Math.PI / n * (u + 1), v = 2 * Math.PI / n * (u + .5);
                                u < n - 1 ? (s.push(new f(e * p(d), e * c(d), .5 * -i)), h.push(2 * u + 2), s.push(new f(t * p(d), t * c(d), .5 * i)), 
                                l.push(2 * u + 3), a.push([ 2 * u + 2, 2 * u + 3, 2 * u + 1, 2 * u ])) : a.push([ 0, 1, 2 * u + 1, 2 * u ]), 
                                (n % 2 == 1 || u < n / 2) && r.push(new f(p(v), c(v), 0));
                            }
                            a.push(l), r.push(new f(0, 0, 1));
                            var y = [];
                            for (u = 0; u < h.length; u++) y.push(h[h.length - u - 1]);
                            a.push(y), m.call(this, s, a, r);
                        }
                        o.prototype = new m();
                    }, {
                        "../math/Quaternion": 29,
                        "../math/Vec3": 31,
                        "./ConvexPolyhedron": 39,
                        "./Shape": 44
                    } ],
                    41: [ function(t, e, i) {
                        var o = t("./Shape"), c = t("./ConvexPolyhedron"), u = t("../math/Vec3"), n = t("../utils/Utils");
                        function s(t, e) {
                            e = n.defaults(e, {
                                maxValue: null,
                                minValue: null,
                                elementSize: 1
                            }), this.data = t, this.maxValue = e.maxValue, this.minValue = e.minValue, this.elementSize = e.elementSize, 
                            null === e.minValue && this.updateMinValue(), null === e.maxValue && this.updateMaxValue(), 
                            this.cacheEnabled = !0, o.call(this, {
                                type: o.types.HEIGHTFIELD
                            }), this.pillarConvex = new c(), this.pillarOffset = new u(), this.updateBoundingSphereRadius(), 
                            this._cachedPillars = {};
                        }
                        ((e.exports = s).prototype = new o()).update = function() {
                            this._cachedPillars = {};
                        }, s.prototype.updateMinValue = function() {
                            for (var t = this.data, e = t[0][0], i = 0; i !== t.length; i++) for (var o = 0; o !== t[i].length; o++) {
                                var n = t[i][o];
                                n < e && (e = n);
                            }
                            this.minValue = e;
                        }, s.prototype.updateMaxValue = function() {
                            for (var t = this.data, e = t[0][0], i = 0; i !== t.length; i++) for (var o = 0; o !== t[i].length; o++) {
                                var n = t[i][o];
                                e < n && (e = n);
                            }
                            this.maxValue = e;
                        }, s.prototype.setHeightValueAtIndex = function(t, e, i) {
                            this.data[t][e] = i, this.clearCachedConvexTrianglePillar(t, e, !1), 0 < t && (this.clearCachedConvexTrianglePillar(t - 1, e, !0), 
                            this.clearCachedConvexTrianglePillar(t - 1, e, !1)), 0 < e && (this.clearCachedConvexTrianglePillar(t, e - 1, !0), 
                            this.clearCachedConvexTrianglePillar(t, e - 1, !1)), 0 < e && 0 < t && this.clearCachedConvexTrianglePillar(t - 1, e - 1, !0);
                        }, s.prototype.getRectMinMax = function(t, e, i, o, n) {
                            n = n || [];
                            for (var s = this.data, r = this.minValue, a = t; a <= i; a++) for (var h = e; h <= o; h++) {
                                var l = s[a][h];
                                r < l && (r = l);
                            }
                            n[0] = this.minValue, n[1] = r;
                        }, s.prototype.getIndexOfPosition = function(t, e, i, o) {
                            var n = this.elementSize, s = this.data, r = Math.floor(t / n), a = Math.floor(e / n);
                            return i[0] = r, i[1] = a, o && (r < 0 && (r = 0), a < 0 && (a = 0), r >= s.length - 1 && (r = s.length - 1), 
                            a >= s[0].length - 1 && (a = s[0].length - 1)), !(r < 0 || a < 0 || r >= s.length - 1 || a >= s[0].length - 1);
                        };
                        var d = [], v = new u(), y = new u(), f = new u(), m = new u();
                        s.prototype.getTriangleAt = function(t, e, i, o, n, s) {
                            var r = d;
                            this.getIndexOfPosition(t, e, r, i);
                            var a = r[0], h = r[1], l = this.data;
                            i && (a = Math.min(l.length - 2, Math.max(0, a)), h = Math.min(l[0].length - 2, Math.max(0, h)));
                            var p = this.elementSize, c = Math.pow(t / p - a, 2) + Math.pow(e / p - h, 2), u = Math.pow(t / p - (a + 1), 2) + Math.pow(e / p - (h + 1), 2) < c;
                            return this.getTriangle(a, h, u, o, n, s), u;
                        };
                        var l = new u(), p = new u(), w = new u(), g = new u(), x = new u();
                        s.prototype.getNormalAt = function(t, e, i, o) {
                            var n = l, s = p, r = w, a = g, h = x;
                            this.getTriangleAt(t, e, i, n, s, r), s.vsub(n, a), r.vsub(n, h), a.cross(h, o), 
                            o.normalize();
                        }, s.prototype.getAabbAtIndex = function(t, e, i) {
                            var o = this.data, n = this.elementSize;
                            i.lowerBound.set(t * n, e * n, o[t][e]), i.upperBound.set((t + 1) * n, (e + 1) * n, o[t + 1][e + 1]);
                        }, s.prototype.getHeightAt = function(t, e, i) {
                            var o = this.data, n = y, s = f, r = m, a = d;
                            this.getIndexOfPosition(t, e, a, i);
                            var h = a[0], l = a[1];
                            i && (h = Math.min(o.length - 2, Math.max(0, h)), l = Math.min(o[0].length - 2, Math.max(0, l)));
                            var p = this.getTriangleAt(t, e, i, n, s, r);
                            !function(t, e, i, o, n, s, r, a, h) {
                                h.x = ((s - a) * (t - r) + (r - n) * (e - a)) / ((s - a) * (i - r) + (r - n) * (o - a)), 
                                h.y = ((a - o) * (t - r) + (i - r) * (e - a)) / ((s - a) * (i - r) + (r - n) * (o - a)), 
                                h.z = 1 - h.x - h.y;
                            }(t, e, n.x, n.y, s.x, s.y, r.x, r.y, v);
                            var c = v;
                            return p ? o[h + 1][l + 1] * c.x + o[h][l + 1] * c.y + o[h + 1][l] * c.z : o[h][l] * c.x + o[h + 1][l] * c.y + o[h][l + 1] * c.z;
                        }, s.prototype.getCacheConvexTrianglePillarKey = function(t, e, i) {
                            return t + "_" + e + "_" + (i ? 1 : 0);
                        }, s.prototype.getCachedConvexTrianglePillar = function(t, e, i) {
                            return this._cachedPillars[this.getCacheConvexTrianglePillarKey(t, e, i)];
                        }, s.prototype.setCachedConvexTrianglePillar = function(t, e, i, o, n) {
                            this._cachedPillars[this.getCacheConvexTrianglePillarKey(t, e, i)] = {
                                convex: o,
                                offset: n
                            };
                        }, s.prototype.clearCachedConvexTrianglePillar = function(t, e, i) {
                            delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(t, e, i)];
                        }, s.prototype.getTriangle = function(t, e, i, o, n, s) {
                            var r = this.data, a = this.elementSize;
                            i ? (o.set((t + 1) * a, (e + 1) * a, r[t + 1][e + 1]), n.set(t * a, (e + 1) * a, r[t][e + 1]), 
                            s.set((t + 1) * a, e * a, r[t + 1][e])) : (o.set(t * a, e * a, r[t][e]), n.set((t + 1) * a, e * a, r[t + 1][e]), 
                            s.set(t * a, (e + 1) * a, r[t][e + 1]));
                        }, s.prototype.getConvexTrianglePillar = function(t, e, i) {
                            var o = this.pillarConvex, n = this.pillarOffset;
                            if (this.cacheEnabled) {
                                if (s = this.getCachedConvexTrianglePillar(t, e, i)) return this.pillarConvex = s.convex, 
                                void (this.pillarOffset = s.offset);
                                o = new c(), n = new u(), this.pillarConvex = o, this.pillarOffset = n;
                            }
                            var s = this.data, r = this.elementSize, a = o.faces;
                            o.vertices.length = 6;
                            for (var h = 0; h < 6; h++) o.vertices[h] || (o.vertices[h] = new u());
                            for (a.length = 5, h = 0; h < 5; h++) a[h] || (a[h] = []);
                            var l = o.vertices, p = (Math.min(s[t][e], s[t + 1][e], s[t][e + 1], s[t + 1][e + 1]) - this.minValue) / 2 + this.minValue;
                            i ? (n.set((t + .75) * r, (e + .75) * r, p), l[0].set(.25 * r, .25 * r, s[t + 1][e + 1] - p), 
                            l[1].set(-.75 * r, .25 * r, s[t][e + 1] - p), l[2].set(.25 * r, -.75 * r, s[t + 1][e] - p), 
                            l[3].set(.25 * r, .25 * r, -p - 1), l[4].set(-.75 * r, .25 * r, -p - 1), l[5].set(.25 * r, -.75 * r, -p - 1), 
                            a[0][0] = 0, a[0][1] = 1, a[0][2] = 2, a[1][0] = 5, a[1][1] = 4, a[1][2] = 3, a[2][0] = 2, 
                            a[2][1] = 5, a[2][2] = 3, a[2][3] = 0, a[3][0] = 3, a[3][1] = 4, a[3][2] = 1, a[3][3] = 0, 
                            a[4][0] = 1, a[4][1] = 4, a[4][2] = 5, a[4][3] = 2) : (n.set((t + .25) * r, (e + .25) * r, p), 
                            l[0].set(-.25 * r, -.25 * r, s[t][e] - p), l[1].set(.75 * r, -.25 * r, s[t + 1][e] - p), 
                            l[2].set(-.25 * r, .75 * r, s[t][e + 1] - p), l[3].set(-.25 * r, -.25 * r, -p - 1), 
                            l[4].set(.75 * r, -.25 * r, -p - 1), l[5].set(-.25 * r, .75 * r, -p - 1), a[0][0] = 0, 
                            a[0][1] = 1, a[0][2] = 2, a[1][0] = 5, a[1][1] = 4, a[1][2] = 3, a[2][0] = 0, a[2][1] = 2, 
                            a[2][2] = 5, a[2][3] = 3, a[3][0] = 1, a[3][1] = 0, a[3][2] = 3, a[3][3] = 4, a[4][0] = 4, 
                            a[4][1] = 5, a[4][2] = 2, a[4][3] = 1), o.computeNormals(), o.computeEdges(), o.updateBoundingSphereRadius(), 
                            this.setCachedConvexTrianglePillar(t, e, i, o, n);
                        }, s.prototype.calculateLocalInertia = function(t, e) {
                            return (e = e || new u()).set(0, 0, 0), e;
                        }, s.prototype.volume = function() {
                            return Number.MAX_VALUE;
                        }, s.prototype.calculateWorldAABB = function(t, e, i, o) {
                            i.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), o.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                        }, s.prototype.updateBoundingSphereRadius = function() {
                            var t = this.data, e = this.elementSize;
                            this.boundingSphereRadius = new u(t.length * e, t[0].length * e, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm();
                        }, s.prototype.setHeightsFromImage = function(t, e) {
                            var i = document.createElement("canvas");
                            i.width = t.width, i.height = t.height;
                            var o = i.getContext("2d");
                            o.drawImage(t, 0, 0);
                            var n = o.getImageData(0, 0, t.width, t.height), s = this.data;
                            s.length = 0, this.elementSize = Math.abs(e.x) / n.width;
                            for (var r = 0; r < n.height; r++) {
                                for (var a = [], h = 0; h < n.width; h++) {
                                    var l = (n.data[4 * (r * n.height + h)] + n.data[4 * (r * n.height + h) + 1] + n.data[4 * (r * n.height + h) + 2]) / 4 / 255 * e.z;
                                    e.x < 0 ? a.push(l) : a.unshift(l);
                                }
                                e.y < 0 ? s.unshift(a) : s.push(a);
                            }
                            this.updateMaxValue(), this.updateMinValue(), this.update();
                        };
                    }, {
                        "../math/Vec3": 31,
                        "../utils/Utils": 54,
                        "./ConvexPolyhedron": 39,
                        "./Shape": 44
                    } ],
                    42: [ function(t, e, i) {
                        e.exports = s;
                        var o = t("./Shape"), n = t("../math/Vec3");
                        function s() {
                            o.call(this, {
                                type: o.types.PARTICLE
                            });
                        }
                        ((s.prototype = new o()).constructor = s).prototype.calculateLocalInertia = function(t, e) {
                            return (e = e || new n()).set(0, 0, 0), e;
                        }, s.prototype.volume = function() {
                            return 0;
                        }, s.prototype.updateBoundingSphereRadius = function() {
                            this.boundingSphereRadius = 0;
                        }, s.prototype.calculateWorldAABB = function(t, e, i, o) {
                            i.copy(t), o.copy(t);
                        };
                    }, {
                        "../math/Vec3": 31,
                        "./Shape": 44
                    } ],
                    43: [ function(t, e, i) {
                        e.exports = s;
                        var o = t("./Shape"), n = t("../math/Vec3");
                        function s() {
                            o.call(this, {
                                type: o.types.PLANE
                            }), this.worldNormal = new n(), this.worldNormalNeedsUpdate = !0, this.boundingSphereRadius = Number.MAX_VALUE;
                        }
                        ((s.prototype = new o()).constructor = s).prototype.computeWorldNormal = function(t) {
                            var e = this.worldNormal;
                            e.set(0, 0, 1), t.vmult(e, e), this.worldNormalNeedsUpdate = !1;
                        }, s.prototype.calculateLocalInertia = function(t, e) {
                            return e = e || new n();
                        }, s.prototype.volume = function() {
                            return Number.MAX_VALUE;
                        };
                        var r = new n();
                        s.prototype.calculateWorldAABB = function(t, e, i, o) {
                            r.set(0, 0, 1), e.vmult(r, r);
                            var n = Number.MAX_VALUE;
                            i.set(-n, -n, -n), o.set(n, n, n), 1 === r.x && (o.x = t.x), 1 === r.y && (o.y = t.y), 
                            1 === r.z && (o.z = t.z), -1 === r.x && (i.x = t.x), -1 === r.y && (i.y = t.y), 
                            -1 === r.z && (i.z = t.z);
                        }, s.prototype.updateBoundingSphereRadius = function() {
                            this.boundingSphereRadius = Number.MAX_VALUE;
                        };
                    }, {
                        "../math/Vec3": 31,
                        "./Shape": 44
                    } ],
                    44: [ function(t, e, i) {
                        e.exports = n;
                        var o = t("../utils/EventTarget"), n = t("./Shape");
                        function n(t) {
                            t = t || {}, o.apply(this), this.id = n.idCounter++, this.type = t.type || 0, this.boundingSphereRadius = 0, 
                            this.collisionResponse = !t.collisionResponse || t.collisionResponse, this.collisionFilterGroup = void 0 !== t.collisionFilterGroup ? t.collisionFilterGroup : 1, 
                            this.collisionFilterMask = void 0 !== t.collisionFilterMask ? t.collisionFilterMask : -1, 
                            this.material = t.material ? t.material : null, this.body = null;
                        }
                        t("../math/Vec3"), t("../math/Quaternion"), t("../material/Material"), n.prototype = new o(), 
                        (n.prototype.constructor = n).prototype.updateBoundingSphereRadius = function() {
                            throw "computeBoundingSphereRadius() not implemented for shape type " + this.type;
                        }, n.prototype.volume = function() {
                            throw "volume() not implemented for shape type " + this.type;
                        }, n.prototype.calculateLocalInertia = function(t, e) {
                            throw "calculateLocalInertia() not implemented for shape type " + this.type;
                        }, n.idCounter = 0, n.types = {
                            SPHERE: 1,
                            PLANE: 2,
                            BOX: 4,
                            COMPOUND: 8,
                            CONVEXPOLYHEDRON: 16,
                            HEIGHTFIELD: 32,
                            PARTICLE: 64,
                            CYLINDER: 128,
                            TRIMESH: 256
                        };
                    }, {
                        "../material/Material": 26,
                        "../math/Quaternion": 29,
                        "../math/Vec3": 31,
                        "../utils/EventTarget": 50,
                        "./Shape": 44
                    } ],
                    45: [ function(t, e, i) {
                        e.exports = s;
                        var o = t("./Shape"), n = t("../math/Vec3");
                        function s(t) {
                            if (o.call(this, {
                                type: o.types.SPHERE
                            }), this.radius = void 0 !== t ? t : 1, this.radius < 0) throw new Error("The sphere radius cannot be negative.");
                            this.updateBoundingSphereRadius();
                        }
                        ((s.prototype = new o()).constructor = s).prototype.calculateLocalInertia = function(t, e) {
                            e = e || new n();
                            var i = 2 * t * this.radius * this.radius / 5;
                            return e.x = i, e.y = i, e.z = i, e;
                        }, s.prototype.volume = function() {
                            return 4 * Math.PI * this.radius / 3;
                        }, s.prototype.updateBoundingSphereRadius = function() {
                            this.boundingSphereRadius = this.radius;
                        }, s.prototype.calculateWorldAABB = function(t, e, i, o) {
                            for (var n = this.radius, s = [ "x", "y", "z" ], r = 0; r < s.length; r++) {
                                var a = s[r];
                                i[a] = t[a] - n, o[a] = t[a] + n;
                            }
                        };
                    }, {
                        "../math/Vec3": 31,
                        "./Shape": 44
                    } ],
                    46: [ function(t, e, i) {
                        e.exports = w;
                        var o = t("./Shape"), l = t("../math/Vec3"), n = (t("../math/Quaternion"), t("../math/Transform")), p = t("../collision/AABB"), s = t("../utils/Octree");
                        function w(t, e) {
                            o.call(this, {
                                type: o.types.TRIMESH
                            }), this.vertices = new Float32Array(t), this.indices = new Int16Array(e), this.normals = new Float32Array(e.length), 
                            this.aabb = new p(), this.edges = null, this.scale = new l(1, 1, 1), this.tree = new s(), 
                            this.updateEdges(), this.updateNormals(), this.updateAABB(), this.updateBoundingSphereRadius(), 
                            this.updateTree();
                        }
                        (w.prototype = new o()).constructor = w;
                        var a = new l();
                        w.prototype.updateTree = function() {
                            var t = this.tree;
                            t.reset(), t.aabb.copy(this.aabb);
                            var e = this.scale;
                            t.aabb.lowerBound.x *= 1 / e.x, t.aabb.lowerBound.y *= 1 / e.y, t.aabb.lowerBound.z *= 1 / e.z, 
                            t.aabb.upperBound.x *= 1 / e.x, t.aabb.upperBound.y *= 1 / e.y, t.aabb.upperBound.z *= 1 / e.z;
                            for (var i = new p(), o = new l(), n = new l(), s = new l(), r = [ o, n, s ], a = 0; a < this.indices.length / 3; a++) {
                                var h = 3 * a;
                                this._getUnscaledVertex(this.indices[h], o), this._getUnscaledVertex(this.indices[1 + h], n), 
                                this._getUnscaledVertex(this.indices[2 + h], s), i.setFromPoints(r), t.insert(i, a);
                            }
                            t.removeEmptyNodes();
                        };
                        var h = new p();
                        w.prototype.getTrianglesInAABB = function(t, e) {
                            h.copy(t);
                            var i = this.scale, o = i.x, n = i.y, s = i.z, r = h.lowerBound, a = h.upperBound;
                            return r.x /= o, r.y /= n, r.z /= s, a.x /= o, a.y /= n, a.z /= s, this.tree.aabbQuery(h, e);
                        }, w.prototype.setScale = function(t) {
                            var e = this.scale.x === this.scale.y === this.scale.z, i = t.x === t.y === t.z;
                            e && i || this.updateNormals(), this.scale.copy(t), this.updateAABB(), this.updateBoundingSphereRadius();
                        }, w.prototype.updateNormals = function() {
                            for (var t = a, e = this.normals, i = 0; i < this.indices.length / 3; i++) {
                                var o = 3 * i, n = this.indices[o], s = this.indices[1 + o], r = this.indices[2 + o];
                                this.getVertex(n, v), this.getVertex(s, y), this.getVertex(r, f), w.computeNormal(y, v, f, t), 
                                e[o] = t.x, e[1 + o] = t.y, e[2 + o] = t.z;
                            }
                        }, w.prototype.updateEdges = function() {
                            function t(t, e) {
                                i[n < s ? n + "_" + s : s + "_" + n] = !0;
                            }
                            for (var i = {}, e = 0; e < this.indices.length / 3; e++) {
                                var o = 3 * e, n = this.indices[o], s = this.indices[1 + o];
                                this.indices[2 + o], t(), t(), t();
                            }
                            var r = Object.keys(i);
                            for (this.edges = new Int16Array(2 * r.length), e = 0; e < r.length; e++) {
                                var a = r[e].split("_");
                                this.edges[2 * e] = parseInt(a[0], 10), this.edges[2 * e + 1] = parseInt(a[1], 10);
                            }
                        }, w.prototype.getEdgeVertex = function(t, e, i) {
                            var o = this.edges[2 * t + (e ? 1 : 0)];
                            this.getVertex(o, i);
                        };
                        var r = new l(), c = new l();
                        w.prototype.getEdgeVector = function(t, e) {
                            var i = r, o = c;
                            this.getEdgeVertex(t, 0, i), this.getEdgeVertex(t, 1, o), o.vsub(i, e);
                        };
                        var u = new l(), d = new l();
                        w.computeNormal = function(t, e, i, o) {
                            e.vsub(t, d), i.vsub(e, u), u.cross(d, o), o.isZero() || o.normalize();
                        };
                        var v = new l(), y = new l(), f = new l();
                        w.prototype.getVertex = function(t, e) {
                            var i = this.scale;
                            return this._getUnscaledVertex(t, e), e.x *= i.x, e.y *= i.y, e.z *= i.z, e;
                        }, w.prototype._getUnscaledVertex = function(t, e) {
                            var i = 3 * t, o = this.vertices;
                            return e.set(o[i], o[1 + i], o[2 + i]);
                        }, w.prototype.getWorldVertex = function(t, e, i, o) {
                            return this.getVertex(t, o), n.pointToWorldFrame(e, i, o, o), o;
                        }, w.prototype.getTriangleVertices = function(t, e, i, o) {
                            var n = 3 * t;
                            this.getVertex(this.indices[n], e), this.getVertex(this.indices[1 + n], i), this.getVertex(this.indices[2 + n], o);
                        }, w.prototype.getNormal = function(t, e) {
                            var i = 3 * t;
                            return e.set(this.normals[i], this.normals[1 + i], this.normals[2 + i]);
                        };
                        var m = new p();
                        w.prototype.calculateLocalInertia = function(t, e) {
                            this.computeLocalAABB(m);
                            var i = m.upperBound.x - m.lowerBound.x, o = m.upperBound.y - m.lowerBound.y, n = m.upperBound.z - m.lowerBound.z;
                            return e.set(1 / 12 * t * (2 * o * 2 * o + 2 * n * 2 * n), 1 / 12 * t * (2 * i * 2 * i + 2 * n * 2 * n), 1 / 12 * t * (2 * o * 2 * o + 2 * i * 2 * i));
                        };
                        var g = new l();
                        w.prototype.computeLocalAABB = function(t) {
                            var e = t.lowerBound, i = t.upperBound, o = this.vertices.length, n = (this.vertices, 
                            g);
                            this.getVertex(0, n), e.copy(n), i.copy(n);
                            for (var s = 0; s !== o; s++) this.getVertex(s, n), n.x < e.x ? e.x = n.x : n.x > i.x && (i.x = n.x), 
                            n.y < e.y ? e.y = n.y : n.y > i.y && (i.y = n.y), n.z < e.z ? e.z = n.z : n.z > i.z && (i.z = n.z);
                        }, w.prototype.updateAABB = function() {
                            this.computeLocalAABB(this.aabb);
                        }, w.prototype.updateBoundingSphereRadius = function() {
                            for (var t = 0, e = this.vertices, i = new l(), o = 0, n = e.length / 3; o !== n; o++) {
                                this.getVertex(o, i);
                                var s = i.norm2();
                                t < s && (t = s);
                            }
                            this.boundingSphereRadius = Math.sqrt(t);
                        }, new l();
                        var x = new n(), b = new p();
                        w.prototype.calculateWorldAABB = function(t, e, i, o) {
                            var n = x, s = b;
                            n.position = t, n.quaternion = e, this.aabb.toWorldFrame(n, s), i.copy(s.lowerBound), 
                            o.copy(s.upperBound);
                        }, w.prototype.volume = function() {
                            return 4 * Math.PI * this.boundingSphereRadius / 3;
                        }, w.createTorus = function(t, e, i, o, n) {
                            t = t || 1, e = e || .5, i = i || 8, o = o || 6, n = n || 2 * Math.PI;
                            for (var s = [], r = [], a = 0; a <= i; a++) for (var h = 0; h <= o; h++) {
                                var l = h / o * n, p = a / i * Math.PI * 2, c = (t + e * Math.cos(p)) * Math.cos(l), u = (t + e * Math.cos(p)) * Math.sin(l), d = e * Math.sin(p);
                                s.push(c, u, d);
                            }
                            for (a = 1; a <= i; a++) for (h = 1; h <= o; h++) {
                                var v = (o + 1) * a + h - 1, y = (o + 1) * (a - 1) + h - 1, f = (o + 1) * (a - 1) + h, m = (o + 1) * a + h;
                                r.push(v, y, m), r.push(y, f, m);
                            }
                            return new w(s, r);
                        };
                    }, {
                        "../collision/AABB": 3,
                        "../math/Quaternion": 29,
                        "../math/Transform": 30,
                        "../math/Vec3": 31,
                        "../utils/Octree": 51,
                        "./Shape": 44
                    } ],
                    47: [ function(t, e, i) {
                        e.exports = n, t("../math/Vec3"), t("../math/Quaternion");
                        var o = t("./Solver");
                        function n() {
                            o.call(this), this.iterations = 10, this.tolerance = 1e-7;
                        }
                        n.prototype = new o();
                        var C = [], q = [], F = [];
                        n.prototype.solve = function(t, e) {
                            var i, o, n, s, r, a = 0, h = this.iterations, l = this.tolerance * this.tolerance, p = this.equations, c = p.length, u = e.bodies, d = u.length, v = t;
                            if (0 !== c) for (var y = 0; y !== d; y++) u[y].updateSolveMassProperties();
                            var f = q, m = F, w = C;
                            for (f.length = c, m.length = c, w.length = c, y = 0; y !== c; y++) {
                                var g = p[y];
                                w[y] = 0, m[y] = g.computeB(v), f[y] = 1 / g.computeC();
                            }
                            if (0 !== c) {
                                for (y = 0; y !== d; y++) {
                                    var x = (E = u[y]).vlambda, b = E.wlambda;
                                    x.set(0, 0, 0), b.set(0, 0, 0);
                                }
                                for (a = 0; a !== h; a++) {
                                    for (var B = s = 0; B !== c; B++) g = p[B], i = m[B], o = f[B], (r = w[B]) + (n = o * (i - g.computeGWlambda() - g.eps * r)) < g.minForce ? n = g.minForce - r : r + n > g.maxForce && (n = g.maxForce - r), 
                                    w[B] += n, s += 0 < n ? n : -n, g.addToWlambda(n);
                                    if (s * s < l) break;
                                }
                                for (y = 0; y !== d; y++) {
                                    var E, A = (E = u[y]).velocity, S = E.angularVelocity;
                                    E.vlambda.vmul(E.linearFactor, E.vlambda), A.vadd(E.vlambda, A), E.wlambda.vmul(E.angularFactor, E.wlambda), 
                                    S.vadd(E.wlambda, S);
                                }
                                for (var z = p.length, M = 1 / v; z--; ) p[z].multiplier = w[z] * M;
                            }
                            return a;
                        };
                    }, {
                        "../math/Quaternion": 29,
                        "../math/Vec3": 31,
                        "./Solver": 48
                    } ],
                    48: [ function(t, e, i) {
                        function o() {
                            this.equations = [];
                        }
                        (e.exports = o).prototype.solve = function(t, e) {
                            return 0;
                        }, o.prototype.addEquation = function(t) {
                            t.enabled && this.equations.push(t);
                        }, o.prototype.removeEquation = function(t) {
                            var e = this.equations, i = e.indexOf(t);
                            -1 !== i && e.splice(i, 1);
                        }, o.prototype.removeAllEquations = function() {
                            this.equations.length = 0;
                        };
                    }, {} ],
                    49: [ function(t, e, i) {
                        e.exports = s, t("../math/Vec3"), t("../math/Quaternion");
                        var o = t("./Solver"), n = t("../objects/Body");
                        function s(t) {
                            for (o.call(this), this.iterations = 10, this.tolerance = 1e-7, this.subsolver = t, 
                            this.nodes = [], this.nodePool = []; this.nodePool.length < 128; ) this.nodePool.push(this.createNode());
                        }
                        s.prototype = new o();
                        var b = [], B = [], E = {
                            bodies: []
                        }, r = n.STATIC;
                        function A(t) {
                            for (var e = t.length, i = 0; i !== e; i++) {
                                var o = t[i];
                                if (!(o.visited || o.body.type & r)) return o;
                            }
                            return !1;
                        }
                        var a = [];
                        function S(t, e, i, o) {
                            for (a.push(t), t.visited = !0, e(t, i, o); a.length; ) for (var n, s = a.pop(); n = A(s.children); ) n.visited = !0, 
                            e(n, i, o), a.push(n);
                        }
                        function z(t, e, i) {
                            e.push(t.body);
                            for (var o = t.eqs.length, n = 0; n !== o; n++) {
                                var s = t.eqs[n];
                                -1 === i.indexOf(s) && i.push(s);
                            }
                        }
                        function M(t, e) {
                            return e.id - t.id;
                        }
                        s.prototype.createNode = function() {
                            return {
                                body: null,
                                children: [],
                                eqs: [],
                                visited: !1
                            };
                        }, s.prototype.solve = function(t, e) {
                            for (var i = b, o = this.nodePool, n = e.bodies, s = this.equations, r = s.length, a = n.length, h = this.subsolver; o.length < a; ) o.push(this.createNode());
                            i.length = a;
                            for (var l = 0; l < a; l++) i[l] = o[l];
                            for (l = 0; l !== a; l++) {
                                var p = i[l];
                                p.body = n[l], p.children.length = 0, p.eqs.length = 0, p.visited = !1;
                            }
                            for (var c = 0; c !== r; c++) {
                                var u = s[c], d = (l = n.indexOf(u.bi), n.indexOf(u.bj)), v = i[l], y = i[d];
                                v.children.push(y), v.eqs.push(u), y.children.push(v), y.eqs.push(u);
                            }
                            var f, m = 0, w = B;
                            h.tolerance = this.tolerance, h.iterations = this.iterations;
                            for (var g = E; f = A(i); ) {
                                w.length = 0, g.bodies.length = 0, S(f, z, g.bodies, w);
                                var x = w.length;
                                for (w = w.sort(M), l = 0; l !== x; l++) h.addEquation(w[l]);
                                h.solve(t, g), h.removeAllEquations(), m++;
                            }
                            return m;
                        };
                    }, {
                        "../math/Quaternion": 29,
                        "../math/Vec3": 31,
                        "../objects/Body": 32,
                        "./Solver": 48
                    } ],
                    50: [ function(t, e, i) {
                        function o() {}
                        (e.exports = o).prototype = {
                            constructor: o,
                            addEventListener: function(t, e) {
                                void 0 === this._listeners && (this._listeners = {});
                                var i = this._listeners;
                                return void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e), this;
                            },
                            hasEventListener: function(t, e) {
                                if (void 0 === this._listeners) return !1;
                                var i = this._listeners;
                                return void 0 !== i[t] && -1 !== i[t].indexOf(e);
                            },
                            hasAnyEventListener: function(t) {
                                return void 0 !== this._listeners && void 0 !== this._listeners[t];
                            },
                            removeEventListener: function(t, e) {
                                if (void 0 === this._listeners) return this;
                                var i = this._listeners;
                                if (void 0 === i[t]) return this;
                                var o = i[t].indexOf(e);
                                return -1 !== o && i[t].splice(o, 1), this;
                            },
                            dispatchEvent: function(t) {
                                if (void 0 === this._listeners) return this;
                                var e = this._listeners[t.type];
                                if (void 0 !== e) {
                                    t.target = this;
                                    for (var i = 0, o = e.length; i < o; i++) e[i].call(this, t);
                                }
                                return this;
                            }
                        };
                    }, {} ],
                    51: [ function(t, e, i) {
                        var h = t("../collision/AABB"), l = t("../math/Vec3");
                        function p(t) {
                            t = t || {}, this.root = t.root || null, this.aabb = t.aabb ? t.aabb.clone() : new h(), 
                            this.data = [], this.children = [];
                        }
                        (e.exports = function o(t, e) {
                            (e = e || {}).root = null, e.aabb = t, p.call(this, e), this.maxDepth = void 0 !== e.maxDepth ? e.maxDepth : 8;
                        }).prototype = new p(), p.prototype.reset = function(t, e) {
                            this.children.length = this.data.length = 0;
                        }, p.prototype.insert = function(t, e, i) {
                            var o = this.data;
                            if (i = i || 0, !this.aabb.contains(t)) return !1;
                            var n = this.children;
                            if (i < (this.maxDepth || this.root.maxDepth)) {
                                var s = !1;
                                n.length || (this.subdivide(), s = !0);
                                for (var r = 0; 8 !== r; r++) if (n[r].insert(t, e, i + 1)) return !0;
                                s && (n.length = 0);
                            }
                            return o.push(e), !0;
                        };
                        var c = new l();
                        p.prototype.subdivide = function() {
                            var t = this.aabb, e = t.lowerBound, i = t.upperBound, o = this.children;
                            o.push(new p({
                                aabb: new h({
                                    lowerBound: new l(0, 0, 0)
                                })
                            }), new p({
                                aabb: new h({
                                    lowerBound: new l(1, 0, 0)
                                })
                            }), new p({
                                aabb: new h({
                                    lowerBound: new l(1, 1, 0)
                                })
                            }), new p({
                                aabb: new h({
                                    lowerBound: new l(1, 1, 1)
                                })
                            }), new p({
                                aabb: new h({
                                    lowerBound: new l(0, 1, 1)
                                })
                            }), new p({
                                aabb: new h({
                                    lowerBound: new l(0, 0, 1)
                                })
                            }), new p({
                                aabb: new h({
                                    lowerBound: new l(1, 0, 1)
                                })
                            }), new p({
                                aabb: new h({
                                    lowerBound: new l(0, 1, 0)
                                })
                            })), i.vsub(e, c), c.scale(.5, c);
                            for (var n = this.root || this, s = 0; 8 !== s; s++) {
                                var r = o[s];
                                r.root = n;
                                var a = r.aabb.lowerBound;
                                a.x *= c.x, a.y *= c.y, a.z *= c.z, a.vadd(e, a), a.vadd(c, r.aabb.upperBound);
                            }
                        }, p.prototype.aabbQuery = function(t, e) {
                            this.data, this.children;
                            for (var i = [ this ]; i.length; ) {
                                var o = i.pop();
                                o.aabb.overlaps(t) && Array.prototype.push.apply(e, o.data), Array.prototype.push.apply(i, o.children);
                            }
                            return e;
                        };
                        var n = new h();
                        p.prototype.rayQuery = function(t, e, i) {
                            return t.getAABB(n), n.toLocalFrame(e, n), this.aabbQuery(n, i), i;
                        }, p.prototype.removeEmptyNodes = function() {
                            for (var t = [ this ]; t.length; ) {
                                for (var e = t.pop(), i = e.children.length - 1; 0 <= i; i--) e.children[i].data.length || e.children.splice(i, 1);
                                Array.prototype.push.apply(t, e.children);
                            }
                        };
                    }, {
                        "../collision/AABB": 3,
                        "../math/Vec3": 31
                    } ],
                    52: [ function(t, e, i) {
                        function o() {
                            this.objects = [], this.type = Object;
                        }
                        (e.exports = o).prototype.release = function() {
                            for (var t = arguments.length, e = 0; e !== t; e++) this.objects.push(arguments[e]);
                            return this;
                        }, o.prototype.get = function() {
                            return 0 === this.objects.length ? this.constructObject() : this.objects.pop();
                        }, o.prototype.constructObject = function() {
                            throw new Error("constructObject() not implemented in this Pool subclass yet!");
                        }, o.prototype.resize = function(t) {
                            for (var e = this.objects; e.length > t; ) e.pop();
                            for (;e.length < t; ) e.push(this.constructObject());
                            return this;
                        };
                    }, {} ],
                    53: [ function(t, e, i) {
                        function o() {
                            this.data = {
                                keys: []
                            };
                        }
                        (e.exports = o).prototype.get = function(t, e) {
                            if (e < t) {
                                var i = e;
                                e = t, t = i;
                            }
                            return this.data[t + "-" + e];
                        }, o.prototype.set = function(t, e, i) {
                            if (e < t) {
                                var o = e;
                                e = t, t = o;
                            }
                            var n = t + "-" + e;
                            return this.get(t, e) || this.data.keys.push(n), this.data[n] = i, this.data[n];
                        }, o.prototype.reset = function() {
                            for (var t = this.data, e = t.keys; 0 < e.length; ) delete t[e.pop()];
                        }, o.prototype.getLength = function() {
                            return this.data.keys.length;
                        }, o.prototype.getKeyByIndex = function(t) {
                            return this.data.keys[t];
                        }, o.prototype.getDataByKey = function(t) {
                            return this.data[t];
                        };
                    }, {} ],
                    54: [ function(t, e, i) {
                        (e.exports = function o() {}).defaults = function(t, e) {
                            for (var i in t = t || {}, e) i in t || (t[i] = e[i]);
                            return t;
                        };
                    }, {} ],
                    55: [ function(t, e, i) {
                        e.exports = s;
                        var o = t("../math/Vec3"), n = t("./Pool");
                        function s() {
                            n.call(this), this.type = o;
                        }
                        (s.prototype = new n()).constructObject = function() {
                            return new o();
                        };
                    }, {
                        "../math/Vec3": 31,
                        "./Pool": 52
                    } ],
                    56: [ function(t, e, i) {
                        e.exports = a;
                        var o = t("../collision/AABB"), E = t("../objects/Body"), n = t("../shapes/Shape"), I = t("../collision/Ray"), w = t("../math/Vec3"), N = t("../math/Transform"), s = (t("../shapes/ConvexPolyhedron"), 
                        t("../math/Quaternion")), r = (t("../solver/Solver"), t("../utils/Vec3Pool")), p = t("../equations/ContactEquation"), f = t("../equations/FrictionEquation");
                        function a(t) {
                            this.contactPointPool = [], this.frictionEquationPool = [], this.result = [], this.frictionResult = [], 
                            this.v3pool = new r(), this.world = t, this.currentContactMaterial = null, this.enableFrictionReduction = !1;
                        }
                        a.prototype.createContactEquation = function(t, e, i, o, n, s) {
                            var r;
                            this.contactPointPool.length ? ((r = this.contactPointPool.pop()).bi = t, r.bj = e) : r = new p(t, e);
                            var a = this.currentContactMaterial;
                            r.restitution = a.restitution, r.setSpookParams(a.contactEquationStiffness, a.contactEquationRelaxation, this.world.dt);
                            var h = i.material || t.material, l = o.material || e.material;
                            return h && l && 0 <= h.restitution && 0 <= l.restitution && (r.restitution = h.restitution * l.restitution), 
                            r.si = n || i, r.sj = s || o, r;
                        }, a.prototype.createFrictionEquationsFromContact = function(t, e) {
                            var i = t.bi, o = t.bj, n = t.si, s = t.sj, r = this.world, a = this.currentContactMaterial, h = a.friction, l = n.material || i.material, p = s.material || o.material;
                            if (l && p && 0 <= l.friction && 0 <= p.friction && (h = l.friction * p.friction), 
                            0 < h) {
                                var c = h * r.gravity.length(), u = i.invMass + o.invMass;
                                0 < u && (u = 1 / u);
                                var d = this.frictionEquationPool, v = d.length ? d.pop() : new f(i, o, c * u), y = d.length ? d.pop() : new f(i, o, c * u);
                                return v.bi = y.bi = i, v.bj = y.bj = o, v.minForce = y.minForce = -c * u, v.maxForce = y.maxForce = c * u, 
                                v.ri.copy(t.ri), v.rj.copy(t.rj), y.ri.copy(t.ri), y.rj.copy(t.rj), t.ni.tangents(v.t, y.t), 
                                v.setSpookParams(a.frictionEquationStiffness, a.frictionEquationRelaxation, r.dt), 
                                y.setSpookParams(a.frictionEquationStiffness, a.frictionEquationRelaxation, r.dt), 
                                v.enabled = y.enabled = t.enabled, e.push(v, y), !0;
                            }
                            return !1;
                        };
                        var h = new w(), l = new w(), c = new w();
                        a.prototype.createFrictionFromAverage = function(t) {
                            var e = this.result[this.result.length - 1];
                            if (this.createFrictionEquationsFromContact(e, this.frictionResult) && 1 !== t) {
                                var i = this.frictionResult[this.frictionResult.length - 2], o = this.frictionResult[this.frictionResult.length - 1];
                                h.setZero(), l.setZero(), c.setZero();
                                for (var n = e.bi, s = (e.bj, 0); s !== t; s++) (e = this.result[this.result.length - 1 - s]).bodyA !== n ? (h.vadd(e.ni, h), 
                                l.vadd(e.ri, l), c.vadd(e.rj, c)) : (h.vsub(e.ni, h), l.vadd(e.rj, l), c.vadd(e.ri, c));
                                var r = 1 / t;
                                l.scale(r, i.ri), c.scale(r, i.rj), o.ri.copy(i.ri), o.rj.copy(i.rj), h.normalize(), 
                                h.tangents(i.t, o.t);
                            }
                        };
                        var A = new w(), S = new w(), z = new s(), M = new s();
                        a.prototype.getContacts = function(t, e, i, o, n, s, r) {
                            this.frictionEquationPool = r, this.result = o, this.frictionResult = s;
                            for (var a = z, h = M, l = A, p = S, c = 0, u = t.length; c !== u; c++) {
                                var d = t[c], v = e[c], y = null;
                                d.material && v.material && (y = i.getContactMaterial(d.material, v.material) || null);
                                for (var f = 0 == d.collisionResponse || 0 == v.collisionResponse || d.type & E.KINEMATIC && v.type & E.STATIC || d.type & E.STATIC && v.type & E.KINEMATIC || d.type & E.KINEMATIC && v.type & E.KINEMATIC, m = 0; m < d.shapes.length; m++) {
                                    d.quaternion.mult(d.shapeOrientations[m], a), d.quaternion.vmult(d.shapeOffsets[m], l), 
                                    l.vadd(d.position, l);
                                    for (var w = d.shapes[m], g = 0; g < v.shapes.length; g++) {
                                        v.quaternion.mult(v.shapeOrientations[g], h), v.quaternion.vmult(v.shapeOffsets[g], p), 
                                        p.vadd(v.position, p);
                                        var x = v.shapes[g];
                                        if (w.collisionFilterMask & x.collisionFilterGroup && x.collisionFilterMask & w.collisionFilterGroup && !(l.distanceTo(p) > w.boundingSphereRadius + x.boundingSphereRadius)) {
                                            f |= 0 == w.collisionResponse || 0 == x.collisionResponse;
                                            var b = null;
                                            w.material && x.material && (b = i.getContactMaterial(w.material, x.material) || null), 
                                            this.currentContactMaterial = b || y || i.defaultContactMaterial;
                                            var B = this[w.type | x.type];
                                            B && (w.type < x.type ? B.call(this, w, x, l, p, a, h, d, v, w, x, f) : B.call(this, x, w, p, l, h, a, v, d, w, x, f)) && f && (i.shapeOverlapKeeper.set(w.id, x.id), 
                                            i.shapeOverlapKeeperExit.set(w.id, x.id));
                                        }
                                    }
                                }
                            }
                        }, a.prototype[n.types.BOX | n.types.BOX] = a.prototype.boxBox = function(t, e, i, o, n, s, r, a, h, l, p) {
                            return t.convexPolyhedronRepresentation.material = t.material, e.convexPolyhedronRepresentation.material = e.material, 
                            t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, 
                            this.convexConvex(t.convexPolyhedronRepresentation, e.convexPolyhedronRepresentation, i, o, n, s, r, a, t, e, p);
                        }, a.prototype[n.types.BOX | n.types.CONVEXPOLYHEDRON] = a.prototype.boxConvex = function(t, e, i, o, n, s, r, a, h, l, p) {
                            return t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, 
                            this.convexConvex(t.convexPolyhedronRepresentation, e, i, o, n, s, r, a, t, e, p);
                        }, a.prototype[n.types.BOX | n.types.PARTICLE] = a.prototype.boxParticle = function(t, e, i, o, n, s, r, a, h, l, p) {
                            return t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, 
                            this.convexParticle(t.convexPolyhedronRepresentation, e, i, o, n, s, r, a, t, e, p);
                        }, a.prototype[n.types.SPHERE] = a.prototype.sphereSphere = function(t, e, i, o, n, s, r, a, h, l, p) {
                            if (p) return i.distanceSquared(o) < Math.pow(t.radius + e.radius, 2);
                            var c = this.createContactEquation(r, a, t, e, h, l);
                            o.vsub(i, c.ni), c.ni.normalize(), c.ri.copy(c.ni), c.rj.copy(c.ni), c.ri.mult(t.radius, c.ri), 
                            c.rj.mult(-e.radius, c.rj), c.ri.vadd(i, c.ri), c.ri.vsub(r.position, c.ri), c.rj.vadd(o, c.rj), 
                            c.rj.vsub(a.position, c.rj), this.result.push(c), this.createFrictionEquationsFromContact(c, this.frictionResult);
                        };
                        var g = new w(), x = new w(), b = new w();
                        a.prototype[n.types.PLANE | n.types.TRIMESH] = a.prototype.planeTrimesh = function(t, e, i, o, n, s, r, a, h, l, p) {
                            var c = new w(), u = g;
                            u.set(0, 0, 1), n.vmult(u, u);
                            for (var d = 0; d < e.vertices.length / 3; d++) {
                                e.getVertex(d, c);
                                var v = new w();
                                v.copy(c), N.pointToWorldFrame(o, s, v, c);
                                var y = x;
                                if (c.vsub(i, y), u.dot(y) <= 0) {
                                    if (p) return !0;
                                    var f = this.createContactEquation(r, a, t, e, h, l);
                                    f.ni.copy(u);
                                    var m = b;
                                    u.scale(y.dot(u), m), c.vsub(m, m), f.ri.copy(m), f.ri.vsub(r.position, f.ri), f.rj.copy(c), 
                                    f.rj.vsub(a.position, f.rj), this.result.push(f), this.createFrictionEquationsFromContact(f, this.frictionResult);
                                }
                            }
                        };
                        var L = new w(), W = new w(), j = (new w(), new w()), O = new w(), k = new w(), _ = new w(), D = new w(), U = new w(), H = new w(), G = new w(), X = new w(), Q = new w(), Y = new w(), K = new o(), Z = [];
                        a.prototype[n.types.SPHERE | n.types.TRIMESH] = a.prototype.sphereTrimesh = function(t, e, i, o, n, s, r, a, h, l, p) {
                            var c = k, u = _, d = D, v = U, y = H, f = G, m = K, w = O, g = W, x = Z;
                            N.pointToLocalFrame(o, s, i, y);
                            var b = t.radius;
                            m.lowerBound.set(y.x - b, y.y - b, y.z - b), m.upperBound.set(y.x + b, y.y + b, y.z + b), 
                            e.getTrianglesInAABB(m, x);
                            for (var B = j, E = t.radius * t.radius, A = 0; A < x.length; A++) for (var S = 0; S < 3; S++) if (e.getVertex(e.indices[3 * x[A] + S], B), 
                            B.vsub(y, g), g.norm2() <= E) {
                                if (w.copy(B), N.pointToWorldFrame(o, s, w, B), B.vsub(i, g), p) return !0;
                                (C = this.createContactEquation(r, a, t, e, h, l)).ni.copy(g), C.ni.normalize(), 
                                C.ri.copy(C.ni), C.ri.scale(t.radius, C.ri), C.ri.vadd(i, C.ri), C.ri.vsub(r.position, C.ri), 
                                C.rj.copy(B), C.rj.vsub(a.position, C.rj), this.result.push(C), this.createFrictionEquationsFromContact(C, this.frictionResult);
                            }
                            for (A = 0; A < x.length; A++) for (S = 0; S < 3; S++) {
                                e.getVertex(e.indices[3 * x[A] + S], c), e.getVertex(e.indices[3 * x[A] + (S + 1) % 3], u), 
                                u.vsub(c, d), y.vsub(u, f);
                                var z = f.dot(d);
                                y.vsub(c, f);
                                var M = f.dot(d);
                                if (0 < M && z < 0 && (y.vsub(c, f), v.copy(d), v.normalize(), M = f.dot(v), v.scale(M, f), 
                                f.vadd(c, f), (V = f.distanceTo(y)) < t.radius)) {
                                    if (p) return !0;
                                    var C = this.createContactEquation(r, a, t, e, h, l);
                                    f.vsub(y, C.ni), C.ni.normalize(), C.ni.scale(t.radius, C.ri), N.pointToWorldFrame(o, s, f, f), 
                                    f.vsub(a.position, C.rj), N.vectorToWorldFrame(s, C.ni, C.ni), N.vectorToWorldFrame(s, C.ri, C.ri), 
                                    this.result.push(C), this.createFrictionEquationsFromContact(C, this.frictionResult);
                                }
                            }
                            for (var q = X, F = Q, R = Y, T = L, P = (A = 0, x.length); A !== P; A++) {
                                e.getTriangleVertices(x[A], q, F, R), e.getNormal(x[A], T), y.vsub(q, f);
                                var V = f.dot(T);
                                if (T.scale(V, f), y.vsub(f, f), V = f.distanceTo(y), I.pointInTriangle(f, q, F, R) && V < t.radius) {
                                    if (p) return !0;
                                    C = this.createContactEquation(r, a, t, e, h, l), f.vsub(y, C.ni), C.ni.normalize(), 
                                    C.ni.scale(t.radius, C.ri), N.pointToWorldFrame(o, s, f, f), f.vsub(a.position, C.rj), 
                                    N.vectorToWorldFrame(s, C.ni, C.ni), N.vectorToWorldFrame(s, C.ri, C.ri), this.result.push(C), 
                                    this.createFrictionEquationsFromContact(C, this.frictionResult);
                                }
                            }
                            x.length = 0;
                        };
                        var v = new w(), y = new w(), m = new w(), B = new w(), C = new w();
                        a.prototype[n.types.SPHERE | n.types.PLANE] = a.prototype.spherePlane = function(t, e, i, o, n, s, r, a, h, l, p) {
                            if (m.set(0, 0, 1), s.vmult(m, m), m.negate(m), m.normalize(), m.mult(t.radius, B), 
                            i.vsub(o, v), m.mult(m.dot(v), y), v.vsub(y, C), -v.dot(m) <= t.radius) {
                                if (p) return !0;
                                var c = this.createContactEquation(r, a, t, e, h, l);
                                c.ni.copy(m), c.ri.copy(B), c.rj.copy(C);
                                var u = c.ri, d = c.rj;
                                u.vadd(i, u), u.vsub(r.position, u), d.vadd(o, d), d.vsub(a.position, d), this.result.push(c), 
                                this.createFrictionEquationsFromContact(c, this.frictionResult);
                            }
                        };
                        var u = new w(), d = new w(), q = new w();
                        function J(t, e, i) {
                            for (var o = null, n = t.length, s = 0; s !== n; s++) {
                                var r = t[s], a = u;
                                t[(s + 1) % n].vsub(r, a);
                                var h = d;
                                a.cross(e, h);
                                var l = q;
                                i.vsub(r, l);
                                var p = h.dot(l);
                                if (!(null === o || 0 < p && !0 === o || p <= 0 && !1 === o)) return !1;
                                null === o && (o = 0 < p);
                            }
                            return !0;
                        }
                        var $ = new w(), tt = new w(), et = new w(), it = new w(), ot = [ new w(), new w(), new w(), new w(), new w(), new w() ], nt = new w(), st = new w(), rt = new w(), at = new w();
                        a.prototype[n.types.SPHERE | n.types.BOX] = a.prototype.sphereBox = function(t, e, i, o, n, s, r, a, h, l, p) {
                            var c = this.v3pool, u = ot;
                            i.vsub(o, $), e.getSideNormals(u, s);
                            for (var d = t.radius, v = !1, y = st, f = rt, m = at, w = null, g = 0, x = 0, b = 0, B = null, E = 0, A = u.length; E !== A && !1 === v; E++) {
                                var S = tt;
                                S.copy(u[E]);
                                var z = S.norm();
                                S.normalize();
                                var M = $.dot(S);
                                if (M < z + d && 0 < M) {
                                    var C = et, q = it;
                                    C.copy(u[(E + 1) % 3]), q.copy(u[(E + 2) % 3]);
                                    var F = C.norm(), R = q.norm();
                                    C.normalize(), q.normalize();
                                    var T = $.dot(C), P = $.dot(q);
                                    if (T < F && -F < T && P < R && -R < P) {
                                        var V = Math.abs(M - z - d);
                                        if ((null === B || V < B) && (B = V, x = T, b = P, w = z, y.copy(S), f.copy(C), 
                                        m.copy(q), g++, p)) return !0;
                                    }
                                }
                            }
                            if (g) {
                                v = !0;
                                var I = this.createContactEquation(r, a, t, e, h, l);
                                y.mult(-d, I.ri), I.ni.copy(y), I.ni.negate(I.ni), y.mult(w, y), f.mult(x, f), y.vadd(f, y), 
                                m.mult(b, m), y.vadd(m, I.rj), I.ri.vadd(i, I.ri), I.ri.vsub(r.position, I.ri), 
                                I.rj.vadd(o, I.rj), I.rj.vsub(a.position, I.rj), this.result.push(I), this.createFrictionEquationsFromContact(I, this.frictionResult);
                            }
                            for (var N = c.get(), L = nt, W = 0; 2 !== W && !v; W++) for (var j = 0; 2 !== j && !v; j++) for (var O = 0; 2 !== O && !v; O++) if (N.set(0, 0, 0), 
                            W ? N.vadd(u[0], N) : N.vsub(u[0], N), j ? N.vadd(u[1], N) : N.vsub(u[1], N), O ? N.vadd(u[2], N) : N.vsub(u[2], N), 
                            o.vadd(N, L), L.vsub(i, L), L.norm2() < d * d) {
                                if (p) return !0;
                                v = !0, (I = this.createContactEquation(r, a, t, e, h, l)).ri.copy(L), I.ri.normalize(), 
                                I.ni.copy(I.ri), I.ri.mult(d, I.ri), I.rj.copy(N), I.ri.vadd(i, I.ri), I.ri.vsub(r.position, I.ri), 
                                I.rj.vadd(o, I.rj), I.rj.vsub(a.position, I.rj), this.result.push(I), this.createFrictionEquationsFromContact(I, this.frictionResult);
                            }
                            c.release(N), N = null;
                            var k = c.get(), _ = c.get(), D = (I = c.get(), c.get()), U = (V = c.get(), u.length);
                            for (W = 0; W !== U && !v; W++) for (j = 0; j !== U && !v; j++) if (W % 3 != j % 3) {
                                u[j].cross(u[W], k), k.normalize(), u[W].vadd(u[j], _), I.copy(i), I.vsub(_, I), 
                                I.vsub(o, I);
                                var H = I.dot(k);
                                for (k.mult(H, D), O = 0; O === W % 3 || O === j % 3; ) O++;
                                V.copy(i), V.vsub(D, V), V.vsub(_, V), V.vsub(o, V);
                                var G = Math.abs(H), X = V.norm();
                                if (G < u[O].norm() && X < d) {
                                    if (p) return !0;
                                    v = !0;
                                    var Q = this.createContactEquation(r, a, t, e, h, l);
                                    _.vadd(D, Q.rj), Q.rj.copy(Q.rj), V.negate(Q.ni), Q.ni.normalize(), Q.ri.copy(Q.rj), 
                                    Q.ri.vadd(o, Q.ri), Q.ri.vsub(i, Q.ri), Q.ri.normalize(), Q.ri.mult(d, Q.ri), Q.ri.vadd(i, Q.ri), 
                                    Q.ri.vsub(r.position, Q.ri), Q.rj.vadd(o, Q.rj), Q.rj.vsub(a.position, Q.rj), this.result.push(Q), 
                                    this.createFrictionEquationsFromContact(Q, this.frictionResult);
                                }
                            }
                            c.release(k, _, I, D, V);
                        };
                        var ht = new w(), lt = new w(), pt = new w(), ct = new w(), ut = new w(), dt = new w(), vt = new w(), yt = new w(), ft = new w(), mt = new w();
                        a.prototype[n.types.SPHERE | n.types.CONVEXPOLYHEDRON] = a.prototype.sphereConvex = function(t, e, i, o, n, s, r, a, h, l, p) {
                            var c = this.v3pool;
                            i.vsub(o, ht);
                            for (var u = e.faceNormals, d = e.faces, v = e.vertices, y = t.radius, f = 0; f !== v.length; f++) {
                                var m = v[f], w = ut;
                                s.vmult(m, w), o.vadd(w, w);
                                var g = ct;
                                if (w.vsub(i, g), g.norm2() < y * y) return !!p || (x = !0, (V = this.createContactEquation(r, a, t, e, h, l)).ri.copy(g), 
                                V.ri.normalize(), V.ni.copy(V.ri), V.ri.mult(y, V.ri), w.vsub(o, V.rj), V.ri.vadd(i, V.ri), 
                                V.ri.vsub(r.position, V.ri), V.rj.vadd(o, V.rj), V.rj.vsub(a.position, V.rj), this.result.push(V), 
                                void this.createFrictionEquationsFromContact(V, this.frictionResult));
                            }
                            for (var x = !1, b = (f = 0, d.length); f !== b && !1 === x; f++) {
                                var B = u[f], E = d[f], A = dt;
                                s.vmult(B, A);
                                var S = vt;
                                s.vmult(v[E[0]], S), S.vadd(o, S);
                                var z = yt;
                                A.mult(-y, z), i.vadd(z, z);
                                var M = ft;
                                z.vsub(S, M);
                                var C = M.dot(A), q = mt;
                                if (i.vsub(S, q), C < 0 && 0 < q.dot(A)) {
                                    for (var F = [], R = 0, T = E.length; R !== T; R++) {
                                        var P = c.get();
                                        s.vmult(v[E[R]], P), o.vadd(P, P), F.push(P);
                                    }
                                    if (J(F, A, i)) {
                                        if (p) return !0;
                                        x = !0;
                                        var V = this.createContactEquation(r, a, t, e, h, l);
                                        A.mult(-y, V.ri), A.negate(V.ni);
                                        var I = c.get();
                                        A.mult(-C, I);
                                        var N = c.get();
                                        A.mult(-y, N), i.vsub(o, V.rj), V.rj.vadd(N, V.rj), V.rj.vadd(I, V.rj), V.rj.vadd(o, V.rj), 
                                        V.rj.vsub(a.position, V.rj), V.ri.vadd(i, V.ri), V.ri.vsub(r.position, V.ri), c.release(I), 
                                        c.release(N), this.result.push(V), this.createFrictionEquationsFromContact(V, this.frictionResult), 
                                        R = 0;
                                        for (var L = F.length; R !== L; R++) c.release(F[R]);
                                        return;
                                    }
                                    for (R = 0; R !== E.length; R++) {
                                        var W = c.get(), j = c.get();
                                        s.vmult(v[E[(R + 1) % E.length]], W), s.vmult(v[E[(R + 2) % E.length]], j), o.vadd(W, W), 
                                        o.vadd(j, j);
                                        var O = lt;
                                        j.vsub(W, O);
                                        var k = pt;
                                        O.unit(k);
                                        var _ = c.get(), D = c.get();
                                        i.vsub(W, D);
                                        var U = D.dot(k);
                                        k.mult(U, _), _.vadd(W, _);
                                        var H = c.get();
                                        if (_.vsub(i, H), 0 < U && U * U < O.norm2() && H.norm2() < y * y) {
                                            if (p) return !0;
                                            for (V = this.createContactEquation(r, a, t, e, h, l), _.vsub(o, V.rj), _.vsub(i, V.ni), 
                                            V.ni.normalize(), V.ni.mult(y, V.ri), V.rj.vadd(o, V.rj), V.rj.vsub(a.position, V.rj), 
                                            V.ri.vadd(i, V.ri), V.ri.vsub(r.position, V.ri), this.result.push(V), this.createFrictionEquationsFromContact(V, this.frictionResult), 
                                            R = 0, L = F.length; R !== L; R++) c.release(F[R]);
                                            return c.release(W), c.release(j), c.release(_), c.release(H), void c.release(D);
                                        }
                                        c.release(W), c.release(j), c.release(_), c.release(H), c.release(D);
                                    }
                                    for (R = 0, L = F.length; R !== L; R++) c.release(F[R]);
                                }
                            }
                        }, new w(), new w(), a.prototype[n.types.PLANE | n.types.BOX] = a.prototype.planeBox = function(t, e, i, o, n, s, r, a, h, l, p) {
                            return e.convexPolyhedronRepresentation.material = e.material, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, 
                            e.convexPolyhedronRepresentation.id = e.id, this.planeConvex(t, e.convexPolyhedronRepresentation, i, o, n, s, r, a, t, e, p);
                        };
                        var F = new w(), R = new w(), T = new w(), P = new w();
                        a.prototype[n.types.PLANE | n.types.CONVEXPOLYHEDRON] = a.prototype.planeConvex = function(t, e, i, o, n, s, r, a, h, l, p) {
                            var c = F, u = R;
                            u.set(0, 0, 1), n.vmult(u, u);
                            for (var d = 0, v = T, y = 0; y !== e.vertices.length; y++) if (c.copy(e.vertices[y]), 
                            s.vmult(c, c), o.vadd(c, c), c.vsub(i, v), u.dot(v) <= 0) {
                                if (p) return !0;
                                var f = this.createContactEquation(r, a, t, e, h, l), m = P;
                                u.mult(u.dot(v), m), c.vsub(m, m), m.vsub(i, f.ri), f.ni.copy(u), c.vsub(o, f.rj), 
                                f.ri.vadd(i, f.ri), f.ri.vsub(r.position, f.ri), f.rj.vadd(o, f.rj), f.rj.vsub(a.position, f.rj), 
                                this.result.push(f), d++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(f, this.frictionResult);
                            }
                            this.enableFrictionReduction && d && this.createFrictionFromAverage(d);
                        };
                        var V = new w(), wt = new w();
                        a.prototype[n.types.CONVEXPOLYHEDRON] = a.prototype.convexConvex = function(t, e, i, o, n, s, r, a, h, l, p, c, u) {
                            var d = V;
                            if (!(i.distanceTo(o) > t.boundingSphereRadius + e.boundingSphereRadius) && t.findSeparatingAxis(e, i, n, o, s, d, c, u)) {
                                var v = [], y = wt;
                                t.clipAgainstHull(i, n, e, o, s, d, -100, 100, v);
                                for (var f = 0, m = 0; m !== v.length; m++) {
                                    if (p) return !0;
                                    var w = this.createContactEquation(r, a, t, e, h, l), g = w.ri, x = w.rj;
                                    d.negate(w.ni), v[m].normal.negate(y), y.mult(v[m].depth, y), v[m].point.vadd(y, g), 
                                    x.copy(v[m].point), g.vsub(i, g), x.vsub(o, x), g.vadd(i, g), g.vsub(r.position, g), 
                                    x.vadd(o, x), x.vsub(a.position, x), this.result.push(w), f++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(w, this.frictionResult);
                                }
                                this.enableFrictionReduction && f && this.createFrictionFromAverage(f);
                            }
                        };
                        var gt = new w(), xt = new w(), bt = new w();
                        a.prototype[n.types.PLANE | n.types.PARTICLE] = a.prototype.planeParticle = function(t, e, i, o, n, s, r, a, h, l, p) {
                            var c = gt;
                            c.set(0, 0, 1), r.quaternion.vmult(c, c);
                            var u = xt;
                            if (o.vsub(r.position, u), c.dot(u) <= 0) {
                                if (p) return !0;
                                var d = this.createContactEquation(a, r, e, t, h, l);
                                d.ni.copy(c), d.ni.negate(d.ni), d.ri.set(0, 0, 0);
                                var v = bt;
                                c.mult(c.dot(o), v), o.vsub(v, v), d.rj.copy(v), this.result.push(d), this.createFrictionEquationsFromContact(d, this.frictionResult);
                            }
                        };
                        var Bt = new w();
                        a.prototype[n.types.PARTICLE | n.types.SPHERE] = a.prototype.sphereParticle = function(t, e, i, o, n, s, r, a, h, l, p) {
                            var c = Bt;
                            if (c.set(0, 0, 1), o.vsub(i, c), c.norm2() <= t.radius * t.radius) {
                                if (p) return !0;
                                var u = this.createContactEquation(a, r, e, t, h, l);
                                c.normalize(), u.rj.copy(c), u.rj.mult(t.radius, u.rj), u.ni.copy(c), u.ni.negate(u.ni), 
                                u.ri.set(0, 0, 0), this.result.push(u), this.createFrictionEquationsFromContact(u, this.frictionResult);
                            }
                        };
                        var Et = new s(), At = new w(), St = (new w(), new w()), zt = new w(), Mt = new w();
                        a.prototype[n.types.PARTICLE | n.types.CONVEXPOLYHEDRON] = a.prototype.convexParticle = function(t, e, i, o, n, s, r, a, h, l, p) {
                            var c = -1, u = St, d = Mt, v = null, y = At;
                            if (y.copy(o), y.vsub(i, y), n.conjugate(Et), Et.vmult(y, y), t.pointIsInside(y)) {
                                t.worldVerticesNeedsUpdate && t.computeWorldVertices(i, n), t.worldFaceNormalsNeedsUpdate && t.computeWorldFaceNormals(n);
                                for (var f = 0, m = t.faces.length; f !== m; f++) {
                                    var w = [ t.worldVertices[t.faces[f][0]] ], g = t.worldFaceNormals[f];
                                    o.vsub(w[0], zt);
                                    var x = -g.dot(zt);
                                    if (null === v || Math.abs(x) < Math.abs(v)) {
                                        if (p) return !0;
                                        v = x, c = f, u.copy(g);
                                    }
                                }
                                if (-1 !== c) {
                                    var b = this.createContactEquation(a, r, e, t, h, l);
                                    u.mult(v, d), d.vadd(o, d), d.vsub(i, d), b.rj.copy(d), u.negate(b.ni), b.ri.set(0, 0, 0);
                                    var B = b.ri, E = b.rj;
                                    B.vadd(o, B), B.vsub(a.position, B), E.vadd(i, E), E.vsub(r.position, E), this.result.push(b), 
                                    this.createFrictionEquationsFromContact(b, this.frictionResult);
                                } else console.warn("Point found inside convex, but did not find penetrating face!");
                            }
                        }, a.prototype[n.types.BOX | n.types.HEIGHTFIELD] = a.prototype.boxHeightfield = function(t, e, i, o, n, s, r, a, h, l, p) {
                            return t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, 
                            this.convexHeightfield(t.convexPolyhedronRepresentation, e, i, o, n, s, r, a, t, e, p);
                        };
                        var Ct = new w(), qt = new w(), Ft = [ 0 ];
                        a.prototype[n.types.CONVEXPOLYHEDRON | n.types.HEIGHTFIELD] = a.prototype.convexHeightfield = function(t, e, i, o, n, s, r, a, h, l, p) {
                            var c = e.data, u = e.elementSize, d = t.boundingSphereRadius, v = qt, y = Ft, f = Ct;
                            N.pointToLocalFrame(o, s, i, f);
                            var m = Math.floor((f.x - d) / u) - 1, w = Math.ceil((f.x + d) / u) + 1, g = Math.floor((f.y - d) / u) - 1, x = Math.ceil((f.y + d) / u) + 1;
                            if (!(w < 0 || x < 0 || m > c.length || g > c[0].length)) {
                                m < 0 && (m = 0), w < 0 && (w = 0), g < 0 && (g = 0), x < 0 && (x = 0), m >= c.length && (m = c.length - 1), 
                                w >= c.length && (w = c.length - 1), x >= c[0].length && (x = c[0].length - 1), 
                                g >= c[0].length && (g = c[0].length - 1);
                                var b = [];
                                e.getRectMinMax(m, g, w, x, b);
                                var B = b[0], E = b[1];
                                if (!(f.z - d > E || f.z + d < B)) for (var A = m; A < w; A++) for (var S = g; S < x; S++) {
                                    var z = !1;
                                    if (e.getConvexTrianglePillar(A, S, !1), N.pointToWorldFrame(o, s, e.pillarOffset, v), 
                                    i.distanceTo(v) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (z = this.convexConvex(t, e.pillarConvex, i, v, n, s, r, a, null, null, p, y, null)), 
                                    p && z) return !0;
                                    if (e.getConvexTrianglePillar(A, S, !0), N.pointToWorldFrame(o, s, e.pillarOffset, v), 
                                    i.distanceTo(v) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (z = this.convexConvex(t, e.pillarConvex, i, v, n, s, r, a, null, null, p, y, null)), 
                                    p && z) return !0;
                                }
                            }
                        };
                        var Rt = new w(), Tt = new w();
                        a.prototype[n.types.SPHERE | n.types.HEIGHTFIELD] = a.prototype.sphereHeightfield = function(t, e, i, o, n, s, r, a, h, l, p) {
                            var c = e.data, u = t.radius, d = e.elementSize, v = Tt, y = Rt;
                            N.pointToLocalFrame(o, s, i, y);
                            var f = Math.floor((y.x - u) / d) - 1, m = Math.ceil((y.x + u) / d) + 1, w = Math.floor((y.y - u) / d) - 1, g = Math.ceil((y.y + u) / d) + 1;
                            if (!(m < 0 || g < 0 || f > c.length || g > c[0].length)) {
                                f < 0 && (f = 0), m < 0 && (m = 0), w < 0 && (w = 0), g < 0 && (g = 0), f >= c.length && (f = c.length - 1), 
                                m >= c.length && (m = c.length - 1), g >= c[0].length && (g = c[0].length - 1), 
                                w >= c[0].length && (w = c[0].length - 1);
                                var x = [];
                                e.getRectMinMax(f, w, m, g, x);
                                var b = x[0], B = x[1];
                                if (!(y.z - u > B || y.z + u < b)) for (var E = this.result, A = f; A < m; A++) for (var S = w; S < g; S++) {
                                    var z = E.length, M = !1;
                                    if (e.getConvexTrianglePillar(A, S, !1), N.pointToWorldFrame(o, s, e.pillarOffset, v), 
                                    i.distanceTo(v) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (M = this.sphereConvex(t, e.pillarConvex, i, v, n, s, r, a, t, e, p)), 
                                    p && M) return !0;
                                    if (e.getConvexTrianglePillar(A, S, !0), N.pointToWorldFrame(o, s, e.pillarOffset, v), 
                                    i.distanceTo(v) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (M = this.sphereConvex(t, e.pillarConvex, i, v, n, s, r, a, t, e, p)), 
                                    p && M) return !0;
                                    if (2 < E.length - z) return;
                                }
                            }
                        };
                    }, {
                        "../collision/AABB": 3,
                        "../collision/Ray": 10,
                        "../equations/ContactEquation": 20,
                        "../equations/FrictionEquation": 22,
                        "../math/Quaternion": 29,
                        "../math/Transform": 30,
                        "../math/Vec3": 31,
                        "../objects/Body": 32,
                        "../shapes/ConvexPolyhedron": 39,
                        "../shapes/Shape": 44,
                        "../solver/Solver": 48,
                        "../utils/Vec3Pool": 55
                    } ],
                    57: [ function(w, g, t) {
                        (function(t) {
                            g.exports = d, w("../shapes/Shape");
                            var e = w("../math/Vec3"), i = (w("../math/Quaternion"), w("../solver/GSSolver")), o = (w("../equations/ContactEquation"), 
                            w("../equations/FrictionEquation"), w("./Narrowphase")), n = w("../utils/EventTarget"), s = (w("../collision/ArrayCollisionMatrix"), 
                            w("../collision/ObjectCollisionMatrix")), r = w("../collision/OverlapKeeper"), a = w("../material/Material"), h = w("../material/ContactMaterial"), P = w("../objects/Body"), l = w("../utils/TupleDictionary"), p = w("../collision/RaycastResult"), c = (w("../collision/AABB"), 
                            w("../collision/Ray")), u = w("../collision/NaiveBroadphase");
                            function d(t) {
                                t = t || {}, n.apply(this), this.dt = -1, this.allowSleep = !!t.allowSleep, this.contacts = [], 
                                this.frictionEquations = [], this.contactsDic = new l(), this.oldContactsDic = new l(), 
                                this.quatNormalizeSkip = void 0 !== t.quatNormalizeSkip ? t.quatNormalizeSkip : 0, 
                                this.quatNormalizeFast = void 0 !== t.quatNormalizeFast && t.quatNormalizeFast, 
                                this.time = 0, this.stepnumber = 0, this.default_dt = 1 / 60, this.nextId = 0, this.gravity = new e(), 
                                t.gravity && this.gravity.copy(t.gravity), this.broadphase = void 0 !== t.broadphase ? t.broadphase : new u(), 
                                this.bodies = [], this.solver = void 0 !== t.solver ? t.solver : new i(), this.constraints = [], 
                                this.narrowphase = new o(this), this.collisionMatrix = new s(), this.triggerMatrix = new s(), 
                                this.shapeOverlapKeeper = new r(), this.shapeOverlapKeeperExit = new r(), this.materials = [], 
                                this.contactmaterials = [], this.contactMaterialTable = new l(), this.defaultMaterial = new a("default"), 
                                this.defaultContactMaterial = new h(this.defaultMaterial, this.defaultMaterial, {
                                    friction: .3,
                                    restitution: 0
                                }), this.profile = {
                                    solve: 0,
                                    makeContactConstraints: 0,
                                    broadphase: 0,
                                    integrate: 0,
                                    narrowphase: 0
                                }, this.accumulator = 0, this.subsystems = [], this.addBodyEvent = {
                                    type: "addBody",
                                    body: null
                                }, this.removeBodyEvent = {
                                    type: "removeBody",
                                    body: null
                                }, this.broadphase.setWorld(this);
                            }
                            t ? (t.doProfiling = !1, t.DEBUG = !0) : window && (window.doProfiling = !1, window.DEBUG = !0), 
                            d.idToBodyMap = {}, d.idToShapeMap = {}, d.prototype = new n();
                            var v = new c();
                            d.prototype.getContactMaterial = function(t, e) {
                                return this.contactMaterialTable.get(t.id, e.id);
                            }, d.prototype.numObjects = function() {
                                return this.bodies.length;
                            }, d.prototype.collisionMatrixTick = function() {}, d.prototype.add = d.prototype.addBody = function(t) {
                                -1 === this.bodies.indexOf(t) && (t.index = this.bodies.length, this.bodies.push(t), 
                                t.world = this, t.initPosition.copy(t.position), t.initVelocity.copy(t.velocity), 
                                t.timeLastSleepy = this.time, t instanceof P && (t.initAngularVelocity.copy(t.angularVelocity), 
                                t.initQuaternion.copy(t.quaternion)), this.collisionMatrix.setNumObjects(this.bodies.length), 
                                this.addBodyEvent.body = t, d.idToBodyMap[t.id] = t, this.dispatchEvent(this.addBodyEvent));
                            }, d.prototype.addConstraint = function(t) {
                                this.constraints.push(t);
                            }, d.prototype.removeConstraint = function(t) {
                                var e = this.constraints.indexOf(t);
                                -1 !== e && this.constraints.splice(e, 1);
                            }, d.prototype.rayTest = function(t, e, i) {
                                i instanceof p ? this.raycastClosest(t, e, {
                                    skipBackfaces: !0
                                }, i) : this.raycastAll(t, e, {
                                    skipBackfaces: !0
                                }, i);
                            }, d.prototype.raycastAll = function(t, e, i, o) {
                                return i.mode = c.ALL, i.from = t, i.to = e, i.callback = o, v.intersectWorld(this, i);
                            }, d.prototype.raycastAny = function(t, e, i, o) {
                                return i.mode = c.ANY, i.from = t, i.to = e, i.result = o, v.intersectWorld(this, i);
                            }, d.prototype.raycastClosest = function(t, e, i, o) {
                                return i.mode = c.CLOSEST, i.from = t, i.to = e, i.result = o, v.intersectWorld(this, i);
                            }, d.prototype.removeBody = d.prototype.remove = function(t) {
                                t.world = null;
                                var e = this.bodies.length - 1, i = this.bodies, o = i.indexOf(t);
                                if (-1 !== o) {
                                    i.splice(o, 1);
                                    for (var n = 0; n !== i.length; n++) i[n].index = n;
                                    this.collisionMatrix.setNumObjects(e), this.removeBodyEvent.body = t, delete d.idToBodyMap[t.id], 
                                    this.dispatchEvent(this.removeBodyEvent);
                                }
                            }, d.prototype.getBodyById = function(t) {
                                return d.idToBodyMap[t];
                            }, d.prototype.getShapeById = function(t) {
                                return d.idToShapeMap[t];
                            }, d.prototype.addMaterial = function(t) {
                                this.materials.push(t);
                            }, d.prototype.addContactMaterial = function(t) {
                                this.contactmaterials.push(t), this.contactMaterialTable.set(t.materials[0].id, t.materials[1].id, t);
                            }, d.prototype.step = function(t, e, i) {
                                if (i = i || 10, e = e || 0, b = this.contacts.slice(), 0 === e) this.internalStep(t), 
                                this.time += t; else {
                                    this.accumulator += e;
                                    for (var o = 0; this.accumulator >= t && o < i; ) this.internalStep(t), this.accumulator -= t, 
                                    o++;
                                    for (var n = this.accumulator % t / t, s = 0; s !== this.bodies.length; s++) {
                                        var r = this.bodies[s];
                                        r.previousPosition.lerp(r.position, n, r.interpolatedPosition), r.previousQuaternion.slerp(r.quaternion, n, r.interpolatedQuaternion), 
                                        r.previousQuaternion.normalize();
                                    }
                                    this.time += e;
                                }
                                for (var a, h, l = this.contacts, p = this.contacts.length; p--; ) {
                                    var c = (g = l[p]).si, u = g.sj, d = this.contactsDic.get(c.id, u.id);
                                    null == d && (d = this.contactsDic.set(c.id, u.id, [])), d.push(g);
                                }
                                for (this.emitTriggeredEvents(), p = this.contactsDic.getLength(); p--; ) if (a = this.contactsDic.getKeyByIndex(p), 
                                null != (h = this.contactsDic.getDataByKey(a))) {
                                    var v = h[0].bi, y = h[0].bj;
                                    if (c = h[0].si, u = h[0].sj, v.allowSleep && v.type === P.DYNAMIC && v.sleepState === P.SLEEPING && y.sleepState === P.AWAKE && y.type !== P.STATIC) {
                                        var f = y.velocity.norm2() + y.angularVelocity.norm2();
                                        2 * Math.pow(y.sleepSpeedLimit, 2) <= f && v.wakeUp();
                                    }
                                    if (y.allowSleep && y.type === P.DYNAMIC && y.sleepState === P.SLEEPING && v.sleepState === P.AWAKE && v.type !== P.STATIC) {
                                        var m = v.velocity.norm2() + v.angularVelocity.norm2();
                                        2 * Math.pow(v.sleepSpeedLimit, 2) <= m && y.wakeUp();
                                    }
                                    this.collisionMatrix.get(v, y) ? x.event = "onCollisionStay" : (this.collisionMatrix.set(v, y, !0), 
                                    x.event = "onCollisionEnter"), x.contacts = h, x.body = u.body, x.selfShape = c, 
                                    x.otherShape = u, c.body.dispatchEvent(x), x.body = c.body, x.selfShape = u, x.otherShape = c, 
                                    u.body.dispatchEvent(x);
                                }
                                var w = b;
                                for (p = w.length; p--; ) {
                                    var g;
                                    c = (g = w[p]).si, u = g.sj, null == this.oldContactsDic.get(c.id, u.id) && this.oldContactsDic.set(c.id, u.id, g);
                                }
                                for (p = this.oldContactsDic.getLength(); p--; ) a = this.oldContactsDic.getKeyByIndex(p), 
                                null == this.contactsDic.getDataByKey(a) && (v = (h = this.oldContactsDic.getDataByKey(a)).bi, 
                                y = h.bj, c = h.si, u = h.sj, this.collisionMatrix.get(v, y) && (v.isSleeping() && y.isSleeping() || (this.collisionMatrix.set(v, y, !1), 
                                x.event = "onCollisionExit", x.body = u.body, x.selfShape = c, x.otherShape = u, 
                                x.contacts.length = 0, x.contacts.push(h), c.body.dispatchEvent(x), x.body = c.body, 
                                x.selfShape = u, x.otherShape = c, u.body.dispatchEvent(x))));
                                this.contactsDic.reset(), this.oldContactsDic.reset(), this.shapeOverlapKeeper.reset();
                            };
                            var x = {
                                type: "collide",
                                event: "",
                                body: null,
                                selfShape: null,
                                otherShape: null,
                                contacts: null
                            }, b = [], V = [], I = [], N = [];
                            d.prototype.internalStep = function(t) {
                                this.dt = t;
                                var e = this.contacts, i = I, o = N, n = this.numObjects(), s = this.bodies, r = this.solver, a = this.gravity, h = (this.profile, 
                                P.DYNAMIC), l = this.constraints, p = V, c = a.x, u = a.y, d = a.z, v = 0;
                                for (v = 0; v !== n; v++) if ((z = s[v]).useGravity && z.type === h) {
                                    var y = z.force, f = z.mass;
                                    y.x += f * c, y.y += f * u, y.z += f * d;
                                }
                                v = 0;
                                for (var m = this.subsystems.length; v !== m; v++) this.subsystems[v].update();
                                i.length = 0, o.length = 0, this.broadphase.collisionPairs(this, i, o);
                                var w = l.length;
                                for (v = 0; v !== w; v++) if (!(B = l[v]).collideConnected) for (var g = i.length - 1; 0 <= g; g -= 1) (B.bodyA === i[g] && B.bodyB === o[g] || B.bodyB === i[g] && B.bodyA === o[g]) && (i.splice(g, 1), 
                                o.splice(g, 1));
                                this.shapeOverlapKeeperExit.tick(), e.length = 0;
                                var x = this.frictionEquations.length;
                                for (v = 0; v !== x; v++) p.push(this.frictionEquations[v]);
                                for (this.frictionEquations.length = 0, this.narrowphase.getContacts(i, o, this, e, null, this.frictionEquations, p), 
                                v = 0; v < this.frictionEquations.length; v++) r.addEquation(this.frictionEquations[v]);
                                var b = e.length;
                                for (v = 0; v !== b; v++) r.addEquation(e[v]);
                                for (w = l.length, v = 0; v !== w; v++) {
                                    var B;
                                    (B = l[v]).update(), g = 0;
                                    for (var E = B.equations.length; g !== E; g++) {
                                        var A = B.equations[g];
                                        r.addEquation(A);
                                    }
                                }
                                r.solve(t, this), r.removeAllEquations();
                                var S = Math.pow;
                                for (n = this.numObjects(), v = 0; v !== n; v++) {
                                    var z;
                                    if ((z = s[v]).type & h) {
                                        var M = S(1 - z.linearDamping, t), C = z.velocity;
                                        C.mult(M, C);
                                        var q = z.angularVelocity;
                                        if (q) {
                                            var F = S(1 - z.angularDamping, t);
                                            q.mult(F, q);
                                        }
                                    }
                                }
                                var R = this.stepnumber % (this.quatNormalizeSkip + 1) == 0, T = this.quatNormalizeFast;
                                for (v = 0; v !== n; v++) s[v].integrate(t, R, T);
                                if (this.clearForces(), this.broadphase.dirty = !0, this.time += t, this.stepnumber += 1, 
                                this.allowSleep) for (v = 0; v !== n; v++) s[v].sleepTick(this.time);
                            };
                            var y = [], f = [], m = {
                                type: "triggered",
                                event: "",
                                selfBody: null,
                                otherBody: null,
                                selfShape: null,
                                otherShape: null
                            };
                            d.prototype.emitTriggeredEvents = function() {
                                y.length = f.length = 0, this.shapeOverlapKeeperExit.getDiff(y, f);
                                for (var t = 0, e = f.length; t < e; t += 2) {
                                    m.event = "onTriggerExit";
                                    var i = this.getShapeById(f[t]), o = this.getShapeById(f[t + 1]);
                                    this.triggerMatrix.set(i, o, !1), m.selfShape = i, m.otherShape = o, m.selfBody = i.body, 
                                    m.otherBody = o.body, i.dispatchEvent(m), m.selfShape = o, m.otherShape = i, m.selfBody = o.body, 
                                    m.otherBody = i.body, o.dispatchEvent(m);
                                }
                                for (y.length = f.length = 0, this.shapeOverlapKeeper.getDiff(y, f), t = 0, e = y.length; t < e; t += 2) {
                                    var n = y[t], s = y[t + 1];
                                    i = this.getShapeById(n), o = this.getShapeById(s), this.triggerMatrix.get(i, o) ? m.event = "onTriggerStay" : (this.triggerMatrix.set(i, o, !0), 
                                    m.event = "onTriggerEnter"), m.selfShape = i, m.otherShape = o, m.selfBody = i.body, 
                                    m.otherBody = o.body, i.dispatchEvent(m), m.selfShape = o, m.otherShape = i, m.selfBody = o.body, 
                                    m.otherBody = i.body, o.dispatchEvent(m);
                                }
                            }, d.prototype.clearForces = function() {
                                for (var t = this.bodies, e = t.length, i = 0; i !== e; i++) {
                                    var o = t[i];
                                    o.force.set(0, 0, 0), o.torque.set(0, 0, 0);
                                }
                            };
                        }).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
                    }, {
                        "../collision/AABB": 3,
                        "../collision/ArrayCollisionMatrix": 4,
                        "../collision/NaiveBroadphase": 7,
                        "../collision/ObjectCollisionMatrix": 8,
                        "../collision/OverlapKeeper": 9,
                        "../collision/Ray": 10,
                        "../collision/RaycastResult": 11,
                        "../equations/ContactEquation": 20,
                        "../equations/FrictionEquation": 22,
                        "../material/ContactMaterial": 25,
                        "../material/Material": 26,
                        "../math/Quaternion": 29,
                        "../math/Vec3": 31,
                        "../objects/Body": 32,
                        "../shapes/Shape": 44,
                        "../solver/GSSolver": 47,
                        "../utils/EventTarget": 50,
                        "../utils/TupleDictionary": 53,
                        "./Narrowphase": 56
                    } ]
                }, {}, [ 2 ])(2);
            });
            cannon_min.CANNON, cannon_min.Shape;
            function stringfyVec3(value) {
                return Vec3.strictEquals(value, new Vec3()) ? "<origin>" : "(x: ".concat(value.x, ", y: ").concat(value.y, ", z: ").concat(value.z, ")");
            }
            function setWrap(object, wrapper) {
                object.__cc_wrapper__ = wrapper;
            }
            function getWrap(object) {
                return object.__cc_wrapper__;
            }
            !function(ERigidBodyType) {
                ERigidBodyType[ERigidBodyType.DYNAMIC = 1] = "DYNAMIC", ERigidBodyType[ERigidBodyType.STATIC = 2] = "STATIC", 
                ERigidBodyType[ERigidBodyType.KINEMATIC = 4] = "KINEMATIC";
            }(ERigidBodyType = ERigidBodyType || {}), function(ETransformSource) {
                ETransformSource[ETransformSource.SCENE = 0] = "SCENE", ETransformSource[ETransformSource.PHYSIC = 1] = "PHYSIC";
            }(ETransformSource = ETransformSource || {});
            var CannonRigidBody = function() {
                function CannonRigidBody(options) {
                    _classCallCheck(this, CannonRigidBody), this._body = void 0, this._onCollidedListener = void 0, 
                    this._collisionCallbacks = [], this._shapes = [], this._userData = void 0, this._world = null, 
                    this._name = void 0, options = options || {}, this._name = options.name || "", this._body = new cannon_min.Body({
                        type: ERigidBodyType.DYNAMIC
                    }), setWrap(this._body, this), this._body.sleepSpeedLimit = .1, this._body.sleepTimeLimit = 1, 
                    this._onCollidedListener = this._onCollided.bind(this);
                }
                return _createClass(CannonRigidBody, [ {
                    key: "impl",
                    get: function get() {
                        return this._body;
                    }
                } ]), _createClass(CannonRigidBody, [ {
                    key: "getAllowSleep",
                    value: function getAllowSleep() {
                        return this._body.allowSleep;
                    }
                }, {
                    key: "setAllowSleep",
                    value: function setAllowSleep(v) {
                        this._body.isSleeping() && this._body.wakeUp(), this._body.allowSleep = v;
                    }
                }, {
                    key: "getGroup",
                    value: function getGroup() {
                        return this._body.collisionFilterGroup;
                    }
                }, {
                    key: "setGroup",
                    value: function setGroup(v) {
                        this._body.collisionFilterGroup = v;
                    }
                }, {
                    key: "addGroup",
                    value: function addGroup(v) {
                        this._body.collisionFilterGroup |= v;
                    }
                }, {
                    key: "removeGroup",
                    value: function removeGroup(v) {
                        this._body.collisionFilterGroup &= ~v;
                    }
                }, {
                    key: "getMask",
                    value: function getMask() {
                        return this._body.collisionFilterMask;
                    }
                }, {
                    key: "setMask",
                    value: function setMask(v) {
                        this._body.collisionFilterMask = v;
                    }
                }, {
                    key: "addMask",
                    value: function addMask(v) {
                        this._body.collisionFilterMask |= v;
                    }
                }, {
                    key: "removeMask",
                    value: function removeMask(v) {
                        this._body.collisionFilterMask &= ~v;
                    }
                }, {
                    key: "wakeUp",
                    value: function wakeUp() {
                        return this._body.wakeUp();
                    }
                }, {
                    key: "sleep",
                    value: function sleep() {
                        return this._body.sleep();
                    }
                }, {
                    key: "name",
                    value: function name() {
                        return this._name;
                    }
                }, {
                    key: "getType",
                    value: function getType() {
                        return this._body.type;
                    }
                }, {
                    key: "setType",
                    value: function setType(v) {
                        this._body.type = v;
                    }
                }, {
                    key: "isAwake",
                    value: function isAwake() {
                        return this._body.isAwake();
                    }
                }, {
                    key: "isSleepy",
                    value: function isSleepy() {
                        return this._body.isSleepy();
                    }
                }, {
                    key: "isSleeping",
                    value: function isSleeping() {
                        return this._body.isSleeping();
                    }
                }, {
                    key: "addShape",
                    value: function addShape(shape, offset) {
                        this._shapes.push(shape), null != offset ? this._body.addShape(shape.impl, Vec3.copy(_tCannonV1, offset)) : this._body.addShape(shape.impl), 
                        shape.setBody(this._body, this._shapes.length - 1);
                    }
                }, {
                    key: "removeShape",
                    value: function removeShape(shape) {
                        var index = this._shapes.indexOf(shape);
                        0 <= index && (this._shapes.splice(index, 1), this._body.removeShape(shape.impl), 
                        shape.setBody(null, -1));
                    }
                }, {
                    key: "getMass",
                    value: function getMass() {
                        return this._body.mass;
                    }
                }, {
                    key: "setMass",
                    value: function setMass(value) {
                        this._body.isSleeping() && this._body.wakeUp(), this._body.mass = value, this._body.updateMassProperties();
                    }
                }, {
                    key: "getIsKinematic",
                    value: function getIsKinematic() {
                        return this._body.type === cannon_min.Body.KINEMATIC;
                    }
                }, {
                    key: "setIsKinematic",
                    value: function setIsKinematic(value) {
                        this._body.type = value ? cannon_min.Body.KINEMATIC : cannon_min.Body.DYNAMIC;
                    }
                }, {
                    key: "getLinearDamping",
                    value: function getLinearDamping() {
                        return this._body.linearDamping;
                    }
                }, {
                    key: "setLinearDamping",
                    value: function setLinearDamping(value) {
                        this._body.linearDamping = value;
                    }
                }, {
                    key: "getAngularDamping",
                    value: function getAngularDamping() {
                        return this._body.angularDamping;
                    }
                }, {
                    key: "setAngularDamping",
                    value: function setAngularDamping(value) {
                        this._body.angularDamping = value;
                    }
                }, {
                    key: "getUseGravity",
                    value: function getUseGravity() {
                        return this._body.useGravity;
                    }
                }, {
                    key: "setUseGravity",
                    value: function setUseGravity(value) {
                        this._body.isSleeping() && this._body.wakeUp(), this._body.useGravity = value;
                    }
                }, {
                    key: "getCollisionResponse",
                    value: function getCollisionResponse() {
                        return this._body.collisionResponse;
                    }
                }, {
                    key: "setCollisionResponse",
                    value: function setCollisionResponse(value) {
                        this._body.isSleeping() && this._body.wakeUp(), this._body.collisionResponse = !value;
                    }
                }, {
                    key: "getLinearVelocity",
                    value: function getLinearVelocity(out) {
                        return Vec3.copy(out, this._body.velocity), out;
                    }
                }, {
                    key: "setLinearVelocity",
                    value: function setLinearVelocity(value) {
                        this._body.isSleeping() && this._body.wakeUp(), Vec3.copy(this._body.velocity, value);
                    }
                }, {
                    key: "getAngularVelocity",
                    value: function getAngularVelocity(out) {
                        return Vec3.copy(out, this._body.angularVelocity), out;
                    }
                }, {
                    key: "setAngularVelocity",
                    value: function setAngularVelocity(value) {
                        this._body.isSleeping() && this._body.wakeUp(), Vec3.copy(this._body.angularVelocity, value);
                    }
                }, {
                    key: "getLinearFactor",
                    value: function getLinearFactor(out) {
                        return Vec3.copy(out, this._body.linearFactor), out;
                    }
                }, {
                    key: "setLinearFactor",
                    value: function setLinearFactor(value) {
                        this._body.isSleeping() && this._body.wakeUp(), Vec3.copy(this._body.linearFactor, value);
                    }
                }, {
                    key: "getAngularFactor",
                    value: function getAngularFactor(out) {
                        return Vec3.copy(out, this._body.angularFactor), out;
                    }
                }, {
                    key: "setAngularFactor",
                    value: function setAngularFactor(value) {
                        this._body.isSleeping() && this._body.wakeUp(), Vec3.copy(this._body.angularFactor, value);
                    }
                }, {
                    key: "getFreezeRotation",
                    value: function getFreezeRotation() {
                        return this._body.fixedRotation;
                    }
                }, {
                    key: "setFreezeRotation",
                    value: function setFreezeRotation(value) {
                        this._body.isSleeping() && this._body.wakeUp(), this._body.fixedRotation = value, 
                        this._body.updateMassProperties();
                    }
                }, {
                    key: "applyForce",
                    value: function applyForce(force, worldPoint) {
                        null == worldPoint && (worldPoint = Vec3.ZERO), this._body.isSleeping() && this._body.wakeUp(), 
                        this._body.applyForce(Vec3.copy(_tCannonV1, force), Vec3.copy(_tCannonV2, worldPoint));
                    }
                }, {
                    key: "applyImpulse",
                    value: function applyImpulse(impulse, worldPoint) {
                        null == worldPoint && (worldPoint = Vec3.ZERO), this._body.isSleeping() && this._body.wakeUp(), 
                        this._body.applyImpulse(Vec3.copy(_tCannonV1, impulse), Vec3.copy(_tCannonV2, worldPoint));
                    }
                }, {
                    key: "applyLocalForce",
                    value: function applyLocalForce(force, localPoint) {
                        null == localPoint && (localPoint = Vec3.ZERO), this._body.isSleeping() && this._body.wakeUp(), 
                        this._body.applyLocalForce(Vec3.copy(_tCannonV1, force), Vec3.copy(_tCannonV2, localPoint));
                    }
                }, {
                    key: "applyLocalImpulse",
                    value: function applyLocalImpulse(impulse, localPoint) {
                        null == localPoint && (localPoint = Vec3.ZERO), this._body.isSleeping() && this._body.wakeUp(), 
                        this._body.applyLocalImpulse(Vec3.copy(_tCannonV1, impulse), Vec3.copy(_tCannonV2, localPoint));
                    }
                }, {
                    key: "applyTorque",
                    value: function applyTorque(torque) {
                        this._body.isSleeping() && this._body.wakeUp(), this._body.torque.x += torque.x, 
                        this._body.torque.y += torque.y, this._body.torque.z += torque.z;
                    }
                }, {
                    key: "applyLocalTorque",
                    value: function applyLocalTorque(torque) {
                        this._body.isSleeping() && this._body.wakeUp(), Vec3.copy(_tCannonV1, torque), this._body.vectorToWorldFrame(_tCannonV1, _tCannonV1), 
                        this._body.torque.x += _tCannonV1.x, this._body.torque.y += _tCannonV1.y, this._body.torque.z += _tCannonV1.z;
                    }
                }, {
                    key: "setWorld",
                    value: function setWorld(world) {
                        this._world && (this._body.removeEventListener("collide", this._onCollidedListener), 
                        this._body.world.remove(this._body), this._world = null);
                        var cworld = world;
                        cworld && (cworld.impl.addBody(this._body), this._body.addEventListener("collide", this._onCollidedListener), 
                        null == this._body.material && (this._body.material = cworld.impl.defaultMaterial)), 
                        this._world = cworld;
                    }
                }, {
                    key: "getPosition",
                    value: function getPosition(out) {
                        Vec3.copy(out, this._body.position);
                    }
                }, {
                    key: "setPosition",
                    value: function setPosition(value) {
                        Vec3.copy(this._body.position, value);
                    }
                }, {
                    key: "getRotation",
                    value: function getRotation(out) {
                        Quat.copy(out, this._body.quaternion);
                    }
                }, {
                    key: "setRotation",
                    value: function setRotation(value) {
                        Quat.copy(this._body.quaternion, value);
                    }
                }, {
                    key: "translateAndRotate",
                    value: function translateAndRotate(m, rot) {
                        Mat4.getTranslation(this._body.position, m), Quat.copy(this._body.quaternion, rot);
                    }
                }, {
                    key: "scaleAllShapes",
                    value: function scaleAllShapes(scale) {
                        var _iterator = this._shapes, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            _ref.setScale(scale);
                        }
                    }
                }, {
                    key: "addCollisionCallback",
                    value: function addCollisionCallback(callback) {
                        this._collisionCallbacks.push(callback);
                    }
                }, {
                    key: "removeCollisionCllback",
                    value: function removeCollisionCllback(callback) {
                        var i = this._collisionCallbacks.indexOf(callback);
                        0 <= i && this._collisionCallbacks.splice(i, 1);
                    }
                }, {
                    key: "getUserData",
                    value: function getUserData() {
                        return this._userData;
                    }
                }, {
                    key: "setUserData",
                    value: function setUserData(data) {
                        this._userData = data;
                    }
                }, {
                    key: "_stringfyThis",
                    value: function _stringfyThis() {
                        return "".concat(this._name.length ? this._name : "<No-name>");
                    }
                }, {
                    key: "_devStrinfy",
                    value: function _devStrinfy() {
                        var shapes = this._body.shapes.map(function(s) {
                            return getWrap(s)._devStrinfy();
                        }).join("; ");
                        return "Name: [[".concat(this._name.length ? this._name : "<No-name>", "]], position: ").concat(stringfyVec3(this._body.position), ", shapes: [").concat(shapes, "]");
                    }
                }, {
                    key: "_onCollided",
                    value: function _onCollided(event) {
                        CollisionEventObject.type = event.event, CollisionEventObject.selfCollider = getWrap(event.selfShape).getUserData(), 
                        CollisionEventObject.otherCollider = getWrap(event.otherShape).getUserData();
                        var i = 0;
                        for (i = CollisionEventObject.contacts.length; i--; ) contactsPool.push(CollisionEventObject.contacts.pop());
                        for (i = 0; i < event.contacts.length; i++) {
                            var cq = event.contacts[i];
                            if (0 < contactsPool.length) {
                                var c = contactsPool.pop();
                                Vec3.copy(c.contactA, cq.ri), Vec3.copy(c.contactB, cq.rj), Vec3.copy(c.normal, cq.ni), 
                                CollisionEventObject.contacts.push(c);
                            } else {
                                var _c = {
                                    contactA: Vec3.copy(new Vec3(), cq.ri),
                                    contactB: Vec3.copy(new Vec3(), cq.rj),
                                    normal: Vec3.copy(new Vec3(), cq.ni)
                                };
                                CollisionEventObject.contacts.push(_c);
                            }
                        }
                        for (i = 0; i < this._collisionCallbacks.length; i++) {
                            (0, this._collisionCallbacks[i])(CollisionEventObject);
                        }
                    }
                } ]), CannonRigidBody;
            }(), CollisionEventObject = {
                type: "onCollisionEnter",
                selfCollider: null,
                otherCollider: null,
                contacts: []
            }, contactsPool = [], _tCannonV1 = new cannon_min.Vec3(), _tCannonV2 = new cannon_min.Vec3(), RaycastResult = function() {
                function RaycastResult() {
                    _classCallCheck(this, RaycastResult), this._hitPoint = new Vec3(), this._distance = 0, 
                    this._collidier = null, this._node = null;
                }
                return _createClass(RaycastResult, [ {
                    key: "_assign",
                    value: function _assign(hitPoint, distance, shape, body) {
                        Vec3.copy(this._hitPoint, hitPoint), this._distance = distance, this._node = body.getUserData(), 
                        this._collidier = shape.getUserData();
                    }
                }, {
                    key: "hitPoint",
                    get: function get() {
                        return this._hitPoint;
                    }
                }, {
                    key: "distance",
                    get: function get() {
                        return this._distance;
                    }
                }, {
                    key: "collider",
                    get: function get() {
                        return this._collidier;
                    }
                }, {
                    key: "node",
                    get: function get() {
                        return this._node;
                    }
                } ]), RaycastResult;
            }();
            function toCannonRaycastOptions(options) {
                return function toCannonOptions(options, optionsRename) {
                    for (var result = {}, _i = 0, _Object$keys = Object.keys(options); _i < _Object$keys.length; _i++) {
                        var key = _Object$keys[_i], destKey = key;
                        if (optionsRename) {
                            var rename = optionsRename[key];
                            rename && (destKey = rename);
                        }
                        result[destKey] = options[key];
                    }
                    return result;
                }(options, {
                    queryTriggerInteraction: "checkCollisionResponse"
                });
            }
            function fillRaycastResult(result, cannonResult) {
                result._assign(cannonResult.hitPointWorld, cannonResult.distance, getWrap(cannonResult.shape), getWrap(cannonResult.body));
            }
            function commitShapeUpdates(body) {
                body.updateMassProperties(), body.updateBoundingRadius(), body.aabbNeedsUpdate = !0;
            }
            var CannonShape = function() {
                function CannonShape() {
                    _classCallCheck(this, CannonShape), this._scale = new Vec3(1, 1, 1), this._shape = null, 
                    this._body = null, this._index = -1, this._center = new Vec3(0, 0, 0), this._userData = void 0, 
                    this._onTriggerListener = void 0, this._triggeredCB = [], this._onTriggerListener = this.onTrigger.bind(this);
                }
                return _createClass(CannonShape, [ {
                    key: "impl",
                    get: function get() {
                        return this._shape;
                    }
                }, {
                    key: "material",
                    set: function set(mat) {
                        null == mat ? this._shape.material = null : (null == CannonShape.idToMaterial[mat._uuid] && (CannonShape.idToMaterial[mat._uuid] = new cannon_min.Material(mat._uuid)), 
                        this._shape.material = CannonShape.idToMaterial[mat._uuid], this._shape.material.friction = mat.friction, 
                        this._shape.material.restitution = mat.restitution);
                    }
                } ]), _createClass(CannonShape, [ {
                    key: "addTriggerCallback",
                    value: function addTriggerCallback(callback) {
                        this._triggeredCB.push(callback);
                    }
                }, {
                    key: "removeTriggerCallback",
                    value: function removeTriggerCallback(callback) {
                        var i = this._triggeredCB.indexOf(callback);
                        0 <= i && this._triggeredCB.splice(i, 1);
                    }
                }, {
                    key: "getUserData",
                    value: function getUserData() {
                        return this._userData;
                    }
                }, {
                    key: "setUserData",
                    value: function setUserData(data) {
                        this._userData = data;
                    }
                }, {
                    key: "setBody",
                    value: function setBody(body, index) {
                        null == body ? this._shape.removeEventListener("triggered", this._onTriggerListener) : this._shape.addEventListener("triggered", this._onTriggerListener), 
                        this._body = body, this._index = index;
                    }
                }, {
                    key: "setCenter",
                    value: function setCenter(center) {
                        Vec3.copy(this._center, center), this._recalcCenter();
                    }
                }, {
                    key: "setScale",
                    value: function setScale(scale) {
                        Vec3.copy(this._scale, scale), this._recalcCenter();
                    }
                }, {
                    key: "setRotation",
                    value: function setRotation() {}
                }, {
                    key: "getCollisionResponse",
                    value: function getCollisionResponse() {
                        return this.impl.collisionResponse;
                    }
                }, {
                    key: "setCollisionResponse",
                    value: function setCollisionResponse(v) {
                        this.impl.collisionResponse = v;
                    }
                }, {
                    key: "_devStrinfy",
                    value: function _devStrinfy() {
                        return this._body ? "centerOffset: ".concat(stringfyVec3(this._body.shapeOffsets[this._index])) : "<NotAttached>";
                    }
                }, {
                    key: "onTrigger",
                    value: function onTrigger(event) {
                        TriggerEventObject.type = event.event, TriggerEventObject.selfCollider = getWrap(event.selfShape).getUserData(), 
                        TriggerEventObject.otherCollider = getWrap(event.otherShape).getUserData();
                        var _iterator = this._triggeredCB, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            _ref(TriggerEventObject);
                        }
                    }
                }, {
                    key: "_recalcCenter",
                    value: function _recalcCenter() {
                        if (this._body) {
                            var shapeOffset = this._body.shapeOffsets[this._index];
                            Vec3.copy(shapeOffset, this._center), Vec3.multiply(shapeOffset, shapeOffset, this._scale), 
                            commitShapeUpdates(this._body);
                        }
                    }
                } ]), CannonShape;
            }();
            CannonShape.idToMaterial = {};
            var _class$1z, _class2$1j, _descriptor$1f, _descriptor2$15, _class3$A, _temp$1r, TriggerEventObject = {
                type: "",
                selfCollider: null,
                otherCollider: null
            }, CannonWorld = function() {
                function CannonWorld() {
                    _classCallCheck(this, CannonWorld), this._world = void 0, this._customBeforeStepListener = [], 
                    this._customAfterStepListener = [], this._raycastResult = new cannon_min.RaycastResult(), 
                    this._world = new cannon_min.World(), setWrap(this._world, this), this._world.broadphase = new cannon_min.NaiveBroadphase();
                }
                return _createClass(CannonWorld, [ {
                    key: "impl",
                    get: function get() {
                        return this._world;
                    }
                } ]), _createClass(CannonWorld, [ {
                    key: "getAllowSleep",
                    value: function getAllowSleep() {
                        return this._world.allowSleep;
                    }
                }, {
                    key: "setAllowSleep",
                    value: function setAllowSleep(v) {
                        this._world.allowSleep = v;
                    }
                }, {
                    key: "setGravity",
                    value: function setGravity(gravity) {
                        Vec3.copy(this._world.gravity, gravity);
                    }
                }, {
                    key: "getGravity",
                    value: function getGravity(out) {
                        Vec3.copy(out, this._world.gravity);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {}
                }, {
                    key: "step",
                    value: function step(deltaTime, time, maxSubStep) {
                        this._callCustomBeforeSteps(), this._world.step(deltaTime, time, maxSubStep), this._callCustomAfterSteps();
                    }
                }, {
                    key: "addBeforeStep",
                    value: function addBeforeStep(cb) {
                        this._customBeforeStepListener.push(cb);
                    }
                }, {
                    key: "removeBeforeStep",
                    value: function removeBeforeStep(cb) {
                        var i = this._customBeforeStepListener.indexOf(cb);
                        i < 0 || this._customBeforeStepListener.splice(i, 1);
                    }
                }, {
                    key: "addAfterStep",
                    value: function addAfterStep(cb) {
                        this._customAfterStepListener.push(cb);
                    }
                }, {
                    key: "removeAfterStep",
                    value: function removeAfterStep(cb) {
                        var i = this._customAfterStepListener.indexOf(cb);
                        i < 0 || this._customAfterStepListener.splice(i, 1);
                    }
                }, {
                    key: "raycastClosest",
                    value: function raycastClosest(from, to, options, result) {
                        var hit = this._world.raycastClosest(from, to, toCannonRaycastOptions(options), this._raycastResult);
                        return hit && fillRaycastResult(result, this._raycastResult), hit;
                    }
                }, {
                    key: "raycastAny",
                    value: function raycastAny(from, to, options, result) {
                        var hit = this._world.raycastAny(from, to, toCannonRaycastOptions(options), this._raycastResult);
                        return hit && fillRaycastResult(result, this._raycastResult), hit;
                    }
                }, {
                    key: "raycastAll",
                    value: function raycastAll(from, to, options, callback) {
                        return this._world.raycastAll(from, to, toCannonRaycastOptions(options), function(cannonResult) {
                            var result = new RaycastResult();
                            fillRaycastResult(result, cannonResult), callback(result);
                        });
                    }
                }, {
                    key: "addConstraint",
                    value: function addConstraint(constraint) {
                        this._world.addConstraint(constraint.impl);
                    }
                }, {
                    key: "removeConstraint",
                    value: function removeConstraint(constraint) {
                        this._world.removeConstraint(constraint.impl);
                    }
                }, {
                    key: "_callCustomBeforeSteps",
                    value: function _callCustomBeforeSteps() {
                        this._customBeforeStepListener.forEach(function(fx) {
                            return fx();
                        });
                    }
                }, {
                    key: "_callCustomAfterSteps",
                    value: function _callCustomAfterSteps() {
                        this._customAfterStepListener.forEach(function(fx) {
                            return fx();
                        });
                    }
                }, {
                    key: "defaultMaterial",
                    set: function set(mat) {
                        this._world.defaultMaterial.friction = mat.friction, this._world.defaultMaterial.restitution = mat.restitution, 
                        null != CannonShape.idToMaterial[mat._uuid] && (CannonShape.idToMaterial[mat._uuid] = this._world.defaultMaterial);
                    }
                } ]), CannonWorld;
            }();
            (function instantiate$1(boxShape, sphereShape, body, world) {
                BoxShape = boxShape, SphereShape = sphereShape, RigidBody = body, PhysicsWorld = world;
            })(function() {
                function CannonBoxShape(size) {
                    var _this;
                    return _classCallCheck(this, CannonBoxShape), (_this = _possibleConstructorReturn(this, _getPrototypeOf(CannonBoxShape).call(this)))._box = void 0, 
                    _this._halfExtent = new cannon_min.Vec3(), Vec3.multiplyScalar(_this._halfExtent, size, .5), 
                    _this._box = new cannon_min.Box(_this._halfExtent.clone()), setWrap(_this._box, _assertThisInitialized(_this)), 
                    _this._shape = _this._box, _this._shape.addEventListener("trigger", _this.onTrigger), 
                    _this;
                }
                return _inherits(CannonBoxShape, CannonShape), _createClass(CannonBoxShape, [ {
                    key: "setScale",
                    value: function setScale(scale) {
                        _get(_getPrototypeOf(CannonBoxShape.prototype), "setScale", this).call(this, scale), 
                        this._recalcExtents();
                    }
                }, {
                    key: "setSize",
                    value: function setSize(size) {
                        Vec3.multiplyScalar(this._halfExtent, size, .5), this._recalcExtents();
                    }
                }, {
                    key: "_stringfyThis",
                    value: function _stringfyThis() {
                        return "".concat(this._body ? getWrap(this._body)._stringfyThis() : "<No-body>", "(Box)");
                    }
                }, {
                    key: "_devStrinfy",
                    value: function _devStrinfy() {
                        return "Box(".concat(_get(_getPrototypeOf(CannonBoxShape.prototype), "_devStrinfy", this).call(this), ", halfExtents: ").concat(stringfyVec3(this._box.halfExtents), ")");
                    }
                }, {
                    key: "_recalcExtents",
                    value: function _recalcExtents() {
                        Vec3.multiply(this._box.halfExtents, this._halfExtent, this._scale), this._box.updateConvexPolyhedronRepresentation(), 
                        null != this._body && commitShapeUpdates(this._body);
                    }
                } ]), CannonBoxShape;
            }(), function() {
                function CannonSphereShape(radius) {
                    var _this;
                    return _classCallCheck(this, CannonSphereShape), (_this = _possibleConstructorReturn(this, _getPrototypeOf(CannonSphereShape).call(this)))._sphere = void 0, 
                    _this._radius = 0, _this._radius = radius, _this._sphere = new cannon_min.Sphere(_this._radius), 
                    setWrap(_this._sphere, _assertThisInitialized(_this)), _this._shape = _this._sphere, 
                    _this;
                }
                return _inherits(CannonSphereShape, CannonShape), _createClass(CannonSphereShape, [ {
                    key: "setScale",
                    value: function setScale(scale) {
                        _get(_getPrototypeOf(CannonSphereShape.prototype), "setScale", this).call(this, scale), 
                        this._recalcRadius();
                    }
                }, {
                    key: "setRadius",
                    value: function setRadius(radius) {
                        this._radius = radius, this._recalcRadius();
                    }
                }, {
                    key: "_devStrinfy",
                    value: function _devStrinfy() {
                        return "Sphere(".concat(_get(_getPrototypeOf(CannonSphereShape.prototype), "_devStrinfy", this).call(this), ", radius: ").concat(this._sphere.radius, ")");
                    }
                }, {
                    key: "_recalcRadius",
                    value: function _recalcRadius() {
                        this._sphere.radius = this._radius * function maxComponent$1(v) {
                            return Math.max(v.x, Math.max(v.y, v.z));
                        }(this._scale), null != this._body && commitShapeUpdates(this._body);
                    }
                } ]), CannonSphereShape;
            }(), CannonRigidBody, CannonWorld);
            var PhysicMaterial = exports("PhysicMaterial", ccclass("cc.PhysicMaterial")((_temp$1r = _class3$A = function() {
                function PhysicMaterial() {
                    var _this;
                    return _classCallCheck(this, PhysicMaterial), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(PhysicMaterial).call(this)), "_friction", _descriptor$1f, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_restitution", _descriptor2$15, _assertThisInitialized(_this)), 
                    PhysicMaterial.allMaterials.push(_assertThisInitialized(_this)), "" == _this._uuid && (_this._uuid = "pm_" + PhysicMaterial._idCounter++), 
                    _this;
                }
                return _inherits(PhysicMaterial, Asset), _createClass(PhysicMaterial, [ {
                    key: "friction",
                    get: function get() {
                        return this._friction;
                    },
                    set: function set(value) {
                        equals(this._friction, value) || (this._friction = value, this.emit("physics_material_update"));
                    }
                }, {
                    key: "restitution",
                    get: function get() {
                        return this._restitution;
                    },
                    set: function set(value) {
                        equals(this._restitution, value) || (this._restitution = value, this.emit("physics_material_update"));
                    }
                } ]), _createClass(PhysicMaterial, [ {
                    key: "clone",
                    value: function clone() {
                        var c = new PhysicMaterial();
                        return c._friction = this._friction, c._restitution = this._restitution, c;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        if (_get(_getPrototypeOf(PhysicMaterial.prototype), "destroy", this).call(this)) {
                            var idx = PhysicMaterial.allMaterials.indexOf(this);
                            return 0 <= idx && PhysicMaterial.allMaterials.splice(idx, 1), !0;
                        }
                        return !1;
                    }
                } ]), PhysicMaterial;
            }(), _class3$A.allMaterials = [], _class3$A._idCounter = 0, _descriptor$1f = _applyDecoratedDescriptor((_class2$1j = _temp$1r).prototype, "_friction", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return -1;
                }
            }), _descriptor2$15 = _applyDecoratedDescriptor(_class2$1j.prototype, "_restitution", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return -1;
                }
            }), _class$1z = _class2$1j)) || _class$1z);
            cc.createRaycastResult = function createRaycastResult() {
                return new RaycastResult();
            };
            var PhysicsSystem = exports("PhysicsSystem", function() {
                function PhysicsSystem() {
                    var _this;
                    return _classCallCheck(this, PhysicsSystem), (_this = _possibleConstructorReturn(this, _getPrototypeOf(PhysicsSystem).call(this)))._world = void 0, 
                    _this._enable = !0, _this._deltaTime = 1 / 60, _this._maxSubStep = 2, _this._allowSleep = !0, 
                    _this._gravity = new Vec3(0, -10, 0), _this._material = null, _this._world = function createPhysicsWorld() {
                        return new PhysicsWorld();
                    }(), _this.gravity = _this._gravity, _this.allowSleep = _this._allowSleep, _this._material = new PhysicMaterial(), 
                    _this._material.friction = .6, _this._material.restitution = -1, _this._material.on("physics_material_update", _this._updateMaterial, _assertThisInitialized(_this)), 
                    _this._world.defaultMaterial = _this._material, _this;
                }
                return _inherits(PhysicsSystem, System), _createClass(PhysicsSystem, [ {
                    key: "enable",
                    get: function get() {
                        return this._enable;
                    },
                    set: function set(value) {
                        this._enable = value;
                    }
                }, {
                    key: "allowSleep",
                    get: function get() {
                        return this._allowSleep;
                    },
                    set: function set(v) {
                        this._allowSleep = v, this._world.setAllowSleep(this._allowSleep);
                    }
                }, {
                    key: "maxSubStep",
                    get: function get() {
                        return this._maxSubStep;
                    },
                    set: function set(value) {
                        this._maxSubStep = value;
                    }
                }, {
                    key: "deltaTime",
                    get: function get() {
                        return this._deltaTime;
                    },
                    set: function set(value) {
                        this._deltaTime = value;
                    }
                }, {
                    key: "gravity",
                    get: function get() {
                        return this._world.getGravity(this._gravity), this._gravity;
                    },
                    set: function set(gravity) {
                        this._gravity.x = gravity.x, this._gravity.y = gravity.y, this._gravity.z = gravity.z, 
                        this._world.setGravity(gravity);
                    }
                }, {
                    key: "defaultMaterial",
                    get: function get() {
                        return this._material;
                    }
                } ]), _createClass(PhysicsSystem, [ {
                    key: "postUpdate",
                    value: function postUpdate(deltaTime) {
                        this._enable && (director.emit(Director.EVENT_BEFORE_PHYSICS), this._world.step(this._deltaTime, deltaTime, this._maxSubStep), 
                        director.emit(Director.EVENT_AFTER_PHYSICS));
                    }
                }, {
                    key: "_updateMaterial",
                    value: function _updateMaterial() {
                        this._world.defaultMaterial = this._material;
                    }
                } ]), PhysicsSystem;
            }());
            PhysicsSystem.instance = void 0, PhysicsSystem.ID = void 0, cc.PhysicsSystem = PhysicsSystem, 
            director.on(Director.EVENT_INIT, function() {
                var sys = new PhysicsSystem();
                PhysicsSystem.instance = sys, director.registerSystem(PhysicsSystem.ID, sys, 0);
            });
            var _dec$1y, _dec2$18, _dec3$T, _dec4$L, _dec5$H, _class$1A, _class2$1k, _descriptor$1g, _descriptor2$16, _descriptor3$R, PhysicsBasedComponent = function() {
                function PhysicsBasedComponent() {
                    var _this;
                    return _classCallCheck(this, PhysicsBasedComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(PhysicsBasedComponent).call(this)))._sharedBody = void 0, 
                    _this._isPreLoaded = !1, _this;
                }
                return _inherits(PhysicsBasedComponent, Component), _createClass(PhysicsBasedComponent, [ {
                    key: "_body",
                    get: function get() {
                        return this._sharedBody.body;
                    }
                }, {
                    key: "sharedBody",
                    get: function get() {
                        return this._sharedBody;
                    }
                }, {
                    key: "_assertPreload",
                    get: function get() {
                        return this._isPreLoaded || error("Physic Error: Please make sure that the node has been added to the scene"), 
                        this._isPreLoaded;
                    }
                } ]), _createClass(PhysicsBasedComponent, [ {
                    key: "setGroup",
                    value: function setGroup(v) {
                        if (this._assertPreload) return this._body.setGroup(v);
                    }
                }, {
                    key: "getGroup",
                    value: function getGroup() {
                        return this._assertPreload ? this._body.getGroup() : 0;
                    }
                }, {
                    key: "addGroup",
                    value: function addGroup(v) {
                        if (this._assertPreload) return this._body.addGroup(v);
                    }
                }, {
                    key: "removeGroup",
                    value: function removeGroup(v) {
                        if (this._assertPreload) return this._body.removeGroup(v);
                    }
                }, {
                    key: "getMask",
                    value: function getMask() {
                        return this._assertPreload ? this._body.getMask() : 0;
                    }
                }, {
                    key: "setMask",
                    value: function setMask(v) {
                        if (this._assertPreload) return this._body.setMask(v);
                    }
                }, {
                    key: "addMask",
                    value: function addMask(v) {
                        if (this._assertPreload) return this._body.addMask(v);
                    }
                }, {
                    key: "removeMask",
                    value: function removeMask(v) {
                        if (this._assertPreload) return this._body.removeMask(v);
                    }
                }, {
                    key: "__preload",
                    value: function __preload() {
                        if (null == this._sharedBody) {
                            var sharedBody = null, _iterator = this.node.getComponents(PhysicsBasedComponent), _isArray = Array.isArray(_iterator), _i = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i >= _iterator.length) break;
                                    _ref = _iterator[_i++];
                                } else {
                                    if ((_i = _iterator.next()).done) break;
                                    _ref = _i.value;
                                }
                                var physicsBasedComponent = _ref;
                                if (physicsBasedComponent._sharedBody) {
                                    sharedBody = physicsBasedComponent._sharedBody;
                                    break;
                                }
                            }
                            if (!sharedBody) {
                                var rigidbody = this.getComponent(cc.RigidBodyComponent);
                                sharedBody = new SharedRigidBody(this.node, rigidbody, PhysicsSystem.instance._world);
                            }
                            sharedBody.ref(), this._sharedBody = sharedBody;
                        }
                        this._isPreLoaded = !0;
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        this.sharedBody.enable();
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this.sharedBody.disable();
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this._sharedBody.deref(), this._sharedBody = null;
                    }
                }, {
                    key: "_findRigidbody",
                    value: function _findRigidbody(begin) {
                        var rigidbody = begin.getComponent(cc.RigidBodyComponent);
                        return rigidbody || (begin.parent ? begin.parent === begin.scene ? null : this._findRigidbody(begin.parent) : null);
                    }
                } ]), PhysicsBasedComponent;
            }(), SharedRigidBody = function() {
                function SharedRigidBody(node, rigidBody, world) {
                    _classCallCheck(this, SharedRigidBody), this._body = void 0, this._refCount = 0, 
                    this._actived = !1, this._world = void 0, this._rigidBody = void 0, this._node = void 0, 
                    this._worldScale = new Vec3(1, 1, 1), this._beforeStepCallback = void 0, this._afterStepCallback = void 0, 
                    this._isShapeOnly = !0, this._body = function createRigidBody(options) {
                        return new RigidBody(options);
                    }({
                        name: node.name
                    }), this._node = node, this._rigidBody = rigidBody, this._world = world, this._body.setUserData(this._rigidBody), 
                    this._beforeStepCallback = this._beforeStep.bind(this), this._afterStepCallback = this._afterStep.bind(this), 
                    this._rigidBody ? this._isShapeOnly = !1 : (this._isShapeOnly = !0, this._body.setUseGravity(!1));
                }
                return _createClass(SharedRigidBody, [ {
                    key: "isShapeOnly",
                    get: function get() {
                        return this._isShapeOnly;
                    }
                }, {
                    key: "body",
                    get: function get() {
                        return this._body;
                    }
                }, {
                    key: "transfromSource",
                    set: function set(v) {
                        v === ETransformSource.SCENE ? this._isShapeOnly = !0 : this._isShapeOnly = !1;
                    }
                }, {
                    key: "rigidBody",
                    get: function get() {
                        return this._rigidBody;
                    }
                } ]), _createClass(SharedRigidBody, [ {
                    key: "ref",
                    value: function ref() {
                        ++this._refCount;
                    }
                }, {
                    key: "deref",
                    value: function deref() {
                        --this._refCount, this._refCount || this.destroy();
                    }
                }, {
                    key: "enable",
                    value: function enable() {
                        this._activeBody();
                    }
                }, {
                    key: "disable",
                    value: function disable() {
                        this._deactiveBody();
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._deactiveBody(), this._body.setUserData(null), this._body = null, this._beforeStepCallback = null, 
                        this._afterStepCallback = null, this._world = null, this._node = null, this._rigidBody && (this._rigidBody = null);
                    }
                }, {
                    key: "syncPhysWithScene",
                    value: function syncPhysWithScene() {
                        this._syncPhysWithScene(this._node);
                    }
                }, {
                    key: "_syncPhysWithScene",
                    value: function _syncPhysWithScene(node) {
                        node.getWorldMatrix(SharedRigidBody._tempMat4), node.getWorldRotation(SharedRigidBody._tempQuat), 
                        this._body.translateAndRotate(SharedRigidBody._tempMat4, SharedRigidBody._tempQuat);
                    }
                }, {
                    key: "_syncSceneWithPhys",
                    value: function _syncSceneWithPhys() {
                        this._node && (this._body.getPosition(SharedRigidBody._tempVec3), this._node.setWorldPosition(SharedRigidBody._tempVec3), 
                        this._body.getFreezeRotation() || (this._body.getRotation(SharedRigidBody._tempQuat), 
                        this._node.setWorldRotation(SharedRigidBody._tempQuat)));
                    }
                }, {
                    key: "_activeBody",
                    value: function _activeBody() {
                        this._syncPhysWithScene(this._node), this._actived || (this._actived = !0, this._body.setWorld(this._world), 
                        this._world.addBeforeStep(this._beforeStepCallback), this._world.addAfterStep(this._afterStepCallback), 
                        this._body.wakeUp());
                    }
                }, {
                    key: "_deactiveBody",
                    value: function _deactiveBody() {
                        this._actived && (this._actived = !1, this._world.removeBeforeStep(this._beforeStepCallback), 
                        this._world.removeAfterStep(this._afterStepCallback), this._body.sleep(), this._body.setWorld(null));
                    }
                }, {
                    key: "_beforeStep",
                    value: function _beforeStep() {
                        this._node.hasChangedFlags && (this._node.hasChangedFlags & TransformDirtyBit.SCALE && this._body.scaleAllShapes(this._node.worldScale), 
                        this._syncPhysWithScene(this._node), this._body.isSleeping() && this._body.wakeUp());
                    }
                }, {
                    key: "_afterStep",
                    value: function _afterStep() {
                        this._isShapeOnly || this._body.getType() !== ERigidBodyType.DYNAMIC ? this._node.hasChangedFlags && (this._syncPhysWithScene(this._node), 
                        this._body.isSleeping() && this._body.wakeUp()) : this._syncSceneWithPhys();
                    }
                } ]), SharedRigidBody;
            }();
            SharedRigidBody._tempMat4 = new Mat4(), SharedRigidBody._tempQuat = new Quat(), 
            SharedRigidBody._tempVec3 = new Vec3();
            var ColliderComponent = exports("ColliderComponent", (_dec$1y = ccclass("cc.ColliderComponent"), 
            _dec2$18 = property({
                type: PhysicMaterial,
                displayName: "Material",
                displayOrder: -1
            }), _dec3$T = property({
                displayOrder: 0
            }), _dec4$L = property({
                type: Vec3,
                displayOrder: 1,
                tooltip: "The center of the collider, in local space"
            }), _dec5$H = property({
                type: PhysicMaterial
            }), _dec$1y((_applyDecoratedDescriptor((_class2$1k = function() {
                function ColliderComponent() {
                    var _this;
                    return _classCallCheck(this, ColliderComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ColliderComponent).call(this)))._callbackTable = createMap(!0), 
                    _this._shapeBase = void 0, _this._isSharedMaterial = !0, _this._trrigerCallback = void 0, 
                    _this._collisionCallBack = void 0, _initializerDefineProperty(_this, "_material", _descriptor$1g, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_isTrigger", _descriptor2$16, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_center", _descriptor3$R, _assertThisInitialized(_this)), 
                    _this._trrigerCallback = _this._onTrigger.bind(_assertThisInitialized(_this)), _this._collisionCallBack = _this._onCollision.bind(_assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(ColliderComponent, PhysicsBasedComponent), _createClass(ColliderComponent, [ {
                    key: "sharedMaterial",
                    get: function get() {
                        return this._material;
                    },
                    set: function set(value) {
                        this.material = value;
                    }
                }, {
                    key: "material",
                    get: function get() {
                        return this._isSharedMaterial && null != this._material && (this._material.off("physics_material_update", this._updateMaterial, this), 
                        this._material = this._material.clone(), this._material.on("physics_material_update", this._updateMaterial, this), 
                        this._isSharedMaterial = !1), this._material;
                    },
                    set: function set(value) {
                        null != value && null != this._material ? this._material._uuid != value._uuid && (this._material.off("physics_material_update", this._updateMaterial, this), 
                        value.on("physics_material_update", this._updateMaterial, this), this._isSharedMaterial = !1, 
                        this._material = value) : null != value && null == this._material ? (value.on("physics_material_update", this._updateMaterial, this), 
                        this._material = value) : null == value && null != this._material && (this._material.off("physics_material_update", this._updateMaterial, this), 
                        this._material = value), this._updateMaterial();
                    }
                }, {
                    key: "isTrigger",
                    get: function get() {
                        return this._isTrigger;
                    },
                    set: function set(value) {
                        if (this._isTrigger = value, this.sharedBody) {
                            var type = this._isTrigger ? ERigidBodyType.DYNAMIC : ERigidBodyType.STATIC;
                            this.sharedBody.body.setType(type), this._shapeBase.setCollisionResponse(!this._isTrigger);
                        }
                    }
                }, {
                    key: "center",
                    get: function get() {
                        return this._center;
                    },
                    set: function set(value) {
                        Vec3.copy(this._center, value);
                        var rigidBody = this.sharedBody.rigidBody;
                        null != rigidBody ? (Vec3.subtract(offset, this.node.worldPosition, rigidBody.node.worldPosition), 
                        Vec3.add(offset, offset, this._center), this._shapeBase.setCenter(offset)) : this._shapeBase.setCenter(this._center);
                    }
                }, {
                    key: "attachedRigidbody",
                    get: function get() {
                        return this.sharedBody.rigidBody;
                    }
                } ]), _createClass(ColliderComponent, [ {
                    key: "on",
                    value: function on() {}
                }, {
                    key: "off",
                    value: function off() {}
                }, {
                    key: "once",
                    value: function once() {}
                }, {
                    key: "targetOff",
                    value: function targetOff() {}
                }, {
                    key: "dispatchEvent",
                    value: function dispatchEvent() {}
                }, {
                    key: "hasEventListener",
                    value: function hasEventListener() {
                        return !1;
                    }
                }, {
                    key: "removeAll",
                    value: function removeAll() {}
                }, {
                    key: "emit",
                    value: function emit() {}
                }, {
                    key: "onLoad",
                    value: function onLoad() {
                        this.isTrigger = this._isTrigger, this.sharedMaterial = null == this._material ? PhysicsSystem.instance.defaultMaterial : this._material, 
                        this.center = this._center;
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        _get(_getPrototypeOf(ColliderComponent.prototype), "onEnable", this).call(this);
                        var rigidBody = this.sharedBody.rigidBody;
                        null != rigidBody ? (Vec3.subtract(offset, this.node.worldPosition, rigidBody.node.worldPosition), 
                        Vec3.add(offset, offset, this._center), this.sharedBody.body.addShape(this._shapeBase, offset)) : this.sharedBody.body.addShape(this._shapeBase, this._center), 
                        this.center = this._center, this._shapeBase.addTriggerCallback(this._trrigerCallback), 
                        this.sharedBody.body.addCollisionCallback(this._collisionCallBack), this.sharedBody.syncPhysWithScene();
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        this._shapeBase.removeTriggerCallback(this._trrigerCallback), this.sharedBody.body.removeCollisionCllback(this._collisionCallBack), 
                        this.sharedBody.body.removeShape(this._shapeBase), this.sharedBody.isShapeOnly && _get(_getPrototypeOf(ColliderComponent.prototype), "onDisable", this).call(this);
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.sharedBody.body.removeShape(this._shapeBase), null != this._material && this._material._uuid != PhysicsSystem.instance.defaultMaterial._uuid && (this._material.destroy(), 
                        this._material = null), _get(_getPrototypeOf(ColliderComponent.prototype), "onDestroy", this).call(this);
                    }
                }, {
                    key: "_updateMaterial",
                    value: function _updateMaterial() {
                        this._shapeBase.material = this._material;
                    }
                }, {
                    key: "_onTrigger",
                    value: function _onTrigger(event) {
                        this.emit(event.type, event);
                    }
                }, {
                    key: "_onCollision",
                    value: function _onCollision(event) {
                        this.emit(event.type, event);
                    }
                } ]), ColliderComponent;
            }()).prototype, "sharedMaterial", [ _dec2$18 ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "sharedMaterial"), _class2$1k.prototype), 
            _applyDecoratedDescriptor(_class2$1k.prototype, "isTrigger", [ _dec3$T ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "isTrigger"), _class2$1k.prototype), 
            _applyDecoratedDescriptor(_class2$1k.prototype, "center", [ _dec4$L ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "center"), _class2$1k.prototype), 
            _descriptor$1g = _applyDecoratedDescriptor(_class2$1k.prototype, "_material", [ _dec5$H ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor2$16 = _applyDecoratedDescriptor(_class2$1k.prototype, "_isTrigger", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor3$R = _applyDecoratedDescriptor(_class2$1k.prototype, "_center", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new cc.Vec3(0, 0, 0);
                }
            }), _class$1A = _class2$1k)) || _class$1A));
            applyMixins(ColliderComponent, [ CallbacksInvoker, EventTarget ]);
            var _dec$1z, _dec2$19, _dec3$U, _dec4$M, _class$1B, _class2$1l, _descriptor$1h, _class$1C, _class2$1m, _descriptor$1i, _dec$1B, _dec2$1b, _dec3$W, _dec4$N, _dec5$I, _dec6$C, _dec7$s, _dec8$i, _dec9$g, _dec10$e, _dec11$d, _class$1D, _class2$1n, _descriptor$1j, _descriptor2$17, _descriptor3$S, _descriptor4$M, _descriptor5$E, _descriptor6$s, _descriptor7$n, _descriptor8$k, _dec$1C, _dec2$1c, _dec3$X, _dec4$O, _dec5$J, _dec6$D, _dec7$t, _dec8$j, _class$1E, _class2$1o, _descriptor$1k, _descriptor2$18, _descriptor3$T, _descriptor4$N, offset = new Vec3(), BoxColliderComponent = exports("BoxColliderComponent", (_dec$1z = ccclass("cc.BoxColliderComponent"), 
            _dec2$19 = executionOrder(98), _dec3$U = menu("Components/BoxCollider"), _dec4$M = property({
                type: Vec3
            }), _dec$1z(_class$1B = _dec2$19(_class$1B = _dec3$U(_class$1B = executeInEditMode((_descriptor$1h = _applyDecoratedDescriptor((_class2$1l = function() {
                function BoxColliderComponent() {
                    var _this;
                    return _classCallCheck(this, BoxColliderComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(BoxColliderComponent).call(this)))._shape = void 0, 
                    _initializerDefineProperty(_this, "_size", _descriptor$1h, _assertThisInitialized(_this)), 
                    _this._shape = function createBoxShape(size) {
                        return new BoxShape(size);
                    }(_this._size), _this._shape.setUserData(_assertThisInitialized(_this)), _this._shapeBase = _this._shape, 
                    _this;
                }
                return _inherits(BoxColliderComponent, ColliderComponent), _createClass(BoxColliderComponent, [ {
                    key: "onLoad",
                    value: function onLoad() {
                        _get(_getPrototypeOf(BoxColliderComponent.prototype), "onLoad", this).call(this), 
                        this.size = this._size, this._shape.setScale(this.node.worldScale);
                    }
                }, {
                    key: "size",
                    get: function get() {
                        return this._size;
                    },
                    set: function set(value) {
                        Vec3.copy(this._size, value), this._shape.setSize(this._size);
                    }
                } ]), BoxColliderComponent;
            }()).prototype, "_size", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec3(0, 0, 0);
                }
            }), _applyDecoratedDescriptor(_class2$1l.prototype, "size", [ _dec4$M ], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "size"), _class2$1l.prototype), 
            _class$1B = _class2$1l)) || _class$1B) || _class$1B) || _class$1B) || _class$1B)), SphereColliderComponent = exports("SphereColliderComponent", ccclass("cc.SphereColliderComponent")(_class$1C = executionOrder(98)(_class$1C = menu("Components/SphereCollider")(_class$1C = executeInEditMode((_descriptor$1i = _applyDecoratedDescriptor((_class2$1m = function() {
                function SphereColliderComponent() {
                    var _this;
                    return _classCallCheck(this, SphereColliderComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SphereColliderComponent).call(this)))._shape = void 0, 
                    _initializerDefineProperty(_this, "_radius", _descriptor$1i, _assertThisInitialized(_this)), 
                    _this._shape = function createSphereShape(radius) {
                        return new SphereShape(radius);
                    }(_this._radius), _this._shape.setUserData(_assertThisInitialized(_this)), _this._shapeBase = _this._shape, 
                    _this;
                }
                return _inherits(SphereColliderComponent, ColliderComponent), _createClass(SphereColliderComponent, [ {
                    key: "onLoad",
                    value: function onLoad() {
                        _get(_getPrototypeOf(SphereColliderComponent.prototype), "onLoad", this).call(this), 
                        this.radius = this._radius, this._shape.setScale(this.node.worldScale);
                    }
                }, {
                    key: "radius",
                    get: function get() {
                        return this._radius;
                    },
                    set: function set(value) {
                        this._radius = value, this._shape.setRadius(this._radius);
                    }
                } ]), SphereColliderComponent;
            }()).prototype, "_radius", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _applyDecoratedDescriptor(_class2$1m.prototype, "radius", [ property ], Object.getOwnPropertyDescriptor(_class2$1m.prototype, "radius"), _class2$1m.prototype), 
            _class$1C = _class2$1m)) || _class$1C) || _class$1C) || _class$1C) || _class$1C), NonRigidBodyProperties_mass = 10, NonRigidBodyProperties_linearDamping = 0, NonRigidBodyProperties_angularDamping = 0, RigidBodyComponent = exports("RigidBodyComponent", (_dec$1B = ccclass("cc.RigidBodyComponent"), 
            _dec2$1b = executionOrder(99), _dec3$W = menu("Components/RigidBody"), _dec4$N = property({
                displayOrder: 0
            }), _dec5$I = property({
                displayOrder: 1
            }), _dec6$C = property({
                displayOrder: 2
            }), _dec7$s = property({
                displayOrder: 3
            }), _dec8$i = property({
                displayOrder: 4
            }), _dec9$g = property({
                displayOrder: 5
            }), _dec10$e = property({
                displayOrder: 6
            }), _dec11$d = property({
                displayOrder: 7
            }), _dec$1B(_class$1D = _dec2$1b(_class$1D = _dec3$W(_class$1D = executeInEditMode(_class$1D = disallowMultiple((_applyDecoratedDescriptor((_class2$1n = function() {
                function RigidBodyComponent() {
                    var _this;
                    return _classCallCheck(this, RigidBodyComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(RigidBodyComponent).call(this)))._allowSleep = !0, 
                    _initializerDefineProperty(_this, "_mass", _descriptor$1j, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_linearDamping", _descriptor2$17, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_angularDamping", _descriptor3$S, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_fixedRotation", _descriptor4$M, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_isKinematic", _descriptor5$E, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_useGravity", _descriptor6$s, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_linearFactor", _descriptor7$n, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_angularFactor", _descriptor8$k, _assertThisInitialized(_this)), 
                    _this;
                }
                return _inherits(RigidBodyComponent, PhysicsBasedComponent), _createClass(RigidBodyComponent, [ {
                    key: "allowSleep",
                    get: function get() {
                        return this._allowSleep;
                    },
                    set: function set(v) {
                        this._allowSleep = v, this.sharedBody.body.setAllowSleep(v);
                    }
                }, {
                    key: "mass",
                    get: function get() {
                        return this._mass;
                    },
                    set: function set(value) {
                        this._mass = value, this._body.setMass(value);
                    }
                }, {
                    key: "linearDamping",
                    get: function get() {
                        return this._linearDamping;
                    },
                    set: function set(value) {
                        this._linearDamping = value, this._body.setLinearDamping(value);
                    }
                }, {
                    key: "angularDamping",
                    get: function get() {
                        return this._angularDamping;
                    },
                    set: function set(value) {
                        this._angularDamping = value, this._body.setAngularDamping(value);
                    }
                }, {
                    key: "isKinematic",
                    get: function get() {
                        return this._isKinematic;
                    },
                    set: function set(value) {
                        this._isKinematic = value, this._body.setIsKinematic(value);
                    }
                }, {
                    key: "useGravity",
                    get: function get() {
                        return this._useGravity;
                    },
                    set: function set(value) {
                        this._useGravity = value, this._body.setUseGravity(value);
                    }
                }, {
                    key: "fixedRotation",
                    get: function get() {
                        return this._fixedRotation;
                    },
                    set: function set(value) {
                        this._fixedRotation = value, this._body.setFreezeRotation(value);
                    }
                }, {
                    key: "linearFactor",
                    get: function get() {
                        return this._body.getLinearFactor(this._linearFactor);
                    },
                    set: function set(value) {
                        Vec3.copy(this._linearFactor, value), this._body.setLinearFactor(this._linearFactor);
                    }
                }, {
                    key: "angularFactor",
                    get: function get() {
                        return this._body.getAngularFactor(this._angularFactor);
                    },
                    set: function set(value) {
                        Vec3.copy(this._angularFactor, value), this._body.setAngularFactor(this._angularFactor);
                    }
                }, {
                    key: "isAwake",
                    get: function get() {
                        return !!this._assertPreload && this._body.isAwake();
                    }
                }, {
                    key: "isSleepy",
                    get: function get() {
                        return !!this._assertPreload && this._body.isSleepy();
                    }
                }, {
                    key: "isSleeping",
                    get: function get() {
                        return !!this._assertPreload && this._body.isSleeping();
                    }
                } ]), _createClass(RigidBodyComponent, [ {
                    key: "applyForce",
                    value: function applyForce(force, relativePoint) {
                        this._assertPreload && this._body.applyForce(force, relativePoint);
                    }
                }, {
                    key: "applyLocalForce",
                    value: function applyLocalForce(force, localPoint) {
                        this._assertPreload && this._body.applyLocalForce(force, localPoint);
                    }
                }, {
                    key: "applyImpulse",
                    value: function applyImpulse(impulse, relativePoint) {
                        this._assertPreload && this._body.applyImpulse(impulse, relativePoint);
                    }
                }, {
                    key: "applyLocalImpulse",
                    value: function applyLocalImpulse(impulse, localPoint) {
                        this._assertPreload && this._body.applyLocalImpulse(impulse, localPoint);
                    }
                }, {
                    key: "applyTorque",
                    value: function applyTorque(torque) {
                        this._assertPreload && this._body.applyTorque(torque);
                    }
                }, {
                    key: "applyLocalTorque",
                    value: function applyLocalTorque(torque) {
                        this._assertPreload && this._body.applyLocalTorque(torque);
                    }
                }, {
                    key: "wakeUp",
                    value: function wakeUp() {
                        this._assertPreload && this._body.wakeUp();
                    }
                }, {
                    key: "sleep",
                    value: function sleep() {
                        this._assertPreload && this._body.sleep();
                    }
                }, {
                    key: "getLinearVelocity",
                    value: function getLinearVelocity(out) {
                        this._assertPreload && this._body.getLinearVelocity(out);
                    }
                }, {
                    key: "setLinearVelocity",
                    value: function setLinearVelocity(value) {
                        this._assertPreload && this._body.setLinearVelocity(value);
                    }
                }, {
                    key: "getAngularVelocity",
                    value: function getAngularVelocity(out) {
                        this._assertPreload && this._body.getAngularVelocity(out);
                    }
                }, {
                    key: "setAngularVelocity",
                    value: function setAngularVelocity(value) {
                        this._assertPreload && this._body.setAngularVelocity(value);
                    }
                }, {
                    key: "onLoad",
                    value: function onLoad() {
                        this.sharedBody && (this.allowSleep = this._allowSleep, this.mass = this._mass, 
                        this.linearDamping = this._linearDamping, this.angularDamping = this._angularDamping, 
                        this.useGravity = this._useGravity, this.isKinematic = this._isKinematic, this.fixedRotation = this._fixedRotation, 
                        this.linearFactor = this._linearFactor, this.angularFactor = this._angularFactor);
                    }
                } ]), RigidBodyComponent;
            }()).prototype, "mass", [ _dec4$N ], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "mass"), _class2$1n.prototype), 
            _applyDecoratedDescriptor(_class2$1n.prototype, "linearDamping", [ _dec5$I ], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "linearDamping"), _class2$1n.prototype), 
            _applyDecoratedDescriptor(_class2$1n.prototype, "angularDamping", [ _dec6$C ], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "angularDamping"), _class2$1n.prototype), 
            _applyDecoratedDescriptor(_class2$1n.prototype, "isKinematic", [ _dec7$s ], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "isKinematic"), _class2$1n.prototype), 
            _applyDecoratedDescriptor(_class2$1n.prototype, "useGravity", [ _dec8$i ], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "useGravity"), _class2$1n.prototype), 
            _applyDecoratedDescriptor(_class2$1n.prototype, "fixedRotation", [ _dec9$g ], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "fixedRotation"), _class2$1n.prototype), 
            _applyDecoratedDescriptor(_class2$1n.prototype, "linearFactor", [ _dec10$e ], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "linearFactor"), _class2$1n.prototype), 
            _applyDecoratedDescriptor(_class2$1n.prototype, "angularFactor", [ _dec11$d ], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "angularFactor"), _class2$1n.prototype), 
            _descriptor$1j = _applyDecoratedDescriptor(_class2$1n.prototype, "_mass", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return NonRigidBodyProperties_mass;
                }
            }), _descriptor2$17 = _applyDecoratedDescriptor(_class2$1n.prototype, "_linearDamping", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return NonRigidBodyProperties_linearDamping;
                }
            }), _descriptor3$S = _applyDecoratedDescriptor(_class2$1n.prototype, "_angularDamping", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return NonRigidBodyProperties_angularDamping;
                }
            }), _descriptor4$M = _applyDecoratedDescriptor(_class2$1n.prototype, "_fixedRotation", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor5$E = _applyDecoratedDescriptor(_class2$1n.prototype, "_isKinematic", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor6$s = _applyDecoratedDescriptor(_class2$1n.prototype, "_useGravity", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor7$n = _applyDecoratedDescriptor(_class2$1n.prototype, "_linearFactor", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec3(1, 1, 1);
                }
            }), _descriptor8$k = _applyDecoratedDescriptor(_class2$1n.prototype, "_angularFactor", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec3(1, 1, 1);
                }
            }), _class$1D = _class2$1n)) || _class$1D) || _class$1D) || _class$1D) || _class$1D) || _class$1D)), ConstantForce = exports("ConstantForce", (_dec$1C = ccclass("cc.ConstantForce"), 
            _dec2$1c = executionOrder(98), _dec3$X = requireComponent(RigidBodyComponent), _dec4$O = menu("Components/ConstantForce"), 
            _dec5$J = property({
                displayOrder: 0
            }), _dec6$D = property({
                displayOrder: 1
            }), _dec7$t = property({
                displayOrder: 2
            }), _dec8$j = property({
                displayOrder: 3
            }), _dec$1C(_class$1E = _dec2$1c(_class$1E = _dec3$X(_class$1E = _dec4$O(_class$1E = disallowMultiple(_class$1E = executeInEditMode((_descriptor$1k = _applyDecoratedDescriptor((_class2$1o = function() {
                function ConstantForce() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, ConstantForce);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ConstantForce)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._rigidbody = null, 
                    _initializerDefineProperty(_this, "_force", _descriptor$1k, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_localForce", _descriptor2$18, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_torque", _descriptor3$T, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_localTorque", _descriptor4$N, _assertThisInitialized(_this)), 
                    _this._mask = 0, _this;
                }
                return _inherits(ConstantForce, Component), _createClass(ConstantForce, [ {
                    key: "onLoad",
                    value: function onLoad() {
                        this._rigidbody = this.node.getComponent(RigidBodyComponent), this._maskUpdate(this._force, 1), 
                        this._maskUpdate(this._localForce, 2), this._maskUpdate(this._torque, 4), this._maskUpdate(this._localTorque, 8);
                    }
                }, {
                    key: "lateUpdate",
                    value: function lateUpdate() {
                        null != this._rigidbody && 0 != this._mask && (1 & this._mask && this._rigidbody.applyForce(this._force), 
                        2 & this._mask && this._rigidbody.applyLocalForce(this.localForce), 4 & this._mask && this._rigidbody.applyTorque(this._torque), 
                        8 & this._mask && this._rigidbody.applyLocalTorque(this._localTorque));
                    }
                }, {
                    key: "_maskUpdate",
                    value: function _maskUpdate(t, m) {
                        t.strictEquals(Vec3.ZERO) ? this._mask &= ~m : this._mask |= m;
                    }
                }, {
                    key: "force",
                    get: function get() {
                        return this._force;
                    },
                    set: function set(value) {
                        Vec3.copy(this._force, value), this._maskUpdate(this._force, 1);
                    }
                }, {
                    key: "localForce",
                    get: function get() {
                        return this._localForce;
                    },
                    set: function set(value) {
                        Vec3.copy(this._localForce, value), this._maskUpdate(this.localForce, 2);
                    }
                }, {
                    key: "torque",
                    get: function get() {
                        return this._torque;
                    },
                    set: function set(value) {
                        Vec3.copy(this._torque, value), this._maskUpdate(this._torque, 4);
                    }
                }, {
                    key: "localTorque",
                    get: function get() {
                        return this._localTorque;
                    },
                    set: function set(value) {
                        Vec3.copy(this._localTorque, value), this._maskUpdate(this._localTorque, 8);
                    }
                } ]), ConstantForce;
            }()).prototype, "_force", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec3();
                }
            }), _descriptor2$18 = _applyDecoratedDescriptor(_class2$1o.prototype, "_localForce", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec3();
                }
            }), _descriptor3$T = _applyDecoratedDescriptor(_class2$1o.prototype, "_torque", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec3();
                }
            }), _descriptor4$N = _applyDecoratedDescriptor(_class2$1o.prototype, "_localTorque", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Vec3();
                }
            }), _applyDecoratedDescriptor(_class2$1o.prototype, "force", [ _dec5$J ], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "force"), _class2$1o.prototype), 
            _applyDecoratedDescriptor(_class2$1o.prototype, "localForce", [ _dec6$D ], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "localForce"), _class2$1o.prototype), 
            _applyDecoratedDescriptor(_class2$1o.prototype, "torque", [ _dec7$t ], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "torque"), _class2$1o.prototype), 
            _applyDecoratedDescriptor(_class2$1o.prototype, "localTorque", [ _dec8$j ], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "localTorque"), _class2$1o.prototype), 
            _class$1E = _class2$1o)) || _class$1E) || _class$1E) || _class$1E) || _class$1E) || _class$1E) || _class$1E));
            cc.ConstantForce = ConstantForce, replaceProperty(PhysicsSystem, "PhysicsSystem", [ {
                name: "ins",
                newName: "instance"
            } ]), cc.ColliderComponent = ColliderComponent, cc.BoxColliderComponent = BoxColliderComponent, 
            cc.SphereColliderComponent = SphereColliderComponent, cc.RigidBodyComponent = RigidBodyComponent, 
            cc.PhysicMaterial = PhysicMaterial;
            var _dec$1D, _dec2$1d, _class$1F, _class2$1p, _descriptor$1l, _descriptor2$19, _class3$B, _temp$1x, PlayingState = {
                INITIALIZING: 0,
                PLAYING: 1,
                STOPPED: 2
            }, AudioPlayer = function() {
                function AudioPlayer(info) {
                    var _this = this;
                    _classCallCheck(this, AudioPlayer), this._state = PlayingState.STOPPED, this._duration = 0, 
                    this._eventTarget = void 0, this._onHide = void 0, this._onShow = void 0, this._interrupted = !1, 
                    this._blocking = !1, this._duration = info.duration, this._eventTarget = info.eventTarget, 
                    this._onHide = function() {
                        _this._blocking = !0, _this._state === PlayingState.PLAYING && (_this.pause(), _this._interrupted = !0);
                    }, this._onShow = function() {
                        _this._blocking = !1, _this._interrupted && (_this.play(), _this._interrupted = !1);
                    }, cc.game.on(cc.Game.EVENT_HIDE, this._onHide), cc.game.on(cc.Game.EVENT_SHOW, this._onShow);
                }
                return _createClass(AudioPlayer, [ {
                    key: "getState",
                    value: function getState() {
                        return this._state;
                    }
                }, {
                    key: "getDuration",
                    value: function getDuration() {
                        return this._duration;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        cc.game.off(cc.Game.EVENT_HIDE, this._onHide), cc.game.off(cc.Game.EVENT_SHOW, this._onShow);
                    }
                } ]), AudioPlayer;
            }(), AudioPlayerDOM = function() {
                function AudioPlayerDOM(info) {
                    var _this;
                    return _classCallCheck(this, AudioPlayerDOM), (_this = _possibleConstructorReturn(this, _getPrototypeOf(AudioPlayerDOM).call(this, info)))._volume = 1, 
                    _this._loop = !1, _this._oneShoting = !1, _this._audio = void 0, _this._post_play = void 0, 
                    _this._on_gesture = void 0, _this._audio = info.clip, _this._post_play = function() {
                        _this._state = PlayingState.PLAYING, _this._eventTarget.emit("started");
                    }, _this._on_gesture = function() {
                        if (_this._audio) {
                            var promise = _this._audio.play();
                            promise ? promise.then(function() {
                                _this._interrupted ? (_this._post_play(), _this._interrupted = !1) : (_this._audio.pause(), 
                                _this._audio.currentTime = 0), cc.game.canvas.removeEventListener("touchend", _this._on_gesture), 
                                cc.game.canvas.removeEventListener("mouseup", _this._on_gesture);
                            }) : console.warn("no promise returned from HTMLMediaElement.play()");
                        }
                    }, _this._audio.volume = _this._volume, _this._audio.loop = _this._loop, _this._audio.addEventListener("ended", function() {
                        _this._oneShoting || (_this._state = PlayingState.STOPPED, _this._audio.currentTime = 0, 
                        _this._eventTarget.emit("ended"));
                    }), cc.game.canvas.addEventListener("touchend", _this._on_gesture), cc.game.canvas.addEventListener("mouseup", _this._on_gesture), 
                    _this;
                }
                return _inherits(AudioPlayerDOM, AudioPlayer), _createClass(AudioPlayerDOM, [ {
                    key: "play",
                    value: function play() {
                        var _this2 = this;
                        if (this._audio && this._state !== PlayingState.PLAYING) if (this._blocking) this._interrupted = !0; else {
                            var promise = this._audio.play();
                            promise ? promise.then(this._post_play).catch(function() {
                                _this2._interrupted = !0;
                            }) : console.warn("no promise returned from HTMLMediaElement.play()");
                        }
                    }
                }, {
                    key: "pause",
                    value: function pause() {
                        this._audio && this._state === PlayingState.PLAYING && (this._audio.pause(), this._state = PlayingState.STOPPED, 
                        this._oneShoting = !1);
                    }
                }, {
                    key: "stop",
                    value: function stop() {
                        this._audio && (this._audio.currentTime = 0, this._state === PlayingState.PLAYING && (this._audio.pause(), 
                        this._state = PlayingState.STOPPED, this._oneShoting = !1));
                    }
                }, {
                    key: "playOneShot",
                    value: function playOneShot(argument_0) {
                        var _this3 = this, volume = 0 < arguments.length && void 0 !== argument_0 ? argument_0 : 1, clip = this._audio;
                        clip && (clip.currentTime = 0, clip.volume = volume, this._oneShoting || (clip.loop = !1, 
                        this._oneShoting = !0, clip.play().then(function() {
                            clip.addEventListener("ended", function() {
                                clip.currentTime = 0, clip.volume = _this3._volume, clip.loop = _this3._loop, _this3._oneShoting = !1;
                            }, {
                                once: !0
                            });
                        }).catch(function() {
                            _this3._oneShoting = !1;
                        })));
                    }
                }, {
                    key: "setCurrentTime",
                    value: function setCurrentTime(val) {
                        this._audio && (this._audio.currentTime = clamp(val, 0, this._duration));
                    }
                }, {
                    key: "getCurrentTime",
                    value: function getCurrentTime() {
                        return this._audio ? this._audio.currentTime : 0;
                    }
                }, {
                    key: "setVolume",
                    value: function setVolume(val) {
                        this._volume = val, this._audio && (this._audio.volume = val);
                    }
                }, {
                    key: "getVolume",
                    value: function getVolume() {
                        return this._audio ? this._audio.volume : this._volume;
                    }
                }, {
                    key: "setLoop",
                    value: function setLoop(val) {
                        this._loop = val, this._audio && (this._audio.loop = val);
                    }
                }, {
                    key: "getLoop",
                    value: function getLoop() {
                        return this._loop;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._audio && (this._audio.src = ""), _get(_getPrototypeOf(AudioPlayerDOM.prototype), "destroy", this).call(this);
                    }
                } ]), AudioPlayerDOM;
            }(), audioSupport = sys.__audioSupport, AudioPlayerWeb = function() {
                function AudioPlayerWeb(info) {
                    var _this;
                    return _classCallCheck(this, AudioPlayerWeb), (_this = _possibleConstructorReturn(this, _getPrototypeOf(AudioPlayerWeb).call(this, info)))._startTime = 0, 
                    _this._offset = 0, _this._volume = 1, _this._loop = !1, _this._currentTimer = 0, 
                    _this._audio = void 0, _this._context = void 0, _this._sourceNode = void 0, _this._gainNode = void 0, 
                    _this._on_ended = void 0, _this._do_play = void 0, _this._on_gesture = void 0, _this._audio = info.clip, 
                    _this._context = audioSupport.context, _this._sourceNode = _this._context.createBufferSource(), 
                    _this._gainNode = _this._context.createGain(), _this._gainNode.connect(_this._context.destination), 
                    _this._on_ended = function() {
                        _this._offset = 0, _this._startTime = _this._context.currentTime, _this._sourceNode.loop || (_this._eventTarget.emit("ended"), 
                        _this._state = PlayingState.STOPPED);
                    }, _this._do_play = function() {
                        _this._sourceNode = _this._context.createBufferSource(), _this._sourceNode.buffer = _this._audio, 
                        _this._sourceNode.loop = _this._loop, _this._sourceNode.connect(_this._gainNode), 
                        _this._sourceNode.start(0, _this._offset), _this._state = PlayingState.PLAYING, 
                        _this._startTime = _this._context.currentTime, director.once(Director.EVENT_AFTER_UPDATE, function() {
                            _this._eventTarget.emit("started");
                        }), clearInterval(_this._currentTimer), _this._currentTimer = window.setInterval(function() {
                            _this._on_ended(), clearInterval(_this._currentTimer), _this._sourceNode.loop && (_this._currentTimer = window.setInterval(_this._on_ended, 1e3 * _this._audio.duration));
                        }, 1e3 * (_this._audio.duration - _this._offset));
                    }, _this._on_gesture = function() {
                        _this._context.resume().then(function() {
                            _this._interrupted && (_this._do_play(), _this._interrupted = !1), cc.game.canvas.removeEventListener("touchend", _this._on_gesture), 
                            cc.game.canvas.removeEventListener("mouseup", _this._on_gesture);
                        });
                    }, "running" !== _this._context.state && (cc.game.canvas.addEventListener("touchend", _this._on_gesture), 
                    cc.game.canvas.addEventListener("mouseup", _this._on_gesture)), _this;
                }
                return _inherits(AudioPlayerWeb, AudioPlayer), _createClass(AudioPlayerWeb, [ {
                    key: "play",
                    value: function play() {
                        this._audio && this._state !== PlayingState.PLAYING && (this._blocking || "running" !== this._context.state ? this._interrupted = !0 : this._do_play());
                    }
                }, {
                    key: "pause",
                    value: function pause() {
                        this._state === PlayingState.PLAYING && (this._sourceNode.stop(), this._offset += this._context.currentTime - this._startTime, 
                        this._state = PlayingState.STOPPED, clearInterval(this._currentTimer));
                    }
                }, {
                    key: "stop",
                    value: function stop() {
                        this._offset = 0, this._state === PlayingState.PLAYING && (this._sourceNode.stop(), 
                        this._state = PlayingState.STOPPED, clearInterval(this._currentTimer));
                    }
                }, {
                    key: "playOneShot",
                    value: function playOneShot(argument_0) {
                        var volume = 0 < arguments.length && void 0 !== argument_0 ? argument_0 : 1;
                        if (this._audio) {
                            var gainNode = this._context.createGain();
                            gainNode.connect(this._context.destination), gainNode.gain.value = volume;
                            var sourceNode = this._context.createBufferSource();
                            sourceNode.buffer = this._audio, sourceNode.loop = !1, sourceNode.connect(gainNode), 
                            sourceNode.start();
                        }
                    }
                }, {
                    key: "setCurrentTime",
                    value: function setCurrentTime(val) {
                        this._offset = clamp(val, 0, this._audio && this._audio.duration || this._duration), 
                        this._state === PlayingState.PLAYING && (this._sourceNode.stop(), this._do_play());
                    }
                }, {
                    key: "getCurrentTime",
                    value: function getCurrentTime() {
                        return this._state !== PlayingState.PLAYING ? this._offset : this._context.currentTime - this._startTime + this._offset;
                    }
                }, {
                    key: "setVolume",
                    value: function setVolume(val, immediate) {
                        this._volume = val, !immediate && this._gainNode.gain.setTargetAtTime ? this._gainNode.gain.setTargetAtTime(val, this._context.currentTime, .01) : this._gainNode.gain.value = val;
                    }
                }, {
                    key: "getVolume",
                    value: function getVolume() {
                        return this._volume;
                    }
                }, {
                    key: "setLoop",
                    value: function setLoop(val) {
                        this._loop = val, this._sourceNode.loop = val;
                    }
                }, {
                    key: "getLoop",
                    value: function getLoop() {
                        return this._loop;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        _get(_getPrototypeOf(AudioPlayerWeb.prototype), "destroy", this).call(this);
                    }
                } ]), AudioPlayerWeb;
            }(), AudioType = Enum({
                WEB_AUDIO: 0,
                DOM_AUDIO: 1,
                WX_GAME_AUDIO: 2,
                UNKNOWN_AUDIO: 3
            }), AudioClip = exports("AudioClip", (_dec$1D = ccclass("cc.AudioClip"), _dec2$1d = property({
                type: AudioType
            }), _dec$1D((_temp$1x = _class3$B = function() {
                function AudioClip() {
                    var _this;
                    return _classCallCheck(this, AudioClip), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(AudioClip).call(this)), "_duration", _descriptor$1l, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_loadMode", _descriptor2$19, _assertThisInitialized(_this)), 
                    _this._audio = null, _this._player = null, _this.loaded = !1, _this;
                }
                return _inherits(AudioClip, Asset), _createClass(AudioClip, [ {
                    key: "destroy",
                    value: function destroy() {
                        return this._player && this._player.destroy(), _get(_getPrototypeOf(AudioClip.prototype), "destroy", this).call(this);
                    }
                }, {
                    key: "play",
                    value: function play() {
                        this._player && this._player.play();
                    }
                }, {
                    key: "pause",
                    value: function pause() {
                        this._player && this._player.pause();
                    }
                }, {
                    key: "stop",
                    value: function stop() {
                        this._player && this._player.stop();
                    }
                }, {
                    key: "playOneShot",
                    value: function playOneShot(volume) {
                        this._player && this._player.playOneShot(volume);
                    }
                }, {
                    key: "setCurrentTime",
                    value: function setCurrentTime(val) {
                        this._player && this._player.setCurrentTime(val);
                    }
                }, {
                    key: "getCurrentTime",
                    value: function getCurrentTime() {
                        return this._player ? this._player.getCurrentTime() : 0;
                    }
                }, {
                    key: "getDuration",
                    value: function getDuration() {
                        return this._player ? this._player.getDuration() : this._duration;
                    }
                }, {
                    key: "setVolume",
                    value: function setVolume(val, immediate) {
                        this._player && this._player.setVolume(val, immediate || !1);
                    }
                }, {
                    key: "getVolume",
                    value: function getVolume() {
                        return this._player ? this._player.getVolume() : 1;
                    }
                }, {
                    key: "setLoop",
                    value: function setLoop(val) {
                        this._player && this._player.setLoop(val);
                    }
                }, {
                    key: "getLoop",
                    value: function getLoop() {
                        return !!this._player && this._player.getLoop();
                    }
                }, {
                    key: "_nativeAsset",
                    set: function set(clip) {
                        var ctor;
                        (this._audio = clip) ? ("undefined" != typeof AudioBuffer && clip instanceof AudioBuffer ? (ctor = AudioPlayerWeb, 
                        this._loadMode = AudioType.WEB_AUDIO) : (ctor = AudioPlayerDOM, this._loadMode = AudioType.DOM_AUDIO), 
                        this._player = new ctor({
                            clip: clip,
                            duration: this._duration,
                            eventTarget: this
                        }), this.loaded = !0, this.emit("load")) : (this._player = null, this._loadMode = AudioType.UNKNOWN_AUDIO, 
                        this._duration = 0, this.loaded = !1);
                    },
                    get: function get() {
                        return this._audio;
                    }
                }, {
                    key: "loadMode",
                    get: function get() {
                        return this._loadMode;
                    }
                }, {
                    key: "state",
                    get: function get() {
                        return this._player ? this._player.getState() : PlayingState.INITIALIZING;
                    }
                } ]), AudioClip;
            }(), _class3$B.PlayingState = PlayingState, _class3$B.AudioType = AudioType, _class3$B.preventDeferredLoadDependents = !0, 
            _descriptor$1l = _applyDecoratedDescriptor((_class2$1p = _temp$1x).prototype, "_duration", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 0;
                }
            }), _descriptor2$19 = _applyDecoratedDescriptor(_class2$1p.prototype, "_loadMode", [ _dec2$1d ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return AudioType.UNKNOWN_AUDIO;
                }
            }), _class$1F = _class2$1p)) || _class$1F));
            cc.AudioClip = AudioClip;
            var _dec$1E, _dec2$1e, _dec3$Y, _dec4$P, _class$1G, _class2$1q, _descriptor$1m, _descriptor2$1a, _descriptor3$U, _descriptor4$O, __audioSupport$1 = sys.__audioSupport, formatSupport$1 = __audioSupport$1.format;
            function loadDomAudio(item, callback) {
                var dom = document.createElement("audio");
                dom.src = item.url;
                function clearEvent() {
                    clearTimeout(timer), dom.removeEventListener("canplaythrough", success, !1), dom.removeEventListener("error", failure, !1), 
                    __audioSupport$1.USE_LOADER_EVENT && dom.removeEventListener(__audioSupport$1.USE_LOADER_EVENT, success, !1);
                }
                var timer = setTimeout(function() {
                    0 === dom.readyState ? failure() : success();
                }, 8e3), success = function success() {
                    clearEvent(), callback(null, dom);
                }, failure = function failure() {
                    clearEvent();
                    var message = "load audio failure - " + item.url;
                    log(message), callback(message);
                };
                dom.addEventListener("canplaythrough", success, !1), dom.addEventListener("error", failure, !1), 
                __audioSupport$1.USE_LOADER_EVENT && dom.addEventListener(__audioSupport$1.USE_LOADER_EVENT, success, !1);
            }
            function loadWebAudio(item, callback) {
                var context = __audioSupport$1.context;
                context || callback(new Error(getError(4926)));
                var request = loader.getXMLHttpRequest();
                request.open("GET", item.url, !0), request.responseType = "arraybuffer", request.onload = function() {
                    context.decodeAudioData(request.response, function(buffer) {
                        callback(null, buffer);
                    }, function() {
                        callback("decode error - " + item.id, null);
                    });
                }, request.onerror = function() {
                    callback("request error - " + item.id, null);
                }, request.send();
            }
            function downloadAudio(item, callback) {
                if (0 === formatSupport$1.length) return new Error(getError(4927));
                (__audioSupport$1.WEB_AUDIO ? item._owner instanceof AudioClip ? item._owner.loadMode === AudioType.WEB_AUDIO ? loadWebAudio : loadDomAudio : item.urlParam && item.urlParam.useDom ? loadDomAudio : loadWebAudio : loadDomAudio)(item, callback);
            }
            loader.downloader.addHandlers({
                mp3: downloadAudio,
                ogg: downloadAudio,
                wav: downloadAudio,
                m4a: downloadAudio
            });
            var AudioSourceComponent = exports("AudioSourceComponent", (_dec$1E = ccclass("cc.AudioSourceComponent"), 
            _dec2$1e = menu("Components/AudioSource"), _dec3$Y = property(AudioClip), _dec4$P = property({
                type: AudioClip
            }), _dec$1E(_class$1G = _dec2$1e((_descriptor$1m = _applyDecoratedDescriptor((_class2$1q = function() {
                function AudioSourceComponent() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, AudioSourceComponent);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AudioSourceComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_clip", _descriptor$1m, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_loop", _descriptor2$1a, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_playOnAwake", _descriptor3$U, _assertThisInitialized(_this)), 
                    _initializerDefineProperty(_this, "_volume", _descriptor4$O, _assertThisInitialized(_this)), 
                    _this._cachedCurrentTime = 0, _this;
                }
                return _inherits(AudioSourceComponent, Component), _createClass(AudioSourceComponent, [ {
                    key: "onLoad",
                    value: function onLoad() {
                        this._syncStates(), this._playOnAwake && this.play();
                    }
                }, {
                    key: "play",
                    value: function play() {
                        this._clip && (this.playing ? this.currentTime = 0 : this._clip.play());
                    }
                }, {
                    key: "pause",
                    value: function pause() {
                        this._clip && this._clip.pause();
                    }
                }, {
                    key: "stop",
                    value: function stop() {
                        this._clip && this._clip.stop();
                    }
                }, {
                    key: "playOneShot",
                    value: function playOneShot(clip, argument_1) {
                        var volumeScale = 1 < arguments.length && void 0 !== argument_1 ? argument_1 : 1;
                        clip.playOneShot(this._volume * volumeScale);
                    }
                }, {
                    key: "_syncStates",
                    value: function _syncStates() {
                        this._clip && (this._clip.setCurrentTime(this._cachedCurrentTime), this._clip.setLoop(this._loop), 
                        this._clip.setVolume(this._volume, !0), this._volume = this._clip.getVolume());
                    }
                }, {
                    key: "clip",
                    set: function set(val) {
                        this._clip = val, this._syncStates();
                    },
                    get: function get() {
                        return this._clip;
                    }
                }, {
                    key: "loop",
                    set: function set(val) {
                        this._loop = val, this._clip && this._clip.setLoop(val);
                    },
                    get: function get() {
                        return this._loop;
                    }
                }, {
                    key: "playOnAwake",
                    set: function set(val) {
                        this._playOnAwake = val;
                    },
                    get: function get() {
                        return this._playOnAwake;
                    }
                }, {
                    key: "volume",
                    set: function set(val) {
                        isNaN(val) ? console.warn("illegal audio volume!") : (val = clamp(val, 0, 1), this._clip ? (this._clip.setVolume(val), 
                        this._volume = this._clip.getVolume()) : this._volume = val);
                    },
                    get: function get() {
                        return this._volume;
                    }
                }, {
                    key: "currentTime",
                    set: function set(num) {
                        isNaN(num) ? console.warn("illegal audio time!") : (num = clamp(num, 0, this.duration), 
                        this._cachedCurrentTime = num, this._clip && this._clip.setCurrentTime(this._cachedCurrentTime));
                    },
                    get: function get() {
                        return this._clip ? this._clip.getCurrentTime() : this._cachedCurrentTime;
                    }
                }, {
                    key: "duration",
                    get: function get() {
                        return this._clip ? this._clip.getDuration() : 0;
                    }
                }, {
                    key: "state",
                    get: function get() {
                        return this._clip ? this._clip.state : AudioClip.PlayingState.INITIALIZING;
                    }
                }, {
                    key: "playing",
                    get: function get() {
                        return this.state === AudioClip.PlayingState.PLAYING;
                    }
                } ]), AudioSourceComponent;
            }()).prototype, "_clip", [ _dec3$Y ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor2$1a = _applyDecoratedDescriptor(_class2$1q.prototype, "_loop", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !1;
                }
            }), _descriptor3$U = _applyDecoratedDescriptor(_class2$1q.prototype, "_playOnAwake", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return !0;
                }
            }), _descriptor4$O = _applyDecoratedDescriptor(_class2$1q.prototype, "_volume", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _applyDecoratedDescriptor(_class2$1q.prototype, "clip", [ _dec4$P ], Object.getOwnPropertyDescriptor(_class2$1q.prototype, "clip"), _class2$1q.prototype), 
            _applyDecoratedDescriptor(_class2$1q.prototype, "loop", [ property ], Object.getOwnPropertyDescriptor(_class2$1q.prototype, "loop"), _class2$1q.prototype), 
            _applyDecoratedDescriptor(_class2$1q.prototype, "playOnAwake", [ property ], Object.getOwnPropertyDescriptor(_class2$1q.prototype, "playOnAwake"), _class2$1q.prototype), 
            _applyDecoratedDescriptor(_class2$1q.prototype, "volume", [ property ], Object.getOwnPropertyDescriptor(_class2$1q.prototype, "volume"), _class2$1q.prototype), 
            _class$1G = _class2$1q)) || _class$1G) || _class$1G));
            cc.AudioSourceComponent = AudioSourceComponent;
            function TweenAction(target, duration, props, opts) {
                if (_classCallCheck(this, TweenAction), this.id = void 0, this.tween = void 0, this._opts = void 0, 
                this._props = void 0, this.id = TweenAction._idCounter++, this.tween = new Tween_min.Tween(target), 
                this._props = props, this._opts = opts, this.tween.to(props, duration), null != opts) {
                    if (null != opts.delay && this.tween.delay(opts.delay), null != opts.repeat && this.tween.repeat(opts.repeat), 
                    null != opts.repeatDelay && this.tween.repeatDelay(opts.repeatDelay), null != opts.yoyo && this.tween.yoyo(opts.yoyo), 
                    null != opts.easing) if ("string" == typeof opts.easing) {
                        var e = opts.easing.split("-");
                        if (2 <= e.length) {
                            var e0 = e[0], e1 = e[1];
                            "Linear" === e0 ? "None" === e1 && this.tween.easing(Tween_min.Easing[e0][e1]) : "In" !== e1 && "Out" !== e1 && "InOut" !== e1 || this.tween.easing(Tween_min.Easing[e0][e1]);
                        }
                    } else this.tween.easing(opts.easing);
                    if (null != opts.interpolation) if ("string" == typeof opts.interpolation) {
                        var i = opts.interpolation.split("-");
                        if (1 <= i.length) {
                            var i0 = i[0];
                            this.tween.interpolation(Tween_min.Interpolation[i0]);
                        }
                    } else this.tween.interpolation(opts.interpolation);
                    null != opts.onStart && this.tween.onStart(opts.onStart), null != opts.onStop && this.tween.onStop(opts.onStop), 
                    null != opts.onUpdate && this.tween.onUpdate(opts.onUpdate), null != opts.onComplete && this.tween.onComplete(opts.onComplete);
                }
            }
            var Tween_min = createCommonjsModule(function(module, exports) {
                function _Group() {
                    this._tweens = {}, this._tweensAddedDuringUpdate = {};
                }
                _Group.prototype = {
                    getAll: function() {
                        return Object.keys(this._tweens).map(function(t) {
                            return this._tweens[t];
                        }.bind(this));
                    },
                    removeAll: function() {
                        this._tweens = {};
                    },
                    add: function(t) {
                        this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t;
                    },
                    remove: function(t) {
                        delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()];
                    },
                    update: function(t, n) {
                        var e = Object.keys(this._tweens);
                        if (0 === e.length) return !1;
                        for (t = void 0 !== t ? t : TWEEN.now(); 0 < e.length; ) {
                            this._tweensAddedDuringUpdate = {};
                            for (var i = 0; i < e.length; i++) {
                                var r = this._tweens[e[i]];
                                r && !1 === r.update(t) && (r._isPlaying = !1, n || delete this._tweens[e[i]]);
                            }
                            e = Object.keys(this._tweensAddedDuringUpdate);
                        }
                        return !0;
                    }
                };
                var i, TWEEN = new _Group();
                TWEEN.Group = _Group, TWEEN._nextId = 0, TWEEN.nextId = function() {
                    return TWEEN._nextId++;
                }, "undefined" == typeof self && "undefined" != typeof process && process.hrtime ? TWEEN.now = function() {
                    var t = process.hrtime();
                    return 1e3 * t[0] + t[1] / 1e6;
                } : "undefined" != typeof self && void 0 !== self.performance && void 0 !== self.performance.now ? TWEEN.now = self.performance.now.bind(self.performance) : void 0 !== Date.now ? TWEEN.now = Date.now : TWEEN.now = function() {
                    return new Date().getTime();
                }, TWEEN.Tween = function(t, n) {
                    this._object = t, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, 
                    this._duration = 1e3, this._repeat = 0, this._repeatDelayTime = void 0, this._yoyo = !1, 
                    this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = null, 
                    this._easingFunction = TWEEN.Easing.Linear.None, this._interpolationFunction = TWEEN.Interpolation.Linear, 
                    this._chainedTweens = [], this._onStartCallback = null, this._onStartCallbackFired = !1, 
                    this._onUpdateCallback = null, this._onRepeatCallback = null, this._onCompleteCallback = null, 
                    this._onStopCallback = null, this._group = n || TWEEN, this._id = TWEEN.nextId(), 
                    this._onCompleteCallbackForCocos = null;
                }, TWEEN.Tween.prototype = {
                    getId: function() {
                        return this._id;
                    },
                    isPlaying: function() {
                        return this._isPlaying;
                    },
                    to: function(t, n) {
                        return this._valuesEnd = JSON.parse(JSON.stringify(t)), void 0 !== n && (this._duration = n), 
                        this;
                    },
                    duration: function(t) {
                        return this._duration = t, this;
                    },
                    start: function(t) {
                        return this._group.add(this), this._isPlaying = !0, this._onStartCallbackFired = !1, 
                        this._startTime = void 0 !== t ? "string" == typeof t ? TWEEN.now() + parseFloat(t) : t : TWEEN.now(), 
                        this._startTime += this._delayTime, TWEEN._recursiveObjetCopy(this._valuesEnd, this._valuesStart, this._valuesStartRepeat, this._object), 
                        this;
                    },
                    stop: function() {
                        return this._isPlaying && (this._group.remove(this), this._isPlaying = !1, null !== this._onStopCallback && this._onStopCallback(this._object), 
                        this.stopChainedTweens()), this;
                    },
                    end: function() {
                        return this.update(1 / 0), this;
                    },
                    stopChainedTweens: function() {
                        for (var t = 0, n = this._chainedTweens.length; t < n; t++) this._chainedTweens[t].stop();
                    },
                    group: function(t) {
                        return this._group = t, this;
                    },
                    delay: function(t) {
                        return this._delayTime = t, this;
                    },
                    repeat: function(t) {
                        return this._repeat = t, this;
                    },
                    repeatDelay: function(t) {
                        return this._repeatDelayTime = t, this;
                    },
                    yoyo: function(t) {
                        return this._yoyo = t, this;
                    },
                    easing: function(t) {
                        return this._easingFunction = t, this;
                    },
                    interpolation: function(t) {
                        return this._interpolationFunction = t, this;
                    },
                    chain: function() {
                        return this._chainedTweens = arguments, this;
                    },
                    onStart: function(t) {
                        return this._onStartCallback = t, this;
                    },
                    onUpdate: function(t) {
                        return this._onUpdateCallback = t, this;
                    },
                    onRepeat: function(t) {
                        return this._onRepeatCallback = t, this;
                    },
                    onComplete: function(t) {
                        return this._onCompleteCallback = t, this;
                    },
                    onStop: function(t) {
                        return this._onStopCallback = t, this;
                    },
                    update: function(t) {
                        var n, e, i;
                        if (t < this._startTime) return !0;
                        if (!1 === this._onStartCallbackFired && (null !== this._onStartCallback && this._onStartCallback(this._object), 
                        this._onStartCallbackFired = !0), e = (t - this._startTime) / this._duration, e = 0 === this._duration || 1 < e ? 1 : e, 
                        i = this._easingFunction(e), TWEEN._recursiveObjetUpdate(this._valuesEnd, this._valuesStart, i, this._object, this), 
                        null !== this._onUpdateCallback && this._onUpdateCallback(this._object, e), 1 !== e) return !0;
                        if (0 < this._repeat) {
                            for (n in isFinite(this._repeat) && this._repeat--, this._valuesStartRepeat) {
                                if ("string" == typeof this._valuesEnd[n] && (this._valuesStartRepeat[n] = this._valuesStartRepeat[n] + parseFloat(this._valuesEnd[n])), 
                                this._yoyo) {
                                    var r = this._valuesStartRepeat[n];
                                    this._valuesStartRepeat[n] = this._valuesEnd[n], this._valuesEnd[n] = r;
                                }
                                this._valuesStart[n] = this._valuesStartRepeat[n];
                            }
                            return this._yoyo && (this._reversed = !this._reversed), void 0 !== this._repeatDelayTime ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime, 
                            null !== this._onRepeatCallback && this._onRepeatCallback(this._object), !0;
                        }
                        if (null !== this._onCompleteCallback && this._onCompleteCallback(this._object), 
                        null !== this._onCompleteCallbackForCocos) this._onCompleteCallbackForCocos(this); else for (var o = 0, a = this._chainedTweens.length; o < a; o++) this._chainedTweens[o].start(this._startTime + this._duration);
                        return !1;
                    },
                    cc_onCompleteCallback: function(t) {
                        this._onCompleteCallbackForCocos = t;
                    }
                }, TWEEN._recursiveObjetUpdate = function(t, n, e, i, r) {
                    var o, a;
                    for (var s in t) o = t[s], a = n[s], o instanceof Array ? i[s] = r._interpolationFunction(o, e) : ("string" == typeof o && (o = "+" === o.charAt(0) || "-" === o.charAt(0) ? a + parseFloat(o) : parseFloat(o)), 
                    "number" == typeof o ? i[s] = a + (o - a) * e : "object" == typeof o && TWEEN._recursiveObjetUpdate(o, a, e, i[s], r));
                }, TWEEN._recursiveObjetCopy = function(t, n, e, i) {
                    for (var r in t) {
                        if (t[r] instanceof Array) {
                            if (0 === t[r].length) continue;
                            t[r] = [ i[r] ].concat(t[r]);
                        }
                        void 0 !== i[r] && ("object" == typeof i[r] ? (n[r] = {}, e[r] = {}, TWEEN._recursiveObjetCopy(t[r], n[r], e[r], i[r])) : (n[r] = i[r], 
                        "string" == typeof n[r] && (n[r] *= 1), e[r] = n[r] || 0));
                    }
                }, TWEEN.Easing = {
                    Linear: {
                        None: function(t) {
                            return t;
                        }
                    },
                    Quadratic: {
                        In: function(t) {
                            return t * t;
                        },
                        Out: function(t) {
                            return t * (2 - t);
                        },
                        InOut: function(t) {
                            return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1);
                        }
                    },
                    Cubic: {
                        In: function(t) {
                            return t * t * t;
                        },
                        Out: function(t) {
                            return --t * t * t + 1;
                        },
                        InOut: function(t) {
                            return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2);
                        }
                    },
                    Quartic: {
                        In: function(t) {
                            return t * t * t * t;
                        },
                        Out: function(t) {
                            return 1 - --t * t * t * t;
                        },
                        InOut: function(t) {
                            return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2);
                        }
                    },
                    Quintic: {
                        In: function(t) {
                            return t * t * t * t * t;
                        },
                        Out: function(t) {
                            return --t * t * t * t * t + 1;
                        },
                        InOut: function(t) {
                            return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2);
                        }
                    },
                    Sinusoidal: {
                        In: function(t) {
                            return 1 - Math.cos(t * Math.PI / 2);
                        },
                        Out: function(t) {
                            return Math.sin(t * Math.PI / 2);
                        },
                        InOut: function(t) {
                            return .5 * (1 - Math.cos(Math.PI * t));
                        }
                    },
                    Exponential: {
                        In: function(t) {
                            return 0 === t ? 0 : Math.pow(1024, t - 1);
                        },
                        Out: function(t) {
                            return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
                        },
                        InOut: function(t) {
                            return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)));
                        }
                    },
                    Circular: {
                        In: function(t) {
                            return 1 - Math.sqrt(1 - t * t);
                        },
                        Out: function(t) {
                            return Math.sqrt(1 - --t * t);
                        },
                        InOut: function(t) {
                            return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
                        }
                    },
                    Elastic: {
                        In: function(t) {
                            return 0 === t ? 0 : 1 === t ? 1 : -Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI);
                        },
                        Out: function(t) {
                            return 0 === t ? 0 : 1 === t ? 1 : Math.pow(2, -10 * t) * Math.sin(5 * (t - .1) * Math.PI) + 1;
                        },
                        InOut: function(t) {
                            return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? -.5 * Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) + 1;
                        }
                    },
                    Back: {
                        In: function(t) {
                            return t * t * (2.70158 * t - 1.70158);
                        },
                        Out: function(t) {
                            return --t * t * (2.70158 * t + 1.70158) + 1;
                        },
                        InOut: function(t) {
                            var n = 2.5949095;
                            return (t *= 2) < 1 ? t * t * ((1 + n) * t - n) * .5 : .5 * ((t -= 2) * t * ((1 + n) * t + n) + 2);
                        }
                    },
                    Bounce: {
                        In: function(t) {
                            return 1 - TWEEN.Easing.Bounce.Out(1 - t);
                        },
                        Out: function(t) {
                            return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
                        },
                        InOut: function(t) {
                            return t < .5 ? .5 * TWEEN.Easing.Bounce.In(2 * t) : .5 * TWEEN.Easing.Bounce.Out(2 * t - 1) + .5;
                        }
                    }
                }, TWEEN.Interpolation = {
                    Linear: function(t, n) {
                        var e = t.length - 1, i = e * n, r = Math.floor(i), o = TWEEN.Interpolation.Utils.Linear;
                        return n < 0 ? o(t[0], t[1], i) : 1 < n ? o(t[e], t[e - 1], e - i) : o(t[r], t[e < r + 1 ? e : r + 1], i - r);
                    },
                    Bezier: function(t, n) {
                        for (var e = 0, i = t.length - 1, r = Math.pow, o = TWEEN.Interpolation.Utils.Bernstein, a = 0; a <= i; a++) e += r(1 - n, i - a) * r(n, a) * t[a] * o(i, a);
                        return e;
                    },
                    CatmullRom: function(t, n) {
                        var e = t.length - 1, i = e * n, r = Math.floor(i), o = TWEEN.Interpolation.Utils.CatmullRom;
                        return t[0] === t[e] ? (n < 0 && (r = Math.floor(i = e * (1 + n))), o(t[(r - 1 + e) % e], t[r], t[(r + 1) % e], t[(r + 2) % e], i - r)) : n < 0 ? t[0] - (o(t[0], t[0], t[1], t[1], -i) - t[0]) : 1 < n ? t[e] - (o(t[e], t[e], t[e - 1], t[e - 1], i - e) - t[e]) : o(t[r ? r - 1 : 0], t[r], t[e < r + 1 ? e : r + 1], t[e < r + 2 ? e : r + 2], i - r);
                    },
                    Utils: {
                        Linear: function(t, n, e) {
                            return (n - t) * e + t;
                        },
                        Bernstein: function(t, n) {
                            var e = TWEEN.Interpolation.Utils.Factorial;
                            return e(t) / e(n) / e(t - n);
                        },
                        Factorial: (i = [ 1 ], function(t) {
                            var n = 1;
                            if (i[t]) return i[t];
                            for (var e = t; 1 < e; e--) n *= e;
                            return i[t] = n;
                        }),
                        CatmullRom: function(t, n, e, i, r) {
                            var o = .5 * (e - t), a = .5 * (i - n), s = r * r;
                            return r * s * (2 * n - 2 * e + o + a) + (-3 * n + 3 * e - 2 * o - a) * s + o * r + n;
                        }
                    }
                }, module.exports = TWEEN;
            });
            Tween_min.TWEEN;
            function setWrap$1(object, wrapper) {
                object.__cc_wrapper__ = wrapper;
            }
            TweenAction._idCounter = 0, cc.TweenAction = TweenAction, window.TWEEN = Tween_min;
            var TweenCommand = function() {
                function TweenCommand() {
                    _classCallCheck(this, TweenCommand), this.quene = [];
                }
                return _createClass(TweenCommand, [ {
                    key: "updateChain",
                    value: function updateChain() {
                        for (var len = this.length, i0 = 0, i1 = 1; i0 < len; ) {
                            var union = this.quene[i0];
                            if (i1 < len) {
                                if (0 < union.length) {
                                    var next = this.quene[i1];
                                    if (0 === union.repeatTimes) {
                                        if (0 < next.length) union.lastAction.tween.chain(next.lastAction.tween);
                                    } else this.wrapAndEvent(union);
                                }
                            } else if (0 < union.length && 0 !== union.repeatTimes) {
                                var _lastAction = union.lastAction;
                                setWrap$1(_lastAction.tween, union), _lastAction.tween.cc_onCompleteCallback(this._onComplete.bind(this));
                            }
                            ++i0, ++i1;
                        }
                    }
                }, {
                    key: "start",
                    value: function start() {
                        this.updateChain(), 0 < this.length && this.firstUnion.start();
                    }
                }, {
                    key: "stop",
                    value: function stop() {
                        for (var i = 0; i < this.length; i++) {
                            if (this.quene[i].stop()) break;
                        }
                    }
                }, {
                    key: "union",
                    value: function union(_union) {
                        this.quene.push(_union);
                    }
                }, {
                    key: "isExistUnion",
                    value: function isExistUnion(union) {
                        return -1 !== this.quene.indexOf(union);
                    }
                }, {
                    key: "wrapAndEvent",
                    value: function wrapAndEvent(union) {
                        var lastAction = union.lastAction;
                        setWrap$1(lastAction.tween, union), lastAction.tween.cc_onCompleteCallback(this._onComplete.bind(this));
                    }
                }, {
                    key: "_onComplete",
                    value: function _onComplete(tween) {
                        var union = function getWrap$1(object) {
                            return object.__cc_wrapper__;
                        }(tween);
                        if (0 < union.repeatTimes && 0 < union.lastCount) {
                            union.runTimes++;
                            var index = this.quene.indexOf(union);
                            if (0 <= index) {
                                for (var i = 0; i < index; i++) this.quene[i].runTimes = 0;
                                this.firstUnion.start();
                            }
                        } else if (-1 === union.repeatTimes) {
                            var _index = this.quene.indexOf(union);
                            if (0 <= _index) {
                                for (var _i = 0; _i < _index; _i++) this.quene[_i].runTimes = 0;
                                this.firstUnion.start();
                            }
                        } else {
                            union.onCompeleteCallback && union.onCompeleteCallback(tween._object);
                            var _index2 = this.quene.indexOf(union);
                            if (_index2 !== this.length - 1) this.quene[_index2 + 1].start();
                        }
                    }
                }, {
                    key: "length",
                    get: function get() {
                        return this.quene.length;
                    }
                }, {
                    key: "firstUnion",
                    get: function get() {
                        return this.quene[0];
                    }
                }, {
                    key: "lastUnion",
                    get: function get() {
                        return this.quene[this.quene.length - 1];
                    }
                } ]), TweenCommand;
            }();
            cc.TweenCommand = TweenCommand;
            var TweenUnion = function() {
                function TweenUnion(target) {
                    _classCallCheck(this, TweenUnion), this.id = void 0, this._actions = [], this._target = void 0, 
                    this._runTimes = 0, this._repeatTimes = 0, this._onCompeleteCallback = void 0, this._delay = 0, 
                    this.id = TweenUnion._idCounter++, this._target = target;
                }
                return _createClass(TweenUnion, [ {
                    key: "actions",
                    get: function get() {
                        return this._actions;
                    }
                }, {
                    key: "length",
                    get: function get() {
                        return this._actions.length;
                    }
                }, {
                    key: "firstAction",
                    get: function get() {
                        return this._actions[0];
                    }
                }, {
                    key: "lastAction",
                    get: function get() {
                        return this._actions[this._actions.length - 1];
                    }
                }, {
                    key: "target",
                    get: function get() {
                        return this._target;
                    }
                }, {
                    key: "runTimes",
                    get: function get() {
                        return this._runTimes;
                    },
                    set: function set(times) {
                        this._runTimes = times;
                    }
                }, {
                    key: "repeatTimes",
                    get: function get() {
                        return this._repeatTimes;
                    },
                    set: function set(times) {
                        this._repeatTimes = times;
                    }
                }, {
                    key: "lastCount",
                    get: function get() {
                        return this._repeatTimes - this._runTimes;
                    }
                }, {
                    key: "onCompeleteCallback",
                    set: function set(callback) {
                        this._onCompeleteCallback = callback;
                    },
                    get: function get() {
                        return this._onCompeleteCallback;
                    }
                }, {
                    key: "delay",
                    get: function get() {
                        return this._delay;
                    },
                    set: function set(v) {
                        this._delay = v;
                    }
                } ]), _createClass(TweenUnion, [ {
                    key: "start",
                    value: function start() {
                        if (0 < this.length) if (0 < this.delay) {
                            var tween = this.actions[0].tween;
                            setTimeout(tween.start.bind(tween), this.delay);
                        } else this.actions[0].tween.start();
                    }
                }, {
                    key: "stop",
                    value: function stop() {
                        for (var i = 0; i < this._actions.length; i++) {
                            var tween = this._actions[i].tween;
                            if (tween.isPlaying()) return tween.stop(), !0;
                        }
                        return !1;
                    }
                } ]), TweenUnion;
            }();
            TweenUnion._idCounter = 0, cc.TweenUnion = TweenUnion;
            var Tween = exports("Tween", function() {
                function Tween(target) {
                    _classCallCheck(this, Tween), this._command = new TweenCommand(), this._default = void 0, 
                    this._uionDirty = !1, this._default = new TweenUnion(target);
                }
                return _createClass(Tween, null, [ {
                    key: "_recursiveForBy",
                    value: function _recursiveForBy(props) {
                        var theProp;
                        for (var property in props) if ("number" == typeof (theProp = props[property])) {
                            var symbol = 0 < theProp ? "+" : "-";
                            props[property] = symbol + theProp;
                        } else "object" === _typeof(theProp) && Tween._recursiveForBy(theProp);
                    }
                } ]), _createClass(Tween, [ {
                    key: "to",
                    value: function to(duration, props, opts) {
                        this._uionDirty && (this._default = new TweenUnion(this._default.target), this._uionDirty = !1);
                        var action = new TweenAction(this._default.target, 1e3 * duration, props, opts);
                        return 0 < this._default.length && this._default.actions[this._default.length - 1].tween.chain(action.tween), 
                        this._default.actions.push(action), this;
                    }
                }, {
                    key: "by",
                    value: function by(duration, props, opts) {
                        this._uionDirty && (this._default = new TweenUnion(this._default.target), this._uionDirty = !1), 
                        Tween._recursiveForBy(props);
                        var action = new TweenAction(this._default.target, 1e3 * duration, props, opts);
                        return 0 < this._default.length && this._default.actions[this._default.length - 1].tween.chain(action.tween), 
                        this._default.actions.push(action), this;
                    }
                }, {
                    key: "union",
                    value: function union() {
                        return this._command.isExistUnion(this._default) || (this._command.union(this._default), 
                        this._uionDirty = !0), this;
                    }
                }, {
                    key: "start",
                    value: function start() {
                        return 0 < this._default.length && (this._command.isExistUnion(this._default) || this._command.union(this._default)), 
                        this._command.start(), this;
                    }
                }, {
                    key: "stop",
                    value: function stop() {
                        return this._command.stop(), this;
                    }
                }, {
                    key: "repeat",
                    value: function repeat(times) {
                        return this._uionDirty ? this._default.repeatTimes = times : 0 < this._default.length && this._default.lastAction.tween.repeat(times), 
                        this;
                    }
                }, {
                    key: "repeatForever",
                    value: function repeatForever() {
                        return this._uionDirty ? this._default.repeatTimes = -1 : 0 < this._default.length && this._default.lastAction.tween.repeat(1 / 0), 
                        this;
                    }
                }, {
                    key: "delay",
                    value: function delay(timeInSecond) {
                        return this._uionDirty ? this._default.delay = 1e3 * timeInSecond : 0 < this._default.length && this._default.lastAction.tween.delay(1e3 * timeInSecond), 
                        this;
                    }
                }, {
                    key: "call",
                    value: function call(callback) {
                        return this._uionDirty ? this._default.onCompeleteCallback = callback : 0 < this._default.length && this._default.lastAction.tween.onComplete(callback), 
                        this;
                    }
                } ]), Tween;
            }());
            function tweenUtil(target) {
                return new Tween(target);
            }
            cc.Tween = Tween, cc.tweenUtil = tweenUtil;
            var TweenSystem = function() {
                function TweenSystem() {
                    return _classCallCheck(this, TweenSystem), _possibleConstructorReturn(this, _getPrototypeOf(TweenSystem).apply(this, arguments));
                }
                return _inherits(TweenSystem, System), _createClass(TweenSystem, [ {
                    key: "postUpdate",
                    value: function postUpdate() {
                        window.TWEEN && window.TWEEN.update(performance.now());
                    }
                } ]), TweenSystem;
            }();
            function tween(target) {
                return warn("tween' is deprecated, please use 'tweenUtil' instead "), tweenUtil(target);
            }
            TweenSystem.ID = "tween", director.on(Director.EVENT_INIT, function() {
                var sys = new TweenSystem();
                director.registerSystem(TweenSystem.ID, sys, 100);
            }), cc.tween = tween;
            exports("HeightField", function() {
                function HeightField(w, h) {
                    _classCallCheck(this, HeightField), this.data = new Uint16Array(), this.w = 0, this.h = 0, 
                    this.w = w, this.h = h, this.data = new Uint16Array(w * h);
                    for (var i = 0; i < w * h; ++i) this.data[i] = 0;
                }
                return _createClass(HeightField, [ {
                    key: "set",
                    value: function set(i, j, value) {
                        this.data[j * this.w + i] = value;
                    }
                }, {
                    key: "get",
                    value: function get(i, j) {
                        return this.data[j * this.w + i];
                    }
                }, {
                    key: "getClamp",
                    value: function getClamp(i, j) {
                        return i = clamp(i, 0, this.w - 1), j = clamp(j, 0, this.h - 1), this.get(i, j);
                    }
                }, {
                    key: "getAt",
                    value: function getAt(x, y) {
                        var fx = x / this.w, fy = y / this.h, ix0 = Math.floor(fx), iz0 = Math.floor(fy), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = fx - ix0, dz = fy - iz0;
                        ix0 = clamp(ix0, 0, this.w - 1), iz0 = clamp(iz0, 0, this.h - 1), ix1 = clamp(ix1, 0, this.w - 1), 
                        iz1 = clamp(iz1, 0, this.h - 1);
                        var a = this.get(ix0, iz0), b = this.get(ix1, iz0), c = this.get(ix0, iz1), d = this.get(ix1, iz1), m = .5 * (b + c);
                        return dx + dz <= 1 ? d = m - a + m : a = m - d + m, (a * (1 - dx) + b * dx) * (1 - dz) + (c * (1 - dx) + d * dx) * dz;
                    }
                } ]), HeightField;
            }()), exports("TERRAIN_MAX_LEVELS", 4), exports("TERRAIN_MAX_BLEND_LAYERS", 4);
            var _class$1H, _class2$1r, _descriptor$1n, _descriptor2$1b, _descriptor3$V, _descriptor4$P, _class4$7, _class5$7, _descriptor5$F, _descriptor6$t, _class7$2, _class8$2, _descriptor7$o, _dec4$Q, _dec5$K, _dec6$E, _dec7$u, _dec8$k, _dec9$h, _dec10$f, _class10$1, _class11$1, _descriptor8$l, _descriptor9$g, _descriptor10$e, _descriptor11$d, _descriptor12$c, TERRAIN_MAX_LAYER_COUNT = exports("TERRAIN_MAX_LAYER_COUNT", 256), TERRAIN_BLOCK_TILE_COMPLEXITY = exports("TERRAIN_BLOCK_TILE_COMPLEXITY", 32), TERRAIN_BLOCK_VERTEX_COMPLEXITY = exports("TERRAIN_BLOCK_VERTEX_COMPLEXITY", 33), TERRAIN_BLOCK_VERTEX_SIZE = exports("TERRAIN_BLOCK_VERTEX_SIZE", 8), TerrainInfo = (exports("TERRAIN_NORTH_INDEX", 0), 
            exports("TERRAIN_SOUTH_INDEX", 1), exports("TERRAIN_WEST_INDEX", 2), exports("TERRAIN_EAST_INDEX", 3), 
            exports("TerrainInfo", ccclass("cc.TerrainInfo")((_descriptor$1n = _applyDecoratedDescriptor((_class2$1r = function() {
                function TerrainInfo() {
                    _classCallCheck(this, TerrainInfo), _initializerDefineProperty(this, "tileSize", _descriptor$1n, this), 
                    _initializerDefineProperty(this, "blockCount", _descriptor2$1b, this), _initializerDefineProperty(this, "weightMapSize", _descriptor3$V, this), 
                    _initializerDefineProperty(this, "lightMapSize", _descriptor4$P, this), this._tileCount = [ 0, 0 ], 
                    this._vertexCount = [ 0, 0 ], this._size = new Size(0, 0);
                }
                return _createClass(TerrainInfo, [ {
                    key: "initialize",
                    value: function initialize() {
                        this._tileCount[0] = this.blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY, this._tileCount[1] = this.blockCount[1] * TERRAIN_BLOCK_TILE_COMPLEXITY, 
                        this._vertexCount[0] = this._tileCount[0] + 1, this._vertexCount[1] = this._tileCount[1] + 1, 
                        this._size.width = this._tileCount[0] * this.tileSize, this._size.height = this._tileCount[1] * this.tileSize;
                    }
                }, {
                    key: "tileCount",
                    get: function get() {
                        return this._tileCount;
                    }
                }, {
                    key: "vertexCount",
                    get: function get() {
                        return this._vertexCount;
                    }
                }, {
                    key: "size",
                    get: function get() {
                        return this._size;
                    }
                } ]), TerrainInfo;
            }()).prototype, "tileSize", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _descriptor2$1b = _applyDecoratedDescriptor(_class2$1r.prototype, "blockCount", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [ 1, 1 ];
                }
            }), _descriptor3$V = _applyDecoratedDescriptor(_class2$1r.prototype, "weightMapSize", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 128;
                }
            }), _descriptor4$P = _applyDecoratedDescriptor(_class2$1r.prototype, "lightMapSize", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 128;
                }
            }), _class$1H = _class2$1r)) || _class$1H)), TerrainLayer = exports("TerrainLayer", ccclass("cc.TerrainLayer")((_descriptor5$F = _applyDecoratedDescriptor((_class5$7 = function TerrainLayer() {
                _classCallCheck(this, TerrainLayer), _initializerDefineProperty(this, "detailMap", _descriptor5$F, this), 
                _initializerDefineProperty(this, "tileSize", _descriptor6$t, this);
            }).prototype, "detailMap", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return null;
                }
            }), _descriptor6$t = _applyDecoratedDescriptor(_class5$7.prototype, "tileSize", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return 1;
                }
            }), _class4$7 = _class5$7)) || _class4$7), TerrainRenderable = (exports("TerrainVertex", function TerrainVertex() {
                _classCallCheck(this, TerrainVertex), this.position = new Vec3(0, 0, 0), this.normal = new Vec3(0, 1, 0), 
                this.uv = new Vec2(0, 0);
            }), exports("TerrainRenderable", function() {
                function TerrainRenderable() {
                    var _getPrototypeOf2, _this;
                    _classCallCheck(this, TerrainRenderable);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TerrainRenderable)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._model = null, 
                    _this._meshData = null, _this._brushMaterial = null, _this._currentMaterial = null, 
                    _this._currentMaterialLayers = 0, _this;
                }
                return _inherits(TerrainRenderable, RenderableComponent), _createClass(TerrainRenderable, [ {
                    key: "destroy",
                    value: function destroy() {
                        this._invalidMaterial(), null != this._model && (this._getRenderScene().destroyModel(this._model), 
                        this._model = null), _get(_getPrototypeOf(TerrainRenderable.prototype), "destroy", this).call(this);
                    }
                }, {
                    key: "_invalidMaterial",
                    value: function _invalidMaterial() {
                        null != this._currentMaterial && (this._clearMaterials(), (this._currentMaterial = null) != this._model && (this._model.enabled = !1));
                    }
                }, {
                    key: "_updateMaterial",
                    value: function _updateMaterial(block, init) {
                        if (null != this._meshData && null != this._model) {
                            var nlayers = block.getMaxLayer();
                            if (null == this._currentMaterial || nlayers !== this._currentMaterialLayers) {
                                if (this._currentMaterial = new Material(), this._currentMaterial.initialize({
                                    effectAsset: EffectAsset.get("builtin-terrain"),
                                    defines: block._getMaterialDefines(nlayers)
                                }), null !== this._brushMaterial) this._currentMaterial.passes.push(this._brushMaterial.passes[0]);
                                init && this._model.initSubModel(0, this._meshData, this._currentMaterial), this.setMaterial(this._currentMaterial, 0), 
                                this._currentMaterialLayers = nlayers, this._model.enabled = !0;
                            }
                        }
                    }
                }, {
                    key: "_onMaterialModified",
                    value: function _onMaterialModified(idx, mtl) {
                        null != this._model && this._onRebuildPSO(idx, mtl || this._getBuiltinMaterial());
                    }
                }, {
                    key: "_onRebuildPSO",
                    value: function _onRebuildPSO(idx, material) {
                        this._model && this._model.setSubModelMaterial(idx, material);
                    }
                }, {
                    key: "_clearMaterials",
                    value: function _clearMaterials() {
                        null != this._model && this._onMaterialModified(0, null);
                    }
                }, {
                    key: "_getBuiltinMaterial",
                    value: function _getBuiltinMaterial() {
                        return builtinResMgr.get("missing-material");
                    }
                } ]), TerrainRenderable;
            }())), TerrainBlockInfo = exports("TerrainBlockInfo", ccclass("cc.TerrainBlockInfo")((_descriptor7$o = _applyDecoratedDescriptor((_class8$2 = function TerrainBlockInfo() {
                _classCallCheck(this, TerrainBlockInfo), _initializerDefineProperty(this, "layers", _descriptor7$o, this);
            }).prototype, "layers", [ property ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [ -1, -1, -1, -1 ];
                }
            }), _class7$2 = _class8$2)) || _class7$2), TerrainBlock = exports("TerrainBlock", function() {
                function TerrainBlock(t, i, j) {
                    _classCallCheck(this, TerrainBlock), this._terrain = void 0, this._info = void 0, 
                    this._node = void 0, this._renderable = void 0, this._index = [ 1, 1 ], this._weightMap = null, 
                    this._terrain = t, this._info = t.getBlockInfo(i, j), this._index[0] = i, this._index[1] = j, 
                    this._node = new PrivateNode(""), this._node.setParent(this._terrain.node), this._node._objFlags |= cc.Object.Flags.DontSave, 
                    this._renderable = this._node.addComponent(TerrainRenderable);
                }
                return _createClass(TerrainBlock, [ {
                    key: "build",
                    value: function build() {
                        for (var gfxDevice = director.root.device, vertexData = new Float32Array(TERRAIN_BLOCK_VERTEX_SIZE * TERRAIN_BLOCK_VERTEX_COMPLEXITY * TERRAIN_BLOCK_VERTEX_COMPLEXITY), index = 0, j = 0; j < TERRAIN_BLOCK_VERTEX_COMPLEXITY; ++j) for (var i = 0; i < TERRAIN_BLOCK_VERTEX_COMPLEXITY; ++i) {
                            var x = this._index[0] * TERRAIN_BLOCK_TILE_COMPLEXITY + i, y = this._index[1] * TERRAIN_BLOCK_TILE_COMPLEXITY + j, position = this._terrain.getPosition(x, y), normal = this._terrain.getNormal(x, y), uv = new Vec2(i / TERRAIN_BLOCK_TILE_COMPLEXITY, j / TERRAIN_BLOCK_TILE_COMPLEXITY);
                            vertexData[index++] = position.x, vertexData[index++] = position.y, vertexData[index++] = position.z, 
                            vertexData[index++] = normal.x, vertexData[index++] = normal.y, vertexData[index++] = normal.z, 
                            vertexData[index++] = uv.x, vertexData[index++] = uv.y;
                        }
                        var vertexBuffer = gfxDevice.createBuffer({
                            usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                            size: TERRAIN_BLOCK_VERTEX_SIZE * Float32Array.BYTES_PER_ELEMENT * TERRAIN_BLOCK_VERTEX_COMPLEXITY * TERRAIN_BLOCK_VERTEX_COMPLEXITY,
                            stride: TERRAIN_BLOCK_VERTEX_SIZE * Float32Array.BYTES_PER_ELEMENT
                        });
                        vertexBuffer.update(vertexData);
                        var gfxAttributes = [ {
                            name: GFXAttributeName.ATTR_POSITION,
                            format: GFXFormat.RGB32F
                        }, {
                            name: GFXAttributeName.ATTR_NORMAL,
                            format: GFXFormat.RGB32F
                        }, {
                            name: GFXAttributeName.ATTR_TEX_COORD,
                            format: GFXFormat.RG32F
                        } ];
                        this._renderable._meshData = {
                            attributes: gfxAttributes,
                            vertexBuffers: [ vertexBuffer ],
                            indexBuffer: this._terrain.getSharedIndexBuffer(),
                            primitiveMode: GFXPrimitiveMode.TRIANGLE_LIST
                        }, this._renderable._model = this._renderable._getRenderScene().createModel(Model, this._node), 
                        this._updateWeightMap(), this._updateMaterial(!0);
                    }
                }, {
                    key: "rebuild",
                    value: function rebuild() {
                        this._updateHeight(), this._updateWeightMap(), this._renderable._invalidMaterial(), 
                        this._updateMaterial(!1);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        null != this._renderable && this._renderable.destroy(), null != this._node && this._node.destroy(), 
                        null != this._weightMap && this._weightMap.destroy();
                    }
                }, {
                    key: "update",
                    value: function update() {
                        this._updateMaterial(!1);
                        var mtl = this._renderable._currentMaterial;
                        if (null != mtl) {
                            var nlayers = this.getMaxLayer(), uvScale = new Vec4(1, 1, 1, 1);
                            if (0 === nlayers) if (-1 !== this.layers[0]) {
                                var l0 = this._terrain.getLayer(this.layers[0]);
                                null != l0 && (uvScale.x = 1 / l0.tileSize), mtl.setProperty("detailMap0", null != l0 ? l0.detailMap : null);
                            } else mtl.setProperty("detailMap0", builtinResMgr.get("default-texture")); else if (1 === nlayers) {
                                var _l = this._terrain.getLayer(this.layers[0]), l1 = this._terrain.getLayer(this.layers[1]);
                                null != _l && (uvScale.x = 1 / _l.tileSize), null != l1 && (uvScale.y = 1 / l1.tileSize), 
                                mtl.setProperty("weightMap", this._weightMap), mtl.setProperty("detailMap0", null != _l ? _l.detailMap : null), 
                                mtl.setProperty("detailMap1", null != l1 ? l1.detailMap : null);
                            } else if (2 === nlayers) {
                                var _l2 = this._terrain.getLayer(this.layers[0]), _l3 = this._terrain.getLayer(this.layers[1]), l2 = this._terrain.getLayer(this.layers[2]);
                                null != _l2 && (uvScale.x = 1 / _l2.tileSize), null != _l3 && (uvScale.y = 1 / _l3.tileSize), 
                                null != l2 && (uvScale.z = 1 / l2.tileSize), mtl.setProperty("weightMap", this._weightMap), 
                                mtl.setProperty("detailMap0", null != _l2 ? _l2.detailMap : null), mtl.setProperty("detailMap1", null != _l3 ? _l3.detailMap : null), 
                                mtl.setProperty("detailMap2", null != l2 ? l2.detailMap : null);
                            } else if (3 === nlayers) {
                                var _l4 = this._terrain.getLayer(this.layers[0]), _l5 = this._terrain.getLayer(this.layers[1]), _l6 = this._terrain.getLayer(this.layers[2]), l3 = this._terrain.getLayer(this.layers[3]);
                                null != _l4 && (uvScale.x = 1 / _l4.tileSize), null != _l5 && (uvScale.y = 1 / _l5.tileSize), 
                                null != _l6 && (uvScale.z = 1 / _l6.tileSize), null != l3 && (uvScale.z = 1 / l3.tileSize), 
                                mtl.setProperty("weightMap", this._weightMap), mtl.setProperty("detailMap0", null != _l4 ? _l4.detailMap : null), 
                                mtl.setProperty("detailMap1", null != _l5 ? _l5.detailMap : null), mtl.setProperty("detailMap2", null != _l6 ? _l6.detailMap : null), 
                                mtl.setProperty("detailMap3", null != l3 ? l3.detailMap : null);
                            }
                            mtl.setProperty("UVScale", uvScale);
                        }
                    }
                }, {
                    key: "setBrushMaterial",
                    value: function setBrushMaterial(mtl) {
                        this._renderable._brushMaterial !== mtl && (this._renderable._brushMaterial = mtl, 
                        this._renderable._invalidMaterial());
                    }
                }, {
                    key: "getTerrain",
                    value: function getTerrain() {
                        return this._terrain;
                    }
                }, {
                    key: "getIndex",
                    value: function getIndex() {
                        return this._index;
                    }
                }, {
                    key: "getRect",
                    value: function getRect() {
                        var rect = new Rect();
                        return rect.x = this._index[0] * TERRAIN_BLOCK_TILE_COMPLEXITY, rect.y = this._index[1] * TERRAIN_BLOCK_TILE_COMPLEXITY, 
                        rect.width = TERRAIN_BLOCK_TILE_COMPLEXITY, rect.height = TERRAIN_BLOCK_TILE_COMPLEXITY, 
                        rect;
                    }
                }, {
                    key: "setLayer",
                    value: function setLayer(index, layerId) {
                        this.layers[index] !== layerId && (this.layers[index] = layerId, this._renderable._invalidMaterial(), 
                        this._updateMaterial(!1));
                    }
                }, {
                    key: "getLayer",
                    value: function getLayer(index) {
                        return this.layers[index];
                    }
                }, {
                    key: "getMaxLayer",
                    value: function getMaxLayer() {
                        return 0 <= this.layers[3] ? 3 : 0 <= this.layers[2] ? 2 : 0 <= this.layers[1] ? 1 : 0;
                    }
                }, {
                    key: "_getMaterialDefines",
                    value: function _getMaterialDefines(nlayers) {
                        return 0 === nlayers ? {
                            LAYERS: 1
                        } : 1 === nlayers ? {
                            LAYERS: 2
                        } : 2 === nlayers ? {
                            LAYERS: 3
                        } : 3 === nlayers ? {
                            LAYERS: 4
                        } : {
                            LAYERS: 0
                        };
                    }
                }, {
                    key: "_invalidMaterial",
                    value: function _invalidMaterial() {
                        this._renderable._invalidMaterial();
                    }
                }, {
                    key: "_updateMaterial",
                    value: function _updateMaterial(init) {
                        this._renderable._updateMaterial(this, init);
                    }
                }, {
                    key: "_updateHeight",
                    value: function _updateHeight() {
                        if (null != this._renderable._meshData) {
                            for (var vertexData = new Float32Array(TERRAIN_BLOCK_VERTEX_SIZE * TERRAIN_BLOCK_VERTEX_COMPLEXITY * TERRAIN_BLOCK_VERTEX_COMPLEXITY), index = 0, j = 0; j < TERRAIN_BLOCK_VERTEX_COMPLEXITY; ++j) for (var i = 0; i < TERRAIN_BLOCK_VERTEX_COMPLEXITY; ++i) {
                                var x = this._index[0] * TERRAIN_BLOCK_TILE_COMPLEXITY + i, y = this._index[1] * TERRAIN_BLOCK_TILE_COMPLEXITY + j, position = this._terrain.getPosition(x, y), normal = this._terrain.getNormal(x, y), uv = new Vec2(i / TERRAIN_BLOCK_VERTEX_COMPLEXITY, j / TERRAIN_BLOCK_VERTEX_COMPLEXITY);
                                vertexData[index++] = position.x, vertexData[index++] = position.y, vertexData[index++] = position.z, 
                                vertexData[index++] = normal.x, vertexData[index++] = normal.y, vertexData[index++] = normal.z, 
                                vertexData[index++] = uv.x, vertexData[index++] = uv.y;
                            }
                            this._renderable._meshData.vertexBuffers[0].update(vertexData);
                        }
                    }
                }, {
                    key: "_updateWeightMap",
                    value: function _updateWeightMap() {
                        if (0 !== this.getMaxLayer()) {
                            null == this._weightMap && (this._weightMap = new Texture2D(), this._weightMap.create(this._terrain.info.weightMapSize, this._terrain.info.weightMapSize, PixelFormat.RGBA8888), 
                            this._weightMap.setFilters(Filter.LINEAR, Filter.LINEAR), this._weightMap.setWrapMode(WrapMode$1.CLAMP_TO_EDGE, WrapMode$1.CLAMP_TO_EDGE));
                            for (var weightData = new Uint8Array(this._terrain.info.weightMapSize * this._terrain.info.weightMapSize * 4), weightIndex = 0, j = 0; j < this._terrain.info.weightMapSize; ++j) for (var i = 0; i < this._terrain.info.weightMapSize; ++i) {
                                var x = this._index[0] * this._terrain.info.weightMapSize + i, y = this._index[1] * this._terrain.info.weightMapSize + j, w = this._terrain.getWeight(x, y);
                                weightData[4 * weightIndex + 0] = Math.floor(255 * w.x), weightData[4 * weightIndex + 1] = Math.floor(255 * w.y), 
                                weightData[4 * weightIndex + 2] = Math.floor(255 * w.z), weightData[4 * weightIndex + 3] = Math.floor(255 * w.w), 
                                weightIndex += 1;
                            }
                            this._weightMap.uploadData(weightData.buffer);
                        } else null != this._weightMap && (this._weightMap.destroy(), this._weightMap = null);
                    }
                }, {
                    key: "layers",
                    get: function get() {
                        return this._info.layers;
                    }
                } ]), TerrainBlock;
            }());
            exports("Terrain", (_dec4$Q = ccclass("cc.Terrain"), _dec5$K = menu("Components/Terrain"), 
            _dec6$E = property({
                type: TerrainInfo,
                visible: !0
            }), _dec7$u = property({
                type: TerrainLayer,
                visible: !0
            }), _dec8$k = property({
                visible: !1
            }), _dec9$h = property({
                visible: !1
            }), _dec10$f = property({
                visible: !1
            }), _dec4$Q(_class10$1 = _dec5$K(_class10$1 = executeInEditMode((_descriptor8$l = _applyDecoratedDescriptor((_class11$1 = function() {
                function Terrain() {
                    var _this2;
                    _classCallCheck(this, Terrain), _initializerDefineProperty(_this2 = _possibleConstructorReturn(this, _getPrototypeOf(Terrain).call(this)), "_info", _descriptor8$l, _assertThisInitialized(_this2)), 
                    _initializerDefineProperty(_this2, "_layers", _descriptor9$g, _assertThisInitialized(_this2)), 
                    _initializerDefineProperty(_this2, "_heights", _descriptor10$e, _assertThisInitialized(_this2)), 
                    _initializerDefineProperty(_this2, "_weights", _descriptor11$d, _assertThisInitialized(_this2)), 
                    _initializerDefineProperty(_this2, "_blockInfos", _descriptor12$c, _assertThisInitialized(_this2)), 
                    _this2._normals = [], _this2._blocks = [], _this2._sharedIndexBuffer = null;
                    for (var i = 0; i < TERRAIN_MAX_LAYER_COUNT; ++i) _this2._layers.push(null);
                    return _this2;
                }
                return _inherits(Terrain, Component), _createClass(Terrain, [ {
                    key: "build",
                    value: function build(info) {
                        return this._info.tileSize = info.tileSize, this._info.blockCount[0] = info.blockCount[0], 
                        this._info.blockCount[1] = info.blockCount[1], this._info.weightMapSize = info.weightMapSize, 
                        this._info.lightMapSize = info.lightMapSize, this._info.initialize(), this._buildImp();
                    }
                }, {
                    key: "rebuild",
                    value: function rebuild(info) {
                        info.initialize();
                        for (var blockInfos = [], i = 0; i < info.blockCount[0] * info.blockCount[1]; ++i) blockInfos.push(new TerrainBlockInfo());
                        for (var w = Math.min(this.info.blockCount[0], info.blockCount[0]), h = Math.min(this.info.blockCount[1], info.blockCount[1]), j = 0; j < h; ++j) for (var _i2 = 0; _i2 < w; ++_i2) {
                            var index0 = j * info.vertexCount[0] + _i2, index1 = j * this.info.vertexCount[0] + _i2;
                            blockInfos[index0] = this._blockInfos[index1];
                        }
                        this._blockInfos = blockInfos;
                        var _iterator = this._blocks, _isArray = Array.isArray(_iterator), _i3 = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i3 >= _iterator.length) break;
                                _ref = _iterator[_i3++];
                            } else {
                                if ((_i3 = _iterator.next()).done) break;
                                _ref = _i3.value;
                            }
                            _ref.destroy();
                        }
                        this._blocks = [], this._rebuildHeights(info), this._rebuildWeights(info), this._info.tileSize = info.tileSize, 
                        this._info.blockCount[0] = info.blockCount[0], this._info.blockCount[1] = info.blockCount[1], 
                        this._info.weightMapSize = info.weightMapSize, this._info.lightMapSize = info.lightMapSize, 
                        this._info.initialize(), this._buildNormals();
                        for (var _j2 = 0; _j2 < this._info.blockCount[1]; ++_j2) for (var _i4 = 0; _i4 < this._info.blockCount[0]; ++_i4) this._blocks.push(new TerrainBlock(this, _i4, _j2));
                        var _iterator2 = this._blocks, _isArray2 = Array.isArray(_iterator2), _i5 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i5 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i5++];
                            } else {
                                if ((_i5 = _iterator2.next()).done) break;
                                _ref2 = _i5.value;
                            }
                            _ref2.build();
                        }
                    }
                }, {
                    key: "importHeightField",
                    value: function importHeightField(hf, heightScale) {
                        for (var index = 0, j = 0; j < this._info.vertexCount[1]; ++j) for (var i = 0; i < this._info.vertexCount[0]; ++i) {
                            var u = i / this._info.tileCount[0], v = j / this._info.tileCount[1], h = hf.getAt(u * hf.w, v * hf.h) * heightScale;
                            this._heights[index++] = h;
                        }
                        this._buildNormals();
                        var _iterator3 = this._blocks, _isArray3 = Array.isArray(_iterator3), _i7 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i7 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i7++];
                            } else {
                                if ((_i7 = _iterator3.next()).done) break;
                                _ref3 = _i7.value;
                            }
                            _ref3._updateHeight();
                        }
                    }
                }, {
                    key: "exportHeightField",
                    value: function exportHeightField(hf, heightScale) {
                        for (var index = 0, j = 0; j < hf.h; ++j) for (var i = 0; i < hf.w; ++i) {
                            var u = i / (hf.w - 1), v = j / (hf.h - 1), x = u * this._info.size.width, y = v * this._info.size.height, h = this.getHeightAt(x, y);
                            null != h && (hf.data[index++] = h * heightScale);
                        }
                    }
                }, {
                    key: "onLoad",
                    value: function onLoad() {
                        for (var gfxDevice = director.root.device, indexData = new Uint16Array(TERRAIN_BLOCK_TILE_COMPLEXITY * TERRAIN_BLOCK_TILE_COMPLEXITY * 6), index = 0, j = 0; j < TERRAIN_BLOCK_TILE_COMPLEXITY; ++j) for (var i = 0; i < TERRAIN_BLOCK_TILE_COMPLEXITY; ++i) {
                            var a = j * TERRAIN_BLOCK_VERTEX_COMPLEXITY + i, b = j * TERRAIN_BLOCK_VERTEX_COMPLEXITY + i + 1, c = (j + 1) * TERRAIN_BLOCK_VERTEX_COMPLEXITY + i, d = (j + 1) * TERRAIN_BLOCK_VERTEX_COMPLEXITY + i + 1;
                            indexData[index++] = a, indexData[index++] = c, indexData[index++] = b, indexData[index++] = b, 
                            indexData[index++] = c, indexData[index++] = d;
                        }
                        this._sharedIndexBuffer = gfxDevice.createBuffer({
                            usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                            size: Uint16Array.BYTES_PER_ELEMENT * TERRAIN_BLOCK_TILE_COMPLEXITY * TERRAIN_BLOCK_TILE_COMPLEXITY * 6,
                            stride: Uint16Array.BYTES_PER_ELEMENT
                        }), this._sharedIndexBuffer.update(indexData);
                    }
                }, {
                    key: "onEnable",
                    value: function onEnable() {
                        0 === this._blocks.length && this._buildImp();
                    }
                }, {
                    key: "onDisable",
                    value: function onDisable() {
                        var _iterator4 = this._blocks, _isArray4 = Array.isArray(_iterator4), _i9 = 0;
                        for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                            var _ref4;
                            if (_isArray4) {
                                if (_i9 >= _iterator4.length) break;
                                _ref4 = _iterator4[_i9++];
                            } else {
                                if ((_i9 = _iterator4.next()).done) break;
                                _ref4 = _i9.value;
                            }
                            _ref4.destroy();
                        }
                        this._blocks = [];
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        for (var i = 0; i < this._layers.length; ++i) this._layers[i] = null;
                        null != this._sharedIndexBuffer && this._sharedIndexBuffer.destroy();
                    }
                }, {
                    key: "onRestore",
                    value: function onRestore() {
                        this.onDisable(), this.onLoad(), this._buildImp();
                    }
                }, {
                    key: "update",
                    value: function update() {
                        var _iterator5 = this._blocks, _isArray5 = Array.isArray(_iterator5), _i10 = 0;
                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                            var _ref5;
                            if (_isArray5) {
                                if (_i10 >= _iterator5.length) break;
                                _ref5 = _iterator5[_i10++];
                            } else {
                                if ((_i10 = _iterator5.next()).done) break;
                                _ref5 = _i10.value;
                            }
                            _ref5.update();
                        }
                    }
                }, {
                    key: "addLayer",
                    value: function addLayer(layer) {
                        for (var i = 0; i < this._layers.length; ++i) if (null == this._layers[i]) return this._layers[i] = layer, 
                        i;
                        return -1;
                    }
                }, {
                    key: "setLayer",
                    value: function setLayer(i, layer) {
                        this._layers[i] = layer;
                    }
                }, {
                    key: "removeLayer",
                    value: function removeLayer(id) {
                        this._layers[id] = null;
                    }
                }, {
                    key: "getLayer",
                    value: function getLayer(id) {
                        return this._layers[id];
                    }
                }, {
                    key: "getPosition",
                    value: function getPosition(i, j) {
                        var x = i * this._info.tileSize, z = j * this._info.tileSize, y = this.getHeight(i, j);
                        return new Vec3(x, y, z);
                    }
                }, {
                    key: "setHeight",
                    value: function setHeight(i, j, h) {
                        this._heights[j * this._info.vertexCount[0] + i] = h;
                    }
                }, {
                    key: "getHeight",
                    value: function getHeight(i, j) {
                        return this._heights[j * this._info.vertexCount[0] + i];
                    }
                }, {
                    key: "getHeightClamp",
                    value: function getHeightClamp(i, j) {
                        return i = clamp(i, 0, this._info.vertexCount[0] - 1), j = clamp(j, 0, this._info.vertexCount[1] - 1), 
                        this.getHeight(i, j);
                    }
                }, {
                    key: "getHeightAt",
                    value: function getHeightAt(x, y) {
                        var fx = x / this._info.vertexCount[0], fy = y / this._info.vertexCount[1], ix0 = Math.floor(fx), iz0 = Math.floor(fy), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = fx - ix0, dz = fy - iz0;
                        if (ix0 < 0 || ix0 > this._info.vertexCount[0] - 1 || iz0 < 0 || iz0 > this._info.vertexCount[1] - 1) return null;
                        ix0 = clamp(ix0, 0, this._info.vertexCount[0] - 1), iz0 = clamp(iz0, 0, this._info.vertexCount[1] - 1), 
                        ix1 = clamp(ix1, 0, this._info.vertexCount[0] - 1), iz1 = clamp(iz1, 0, this._info.vertexCount[1] - 1);
                        var a = this.getHeight(ix0, iz0), b = this.getHeight(ix1, iz0), c = this.getHeight(ix0, iz1), d = this.getHeight(ix1, iz1), m = .5 * (b + c);
                        return dx + dz <= 1 ? d = m - a + m : a = m - d + m, (a * (1 - dx) + b * dx) * (1 - dz) + (c * (1 - dx) + d * dx) * dz;
                    }
                }, {
                    key: "_setNormal",
                    value: function _setNormal(i, j, n) {
                        var index = j * this._info.vertexCount[0] + i;
                        this._normals[3 * index + 0] = n.x, this._normals[3 * index + 1] = n.y, this._normals[3 * index + 2] = n.z;
                    }
                }, {
                    key: "getNormal",
                    value: function getNormal(i, j) {
                        var index = j * this._info.vertexCount[0] + i, n = new Vec3();
                        return n.x = this._normals[3 * index + 0], n.y = this._normals[3 * index + 1], n.z = this._normals[3 * index + 2], 
                        n;
                    }
                }, {
                    key: "getNormalAt",
                    value: function getNormalAt(x, y) {
                        var fx = x / this._info.vertexCount[0], fy = y / this._info.vertexCount[1], ix0 = Math.floor(fx), iz0 = Math.floor(fy), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = fx - ix0, dz = fy - iz0;
                        if (ix0 < 0 || ix0 > this._info.vertexCount[0] - 1 || iz0 < 0 || iz0 > this._info.vertexCount[1] - 1) return null;
                        ix0 = clamp(ix0, 0, this._info.vertexCount[0] - 1), iz0 = clamp(iz0, 0, this._info.vertexCount[1] - 1), 
                        ix1 = clamp(ix1, 0, this._info.vertexCount[0] - 1), iz1 = clamp(iz1, 0, this._info.vertexCount[1] - 1);
                        var a = this.getNormal(ix0, iz0), b = this.getNormal(ix1, iz0), c = this.getNormal(ix0, iz1), d = this.getNormal(ix1, iz1), m = new Vec3();
                        Vec3.add(m, b, c).multiplyScalar(.5), dx + dz <= 1 ? (d.set(m), d.subtract(a), d.add(m)) : (a.set(m), 
                        a.subtract(d), a.add(m));
                        var n1 = new Vec3(), n2 = new Vec3(), n = new Vec3();
                        return Vec3.lerp(n1, a, b, dx), Vec3.lerp(n2, c, d, dx), Vec3.lerp(n, n1, n2, dz), 
                        n;
                    }
                }, {
                    key: "setWeight",
                    value: function setWeight(i, j, w) {
                        var index = j * this.info.weightMapSize * this.info.blockCount[0] + i;
                        this._weights[4 * index + 0] = 255 * w.x, this._weights[4 * index + 1] = 255 * w.y, 
                        this._weights[4 * index + 2] = 255 * w.z, this._weights[4 * index + 3] = 255 * w.w;
                    }
                }, {
                    key: "getWeight",
                    value: function getWeight(i, j) {
                        var index = j * this.info.weightMapSize * this.info.blockCount[0] + i, w = new Vec4();
                        return w.x = this._weights[4 * index + 0] / 255, w.y = this._weights[4 * index + 1] / 255, 
                        w.z = this._weights[4 * index + 2] / 255, w.w = this._weights[4 * index + 3] / 255, 
                        w;
                    }
                }, {
                    key: "getWeightAt",
                    value: function getWeightAt(x, y) {
                        var fx = x / this._info.vertexCount[0], fy = y / this._info.vertexCount[1], ix0 = Math.floor(fx), iz0 = Math.floor(fy), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = fx - ix0, dz = fy - iz0;
                        if (ix0 < 0 || ix0 > this._info.vertexCount[0] - 1 || iz0 < 0 || iz0 > this._info.vertexCount[1] - 1) return null;
                        ix0 = clamp(ix0, 0, this._info.vertexCount[0] - 1), iz0 = clamp(iz0, 0, this._info.vertexCount[1] - 1), 
                        ix1 = clamp(ix1, 0, this._info.vertexCount[0] - 1), iz1 = clamp(iz1, 0, this._info.vertexCount[1] - 1);
                        var a = this.getWeight(ix0, iz0), b = this.getWeight(ix1, iz0), c = this.getWeight(ix0, iz1), d = this.getWeight(ix1, iz1), m = new Vec4();
                        Vec4.add(m, b, c).multiplyScalar(.5), dx + dz <= 1 ? (d = new Vec4(), Vec4.subtract(d, m, a).add(m)) : (a = new Vec4(), 
                        Vec4.subtract(a, m, d).add(m));
                        var n1 = new Vec4(), n2 = new Vec4(), n = new Vec4();
                        return Vec4.lerp(n1, a, b, dx), Vec4.lerp(n2, c, d, dx), Vec4.lerp(n, n1, n2, dz), 
                        n;
                    }
                }, {
                    key: "getBlockInfo",
                    value: function getBlockInfo(i, j) {
                        return this._blockInfos[j * this._info.blockCount[0] + i];
                    }
                }, {
                    key: "getBlock",
                    value: function getBlock(i, j) {
                        return this._blocks[j * this._info.blockCount[0] + i];
                    }
                }, {
                    key: "getBlocks",
                    value: function getBlocks() {
                        return this._blocks;
                    }
                }, {
                    key: "getSharedIndexBuffer",
                    value: function getSharedIndexBuffer() {
                        return this._sharedIndexBuffer;
                    }
                }, {
                    key: "rayCheck",
                    value: function rayCheck(start, dir, step) {
                        var i = 0, trace = start, position = null, dstep = new Vec3();
                        if (dstep.set(dir), dstep.multiplyScalar(step), dir.equals(new Vec3(0, 1, 0))) {
                            var y = this.getHeightAt(trace.x, trace.z);
                            null != y && trace.y <= y && (position = new Vec3(trace.x, y, trace.z));
                        } else if (dir.equals(new Vec3(0, -1, 0))) {
                            var _y2 = this.getHeightAt(trace.x, trace.z);
                            null != _y2 && trace.y >= _y2 && (position = new Vec3(trace.x, _y2, trace.z));
                        } else for (;i++ < 2e3; ) {
                            var _y3 = this.getHeightAt(trace.x, trace.z);
                            if (null != _y3 && trace.y <= _y3) {
                                position = new Vec3(trace.x, _y3, trace.z);
                                break;
                            }
                            trace.add(dstep);
                        }
                        return position;
                    }
                }, {
                    key: "_calcuNormal",
                    value: function _calcuNormal(x, z) {
                        var right, up, flip = 1, here = this.getPosition(x, z);
                        right = x < this._info.vertexCount[0] - 1 ? this.getPosition(x + 1, z) : (flip *= -1, 
                        this.getPosition(x - 1, z)), up = z < this._info.vertexCount[1] - 1 ? this.getPosition(x, z + 1) : (flip *= -1, 
                        this.getPosition(x, z - 1)), right.subtract(here), up.subtract(here);
                        var normal = new Vec3();
                        return normal.set(up), normal.cross(right), normal.multiplyScalar(flip), normal.normalize(), 
                        normal;
                    }
                }, {
                    key: "_buildNormals",
                    value: function _buildNormals() {
                        for (var index = 0, y = 0; y < this._info.vertexCount[1]; ++y) for (var x = 0; x < this._info.vertexCount[0]; ++x) {
                            var n = this._calcuNormal(x, y);
                            this._normals[3 * index + 0] = n.x, this._normals[3 * index + 1] = n.y, this._normals[3 * index + 2] = n.z, 
                            index += 1;
                        }
                    }
                }, {
                    key: "_buildImp",
                    value: function _buildImp() {
                        if (0 < this._blocks.length) return !0;
                        if (this._info.initialize(), 0 === this._info.blockCount[0] || 0 === this._info.blockCount[1]) return !1;
                        var vcount = this._info.vertexCount[0] * this._info.vertexCount[1];
                        if (this._heights.length !== vcount) {
                            this._heights = new Array(vcount), this._normals = new Array(3 * vcount);
                            for (var i = 0; i < vcount; ++i) this._heights[i] = 0, this._normals[3 * i + 0] = 0, 
                            this._normals[3 * i + 1] = 1, this._normals[3 * i + 2] = 0;
                        } else this._normals = new Array(3 * vcount), this._buildNormals();
                        var weightMapComplexityU = this.info.weightMapSize * this.info.blockCount[0], weightMapComplexityV = this.info.weightMapSize * this.info.blockCount[1];
                        if (this._weights.length !== weightMapComplexityU * weightMapComplexityV * 4) {
                            this._weights = new Uint8Array(weightMapComplexityU * weightMapComplexityV * 4);
                            for (var _i11 = 0; _i11 < weightMapComplexityU * weightMapComplexityV; ++_i11) this._weights[4 * _i11 + 0] = 255, 
                            this._weights[4 * _i11 + 1] = 0, this._weights[4 * _i11 + 2] = 0, this._weights[4 * _i11 + 3] = 0;
                        }
                        if (this._blockInfos.length !== this.info.blockCount[0] * this.info.blockCount[1]) {
                            this._blockInfos = [];
                            for (var j = 0; j < this.info.blockCount[1]; ++j) for (var _i12 = 0; _i12 < this.info.blockCount[0]; ++_i12) this._blockInfos.push(new TerrainBlockInfo());
                        }
                        for (var _j3 = 0; _j3 < this.info.blockCount[1]; ++_j3) for (var _i13 = 0; _i13 < this.info.blockCount[0]; ++_i13) this._blocks.push(new TerrainBlock(this, _i13, _j3));
                        var _iterator6 = this._blocks, _isArray6 = Array.isArray(_iterator6), _i14 = 0;
                        for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                            var _ref6;
                            if (_isArray6) {
                                if (_i14 >= _iterator6.length) break;
                                _ref6 = _iterator6[_i14++];
                            } else {
                                if ((_i14 = _iterator6.next()).done) break;
                                _ref6 = _i14.value;
                            }
                            _ref6.build();
                        }
                    }
                }, {
                    key: "_rebuildHeights",
                    value: function _rebuildHeights(info) {
                        if (this.info.vertexCount[0] === info.vertexCount[0] && this.info.vertexCount[1] === info.vertexCount[1]) return !1;
                        for (var heights = new Array(info.vertexCount[0] * info.vertexCount[1]), i = 0; i < heights.length; ++i) heights[i] = 0;
                        for (var w = Math.min(this.info.vertexCount[0], info.vertexCount[0]), h = Math.min(this.info.vertexCount[1], info.vertexCount[1]), j = 0; j < h; ++j) for (var _i16 = 0; _i16 < w; ++_i16) {
                            var index0 = j * info.vertexCount[0] + _i16, index1 = j * this.info.vertexCount[0] + _i16;
                            heights[index0] = this._heights[index1];
                        }
                        return this._heights = heights, !0;
                    }
                }, {
                    key: "_rebuildWeights",
                    value: function _rebuildWeights(info) {
                        var _this3 = this, oldWeightMapSize = this.info.weightMapSize, oldWeightMapComplexityU = this.info.weightMapSize * this.info.blockCount[0], oldWeightMapComplexityV = this.info.weightMapSize * this.info.blockCount[1], weightMapComplexityU = info.weightMapSize * info.blockCount[0], weightMapComplexityV = info.weightMapSize * info.blockCount[1];
                        if (weightMapComplexityU == oldWeightMapComplexityU && weightMapComplexityV == oldWeightMapComplexityV) return !1;
                        for (var weights = new Uint8Array(weightMapComplexityU * weightMapComplexityV * 4), i = 0; i < weightMapComplexityU * weightMapComplexityV; ++i) weights[4 * i + 0] = 255, 
                        weights[4 * i + 1] = 0, weights[4 * i + 2] = 0, weights[4 * i + 3] = 0;
                        for (var w = Math.min(info.blockCount[0], this.info.blockCount[0]), h = Math.min(info.blockCount[1], this.info.blockCount[1]), getOldWeight = function getOldWeight(_i, _j, _weights) {
                            var index = _j * oldWeightMapComplexityU + _i, weight = new Vec4();
                            return weight.x = _weights[4 * index + 0] / 255, weight.y = _weights[4 * index + 1] / 255, 
                            weight.z = _weights[4 * index + 2] / 255, weight.w = _weights[4 * index + 3] / 255, 
                            weight;
                        }, sampleOldWeight = function sampleOldWeight(_x, _y, _xoff, _yoff) {
                            var ix0 = Math.floor(_x), iz0 = Math.floor(_y), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = _x - ix0, dz = _y - iz0, a = getOldWeight(ix0 + _xoff, iz0 + _yoff, _this3._weights), b = getOldWeight(ix1 + _xoff, iz0 + _yoff, _this3._weights), c = getOldWeight(ix0 + _xoff, iz1 + _yoff, _this3._weights), d = getOldWeight(ix1 + _xoff, iz1 + _yoff, _this3._weights), m = new Vec4();
                            Vec4.add(m, b, c).multiplyScalar(.5), dx + dz <= 1 ? (d.set(m), d.subtract(a), d.add(m)) : (a.set(m), 
                            a.subtract(d), a.add(m));
                            var n1 = new Vec4(), n2 = new Vec4(), n = new Vec4();
                            return Vec4.lerp(n1, a, b, dx), Vec4.lerp(n2, c, d, dx), Vec4.lerp(n, n1, n2, dz), 
                            n;
                        }, j = 0; j < h; ++j) for (var _i17 = 0; _i17 < w; ++_i17) for (var uoff = _i17 * oldWeightMapSize, voff = j * oldWeightMapSize, v = 0; v < this.info.weightMapSize; ++v) for (var u = 0; u < this.info.weightMapSize; ++u) {
                            var _w = void 0;
                            if (info.weightMapSize == oldWeightMapSize) _w = getOldWeight(u + uoff, v + voff, this._weights); else _w = sampleOldWeight(u / (this.info.weightMapSize - 1) * (oldWeightMapSize - 1), v / (this.info.weightMapSize - 1) * (oldWeightMapSize - 1), uoff, voff, this._weights);
                            var du = _i17 * this.info.weightMapSize + u, index = (j * this.info.weightMapSize + v) * weightMapComplexityU + du;
                            weights[4 * index + 0] = 255 * _w.x, weights[4 * index + 1] = 255 * _w.y, weights[4 * index + 2] = 255 * _w.z, 
                            weights[4 * index + 3] = 255 * _w.w;
                        }
                        return this._weights = weights, !0;
                    }
                }, {
                    key: "info",
                    get: function get() {
                        return this._info;
                    }
                } ]), Terrain;
            }()).prototype, "_info", [ _dec6$E ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new TerrainInfo();
                }
            }), _descriptor9$g = _applyDecoratedDescriptor(_class11$1.prototype, "_layers", [ _dec7$u ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor10$e = _applyDecoratedDescriptor(_class11$1.prototype, "_heights", [ _dec8$k ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _descriptor11$d = _applyDecoratedDescriptor(_class11$1.prototype, "_weights", [ _dec9$h ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return new Uint8Array();
                }
            }), _descriptor12$c = _applyDecoratedDescriptor(_class11$1.prototype, "_blockInfos", [ _dec10$f ], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function initializer() {
                    return [];
                }
            }), _class10$1 = _class11$1)) || _class10$1) || _class10$1) || _class10$1));
        }
    };
});
